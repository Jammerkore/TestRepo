using System;
using System.Collections;
using System.Collections.Generic;  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
using System.Globalization;
using System.Diagnostics;
using MIDRetail.Common;
using MIDRetail.Data;
using MIDRetail.DataCommon;

// Assortment: Color/size change (All references to "ColorKey"  changed to "ColorCodeRID")

namespace MIDRetail.Business.Allocation
{
	#region AllocationProfileComparer
	/// <summary>
	/// Compares two Allocation profiles based on the units allocated to a specific store in the GeneralComponent.
	/// </summary>
	public class AllocationProfileStoreComparer:IComparer
	{
		private Index_RID _store;
		private GeneralComponent _generalComponent;
		internal AllocationProfileStoreComparer(GeneralComponent aGeneralComponent, Index_RID aStore)
		{
			_store = aStore;
			_generalComponent = aGeneralComponent;
		}
		public int Compare (object x, object y)
		{
			if (!((x is AllocationProfile)
				|| (y is AllocationProfile)))
			{
				throw new MIDException(eErrorLevel.fatal,
					(int)(eMIDTextCode.msg_al_CompareObjMustBeAllocationProfile),
					MIDText.GetText(eMIDTextCode.msg_al_CompareObjMustBeAllocationProfile));
			}
			if (x == null)
			{
				return -1;
			}
			if (y == null)
			{
				return 1;
			}
			if (((AllocationProfile)x).GetStoreQtyAllocated(_generalComponent, _store)
				< ((AllocationProfile)y).GetStoreQtyAllocated(_generalComponent, _store))
			{
				return -1;
			}
			if (((AllocationProfile)x).GetStoreQtyAllocated(_generalComponent, _store)
				>= ((AllocationProfile)y).GetStoreQtyAllocated(_generalComponent, _store))
			{
				return +1;
			}
			return -1;
		}
	}
	#endregion AllocationProfileComparer

	#region AllocationSubtotalProfileList
	/// <summary>
	/// List of allocation subtotal profiles.
	/// </summary>
	public class AllocationSubtotalProfileList : ProfileList
	{
		/// <summary>
		/// Used to construct an instance of the class.
		/// </summary>
		public AllocationSubtotalProfileList(eProfileType aProfileType)
			: base(aProfileType)
		{
			
		}
	}
	#endregion AllocationSubtotalProfileList

	#region AllocationSubtotalProfile
	/// <summary>
	/// Describes AllocationProfile Subtotals.
	/// </summary>
	public class AllocationSubtotalProfile:Profile
	{
		#region Fields
		//=======
		// FIELDS
		//=======
		private bool _buildMinMax;  // MID Change j.ellis Delay Grades till needed
		private ApplicationSessionTransaction Transaction;
		private SessionAddressBlock SAB;               // used by some not all methods
		private ProfileList _allStoreList;
		private int _filterStoreRID;
		private ProfileList _filterStoreList;
		//		private ProfileList _storeGroup;
		private AllocationProfileList _allocationProfileList;         // allocation profiles in this subtotal
        private List<AllocationProfile> _headersForStoreQtyAllocatedNotIntransit = null;  // TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.
		private string _subtotalName;
		private bool BulkIsDetail;
		private int _gradeWeekCount;
		private ArrayList _grade;
		private DateTime _beginDay;
		private DateTime _endDay;
		private DateTime _beginCDR_FirstDate; // MID Change j.ellis For Performance
		private DateTime _endCDR_Date; // MID Change j.ellis For Performance
		private int _planHnRID;
        private int _eligibilityHnRID;
		private int _onHandHnRID;
		private double _planPercentFactor;
		private bool[] _storeIsEligible;
		private int[] _gradeIndex;
		private Hashtable _capacityNodes;
		private string _errorMsg;
		private Hashtable _storeSizeIntransitPctToColorHash;
		private Hashtable _storeSizeOnHandPctToColorHash;
		private Hashtable _storeSizeOHplusITPctToColorHash;
		private Hashtable _storeListSizePctToColorHash;
		private Hashtable _storeListSizeIntransitPctToColorHash;
		private Hashtable _storeListSizeOnHandPctToColorHash;
		private Hashtable _storeListSizeOHplusITPctToColorHash;

		private HdrAllocationBin _headerTotal;
		private HdrAllocationBin _genericTotal;
		private HdrAllocationBin _detailTotal;
		private HdrAllocationBin _bulkTotal;
		private Hashtable _subtotalPacks;
		private PackHdrCompareDescend _packDescendCompare;
		private SortedList _genericPacks;
		private SortedList _nonGenericPacks;
		private int _totalBulkColorUnitsToAllocate;
        // begin TT#1166 - MD - Jellis - Color not in Bulk OR No Stores in Size Analysis
        private HdrColorBin _lastSubtotalColorBin;
        private HdrSizeBin _lastSubtotalSizeBin;
        // end TT#1166 - MD - Jellis - Color not in Bulk OR no Stores in Size Analysis
		private Hashtable _bulkColors;
		private ProfileList _sizeList;
		private SubtotalAllocatedBaseBin[] _subtotalTotal;
		private SubtotalAllocatedBaseBin[] _subtotalGenericType;
		private int[] _subtotalTotalGenericUnitsAllocated;
        private int[] _subtotalTotalGenericItemUnitsAllocated; // TT#1401 - JEllis - Urban Reservation Stores pt 2
		private SubtotalAllocatedBaseBin[] _subtotalDetailType;
		private int[] _subtotalTotalNonGenericUnitsAllocated;
        private int[] _subtotalTotalNonGenericItemUnitsAllocated; // TT#1401 - JEllis - Urban Reservation Stores pt 2
		private SubtotalAllocatedBaseBin[] _subtotalBulk;
		// private int[] _subtotalBulkColorTotalUnitsAllocated;  // MID Track 3326 Cannot manually key size qty when no secondary dimension
		private bool _loadIntransit;
		private int _velocityStyleRID;
		private bool _loadVelocityBasisOnHand;
		private int[] _velocityBasisOnHand;
		private bool _loadVelocityBasisInTransit;
		private int[] _velocityBasisInTransit;
        // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 34
        private bool _loadVelocityBasisImoHistory;
        private int[] _velocityBasisImoHistory;
        // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 34
		private bool _loadVelocityStyleInTransit;
		private double[] _velocityStoreBasisStock;
		private double[] _velocityStoreBasisSales;
		private double[] _velocityStoreAvgWklySales;
		private double[] _velocityStoreAvgWklyStock;
		private double[] _velocityStoreGradeIDX_Chain;
		private double[] _velocityStoreGradeIDX_Set;
        private bool _buildItemSubtotals; // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 30
        private bool _buildingItemSubtotals; // TT#2344 - JEllis - AnF VSW Subtotals Broken for Store Item
		private bool _buildSubtotal;   // MID Change j.ellis delay build until a request for information.
        private bool _buildingSubtotals; // TT#1401 - Jellis - Urban Virtual Store Warehouse pt 28F
        private string[] _basisStoreGradeList; // TT#638 - RMatelic - Style Review - Add Basis Variables
        private bool _construct; // TT#1185 - MD - Jellis - Group Allocation - Style Review not showing all eligible stores
        private StoreSalesITHorizon _storeSalesITHorizon; // TT#4345 - MD - JEllis - GA VSW calculated incorrectly
        private StoreSalesITHorizon _velocityStoreSalesITHorizon; // TT#4345 - MD - Jelli s- GA VSW calculated incorrectly
        private StoreSalesITHorizon _velocityBasisStoreSalesITHorizon; // TT#4345 - MD - Jellis - GA VSW calculated incorrectly
 		#endregion Fields

		#region Constructors
		//=============
		// CONSTRUCTORS
		//=============
		/// <summary>
		/// Creates an instance of this class.
		/// </summary>
		/// <param name="aTransaction">Transaction associated with this subtotal.</param>
		/// <param name="aSubtotalName">Subtotal name.</param>
		/// <param name="aKey">Subtotal Key.</param>
		public AllocationSubtotalProfile(
			ApplicationSessionTransaction aTransaction, string aSubtotalName, int aKey)
			:base(aKey)
		{
			Transaction = aTransaction;
			SAB = Transaction.SAB;
			_subtotalName = aSubtotalName;
			_allocationProfileList = new AllocationProfileList(eProfileType.AllocationSubtotal);

			this.Constructor();
		}
		private void Constructor()
		{
			_subtotalPacks = new Hashtable();
			_packDescendCompare = new PackHdrCompareDescend();
			_genericPacks = new SortedList(_packDescendCompare);
			_nonGenericPacks = new SortedList(_packDescendCompare);
			_bulkColors = new Hashtable();
			_gradeWeekCount = 0;
			_planPercentFactor = -1;
			_beginDay = Include.UndefinedDate;
			_endDay = Include.UndefinedDate;
			_planHnRID = Include.NoRID;
            _eligibilityHnRID = Include.NoRID;
			_onHandHnRID = Include.NoRID;
			_capacityNodes = null;
			_buildMinMax = true; // MID Change j.ellis Delay Grades till needed
            _lastSubtotalColorBin = null; // TT#1166 - MD - Jellis - Color not in Bulk OR No Store in Size Analysis
            _lastSubtotalSizeBin = null;  // TT#1166 - MD - Jellis - Color not in Bulk OR no Store in Size Analaysis
 
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 31
            //_headerTotal.SetQtyAllocated(0);
            //_headerTotal.SetFilterQtyAllocated(0);
            //_headerTotal.SetQtyToAllocate(0);
            //_headerTotal.SetUnitMultiple(Include.DefaultUnitMultiple);
            //_genericTotal.SetQtyAllocated(0);
            //_genericTotal.SetFilterQtyAllocated(0);
            //_genericTotal.SetQtyToAllocate(0);
            //_genericTotal.SetUnitMultiple(Include.DefaultUnitMultiple);
            //_detailTotal.SetQtyAllocated(0);
            //_detailTotal.SetFilterQtyAllocated(0);
            //_detailTotal.SetQtyToAllocate(0);
            //_detailTotal.SetUnitMultiple(Include.DefaultUnitMultiple);
            //_bulkTotal.SetQtyAllocated(0);
            //_bulkTotal.SetFilterQtyAllocated(0);
            //_bulkTotal.SetQtyToAllocate(0);
            //_bulkTotal.SetUnitMultiple(Include.DefaultUnitMultiple);
            //_totalBulkColorUnitsToAllocate = 0;
            //_allStoreList = Transaction.GetProfileList(eProfileType.Store);
            //SetStoreDimension(_allStoreList.Count);
			//			_allStoreList = null;
            _allStoreList = Transaction.GetProfileList(eProfileType.Store);
            SetStoreDimension(_allStoreList.Count);
            InitializeAllocationTotals();
            // end TT#1401 - Jellis - Urban Virtual Store Warehouse pt 31
			_filterStoreList = null;
			_filterStoreRID = Include.NoRID;
			_velocityStyleRID = Include.NoRID;
			//			_storeGroup = SAB.StoreServerSession.GetStoreGroupLevelList( 
			//				SAB.ApplicationServerSession.GlobalOptions.AllocationStoreGroupRID);
			//			_subtotalProfileList = aTransaction.GetMasterProfileList(eProfileType.AllocationSubtotal);
			//			if (_subtotalProfileList == null)
			//			{
			//				_subtotalProfileList = new ProfileList(eProfileType.AllocationSubtotal);
			//				aTransaction.SetMasterProfileList(_subtotalProfileList);
			//			}
			//			_subtotalProfileList.Add(this);
			this._gradeIndex = null;
			this._storeIsEligible = null;
			_loadIntransit = true;
			this._loadVelocityBasisOnHand = true;
			this._loadVelocityBasisInTransit = true;
            this._loadVelocityBasisImoHistory = true;
			this._loadVelocityStyleInTransit = true;
			this._sizeList = new ProfileList(eProfileType.SizeCode);
			_storeSizeIntransitPctToColorHash = new Hashtable();
			_storeSizeOnHandPctToColorHash = new Hashtable();
			_storeSizeOHplusITPctToColorHash = new Hashtable();
			_storeListSizePctToColorHash = new Hashtable();
			_storeListSizeIntransitPctToColorHash = new Hashtable();
			_storeListSizeOnHandPctToColorHash = new Hashtable();
			_storeListSizeOHplusITPctToColorHash = new Hashtable();

			_velocityStoreBasisStock = null;
			_velocityStoreBasisSales = null;
			_velocityStoreAvgWklySales = null;
			_velocityStoreAvgWklyStock = null;
			_velocityStoreGradeIDX_Chain = null;
			_velocityStoreGradeIDX_Set = null;
			_beginCDR_FirstDate = Include.UndefinedDate;  // MID Change j.ellis For Performance
			_endCDR_Date = Include.UndefinedDate;  // MID Change j.ellis For Performance
            _buildingSubtotals = false;            // TT#1401 - JEllis - Virtual Store Warehouse pt 28F
            _buildItemSubtotals = true;            // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 30
            _buildingItemSubtotals = false;        // TT#2344 - JEllis - AnF VSW Subtotals for Store Item Broken
            _construct = false; // TT#1185 - MD - Jellis - Group Allocation - Style Review not showing all eligible stores 
		}
        // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 31
        private void InitializeAllocationTotals()
        {
            _headerTotal.SetQtyAllocated(0);
            _headerTotal.SetFilterQtyAllocated(0);
            _headerTotal.SetQtyToAllocate(0);
            _headerTotal.SetUnitMultiple(Include.DefaultUnitMultiple);
            _genericTotal.SetQtyAllocated(0);
            _genericTotal.SetFilterQtyAllocated(0);
            _genericTotal.SetQtyToAllocate(0);
            _genericTotal.SetUnitMultiple(Include.DefaultUnitMultiple);
            _detailTotal.SetQtyAllocated(0);
            _detailTotal.SetFilterQtyAllocated(0);
            _detailTotal.SetQtyToAllocate(0);
            _detailTotal.SetUnitMultiple(Include.DefaultUnitMultiple);
            _bulkTotal.SetQtyAllocated(0);
            _bulkTotal.SetFilterQtyAllocated(0);
            _bulkTotal.SetQtyToAllocate(0);
            _bulkTotal.SetUnitMultiple(Include.DefaultUnitMultiple);
            _totalBulkColorUnitsToAllocate = 0;
            SetStoreDimension(_allStoreList.Count);
        }
        // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 31
		#endregion Constructors

		#region Properties
		//===========
		// PROPERTIES
		//===========
		/// <summary>
		/// Returns the eProfileType of this profile.
		/// </summary>
		override public eProfileType ProfileType
		{
			get
			{
				return eProfileType.AllocationSubtotal;
			}
		}

		/// <summary>
		/// Gets or sets the subtotal name.
		/// </summary>
		public string SubtotalName
		{
			get
			{
				return _subtotalName;
			}
			set
			{
				_subtotalName = value;
			}
		}
        
		/// <summary>
		/// Gets an allocation profile list of members for this subtotal
		/// </summary>
		public AllocationProfileList SubtotalMembers
		{
			get 
			{
				return _allocationProfileList;
			}
		}
        // begin TT#2475 - JEllis - Size Review error 80253 when manually change size allocation  // TT#198- MD JEllis - Port ver 4.0 fix to ver 4.2
        public bool RebuildSubtotals
        {
            set
            {
                _buildSubtotal = value;
            }
        }
        // end TT#2475 - JEllis - Size Review error 80253 when manually change size allocation  // TT#198- MD JEllis - Port ver 4.0 fix to ver 4.2

        // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
        public bool BuildingSubtotals
        {
            get
            {
                // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                if (_buildSubtotal)
                {
                    BuildSubtotal();
                }
                // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                return _buildingSubtotals;
            }
        }
        public bool BuildItemSubtotals
        {
            get
            {
                return _buildItemSubtotals;
            }
            set
            {
                _buildItemSubtotals = value;
            }
        }
        // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F

		/// <summary>
		/// Gets or sets the bool "LoadIntransit".
		/// </summary>
		internal bool LoadIntransit
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal) 
                {
					this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
				}
				// END MID Change j.ellis Delay subtotal build until request for info.
				return this._loadIntransit;
			}
			set
			{
				this._loadIntransit = value;
			}
		}

        // begin TT#887 - JEllis Severe Error when General Method Processed
        internal bool LoadGrades
        {
            get
            {
                return (_gradeIndex == null);
            }
            set
            {
                if (value == true)
                {
                    _gradeIndex = null;
                }
                else
                {
                    DetermineStoreGrades();
                }
            }
        }
        // end TT#887 - JEllis - Severe Error when General Method Processed

		/// <summary>
		/// Gets or sets GradeWeekCount for the subtotal
		/// </summary>
		public int GradeWeekCount
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				if (_gradeWeekCount < 1)
				{
					if (this.SubtotalName == MIDText.GetTextOnly((int) eHeaderNode.GrandTotal) &&
						!this.Transaction.NeedAnalysisFrom1stHeader)
					{
						//						return this.SAB.ApplicationServerSession.GlobalOptions.StoreGradePeriod;
						return this.Transaction.GlobalOptions.StoreGradePeriod;
					}
                    // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    if (SubtotalMembers.Count == 0)
                    {
                        if (Transaction.AssortmentProfile == null)
                        {
                            return Transaction.GlobalOptions.StoreGradePeriod;
                        }
                        return Transaction.AssortmentProfile.GradeWeekCount;
                    }
                    // end TT#1154 - MD- Jellis-  Group Allocation Infinite  Loop When Going to SIze Analysis
					AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
					if (ap == null)
					{
						//						return this.Transaction.SAB.ApplicationServerSession.GlobalOptions.StoreGradePeriod;
						return this.Transaction.GlobalOptions.StoreGradePeriod;
					}
					return ap.GradeWeekCount;
				}
				return _gradeWeekCount;
			}
			set
			{
				if (value < 1)
				{
					throw new MIDException(eErrorLevel.warning,
						(int)eMIDTextCode.msg_GradeWeekCountCannotBeLT1,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_GradeWeekCountCannotBeLT1));
				}
				_gradeWeekCount = value;
			}
		}

        // begin TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        /// <summary>
        /// Gets associated Assortment Profile if it exists (null if it does not exist)
        /// </summary>
        public AssortmentProfile AssortmentProfile
        {
            get
            {
                // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                //if (SubtotalMembers.Count > 0)
                //{
                //    AllocationProfile ap = (AllocationProfile)SubtotalMembers[0];
                //    if (ap.AsrtRID != Include.NoRID)
                //    {
                //        return ap.AssortmentProfile;
                //    }
                //}
                //return null;
                return Transaction.AssortmentProfile;
                // end  TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
            }
        }
        public List<int> InventoryBasisRIDs
        {
            get
            {
                List<int> inventoryBasisRIDs = new List<int>();
                foreach (AllocationProfile ap in SubtotalMembers)
                {
                    if (ap.GradeInventoryBasisHnRID != Include.NoRID)
                    {
                        if (!(inventoryBasisRIDs.Exists(i => i == ap.GradeInventoryBasisHnRID)))
                        {
                            inventoryBasisRIDs.Add(ap.GradeInventoryBasisHnRID);
                        }
                    }
                    if (ap.CapacityNodeRID != Include.NoRID
                        && !(inventoryBasisRIDs.Exists(i => i == ap.CapacityNodeRID)))
                    {
                        inventoryBasisRIDs.Add(ap.CapacityNodeRID);
                    }
                }
                return inventoryBasisRIDs;
            }
        }
        // end TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken

		/// <summary>
		/// Gets or sets Plan Factor
		/// </summary>
		public double PlanFactor
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				if (_planPercentFactor < 0)
				{
					if (this.SubtotalName == MIDText.GetTextOnly((int) eHeaderNode.GrandTotal) &&
						!this.Transaction.NeedAnalysisFrom1stHeader)
					{
						return 100.0d;
					}
                    // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    if (SubtotalMembers.Count == 0)
                    {
                        if (Transaction.AssortmentProfile == null)
                        {
                            return 100.0d;
                        }
                        return Transaction.AssortmentProfile.PlanFactor;
                    }
                    // end TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
					AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
					if (ap == null)
					{
						return 100.0d;
					}
					return ap.PlanFactor;
				}
				return _planPercentFactor;
			}
			set
			{
				if (value < 0)
				{
					throw new MIDException(eErrorLevel.warning,
						(int)eMIDTextCode.msg_PlanFactorCannotBeNeg,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_PlanFactorCannotBeNeg));
				}
				_planPercentFactor = value;
			}
		}

		/// <summary>
		/// Gets or sets BeginDay
		/// </summary>
		public DateTime BeginDay
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				if (_beginDay == Include.UndefinedDate)
				{
					if (this.SubtotalName == MIDText.GetTextOnly((int) eHeaderNode.GrandTotal))
					{
                        // BEGIN MID Change j.ellis For Performance
						if (_beginCDR_FirstDate != Include.UndefinedDate)
						{
							return _beginCDR_FirstDate;
						}
                        // END MID Change j.ellis For Performance
						int beginCDR;
						if (this.Transaction.Velocity != null)
						{
							beginCDR = this.Transaction.Velocity.OTS_Begin_CDR_RID;
							if (beginCDR != Include.UndefinedCalendarDateRange
								&& beginCDR > 0)
							{
                                // BEGIN MID Change j.ellis For Performance
								_beginCDR_FirstDate = ((DayProfile)(this.Transaction.SAB.ApplicationServerSession.Calendar.GetFirstDayOfRange(beginCDR))).Date;
								return _beginCDR_FirstDate;
//								return ((DayProfile)(this.Transaction.SAB.ApplicationServerSession.Calendar.GetFirstDayOfRange(beginCDR))).Date;
							    // END MID Change j.ellis For Performance
							}
						}
						if (!this.Transaction.NeedAnalysisFrom1stHeader)
						{
							beginCDR = this.Transaction.AllocationNeedAnalysisPeriodBeginRID;
							if (beginCDR != Include.UndefinedCalendarDateRange
								&& beginCDR > 0)
							{
                                // BEGIN MID Change j.ellis For Performance
								_beginCDR_FirstDate = ((DayProfile)(this.Transaction.SAB.ApplicationServerSession.Calendar.GetFirstDayOfRange(beginCDR))).Date;
								return _beginCDR_FirstDate;
//								return ((DayProfile)(this.Transaction.SAB.ApplicationServerSession.Calendar.GetFirstDayOfRange(beginCDR))).Date;
							    // END MID Change j.ellis For Performance
							}						
						}
					}
                    // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    if (SubtotalMembers.Count == 0)
                    {
                        if (Transaction.AssortmentProfile == null)
                        {
                            return Include.UndefinedDate;
                        }
                        return Transaction.AssortmentProfile.BeginDay;
                    }
                    // end TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
					AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
					if (ap == null)
					{
						return Include.UndefinedDate;
					}
					return ap.BeginDay;
				}
				return _beginDay;
			}
			set
			{
				_beginDay = value;
			}
		}

		/// <summary>
		/// Gets the on-hand day profile (where on-hand will reside for this allocation)
		/// </summary>
		public DayProfile OnHandDayProfile
		{
			get
			{
				if (BeginDay == Include.UndefinedDate)
				{
					return this.Transaction.SAB.ApplicationServerSession.Calendar.CurrentDate;
				}
				else
				{
					return this.Transaction.SAB.ApplicationServerSession.Calendar.GetDay(BeginDay);
				}
			}
		}

		/// <summary>
		/// Gets or sets EndDay.
		/// </summary>
		public DateTime EndDay
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				if (this._endDay == Include.UndefinedDate)
				{
					if (this.SubtotalName == MIDText.GetTextOnly((int) eHeaderNode.GrandTotal))
					{
                        // BEGIN MID Change j.ellis For Performance
						if (_endCDR_Date != Include.UndefinedDate)
						{
							return _endCDR_Date;
						}
                        // END MID Change j.ellis For Performance
						int endCDR;
						if (this.Transaction.Velocity != null)
						{
							endCDR = this.Transaction.Velocity.OTS_Ship_To_CDR_RID;
							if (endCDR != Include.UndefinedCalendarDateRange
								&& endCDR > 0)
							{
                                // BEGIN MID Change j.ellis For Performance
								_endCDR_Date = ((DayProfile)(this.Transaction.SAB.ApplicationServerSession.Calendar.GetFirstDayOfRange(endCDR))).Date;
								return _endCDR_Date;
//								return ((DayProfile)(this.Transaction.SAB.ApplicationServerSession.Calendar.GetFirstDayOfRange(endCDR))).Date;
							    // END MID Change j.ellis For Performance
							}
						}
                        // begin TT#1166 - MD - Jellis - Color not in Bulk and No STores in Size Analysis
                        //   StyleView is always null here when Size Analysis is the chosen view; it is likely null even when Style is the chosen view because the subtotal is built before any of the views are built
                        //   This "if" prevents the Select from overriding the ShipDay (or EndDay) of the Shipping Horizon (and it never gets set for Size or Style Analysis resulting in no stores being displayed).
                        //if (this.Transaction.StyleView != null)//TT#874 - MD - DOConnell - Recieving an Out of Range exception when opening an Assortment with placeholders
                        //{
                        // end TT#1166 - MD - Jellis - Color not in Bulk and No STores in Size Analysis
                            if (!this.Transaction.NeedAnalysisFrom1stHeader)
                            {
                                endCDR = this.Transaction.AllocationNeedAnalysisPeriodEndRID;
                                if (endCDR != Include.UndefinedCalendarDateRange
                                    && endCDR > 0)
                                {
                                    // BEGIN MID Change j.ellis For Performance
                                    _endCDR_Date = ((DayProfile)(this.Transaction.SAB.ApplicationServerSession.Calendar.GetFirstDayOfRange(endCDR))).Date;
                                    return _endCDR_Date;
                                    //								return ((DayProfile)(this.Transaction.SAB.ApplicationServerSession.Calendar.GetFirstDayOfRange(endCDR))).Date;
                                    // END MID Change j.ellis For Performance
                                }
                            }
                        //}//TT#874 - MD - DOConnell - Recieving an Out of Range exception when opening an Assortment with placeholders // TT#1166 - MD - Jellis - Color not in Bulk and No STores in Size Analysis
					}
                    // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    if (SubtotalMembers.Count == 0)
                    {
                        if (Transaction.AssortmentProfile == null)
                        {
                            return Include.UndefinedDate;
                        }
                        return Transaction.AssortmentProfile.ShipToDay;
                    }
                    // end TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
					AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
					if (ap == null)
					{
						return Include.UndefinedDate;
					}
					return ap.ShipToDay;
				}
				return _endDay;
			}
			set
			{
				_endDay = value;
			}
		}

        /// <summary>
		/// Gets the merchandise key to use for eligibility
		/// </summary>
        private int EligibilityHnRID
        {
            get
            {
                if (_eligibilityHnRID == Include.NoRID)
                {
                    // use the plan level if not external eligibility
                    _eligibilityHnRID = PlanHnRID;
                    if (this.Transaction.GlobalOptions.UseExternalEligibilityAllocation)
                    {
                        // use the first header to determine the merchandise key
                        if (this.SubtotalMembers.Count > 0)
                        {
                            AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
                            _eligibilityHnRID = ap.GetEligibilityNodeForExternalEligibility();
                        }
                    }
                }
                return _eligibilityHnRID;
            }
        }

		/// <summary>
		/// Gets or sets PlanHnRID
		/// </summary>
		public int PlanHnRID
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
                } 
                // END MID Change j.ellis Delay subtotal build until request for info.
                // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                //if (this.SubtotalMembers.Count == 0)
                //{
                //    throw new MIDException(eErrorLevel.fatal,
                //        (int)eMIDTextCode.msg_al_SubtotalHasNoMembers,
                //        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalHasNoMembers));
                //}
                //AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
                int styleHnRID;
                AllocationProfile ap = null; // TT#1154 - MD - Jellis - Group ALlocation Infinite Loop when going to Size Analysis
                //int planHnRID;
                if (SubtotalMembers.Count == 0)
                {
                    if (Transaction.AssortmentProfile == null)
                    {
                        throw new MIDException(eErrorLevel.fatal,
                           (int)eMIDTextCode.msg_al_SubtotalHasNoMembers,
                           this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalHasNoMembers));
                    }
                    styleHnRID = Transaction.AssortmentProfile.StyleHnRID;
                    //planHnRID = Transaction.AssortmentProfile.PlanHnRID;
                }
                else
                {
                    ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0]; // TT#1154 - MD - Jellis - Group ALlocation Infinite Loop when going to Size Analysis
                    styleHnRID = ap.StyleHnRID;
                    //planHnRID = ap.PlanHnRID;
                }
                // end  TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
				if (_planHnRID == Include.NoRID)
				{
					if (this.SubtotalName == this.Transaction.GrandTotalName)
					{
						if (this.Transaction.Velocity != null)
						{
							if (this.Transaction.Velocity.OTSPlanHNRID == Include.NoRID)
							{
								if (this.Transaction.Velocity.OTSPlanPHRID == Include.NoRID)
								{
									//									if (this.Transaction.Velocity.OTSPlanPHLSeq == 0)
									//									{
									//										return this.GetPlanLevelData(ap.StyleHnRID);
									//									}
									//									else
									//									{
									//										return this.Transaction.GetAncestorDataByLevel(ap.StyleHnRID, ap.StyleHnRID, this.Transaction.Velocity.OTSPlanPHLSeq);
									//									}
								}
								else
								{
									//return this.SAB.HierarchyServerSession.GetAncestorDataByLevel(this.Transaction.Velocity.OTSPlanPHRID, ap.StyleHnRID, this.Transaction.Velocity.OTSPlanPHLSeq).Key; // MID Change j.ellis Performance
                                    // begin TT#1154 - MD- Jellis -  Group Allocation Infinite  Loop When Going to SIze Analysis
                                    //return this.Transaction.GetAncestorDataByLevel(this.Transaction.Velocity.OTSPlanPHRID, ap.StyleHnRID, this.Transaction.Velocity.OTSPlanPHLSeq).Key;                  // MID Change j.ellis Performance
                                    return this.Transaction.GetAncestorDataByLevel(this.Transaction.Velocity.OTSPlanPHRID, styleHnRID, this.Transaction.Velocity.OTSPlanPHLSeq).Key;                  // MID Change j.ellis Performance
                                    // end TT#1154 - MD- JEllis-  Group Allocation Infinite  Loop When Going to SIze Analysis
                                }
							}
							else
							{
								return this.Transaction.Velocity.OTSPlanHNRID;
								//								return this.Transaction.GetPlanLevelData(this.Transaction.Velocity.OTSPlanHNRID).Key;
							}
						}

                        // begin TT#1020 - MD - Jellis - MID Client stops working when going to Need Analysis
                        // NOTE:  Style Review will be null at this point but "NeedAnalysisFrom1stHeader will be set.  So the check to see if Style View is there cannot be done here!
                        //        The changelist for issue TT#873 does not show that the Allocation Subtotal Profile was changed for issue 873; so not clear why this change was originally made
                        //if (this.Transaction.StyleView != null) //TT#873-MD-DOConnell - System Exception: Header does not have Placeholder ID - when trying to add placeholders to an Assortment.
                        //{
                            // end TT#1020 - MD - Jellis - MID Client stops working when going to Need Analysis
                        if (!this.Transaction.NeedAnalysisFrom1stHeader)
                        {
                            int planHnRID = this.Transaction.AllocationNeedAnalysisHNID;
                            if (planHnRID != Include.NoRID)
                            {
                                return this.Transaction.AllocationNeedAnalysisHNID;
                            }
                        }
                        //} //TT#873-MD-DOConnell - System Exception: Header does not have Placeholder ID - when trying to add placeholders to an Assortment. // TT#1020 - MD - Jellis - MID Client stops working when going to Need Analysis
					}
                    if (ap == null)  //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    {                //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                        return Transaction.AssortmentProfile.PlanHnRID; //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    }                                       //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    return ap.PlanHnRID; //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    //return ap.PlanHnRID; //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
				}
				return _planHnRID;
			}
			set
			{
				_planHnRID = value;
			}
		}

		/// <summary>
		/// Gets or sets onhand hierarchy node RID.
		/// </summary>
		public int OnHandHnRID
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				if (_onHandHnRID == Include.NoRID)
				{
					if (this.SubtotalName == MIDText.GetTextOnly((int) eHeaderNode.GrandTotal) &&
						!this.Transaction.NeedAnalysisFrom1stHeader)
					{
                        // begin TT#1154 - MD - Jellis - Group Allocation Style Review No Stores
                        if (Transaction.AllocationNeedAnalysisHNID > 0)
                        {
                            // end TT#1154 - MD - Jellis - Group Allocation Style Review No Stores
                            return this.Transaction.AllocationNeedAnalysisHNID;
                        }   // TT#1154 - MD - Jellis- Group ALlocation Style Review No Stores
					}
					if (this.SubtotalMembers.Count == 0)
					{
                        // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                        if (Transaction.AssortmentProfile != null)
                        {
                            return Transaction.AssortmentProfile.OnHandHnRID;
                        }
                        // end TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
						throw new MIDException(eErrorLevel.fatal,
							(int)eMIDTextCode.msg_al_SubtotalHasNoMembers,
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalHasNoMembers));
					}
					AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
                    return ap.OnHandHnRID;
				}
				return _onHandHnRID;
			}
			set
			{
				_onHandHnRID = value;
			}
		}

		/// <summary>
		/// Gets or sets velocity style hierarchy node RID.
		/// </summary>
		public int VelocityStyleHnRID
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				if (_velocityStyleRID == Include.NoRID)
				{
                    // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    //if (this.SubtotalMembers.Count == 0)
                    //{
                    //    throw new MIDException(eErrorLevel.fatal,
                    //        (int)eMIDTextCode.msg_al_SubtotalHasNoMembers,
                    //        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalHasNoMembers));
                    //}
                    //AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
                    int velocityHeaderOnhandHnRID;
                    if (SubtotalMembers.Count == 0)
                    {
                        if (Transaction.AssortmentProfile == null)
                        {
                            throw new MIDException(eErrorLevel.fatal,
                                (int)eMIDTextCode.msg_al_SubtotalHasNoMembers,
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalHasNoMembers));
                        }
                        velocityHeaderOnhandHnRID = Transaction.AssortmentProfile.VelocityHeaderOnhandHnRID;
                    }
                    else
                    {
                        AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
                        velocityHeaderOnhandHnRID = ap.VelocityHeaderOnhandHnRID;
                    }
                    // end  TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
					if (this.BeginDay == Include.UndefinedDate)
					{
                        // begin TT#675 - MD - JEllis - Velocity Ship To Header should use Onhand Source when overridden, else Color when one color and Style When multiple colors
                        //return ap.StyleHnRID;
                        //return ap.VelocityHeaderOnhandHnRID; //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                        return velocityHeaderOnhandHnRID;      //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                        // endn TT#675 - MD - JEllis - Velocity Ship To Header should use Onhand Source when overridden, else Color when one color and Style When multiple colors
					}
                    // begin TT#675 - MD - JEllis - Velocity Ship To Header should use Onhand Source when overridden, else Color when one color and Style When multiple colors
                    //return this.OnHandHnRID;
                    //return ap.VelocityHeaderOnhandHnRID; //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    return velocityHeaderOnhandHnRID;      //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    // end TT#675 - MD - JEllis - Velocity Ship To Header should use Onhand Source when overridden, else Color when one color and Style When multiple colors
				}
				return _velocityStyleRID;
			}
			set
			{
				_velocityStyleRID = value;
			}
		}

		/// <summary>
		/// Gets or sets the GradeList definition.
		/// </summary>
		public ArrayList GradeList
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal) 
                {
                    this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
				}
				// END MID Change j.ellis Delay subtotal build until request for info.
				if (_grade == null)
				{
					if (this.SubtotalName == this.Transaction.GrandTotalName)
					{
						if (this.Transaction.NeedAnalysisFrom1stHeader)
						{
							if (this.SubtotalMembers.Count == 0)
							{
                                // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                                if (Transaction.AssortmentProfile != null)
                                {
                                    return Transaction.AssortmentProfile.GradeList;
                                }
                                // end  TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
								throw new MIDException(eErrorLevel.fatal,
									(int)eMIDTextCode.msg_al_SubtotalHasNoMembers,
									this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalHasNoMembers));
							}
							AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
							return ap.GradeList;
						}
					}
					ArrayList aGradeList;
					AllocationGradeBin aGradeBin;
					aGradeList = new ArrayList();
					StoreGradeList sgl = ((ApplicationSessionTransaction)Transaction).GetStoreGradeList(PlanHnRID);
					foreach (StoreGradeProfile aGrade in sgl)
					{
						aGradeBin = new AllocationGradeBin();
						aGradeBin.SetGrade(aGrade.StoreGrade);
						aGradeBin.SetGradeAdMinimum(aGrade.MinAd);
						aGradeBin.SetGradeColorMaximum(aGrade.MaxColor);
						aGradeBin.SetGradeColorMinimum(aGrade.MinColor);
						aGradeBin.SetGradeMaximum(aGrade.MaxStock);
						aGradeBin.SetGradeMinimum(aGrade.MinStock);
						aGradeBin.SetLowBoundary(aGrade.Boundary);
						aGradeList.Add(aGradeBin);
					}
					aGradeList.Sort(new AllocationGradeBinCompareDescend());
					_grade = aGradeList;
				}
				return _grade;
			}
		}

		/// <summary>
		/// Gets Total Units To Allocate
		/// </summary>
		public int TotalUnitsToAllocate
		{
			get
			{
			    // BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _headerTotal.QtyToAllocate;
			}
		}

		/// <summary>
		/// Gets or spreads Total Units Allocated
		/// </summary>
		public int TotalUnitsAllocated
		{
			get
			{
				return AccumTotalUnitsAllocated(_allStoreList, _subtotalTotal);
			}
			set
			{
				GeneralComponent gc = new GeneralComponent(eGeneralComponentType.Total);
				SpreadStoreListTotalQtyAllocated(
					gc, 
					_allStoreList,
					value);
				//				SpreadTotalUnitsAllocated(eAllocationSummaryNode.Total, _allStoreList, value, 
				//					_subtotalTotal);
			}
		}
		
		/// <summary>
		/// Gets or sets Total Allocation Multiple
		/// </summary>
		private int TotalMultiple
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _headerTotal.UnitMultiple;
			}
			set
			{
				_headerTotal.SetUnitMultiple(value);
			}
		}

		public ProfileList AllocationFilteredStoreList
		{
			get
			{
				//				if (this._filterStoreRID != this.Transaction.AllocationFilterID
				//					|| this._filterStoreList == null)
				//				{
				//					if (this.Transaction.AllocationFilterID != Include.NoRID)
				//					{
				//						_filterStoreRID = this.Transaction.AllocationFilterID;
				//						_filterStoreList = this.Transaction.GetAllocationFilteredStoreList(this.PlanHnRID, _filterStoreRID); 
				//					}
				//					else if (_filterStoreRID != Include.AllStoreFilterRID)
				//					{
				//						_filterStoreRID = Include.AllStoreFilterRID;
				//						_filterStoreList = this._allStoreList;
				//					}
				//				}
				//				return _filterStoreList;
				if (this.Transaction.AllocationFilterID == Include.NoRID)
				{
					_filterStoreRID = Include.AllStoreFilterRID;
				}
				else
				{
					_filterStoreRID = this.Transaction.AllocationFilterID;
				}
				// BEGIN Issue 5727 stodd
				bool outdatedFilter = false;
				// begin MID Track 5727 - J.Ellis (Fix Null Reference)
				//ProfileList storeList = this.Transaction.GetAllocationFilteredStoreList(this.PlanHnRID, _filterStoreRID, ref outdatedFilter);
				_filterStoreList =
					this.Transaction.GetAllocationFilteredStoreList(
                        this.PlanHnRID, 
                        GetCubeEligibilityNode(), 
                        _filterStoreRID, 
                        ref outdatedFilter);
				// end MID Track 5727 - J.Ellis (Fix Null Reference)
				if (outdatedFilter)
				{
					_filterStoreList.Clear();
					FilterData storeFilterData = new FilterData();
					string filterName = storeFilterData.FilterGetName(_filterStoreRID);
					string msg = MIDText.GetText(eMIDTextCode.msg_FilterInvalid);
					msg = msg.Replace("{0}",filterName);
					string suffix = "- AllocationFilteredStoreList.";
					string auditMsg = msg + suffix;
					// begin MID Track 5778 - Scheduler 'Run Now' feature gets error in audit
					//SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Error, eMIDTextCode.msg_FilterInvalid, auditMsg, this.ToString()); 
					SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Error, eMIDTextCode.msg_FilterInvalid, auditMsg, this.GetType().Name);
					// end MID Track 5778 - Scheduler 'Run Now' feature gets error in audit
					throw new MIDException(eErrorLevel.severe, (int)eMIDTextCode.msg_FilterInvalid, msg);
				}
				// END Issue 5727
				return _filterStoreList;
			}
		}


		/// <summary>
		/// Gets or spreads FilterTotal Units Allocated
		/// </summary>
		public int FilterTotalUnitsAllocated
		{
			get
			{
				return AccumTotalUnitsAllocated(AllocationFilteredStoreList, _subtotalTotal);
			}
			set
			{
				GeneralComponent gc = new GeneralComponent(eGeneralComponentType.Total);
				SpreadStoreListTotalQtyAllocated(
					gc,
					this.AllocationFilteredStoreList,
					value);
				//				SpreadTotalUnitsAllocated(eAllocationSummaryNode.Total, _filterStoreList, value, 
				//					_subtotalTotal);
			}
		}

		/// <summary>
		/// Gets Generic Type Units To Allocate
		/// </summary>
		public int GenericTypeUnitsToAllocate
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _genericTotal.QtyToAllocate;
			}
		}

		/// <summary>
		/// Gets or spreads Generic Type Units Allocated
		/// </summary>
		public int GenericTypeUnitsAllocated
		{
			get
			{
				return AccumTotalUnitsAllocated(_allStoreList, _subtotalGenericType);
			}
			set
			{
				GeneralComponent gc = new GeneralComponent(eGeneralComponentType.GenericType);
				SpreadStoreListTotalQtyAllocated(
					gc,
					_allStoreList,
					value);
				//				SpreadTotalUnitsAllocated(eAllocationSummaryNode.GenericType, _allStoreList,
				//					value, _subtotalGenericType);
			}
		}
		
		/// <summary>
		/// Gets or sets Generic Type Allocation Multiple
		/// </summary>
		private int GenericTypeMultiple
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _genericTotal.UnitMultiple;
			}
			set
			{
				_genericTotal.SetUnitMultiple(value);
			}
		}

		/// <summary>
		/// Gets or spreads Filter GenericType Units Allocated
		/// </summary>
		public int FilterGenericTypeUnitsAllocated
		{
			get
			{
				return AccumTotalUnitsAllocated(AllocationFilteredStoreList, _subtotalGenericType);
			}
			set
			{
				GeneralComponent gc = new GeneralComponent(eGeneralComponentType.GenericType);
				SpreadStoreListTotalQtyAllocated(
					gc,
					AllocationFilteredStoreList,
					value);
				//				SpreadTotalUnitsAllocated(eAllocationSummaryNode.GenericType, _filterStoreList, value, 
				//					_subtotalGenericType);
			}
		}

		/// <summary>
		/// Gets Detail Type Units To Allocate
		/// </summary>
		public int DetailTypeUnitsToAllocate
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _detailTotal.QtyToAllocate;
			}
		}

		/// <summary>
		/// Gets or spreads Detail Type Units Allocated
		/// </summary>
		public int DetailTypeUnitsAllocated
		{
			get
			{
				return AccumTotalUnitsAllocated(_allStoreList, _subtotalDetailType);
			}
			set
			{
				GeneralComponent gc = new GeneralComponent(eGeneralComponentType.DetailType);
				SpreadStoreListTotalQtyAllocated(
					gc,
					_allStoreList,
					value);
				//				SpreadTotalUnitsAllocated(eAllocationSummaryNode.DetailType, _allStoreList,
				//					value, _subtotalDetailType);
			}
		}
		
		/// <summary>
		/// Gets or sets Detail Type Allocation Multiple
		/// </summary>
		private int DetailTypeMultiple
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _detailTotal.UnitMultiple;
			}
			set
			{
				_detailTotal.SetUnitMultiple(value);
			}
		}

		/// <summary>
		/// Gets or spreads Filter DetailType Units Allocated
		/// </summary>
		public int FilterDetailTypeUnitsAllocated
		{
			get
			{
				return AccumTotalUnitsAllocated(AllocationFilteredStoreList, _subtotalDetailType);
			}
			set
			{
				GeneralComponent gc = new GeneralComponent(eGeneralComponentType.DetailType);
				SpreadStoreListTotalQtyAllocated(
					gc,
					AllocationFilteredStoreList,
					value);
				//				SpreadTotalUnitsAllocated(eAllocationSummaryNode.DetailType, _filterStoreList,
				//					value, _subtotalDetailType);
			}
		}

		/// <summary>
		/// Gets Bulk Units To Allocate
		/// </summary>
		public int BulkUnitsToAllocate
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _bulkTotal.QtyToAllocate;
			}
		}

		/// <summary>
		/// Gets or spreads Bulk Units Allocated
		/// </summary>
		public int BulkUnitsAllocated
		{
			get
			{
				return AccumTotalUnitsAllocated(_allStoreList, _subtotalBulk);
			}
			set
			{
				GeneralComponent gc = new GeneralComponent(eGeneralComponentType.Bulk);
				SpreadStoreListTotalQtyAllocated(
					gc,
					_allStoreList,
					value);
				//				SpreadTotalUnitsAllocated(eAllocationSummaryNode.Bulk, _allStoreList,
				//					value, _subtotalBulk);
			}
		}
		
		/// <summary>
		/// Gets or sets Bulk Allocation Multiple
		/// </summary>
		private int BulkMultiple
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _bulkTotal.UnitMultiple;
			}
			set
			{
				_bulkTotal.SetUnitMultiple(value);
			}
		}

		/// <summary>
		/// Gets or spreads Filter Bulk Units Allocated
		/// </summary>
		public int FilterBulkUnitsAllocated
		{
			get
			{
				return AccumTotalUnitsAllocated(AllocationFilteredStoreList, _subtotalBulk);
			}
			set
			{
				GeneralComponent gc = new GeneralComponent(eGeneralComponentType.Bulk);
				SpreadStoreListTotalQtyAllocated(
					gc,
					AllocationFilteredStoreList,
					value);
				//				SpreadTotalUnitsAllocated(eAllocationSummaryNode.Bulk, _filterStoreList,
				//					value, _subtotalBulk);
			}
		}

		public int StoreDimension
		{
			get 
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _subtotalTotal.Length;
			}
		}


		/// <summary>
		/// Gets the bulk color hashtable
		/// </summary>
		/// <returns>Bulk color hashtable.</returns>
		internal Hashtable BulkColors  // TT#1166 - MD - Jellis - Color not in bulk OR no store in Size Analysis (don't allow access to underlying structure
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _bulkColors;
			}
		}

		/// <summary>
		/// Gets the subtotal pack hashtable.
		/// </summary>
		public Hashtable SubtotalPacks
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				return _subtotalPacks;
			}
		}
 
		/// <summary>
		/// Gets number of unique packs defined on subtotal.
		/// </summary>
		public int SubtotalPackCount
		{
			get
			{
				return SubtotalPacks.Count;
			}
		}

		/// <summary>
		/// Indicates whether all members of the subtotal update intransit
		/// </summary>
		public bool AllMembersUpdateStyleIntransit
		{
			get
			{
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					if (!ap.StyleIntransitUpdated)
					{
						return false;
					}
				}
				return true;
			}
		}

		/// <summary>
		/// Indicates whether all members of the subtotal update size intransit
		/// </summary>
		public bool AllMembersUpdateBulkSizeIntransit
		{
			get
			{
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					if (!ap.BulkSizeIntransitUpdated)
					{
						return false;
					}
				}
				return true;
			}
		}

		/// <summary>
		/// Gets CapacityNodes, a Hashtable containing arraylists of allocation profiles having the same capacity node.
		/// </summary>
		public Hashtable CapacityNodes
		{
			get
			{
				// BEGIN MID Change j.ellis Delay subtotal build until request for info.
                if (_buildSubtotal)
                {
                    this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
                }
				// END MID Change j.ellis Delay subtotal build until request for info.
				if (_capacityNodes == null)
				{
					_capacityNodes = new Hashtable();
					ArrayList capacityNodeHeaders;
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (_capacityNodes.Contains(ap.CapacityNodeRID))
						{
							capacityNodeHeaders = (ArrayList)_capacityNodes[ap.CapacityNodeRID]; 
						}
						else
						{
							capacityNodeHeaders = new ArrayList();
							_capacityNodes.Add(ap.CapacityNodeRID, capacityNodeHeaders);
						}
						capacityNodeHeaders.Add(ap);
					}
				}
				return _capacityNodes;
			}
		}

		// BEGIN Issue 4778 stodd 10.5.2007
		// Add these primarily so they could be nulled out to force the basis to be rebuilt
		// when the header changes. Only done when Velocity processing is NOT interactive and
		// the basis is a forecast level
		private double[] VelocityStoreBasisStock
		{
			get
			{
				return _velocityStoreBasisStock;
			}
			set
			{
				_velocityStoreBasisStock = value;
			}
		}

		private double[] VelocityStoreBasisSales
		{
			get
			{
				return _velocityStoreBasisSales;
			}
			set
			{
				_velocityStoreBasisSales = value;
			}
		}
		// END Issue 4778 stodd 10.5.2007

		#endregion Properties
 	
		
		#region Methods
		//========
		// METHODS
		//========
		#region UnitsToAllocate
		/// <summary>
		/// Gets total quantity to allocate for the specified component of the specified Allocation Profile
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile</param>
		/// <param name="aGeneralComponent">General Component descrition</param>
		/// <returns>Total quantity to allocate across all members of the subtotal.</returns>
		public int GetQtyToAllocate(AllocationProfile aAllocationProfile, GeneralComponent aGeneralComponent)
		{
			if (aAllocationProfile == null)
			{
				return GetQtyToAllocate(aGeneralComponent);
			}
			return aAllocationProfile.GetQtyToAllocate(aGeneralComponent);
		}

		/// <summary>
		/// Gets total quantity to allocate for the specified component across all members of the subtotal
		/// </summary>
		/// <param name="aGeneralComponent">General Component descrition</param>
		/// <returns>Total quantity to allocate across all members of the subtotal.</returns>
		public int GetQtyToAllocate(GeneralComponent aGeneralComponent)
		{
			GeneralComponent gc;
			AllocationPackComponent packComponent;
			PackHdr subtotalPack = null;
			if (aGeneralComponent is AllocationPackComponent)
			{
				packComponent = (AllocationPackComponent)aGeneralComponent;
				subtotalPack = this.GetSubtotalPackHdr(packComponent.PackName);
				AllocationPackComponent apc = new AllocationPackComponent(subtotalPack.PackName);
				gc = apc;
			}
			else
			{
				gc = aGeneralComponent;
			}
			int qtyToAllocate = 0;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			AllocationColorSizeComponent colorAndSizeComponent;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				bool componentValid = true;
				if (aGeneralComponent is AllocationPackComponent)
				{
					if (!ap.PackIsOnHeader(subtotalPack.PackName))
					{
						componentValid = false;
					}
				}
				else if (aGeneralComponent is AllocationColorOrSizeComponent)
				{
					colorComponent = (AllocationColorOrSizeComponent) aGeneralComponent;
					if (!ap.BulkColorIsOnHeader(colorComponent.ColorRID))
					{
						componentValid = false;
					}
				}
				else if (aGeneralComponent is AllocationColorSizeComponent)
				{
					colorAndSizeComponent = (AllocationColorSizeComponent)aGeneralComponent;
					if (colorAndSizeComponent.ColorComponent is AllocationColorOrSizeComponent)
					{
						colorComponent = (AllocationColorOrSizeComponent)colorAndSizeComponent.ColorComponent;
						if (!ap.BulkColorIsOnHeader(colorComponent.ColorRID))
						{
							componentValid = false;
						}
						else if (colorAndSizeComponent.SizeComponent is AllocationColorOrSizeComponent)
						{
							sizeComponent = (AllocationColorOrSizeComponent)colorAndSizeComponent.SizeComponent;
							if (sizeComponent.ComponentType == eComponentType.SpecificSize)
							{
								if (!ap.GetHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
								{
									componentValid = false;
								}
							}
							// else primary and secondary sizes are always valid.
						}
						// else assume all sizes
					}
					else
					{   //  assume all colors  
						if (colorAndSizeComponent.SizeComponent is AllocationColorOrSizeComponent)
						{
							sizeComponent = (AllocationColorOrSizeComponent)colorAndSizeComponent.SizeComponent;
							if (sizeComponent.ComponentType == eComponentType.SpecificSize)
							{
								foreach (HdrColorBin hcb in ap.BulkColors.Values) 	// MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color

								{
									if (!hcb.SizeIsInColor(sizeComponent.SizeRID))
									{
										componentValid = false;
									}
								}
							}
							// else primary and secondary sizes are always valid.
						}
						//else assume all sizes
					}
				}
				if (componentValid)
				{
					qtyToAllocate += ap.GetQtyToAllocate(gc);
				}
			}
			return qtyToAllocate;
		}

		/// <summary>
		/// Sets Total units to allocate
		/// </summary>
		/// <param name="aUnitsToAllocate">Units to allocate</param>
		internal void SetTotalUnitsToAllocate (int aUnitsToAllocate)
		{
			_headerTotal.SetQtyToAllocate(aUnitsToAllocate);
		}

		/// <summary>
		/// Sets GenericType units to allocate
		/// </summary>
		/// <param name="aUnitsToAllocate">Units to allocate</param>
		internal void SetGenericTypeUnitsToAllocate (int aUnitsToAllocate)
		{
			_genericTotal.SetQtyToAllocate(aUnitsToAllocate);
		}

		/// <summary>
		/// Sets Detail Type units to allocate
		/// </summary>
		/// <param name="aUnitsToAllocate">Units to allocate</param>
		internal void SetDetailTypeUnitsToAllocate (int aUnitsToAllocate)
		{
			_detailTotal.SetQtyToAllocate(aUnitsToAllocate);
		}

		/// <summary>
		/// Sets Bulk units to allocate
		/// </summary>
		/// <param name="aUnitsToAllocate">Units to allocate</param>
		internal void SetBulkUnitsToAllocate (int aUnitsToAllocate)
		{
			_bulkTotal.SetQtyToAllocate(aUnitsToAllocate);
		}
		#endregion UnitsToAllocate

		#region UnitsAllocated
		/// <summary>
		/// Accumulates subtotal total units allocated for selected stores.
		/// </summary>
		/// <param name="aStoreList">Selected stores</param>
		/// <returns>Total Units Allocated</returns>
		internal int AccumTotalUnitsAllocated(ProfileList aStoreList, 
			SubtotalAllocatedBaseBin[] aSubtotalAllocatedBin)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			int total = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					total += aSubtotalAllocatedBin[storeIdxRID.Index].QtyAllocated;
				}
			}
			return total;
		}

		//		/// <summary>
		//		/// Sets Total Units Allocated
		//		/// </summary>
		//		/// <param name="aQtyAllocated"></param>
		//		internal void SetTotalUnitsAllocated(int aQtyAllocated)
		//		{
		//			_headerTotal.SetQtyAllocated(aQtyAllocated);
		//		}
		//
		//		/// <summary>
		//		/// Sets GenericType Units Allocated
		//		/// </summary>
		//		/// <param name="aQtyAllocated"></param>
		//		internal void SetGenericUnitsAllocated(int aQtyAllocated)
		//		{
		//			_genericTotal.SetQtyAllocated(aQtyAllocated);
		//		}
		//
		//		/// <summary>
		//		/// Sets Detail Type Units Allocated
		//		/// </summary>
		//		/// <param name="aQtyAllocated"></param>
		//		internal void SetDetailTypeUnitsAllocated(int aQtyAllocated)
		//		{
		//			_detailTotal.SetQtyAllocated(aQtyAllocated);
		//		}
		//
		//		/// <summary>
		//		/// Sets Bulk Units Allocated
		//		/// </summary>
		//		/// <param name="aQtyAllocated"></param>
		//		internal void SetBulkUnitsAllocated(int aQtyAllocated)
		//		{
		//			_bulkTotal.SetQtyAllocated(aQtyAllocated);
		//		}
		#endregion TotalUnitsAllocated

		#region PackHeader
		#region PackOnSubtotalTest
		/// <summary>
		/// Indicates whether the specified pack is defined on the allocation subtotal.
		/// </summary>
		/// <param name="aSubtotalPackName">The name of the subtotal pack.</param>
		/// <returns>True when the pack is defined on the subtotal, false otherwise.</returns>
		public bool PackIsOnSubtotal(string aSubtotalPackName)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			if (SubtotalPackCount == 0)
			{
				return false;
			}
			else
			{
				return _subtotalPacks.Contains(aSubtotalPackName);
			}
		}
		#endregion PackOnSubtotalTest

		#region GetSubtotalPackHdr
		/// <summary>
		/// Gets requested subtotal PackHdr
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack name.</param>
		/// <returns>Requested PackHdr definition</returns>
		public PackHdr GetSubtotalPackHdr(string aSubtotalPackName)
		{
			if (PackIsOnSubtotal(aSubtotalPackName))
			{
				return (PackHdr)_subtotalPacks[aSubtotalPackName];
			}
			else
			{
				throw new MIDException (eErrorLevel.warning,
					(int)eMIDTextCode.msg_al_PackNotDefinedOnSubtotal,
					this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_PackNotDefinedOnSubtotal));
			}
		}
		#endregion GetSubtotalPackHdr

		#region PackName
		//====================//
		// Subtotal Pack Name //
		//====================//
		/// <summary>
		/// Gets an ICollection of the subtotal pack names for this subtotal.
		/// </summary>
		/// <returns>ICollection of the pack names for this subtotal.</returns>
		public string[] GetSubtotalPackNames ()
		{
			return (string[])SubtotalPacks.Keys;
		}
		#endregion PackName

		#region PackType
		//==================================//
		// Pack Type: Generic or NonGeneric //
		//==================================//
		/// <summary>
		/// Gets pack generic flag value.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <returns>True when pack is a generic pack; false otherwise.</returns>
		public bool GenericPack (string aSubtotalPackName)
		{
			return GenericPack(GetSubtotalPackHdr(aSubtotalPackName));
		}

		/// <summary>
		/// Gets pack generic flag value.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes subtotal pack</param>
		/// <returns>True when subtotal pack is a generic pack; false otherwise.</returns>
		internal bool GenericPack (PackHdr aSubtotalPack)
		{
			return aSubtotalPack.GenericPack;
		}
        
		/// <summary>
		/// Gets pack type (generic or non-generic)
		/// </summary>
		/// <param name="aSubtotalPackName">SubtotalPack name</param>
		/// <returns>eAllocationType of the subtotal pack</returns>
		public eAllocationType GetPackType(string aSubtotalPackName)
		{
			return GetPackType(GetSubtotalPackHdr(aSubtotalPackName));
		}

		/// <summary>
		/// Gets pack type (generic or non-generic)
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that identifies the subtotal pack</param>
		/// <returns>eAllocationType of the subtotal pack</returns>
		internal eAllocationType GetPackType(PackHdr aSubtotalPack)
		{
			if (aSubtotalPack.GenericPack)
			{
				return eAllocationType.GenericType;
			}	
			else
			{
				return eAllocationType.DetailType;
			}
		} 
		#endregion PackType

		#region PackMultiple
		//===============//
		// Pack Multiple //
		//===============//
		/// <summary>
		/// Gets pack multiple (total units in the pack).
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <returns>Number of units in the subtotal pack (the pack multiple).</returns>
		public int GetPackMultiple (string aSubtotalPackName)
		{
			return GetPackMultiple(GetSubtotalPackHdr(aSubtotalPackName));
		}

		/// <summary>
		/// Gets pack multiple (total units in the pack).
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <returns>Number of units in the pack (the pack multiple).</returns>
		internal int GetPackMultiple (PackHdr aSubtotalPack)
		{
			return aSubtotalPack.PackMultiple;
		}
		#endregion PackMultiple

		#region PacksToAllocate
		//===================//
		// Packs To Allocate //
		//===================//
		/// <summary>
		/// Gets number of packs to allocate.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <returns>Number of packs to allocate.</returns>
		public int GetPacksToAllocate (string aSubtotalPackName)
		{
			return GetPacksToAllocate(GetSubtotalPackHdr(aSubtotalPackName));
		}
		
		/// <summary>
		/// Gets number of packs to allocate.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes subtotal pack.</param>
		/// <returns>Number of packs to allocate.</returns>
		internal int GetPacksToAllocate (PackHdr aSubtotalPack)
		{
			return aSubtotalPack.PacksToAllocate;
		}
	
		/// <summary>
		/// Gets total units to allocate for this subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <returns>Total units to allocate for this subtotal pack.</returns>
		public int GetUnitsToAllocateByPack (string aSubtotalPackName)
		{
			return GetUnitsToAllocateByPack(GetSubtotalPackHdr(aSubtotalPackName));
		}

		/// <summary>
		/// Gets total units to allocate for this subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <returns>Total units to allocate for this subtotal pack.</returns>
		internal int GetUnitsToAllocateByPack (PackHdr aSubtotalPack)
		{
			return aSubtotalPack.UnitsToAllocate;
		}
		#endregion PacksToAllocate

		#region PacksAllocated
		//==========================//
		// Subtotal Packs Allocated //
		//==========================//
		/// <summary>
		/// Gets number of packs allocated to stores.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <returns>Number of packs allocated to stores.</returns>
		public int GetPacksAllocated (string aSubtotalPackName)
		{
			return GetPacksAllocated(GetSubtotalPackHdr(aSubtotalPackName));
		}

		/// <summary>
		/// Gets number of packs allocated to stores.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack.</param>
		/// <returns>Number of packs allocated to stores.</returns>
		internal int GetPacksAllocated (PackHdr aSubtotalPack)
		{
			return aSubtotalPack.PacksAllocated;
		}

		/// <summary>
		/// Sets number of packs allocated to stores.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <param name="aPacksAllocated">Number of packs allocated</param>
		/// <remarks>This will spread the specified packs allocated to the stores based on their current allocation in this pack.</remarks>
		public void SetPacksAllocated (string aSubtotalPackName, int aPacksAllocated)
		{
			SpreadPacksAllocated(GetSubtotalPackHdr(aSubtotalPackName), aPacksAllocated, true);
		}

		/// <summary>
		/// Sets number of packs allocated to stores.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack.</param>
		/// <param name="aPacksAllocated">Number of packs allocated.</param>
		internal void SetPacksAllocated (PackHdr aSubtotalPack, int aPacksAllocated)
		{
			aSubtotalPack.SetPacksAllocated(aPacksAllocated);
		}

		/// <summary>
		/// Adjusts the total number of packs allocated to the stores.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <param name="aAdjValue">Adjustment value</param>
		/// <remarks>
		/// If the requested adjustment causes the quantity allocated to be negative
		/// an exception will occur and the update will not occur.
		/// </remarks>
		internal void AdjustPacksAllocated (string aSubtotalPackName, int aAdjValue)
		{
			AdjustPacksAllocated(GetSubtotalPackHdr(aSubtotalPackName),	aAdjValue);
		}
	
		/// <summary>
		/// Adjusts the total number of packs allocated to the stores.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <param name="aAdjValue">Adjustment value</param>
		/// <remarks>
		/// If the requested adjustment causes the quantity allocated to be negative
		/// an exception will occur and the update will not occur.
		/// </remarks>
		internal void AdjustPacksAllocated (PackHdr aSubtotalPack, int aAdjValue)
		{
			aSubtotalPack.SetPacksAllocated(
				aSubtotalPack.PacksAllocated
				+ aAdjValue);
		}
	
		/// <summary>
		/// Spreads total number of packs allocated to stores.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes subtotal pack.</param>
		/// <param name="aPacksAllocated">Number of packs allocated.</param>
		/// <param name="aIsManual">True: indicates this ia a manually keyed value (ignored when aSpread is false).</param>
		internal void SpreadPacksAllocated (PackHdr aSubtotalPack, int aPacksAllocated, bool aIsManual)
		{
			int newTotal = aPacksAllocated;
			int oldTotal = this.GetPacksAllocated(aSubtotalPack);
			int lockTotal = 0;
			ArrayList storeArray = new ArrayList();
			Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
			foreach (Index_RID storeIdxRID in index_RID_Array)
			{
				if (this.GetStoreLocked(aSubtotalPack, storeIdxRID)
					|| this.GetStoreTempLock(aSubtotalPack, storeIdxRID))
				{
					lockTotal += this.GetStoreQtyAllocated(aSubtotalPack, storeIdxRID);
				}
				else
				{
					storeArray.Add(storeIdxRID);
				}
			}
			newTotal -= lockTotal;
			oldTotal -= lockTotal;
			if (newTotal <= 0)
			{
				newTotal = 0;
				this.Transaction.SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Information, 
					eMIDTextCode.msg_al_LockTotalExceedsNew,
					this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew, false));
			}
			int oldUnitsAllocated;
			int newUnitsAllocated;
			foreach (Index_RID storeIdxRID in storeArray)
			{
				if (oldTotal > 0)
				{
					oldUnitsAllocated = this.GetStoreQtyAllocated(aSubtotalPack, storeIdxRID);
					newUnitsAllocated = 
						(int)(((double) oldUnitsAllocated
						* (double) newTotal
						/ (double) oldTotal)
						+ .5d);
					if (newUnitsAllocated > newTotal)
					{
						newUnitsAllocated = newTotal;
					}
					oldTotal -= oldUnitsAllocated;
				}
				else
				{
					newUnitsAllocated = 0;
				}
				this.SetStoreQtyAllocated(aSubtotalPack, storeIdxRID, newUnitsAllocated, eDistributeChange.ToNone, false);
				newTotal -= this.GetStoreQtyAllocated(aSubtotalPack, storeIdxRID);
			}
		}

		/// <summary>
		/// Gets total units allocated to the stores by the subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <returns>Total units allocated to the stores by this subtotal pack.</returns>
		public int GetUnitsAllocatedByPack (string aSubtotalPackName)
		{
			return GetUnitsAllocatedByPack(GetSubtotalPackHdr(aSubtotalPackName));
		}

		/// <summary>
		/// Gets total units allocated to the stores by the subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <returns>Total units allocated to the stores by this subtotal pack.</returns>
		internal int GetUnitsAllocatedByPack (PackHdr aSubtotalPack)
		{
			return aSubtotalPack.UnitsAllocated;
		}
		#endregion PacksAllocated

		#region PackColorContent
		#region PackColorRID
		//================//
		// Pack Color Key //
		//================//
		/// <summary>
		/// Gets an ICollection of the color keys in a subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal pack name.</param>
		/// <returns>ICollection of the color keys within the specified subtotal pack.</returns>
		public int[] GetPackColorCodeRIDs (string aSubtotalPackName)
		{
			return GetPackColorCodeRIDs(GetSubtotalPackHdr(aSubtotalPackName));
		}

		/// <summary>
		/// Gets an ICollection of the color keys in a subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack.</param>
		/// <returns>ICollection of the color keys within the specified subtotal pack.</returns>
		internal int[] GetPackColorCodeRIDs (PackHdr aSubtotalPack)
		{
			return (int[])aSubtotalPack.PackColors.Keys;
		}
		#endregion PackColorCodeRID

		#region PackColorSequence
		/// <summary>
		/// Gets color sequence within a subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name.</param>
		/// <param name="aColorCodeRID">RID of the color</param>
		/// <returns>Display sequence of the color within the subtotal pack.</returns>
		public int GetPackColorSequence (string aSubtotalPackName, int aColorCodeRID)
		{
			return GetPackColorSequence(GetSubtotalPackHdr(aSubtotalPackName), aColorCodeRID);
		}

		/// <summary>
		/// Gets color sequence within a subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack.</param>
		/// <param name="aColorCodeRID">RID of the color</param>
		/// <returns>Display sequence of the color within the subtotal pack.</returns>
		internal int GetPackColorSequence(PackHdr aSubtotalPack, int aColorCodeRID)
		{
			return aSubtotalPack.GetColorBin(aColorCodeRID).ColorSequenceInPack;
		}
		#endregion PackColorSequence

		#region PackColorCount
		/// <summary>
		/// Get the color count for the specified subtotal pack
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <returns>Number of colors on the specified subtotal pack</returns>
		public int GetPackColorCount (string aSubtotalPackName)
		{
			return GetSubtotalPackHdr(aSubtotalPackName).PackColorCount;
		}
		#endregion PackColorCount

		#region PackColorUnitsInPack
		/// <summary>
		/// Gets the specified color units within the specified subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <returns>Color units for the specified color within the specified subtotal pack</returns>
		public int GetColorUnitsInPack (string aSubtotalPackName, int aColorCodeRID)
		{
			return GetColorUnitsInPack(GetSubtotalPackHdr(aSubtotalPackName), aColorCodeRID);
		}

		/// <summary>
		/// Gets the specified color units within the specified subtotal pack
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack.</param>
		/// <param name="aColorCodeRID">RID for the color</param>
		/// <returns>Color units within the subtotal pack.</returns>
		internal int GetColorUnitsInPack (PackHdr aSubtotalPack, int aColorCodeRID)
		{
			return aSubtotalPack.GetColorUnitsInPack(aColorCodeRID);
		}
		#endregion PackColorUnitsInPack

		#region PackColorUnitsToAllocate
		/// <summary>
		/// Gets the total units to allocate for the specified color within the specified subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">SubtotalPack Name</param>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <returns>Total units to allocated for the specified color within the specified subtotal pack.</returns>
		public int GetColorUnitsToAllocateByPack (string aSubtotalPackName, int aColorCodeRID)
		{
			return (GetColorUnitsToAllocateByPack (GetSubtotalPackHdr(aSubtotalPackName), aColorCodeRID));
		}

		/// <summary>
		/// Gets the total units to allocate for the specified color within the specified subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <returns>Total units to allocated for the specified color within the specified subtotal pack.</returns>
		internal int GetColorUnitsToAllocateByPack (PackHdr aSubtotalPack, int aColorCodeRID)
		{
			return aSubtotalPack.GetColorUnitsInPack(aColorCodeRID) * aSubtotalPack.PacksToAllocate;
		}
		#endregion PackColorUnitsToAllocate

		#region PackColorUnitsAllocated
		/// <summary>
		/// Gets the total units allocated to stores by the specified subtotal pack in the specified color.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <param name="aColorCodeRID">Database RID for this color</param>
		/// <returns>Total units allocated to stores by the specified subtotal pack in the specified color.</returns>
		public int GetColorUnitsAllocatedByPack (string aSubtotalPackName, int aColorCodeRID)
		{
			return GetColorUnitsAllocatedByPack (GetSubtotalPackHdr(aSubtotalPackName), aColorCodeRID);
		}

		/// <summary>
		/// Gets the total units allocated to stores by the specified subtotal pack in the specified color.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <param name="aColorCodeRID">Database RID for this color</param>
		/// <returns>Total units allocated to stores by the specified subtotal pack in the specified color.</returns>
		internal int GetColorUnitsAllocatedByPack (PackHdr aSubtotalPack, int aColorCodeRID)
		{
			return aSubtotalPack.GetColorUnitsAllocated(aColorCodeRID);
		}
		#endregion PackColorUnitsAllocated

		#region PackColorTotalSizeUnits
		/// <summary>
		/// Gets the total size units across all sizes within a given color of a subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <param name="aColorCodeRID">RID of the color.</param>
		/// <returns>Total Size Units within a given color of a subtotal pack.</returns>
		public int GetPackColorTotalSize (string aSubtotalPackName, int aColorCodeRID)
		{
			return GetPackColorTotalSize (GetSubtotalPackHdr(aSubtotalPackName), aColorCodeRID);
		}

		/// <summary>
		/// Gets the total size units across all sizes within a given color of a subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <param name="aColorCodeRID">RID of the color.</param>
		/// <returns>Total Size Units within a given color of a subtotal pack.</returns>
		internal int GetPackColorTotalSize (PackHdr aSubtotalPack, int aColorCodeRID)
		{
			return aSubtotalPack.GetColorBin(aColorCodeRID).TotalSizeUnitsInPackColor;
		}
		#endregion PackColorTotalSizeUnits
		#endregion PackColorContent

		#region PackSizeContent
		#region PackColorSizeRID
		//====================//
		// Pack ColorSize Key //
		//====================//
		/// <summary>
		/// Gets an ICollection of the size keys for a given color in a given subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack name.</param>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <returns>ICollection of the color keys within the specified subtotal pack.</returns>
		public int[] GetPackColorSizeKeys (string aSubtotalPackName, int aColorCodeRID)
		{
			return GetPackColorSizeKeys(GetSubtotalPackHdr(aSubtotalPackName), aColorCodeRID);
		}

		/// <summary>
		/// Gets an ICollection of the size keys in a given color in a given subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack.</param>
		/// <param name="aColorCodeRID">RID of the color</param>
		/// <returns>ICollection of the color keys within the specified subtotal pack.</returns>
		internal int[] GetPackColorSizeKeys (PackHdr aSubtotalPack, int aColorCodeRID)
		{
			return (int[])GetPackColorSizeKeys (aSubtotalPack, aSubtotalPack.GetColorBin(aColorCodeRID));
		}

		/// <summary>
		/// Gets an ICollection of the size keys in a given color in a given subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack.</param>
		/// <param name="aColor">PackColorSize that describes the color.</param>
		/// <returns>ICollection of the color keys within the specified subtotal pack.</returns>
		internal ICollection GetPackColorSizeKeys (PackHdr aSubtotalPack, PackColorSize aColor)
		{
			return aColor.ColorSizes.Keys;
		}
		#endregion PackColorCodeRID

		#region PackColorSizeSequence
		/// <summary>
		/// Gets size sequence within a color of a subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name.</param>
		/// <param name="aColorCodeRID">RID of the color</param>
		/// <param name="aSizeRID">RID of the size</param>
		/// <returns>Display sequence of the sizes within a subtotal pack color.</returns>
		public int GetPackColorSizeSequence (string aSubtotalPackName, int aColorCodeRID, int aSizeRID)
		{
			return GetPackColorSizeSequence(GetSubtotalPackHdr(aSubtotalPackName), aColorCodeRID, aSizeRID);
		}

		/// <summary>
		/// Gets size sequence within a color of a subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack.</param>
		/// <param name="aColorCodeRID">RID of the color</param>
		/// <returns>Display sequence of the sizes within a subtotal pack color.</returns>
		internal int GetPackColorSizeSequence(PackHdr aSubtotalPack, int aColorCodeRID, int aSizeRID)
		{
			return aSubtotalPack.GetColorBin(aColorCodeRID).GetPackColorSizeSequence(aSizeRID);
		}
		#endregion PackColorSizeSequence

		#region SizeCountWithinPackColor
		/// <summary>
		/// Gets the number of sizes in a specified color within a specified subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">SubtotalPack Name</param>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <returns>Number of sizes in the specified color within the specified subtotal pack.</returns>
		public int GetPackColorSizeCount (string aSubtotalPackName, int aColorCodeRID)
		{
			return GetPackColorSizeCount(GetSubtotalPackHdr(aSubtotalPackName), aColorCodeRID);
		}

		/// <summary>
		/// Gets the number of sizes in a specified color within a specified subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <returns>Number of sizes in the specified color within the specified subtotal pack.</returns>
		internal int GetPackColorSizeCount(PackHdr aSubtotalPack, int aColorCodeRID)
		{
			return aSubtotalPack.GetColorBin(aColorCodeRID).SizeCountInColor;
		}
		#endregion SizeCountWithinPackColor

		#region PackColorSizeUnits
		/// <summary>
		/// Gets the units of a specified color-size in this subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>The units to allocate for the specified color-width-size in this subtotal pack.</returns>
		public int GetPackColorSizeUnits (string aSubtotalPackName, int aColorCodeRID, int aSizeRID)
		{
			return GetPackColorSizeUnits (GetSubtotalPackHdr(aSubtotalPackName), aColorCodeRID, aSizeRID);
		}
		
		/// <summary>
		/// Gets the units of a specified color-size in this subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>The units to allocate for the specified color-width-size in this subtotal pack.</returns>
		internal int GetPackColorSizeUnits (PackHdr aSubtotalPack, int aColorCodeRID, int aSizeRID)
		{
			return GetPackColorSizeUnits(aSubtotalPack, aSubtotalPack.GetColorBin(aColorCodeRID), aSizeRID);
		}

		/// <summary>
		/// Gets the units of a specified color-size in this subtotal pack.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <param name="aColor">PackColorSize that describes the color on the subtotal pack</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>The units to allocate for the specified color-width-size in this subtotal pack.</returns>
		internal int GetPackColorSizeUnits(PackHdr aSubtotalPack, PackColorSize aColor,
			int aSizeRID)
		{
			return aColor.GetSizeUnitsInColor(aSizeRID);
		}
		#endregion PackColorSizeUnits

		#region PackColorSizeUnitsAllocated
		/// <summary>
		/// Gets the total units allocated to the stores by the specified subtotal pack for the specified color and size.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack Name</param>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>Total units allocated to the stores by the specified subtotal pack in the specified color and size.</returns>
		public int GetPackColorSizeUnitsAllocated (string aSubtotalPackName, int aColorCodeRID, int aSizeRID)
		{
			return GetPackColorSizeUnitsAllocated(GetSubtotalPackHdr(aSubtotalPackName), aColorCodeRID, aSizeRID);
		}

		/// <summary>
		/// Gets the total units allocated to the stores by the specified subtotal pack for the specified color and size.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>Total units allocated to the stores by the specified pack in the specified color and size.</returns>
		internal int GetPackColorSizeUnitsAllocated(PackHdr aSubtotalPack, int aColorCodeRID, int aSizeRID)
		{
			return GetPackColorSizeUnitsAllocated(aSubtotalPack, aSubtotalPack.GetColorBin(aColorCodeRID), aSizeRID);
		}

		/// <summary>
		/// Gets the total units allocated to the stores by the specified subtotal pack for the specified color and size.
		/// </summary>
		/// <param name="aSubtotalPack">PackHdr that describes the subtotal pack</param>
		/// <param name="aColor">PackColorSize that describes the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>Total units allocated to the stores by the specified pack in the specified color and size.</returns>
		internal int GetPackColorSizeUnitsAllocated(PackHdr aSubtotalPack, PackColorSize aColor, int aSizeRID)
		{
			return aColor.GetSizeUnitsInColor(aSizeRID) * aSubtotalPack.PacksAllocated;
		}
		#endregion PackColorSizeUnitsAllocated
		#endregion PackSizeContent
		#endregion PackHeader

		#region Bulk
		#region BulkColor
		#region BulkColorIsOnSubtotalTest
		/// <summary>
		/// Indicates whether the specified bulk color is defined on the subtotal. 
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color.</param>
		/// <returns>True when the bulk color is defined on the header; otherwise false.</returns>
		public bool BulkColorIsOnSubtotal (int aColorCodeRID)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			if (_bulkColors == null)
			{
				return false;
			}
			else
			{
				return _bulkColors.Contains(aColorCodeRID);
			}
		}
		#endregion BulkColorIsOnSubtotalTest

		#region GetSubtotalHdrColorBin
        // begin TT#1176 - MD - Jellis - Group Allocation Size Need Not observing inv min max
        /// <summary>
        /// Try to get HdrColorBin that describes a bulk color
        /// </summary>
        /// <param name="aColorCodeRID">RID of the color</param>
        /// <param name="aColorBin">TRUE:  the requested color bin; FALSE: null (color not found)</param>
        /// <param name="aStatusReasonCode">TRUE: msg_al_TryGetSuccessful; FALSE:  msg_ColorNotDefinedInBulk</param>
        /// <returns></returns>
        public bool TryGetSubtotalHdrColorBin(int aColorCodeRID, out HdrColorBin aColorBin, out eMIDTextCode aStatusReasonCode)
        {
            if (_lastSubtotalColorBin == null
                || aColorCodeRID != _lastSubtotalColorBin.ColorCodeRID)
            {
                _lastSubtotalColorBin = (HdrColorBin)_bulkColors[aColorCodeRID];
                if (_lastSubtotalColorBin == null)
                {
                    aStatusReasonCode = eMIDTextCode.msg_ColorNotDefinedInBulk;
                    aColorBin = null;
                    return false;
                }
            }
            aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
            aColorBin = _lastSubtotalColorBin;
            return true;
        }
        /// <summary>
        /// Get HdrColorBin container that describes a bulk color
        /// </summary>
        /// <param name="aColorCodeRID">RID of the color</param>
        /// <returns>HdrColorBin</returns>
        public HdrColorBin GetSubtotalHdrColorBin(int aColorCodeRID)
        {
            // BEGIN TT#5560 - AGallagher/JSmith - Error message - Color not defined for bulk - Again
            if (_buildSubtotal)
            {
                this.BuildSubtotal();
            }
            // END TT#5560 - AGallagher/JSmith - Error message - Color not defined for bulk - Again
            HdrColorBin colorBin;
            eMIDTextCode statusReasonCode;
            if (TryGetSubtotalHdrColorBin(aColorCodeRID, out colorBin, out statusReasonCode))
            {
                return colorBin;
            }
            throw new MIDException(eErrorLevel.warning,
                (int)(eMIDTextCode.msg_ColorNotDefinedInBulk),
                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_ColorNotDefinedInBulk) 
                + " [Color Code RID=" + aColorCodeRID.ToString() 
                + "] [Source/Method=" + GetType().Name + " / GetSubtotalHdrColorBin]");
        }
        ///// <summary>
        ///// Get HdrColorBin container that describes a bulk color.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID of the color.</param>
        ///// <returns>HdrColorBin container.</returns>
        //public HdrColorBin GetSubtotalHdrColorBin(int aColorCodeRID)
        //{
        //    // begin TT#1166 - MD - Jellis - Color not in bulk OR No stores in Size Analysis
        //    //if (BulkColorIsOnSubtotal(aColorCodeRID))
        //    //{
        //    //    return (HdrColorBin)_bulkColors[aColorCodeRID];
        //    //}
        //    //else
        //    //{
        //    //    throw new MIDException (eErrorLevel.warning,
        //    //        (int)(eMIDTextCode.msg_ColorNotDefinedInBulk),
        //    //        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_ColorNotDefinedInBulk));
        //    //}
        //    if (_lastSubtotalColorBin == null
        //        || aColorCodeRID != _lastSubtotalColorBin.ColorCodeRID)
        //    {
        //        _lastSubtotalColorBin = (HdrColorBin)_bulkColors[aColorCodeRID];
        //        if (_lastSubtotalColorBin == null)
        //        {
        //            throw new MIDException(eErrorLevel.warning,
        //                (int)(eMIDTextCode.msg_ColorNotDefinedInBulk),
        //                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_ColorNotDefinedInBulk) 
        //                + " [Color Code RID=" + aColorCodeRID.ToString() 
        //                + "] [Source=" + GetType().Name + "]");
        //        }
        //    }
        //    return _lastSubtotalColorBin;
        //}
        // end TT#1176 - MD - Jellis - Group Allocation Size need not observing inv min max
		#endregion GetSubtotalHdrColorBin

		#region BulkColorCodeRID
		//================//
		// Bulk Color Key //
		//================//
		/// <summary>
		/// Gets an ICollection of the bulk colors on this header.
		/// </summary>
		/// <returns>ICollection of the bulk colors on this header.</returns>
		public int[] GetBulkColorCodeRIDs ()
		{
			return (int[])BulkColors.Keys;
		}
		#endregion BulkColorCodeRID

		#region BulkColorUnitsToAllocate
		/// <summary>
		/// Gets bulk color units to allocate.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <returns>Units to allocate for the specified bulk color.</returns>
		public int GetColorUnitsToAllocate (int aColorCodeRID)
		{
			return GetColorUnitsToAllocate(GetSubtotalHdrColorBin(aColorCodeRID));
		}

		/// <summary>
		/// Gets bulk color units to allocate.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color</param>
		/// <returns>Units to allocate for the specified bulk color.</returns>
		internal int GetColorUnitsToAllocate(HdrColorBin aColor)
		{
			return aColor.ColorUnitsToAllocate;
		}

		/// <summary>
		/// Sets bulk color units to allocate.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aUnitsToAllocate">Units to allocated for the color</param>
		public void SetColorUnitsToAllocate (int aColorCodeRID, int aUnitsToAllocate)
		{
			SetColorUnitsToAllocate(GetSubtotalHdrColorBin(aColorCodeRID), aUnitsToAllocate);
		}

		/// <summary>
		/// Sets bulk color units to allocate.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aUnitsToAllocate">Units to allocated for the color</param>
		internal void SetColorUnitsToAllocate(HdrColorBin aColor, int aUnitsToAllocate)
		{
			int difference = 
				aUnitsToAllocate
				- GetColorUnitsToAllocate(aColor);
			aColor.SetColorUnitsToAllocate(aUnitsToAllocate);
			_totalBulkColorUnitsToAllocate += difference;
		}
		#endregion BulkColorUnitsToAllocate

		#region BulkColorMultiple
		/// <summary>
		/// Gets color multiple for the specified bulk color
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <returns>Specified color multiple</returns>
		public int GetColorMulitple (int aColorCodeRID)
		{
			return GetColorMultiple (GetSubtotalHdrColorBin(aColorCodeRID));
		}

		/// <summary>
		/// Gets color multiple for the specified bulk color
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <returns>Specified color multiple</returns>
		internal int GetColorMultiple (HdrColorBin aColor)
		{
			return aColor.ColorMultiple;
		}

		/// <summary>
		/// Set the multiple for a bulk color
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aMultiple">Color multiple value.</param>
		public void SetColorMultiple (int aColorCodeRID, int aMultiple)
		{
			SetColorMultiple (GetSubtotalHdrColorBin(aColorCodeRID), aMultiple);
		}

		internal void SetColorMultiple (HdrColorBin aColor, int aMultiple)
		{
			aColor.SetColorMultiple(aMultiple);
		}
		#endregion BulkColorMultiple

		#region BulkColorSequence
		/// <summary>
		/// Gets color sequence for Bulk.
		/// </summary>
		/// <param name="aColorCodeRID">RID of the color</param>
		/// <returns>Display sequence of the color for bulk.</returns>
		public int GetBulkColorSequence (int aColorCodeRID)
		{
			return GetBulkColorSequence(GetSubtotalHdrColorBin(aColorCodeRID));
		}

		/// <summary>
		/// Gets color sequence for Bulk.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <returns>Display sequence of the color for bulk.</returns>
		internal int GetBulkColorSequence(HdrColorBin aColor)
		{
			return aColor.ColorSequence;
		}

		/// <summary>
		/// Sets color sequence for Bulk.
		/// </summary>
		/// <param name="aColorCodeRID">RID of the color</param>
		/// <param name="aSequence">Display sequence of the color for bulk</param>
		public void SetBulkColorSequence (int aColorCodeRID, int aSequence)
		{
			SetBulkColorSequence(GetSubtotalHdrColorBin(aColorCodeRID), aSequence);
		}

		/// <summary>
		/// Sets color sequence for Bulk.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aSequence">Display sequence of the color for bulk</param>
		internal void SetBulkColorSequence(HdrColorBin aColor, int aSequence)
		{
			if (aSequence < 1)
			{
				aColor.ColorSequence = _bulkColors.Count;
			}
			else
			{
				aColor.ColorSequence = aSequence;
			}
		}
		#endregion BulkColorSequence
		
		#region BulkColorUnitsAllocated
		/// <summary>
		/// Gets bulk color total units allocated to stores.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <returns>Total units allocated to stores for the specified bulk color</returns>
		public int GetColorUnitsAllocated (int aColorCodeRID)
		{
			return GetColorUnitsAllocated(GetSubtotalHdrColorBin(aColorCodeRID));
		}

		/// <summary>
		/// Gets bulk color total units allocated to stores.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <returns>Total units allocated to stores for the specified bulk color</returns>
		internal int GetColorUnitsAllocated(HdrColorBin aColor)
		{
			return aColor.ColorUnitsAllocated;
		}
	
		/// <summary>
		/// Sets bulk color total units allocated to stores.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aUnitsAllocated">Color Units Allocated</param>
		public void SetColorUnitsAllocated (int aColorCodeRID, int aUnitsAllocated)
		{
			SetColorUnitsAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aUnitsAllocated);
		}

		/// <summary>
		/// Sets bulk color total units allocated to stores.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aUnitsAllocated">Color Units Allocated</param>
		internal void SetColorUnitsAllocated(HdrColorBin aColor, int aUnitsAllocated)
		{
			aColor.SetColorUnitsAllocated(aUnitsAllocated);
		}

		/// <summary>
		/// Adjusts the total units allocated to the stores for the specified bulk color.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="AdjValue">Adjustment value</param>
		public void AdjustColorUnitsAllocated (int aColorCodeRID, int AdjValue)
		{
			AdjustColorUnitsAllocated(GetSubtotalHdrColorBin(aColorCodeRID), AdjValue);
		}
	
		/// <summary>
		/// Adjusts the total units allocated to the stores for the specified bulk color.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="AdjValue">Adjustment value</param>
		internal void AdjustColorUnitsAllocated(HdrColorBin aColor, int AdjValue)
		{
			SetColorUnitsAllocated(aColor, GetColorUnitsAllocated(aColor) + AdjValue);
		}
		#endregion BulkColorUnitsAllocated

		#region BulkColorMinimum
		/// <summary>
		/// Gets the bulk color allocation minimum
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color.</param>
		/// <returns>Bulk Color allocation minimum</returns>
		public int GetColorMinimum (int aColorCodeRID)
		{
			return GetColorMinimum(GetSubtotalHdrColorBin(aColorCodeRID));
		}
		
		/// <summary>
		/// Gets the bulk color allocation minimum
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color.</param>
		/// <returns>Bulk Color allocation minimum</returns>
		internal int GetColorMinimum (HdrColorBin aColor)
		{
			return aColor.ColorMinimum;
		}
			
		/// <summary>
		/// Sets the bulk color allocation minimum for the specified color.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aMinimum">Color minimum value</param>
		public void SetColorMinimum (int aColorCodeRID, int aMinimum)
		{
			SetColorMinimum (GetSubtotalHdrColorBin(aColorCodeRID), aMinimum);
		}

		/// <summary>
		/// Sets the bulk color allocation minimum for the specified color.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aMinimum">Color minimum value</param>
		internal void SetColorMinimum (HdrColorBin aColor, int aMinimum)
		{
			aColor.SetColorMinimum(aMinimum);
		}
		#endregion BulkColorMinimum
		
		#region BulkColorMaximum
		/// <summary>
		/// Gets the bulk color allocation Maximum
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color.</param>
		/// <returns>Bulk Color allocation Maximum</returns>
		public int GetColorMaximum (int aColorCodeRID)
		{
			return GetColorMaximum(GetSubtotalHdrColorBin(aColorCodeRID));
		}
		
		/// <summary>
		/// Gets the bulk color allocation Maximum
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color.</param>
		/// <returns>Bulk Color allocation Maximum</returns>
		internal int GetColorMaximum (HdrColorBin aColor)
		{
			return aColor.ColorMaximum;
		}
			
		/// <summary>
		/// Sets the bulk color allocation Maximum for the specified color.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aMaximum">Color Maximum value</param>
		public void SetColorMaximum (int aColorCodeRID, int aMaximum)
		{
			SetColorMaximum (GetSubtotalHdrColorBin(aColorCodeRID), aMaximum);
		}

		/// <summary>
		/// Sets the bulk color allocation Maximum for the specified color.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aMaximum">Color Maximum value</param>
		internal void SetColorMaximum (HdrColorBin aColor, int aMaximum)
		{
			aColor.SetColorMaximum(aMaximum);
		}
		#endregion BulkColorMaximum
		#endregion BulkColor

		#region BulkSize
		#region BulkSizeOnSubtotal
		/// <summary>
		/// Bool indicating if a specified size key exists in bulk on the subtotal
		/// </summary>
		/// <param name="aSizeKey">Size RID</param>
		/// <returns>True: size exists; False: size does not exist in bulk on the subtotal</returns>
		public bool BulkSizeOnSubtotal(int aSizeKey)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			if (_sizeList.Contains(aSizeKey))
			{
				return true;
			}
			return false;
		}

		public SizeCodeProfile[] BulkSizeProfileArray()
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			SizeCodeProfile[] sizeArray = new SizeCodeProfile[_sizeList.Count];
			_sizeList.ArrayList.CopyTo(sizeArray);
			
			return sizeArray;
		}
		#endregion BulkSizeOnSubtotal
        
		#region GetSubtotalHdrSizeBin
        // begin TT#1176 - MD - Jellis - Group Allocation Size Need not observing inv min max
        public bool TryGetSubtotalHdrSizeBin(HdrColorBin aColorBin, int aSizeKey, out HdrSizeBin aSizeBin, out eMIDTextCode aStatusReasonCode)
        {
            if (_lastSubtotalSizeBin == null
                || _lastSubtotalSizeBin.Color.ColorCodeRID != aColorBin.ColorCodeRID
                || _lastSubtotalSizeBin.SizeCodeRID != aSizeKey)
            {
                if (!aColorBin.TryGetSizeBin(aSizeKey, out _lastSubtotalSizeBin, out aStatusReasonCode))
                {
                    aSizeBin = _lastSubtotalSizeBin;
                    return false;
                }
            }
            aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
            aSizeBin = _lastSubtotalSizeBin;
            return true;
        }
        public HdrSizeBin GetSubtotalHdrSizeBin(HdrColorBin aColorBin, int aSizeKey)
        {
            HdrSizeBin sizeBin;
            eMIDTextCode statusReasonCode;
            if (TryGetSubtotalHdrSizeBin(aColorBin, aSizeKey, out sizeBin, out statusReasonCode))
            {
                return sizeBin;
            }
            throw new MIDException (eErrorLevel.warning,
                (int)(eMIDTextCode.msg_SizeNotDefinedInBulkColor),
                SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_SizeNotDefinedInBulkColor)
                + " [Color Code RID=" + aColorBin.ColorCodeRID.ToString() 
                + "] [Size Code RID=" + aSizeKey.ToString()
                + "] [Source/Method=" + GetType().Name + " / GetSubtotalHdrSize]");
        }
        ///// <summary>
        ///// Get HdrSizeBin container that describes a subtotal bulk Size.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin containing the size</param>
        ///// <param name="aSizeKey">RID of the Size.</param>
        ///// <returns>HdrSizeBin container.</returns>
        //public HdrSizeBin GetSubtotalHdrSizeBin(HdrColorBin aColor, int aSizeKey)
        //{
        //    // begin TT#1166 - MD - Jellis - Color not in Bulk OR no stores in size analysis
        //    //if (aColor.SizeIsInColor(aSizeKey))
        //    //{
        //    //    return (HdrSizeBin)aColor.ColorSizes[aSizeKey];
        //    //}
        //    //else
        //    //{
        //    //    throw new MIDException (eErrorLevel.warning,
        //    //        (int)(eMIDTextCode.msg_SizeNotDefinedInBulkColor),
        //    //        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_SizeNotDefinedInBulkColor));
        //    //}
        //    if (_lastSubtotalSizeBin == null
        //        || _lastSubtotalSizeBin.Color.ColorCodeRID != aColor.ColorCodeRID
        //        || _lastSubtotalSizeBin.SizeCodeRID != aSizeKey)
        //    {
        //        _lastSubtotalSizeBin = (HdrSizeBin)aColor.ColorSizes[aSizeKey];
        //        if (_lastSubtotalSizeBin == null)
        //        {
        //            throw new MIDException (eErrorLevel.warning,
        //                (int)(eMIDTextCode.msg_SizeNotDefinedInBulkColor),
        //                SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_SizeNotDefinedInBulkColor)
        //                + " [Color Code RID=" + aColor.ColorCodeRID.ToString() 
        //                + "] [Size Code RID=" + aSizeKey.ToString()
        //                + "] [Source=" + GetType().Name);
        //        }
        //    }
        //    return _lastSubtotalSizeBin;
        //    // end TT#1176 - MD - Jellis - Group Allocation Not observing inv min max
        //}
        // end TT#1166 - MD - Jellis - Color not in Bulk Or no stores in size analsis
		#endregion GetSubtotalHdrSizeBin

		#region BulkColorSizeKey
		//=====================//
		// Bulk Color Size Key //
		//=====================//
		/// <summary>
		/// Gets an ICollection of the bulk sizes in a bulk color.
		/// </summary>
		/// <param name="aColorCodeRID">RID of the color</param>
		/// <returns>ICollection of the bulk colors on this header.</returns>
		public int[] GetBulkColorSizeKeys (int aColorCodeRID)
		{
			return GetBulkColorSizeKeys (GetSubtotalHdrColorBin(aColorCodeRID));
		}

		/// <summary>
		/// Gets an ICollection of the bulk sizes in a bulk color.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <returns>ICollection of the bulk colors on this header.</returns>
		internal int[] GetBulkColorSizeKeys(HdrColorBin aColor)
		{
			return (int[])aColor.ColorSizes.Keys;
		}
		#endregion BulkColorSizeKey

		#region BulkSizeUnitsToAllocate
		/// <summary>
		/// Gets Size Units to Allocate for the given allocation profile and color size component
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile; null returns subtotal color size units to allocate</param>
		/// <param name="aColorSizeComponent">Color-Size Component</param>
		/// <returns>Size Units To Allocate</returns>
		public int GetSizeUnitsToAllocate(AllocationProfile aAllocationProfile, AllocationColorSizeComponent aColorSizeComponent)
		{
			int unitsToAllocate;
			if (aAllocationProfile == null)
			{
				unitsToAllocate = 0;
				switch (aColorSizeComponent.ColorComponent.ComponentType)
				{
					case (eComponentType.SpecificColor):
					{
						int colorRID = ((AllocationColorOrSizeComponent)aColorSizeComponent.ColorComponent).ColorRID;
						if (this.BulkColorIsOnSubtotal(colorRID))
						{
							HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorRID);
							switch (aColorSizeComponent.SizeComponent.ComponentType)
							{
								case (eComponentType.SpecificSize):
								{
									int sizeRID = ((AllocationColorOrSizeComponent)aColorSizeComponent.SizeComponent).SizeRID;
									if (hcb.SizeIsInColor(sizeRID))
									{
										unitsToAllocate += hcb.GetSizeBin(sizeRID).SizeUnitsToAllocate;
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)aColorSizeComponent.SizeComponent).PrimarySizeDimRID);
									foreach (SizeCodeProfile scp in scl)
									{
										if (hcb.SizeIsInColor(scp.Key))
										{
											unitsToAllocate += hcb.GetSizeBin(scp.Key).SizeUnitsToAllocate;
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)aColorSizeComponent.SizeComponent).SecondarySizeDimRID);
									foreach (SizeCodeProfile scp in scl)
									{
										if (hcb.SizeIsInColor(scp.Key))
										{
											unitsToAllocate += hcb.GetSizeBin(scp.Key).SizeUnitsToAllocate;
										}
									}
									break;
								}
								default:
								{
									// assum all sizes
									foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
									{
										unitsToAllocate += hsb.SizeUnitsToAllocate;
									}
									break;
								}
							}
						}
						break;
					}
					default:
					{
						// assume all colors
						foreach (HdrColorBin hcb in this.BulkColors.Values)
						{
							switch (aColorSizeComponent.SizeComponent.ComponentType)
							{
								case (eComponentType.SpecificSize):
								{
									int sizeRID = ((AllocationColorOrSizeComponent)aColorSizeComponent.SizeComponent).SizeRID;
									if (hcb.SizeIsInColor(sizeRID))
									{
										unitsToAllocate += hcb.GetSizeBin(sizeRID).SizeUnitsToAllocate;
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)aColorSizeComponent.SizeComponent).PrimarySizeDimRID);
									foreach (SizeCodeProfile scp in scl)
									{
										if (hcb.SizeIsInColor(scp.Key))
										{
											unitsToAllocate += hcb.GetSizeBin(scp.Key).SizeUnitsToAllocate;
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)aColorSizeComponent.SizeComponent).SecondarySizeDimRID);
									foreach (SizeCodeProfile scp in scl)
									{
										if (hcb.SizeIsInColor(scp.Key))
										{
											unitsToAllocate += hcb.GetSizeBin(scp.Key).SizeUnitsToAllocate;
										}
									}
									break;
								}
								default:
								{
									// assum all sizes
									foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
									{
										unitsToAllocate += hsb.SizeUnitsToAllocate;
									}
									break;
								}
							}
						}
						break;
					}
				}
			}
			else
			{
				unitsToAllocate = aAllocationProfile.GetSizeUnitsToAllocate(aColorSizeComponent);
			}
			return unitsToAllocate;
		}
		/// <summary>
		/// Gets Size Units to Allocate for the specified color and size.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color.</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>The specified width-size units to allocate within the specified color.</returns>
		public int GetSizeUnitsToAllocate (int aColorCodeRID, int aSizeRID)
		{
			return GetSizeUnitsToAllocate (GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID);
		}

		/// <summary>
		/// Gets Size Units to Allocate for the specified color and size.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color.</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>The specified width-size units to allocate within the specified color.</returns>
		internal int GetSizeUnitsToAllocate (HdrColorBin aColor, int aSizeRID)
		{
			return aColor.GetSizeUnitsToAllocate(aSizeRID);
		}

		/// <summary>
		/// Sets Size Units to Allocate for the specified color and size.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color.</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <param name="aUnitsToAllocate">Size Units To Allocate</param>
		public void SetSizeUnitsToAllocate (int aColorCodeRID, int aSizeRID, int aUnitsToAllocate)
		{
			SetSizeUnitsToAllocate (GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aUnitsToAllocate);
		}

		/// <summary>
		/// Sets Size Units to Allocate for the specified color and size.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color.</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <param name="aUnitsToAllocate">Size Units To Allocate</param>
		internal void SetSizeUnitsToAllocate (HdrColorBin aColor, int aSizeRID, int aUnitsToAllocate)
		{
			aColor.SetSizeUnitsToAllocate(aSizeRID, aUnitsToAllocate);
		}
		#endregion BulkSizeUnitsToAllocate

		#region BulkSizeUnitsAllocated
		/// <summary>
		/// Gets units allocated to stores for the specified size within specified color.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeKey">Database RID for the width-size</param>
		/// <returns>Total units allocated to stores in the specified size within the specified color.</returns>
		public int GetSizeUnitsAllocated (int aColorCodeRID, int aSizeKey)
		{
			return GetSizeUnitsAllocated (GetSubtotalHdrColorBin(aColorCodeRID), aSizeKey);
		}

		/// <summary>
		/// Gets units allocated to stores for the specified size within specified color.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aSizeKey">Database RID for the width-size</param>
		/// <returns>Total units allocated to stores in the specified size within the specified color.</returns>
		internal int GetSizeUnitsAllocated (HdrColorBin aColor, int aSizeKey)
		{
			return aColor.GetSizeUnitsAllocated(aSizeKey);
		}

		/// <summary>
		/// Sets units allocated to stores for the specified size within specified color.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeKey">Database RID for the width-size</param>
		/// <param name="aUnitsAllocated">Size Units Allocated</param>
		public void SetSizeUnitsAllocated (int aColorCodeRID, int aSizeKey, int aUnitsAllocated)
		{
			SetSizeUnitsAllocated (GetSubtotalHdrColorBin(aColorCodeRID), aSizeKey, aUnitsAllocated);
		}

		/// <summary>
		/// Sets units allocated to stores for the specified size within specified color.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aSizeKey">Database RID for the width-size</param>
		/// <param name="aUnitsAllocated">Size Units Allocated</param>
		internal void SetSizeUnitsAllocated (HdrColorBin aColor, int aSizeKey, int aUnitsAllocated)
		{
			aColor.SetSizeUnitsAllocated(aSizeKey, aUnitsAllocated);
		}

		/// <summary>
		/// Adjusts total size units allocated to the stores for the specified size within the specified color
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <param name="aAdjValue">Adjust value</param>
		public void AdjustSizeUnitsAllocated (int aColorCodeRID, int aSizeRID, int aAdjValue)
		{
			AdjustSizeUnitsAllocated (GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aAdjValue);
		}

		/// <summary>
		/// Adjusts total size units allocated to the stores for the specified size within the specified color
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <param name="aAdjValue">Adjust value</param>
		internal void AdjustSizeUnitsAllocated(HdrColorBin aColor, int aSizeRID, int aAdjValue)
		{
			aColor.AdjustSizeUnitsAllocated(aSizeRID, aAdjValue);
		}
		#endregion BulkSizeUnitsAllocated

		#region BulkSizeMinimum
		/// <summary>
		/// Gets the bulk size allocation minimum for the specified color and size.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>Allocation minimum for the specified color and size</returns>
		public int GetSizeMinimum (int aColorCodeRID, int aSizeRID)
		{
			return GetSizeMinimum (GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID);
		}

		/// <summary>
		/// Gets the bulk size allocation minimum for the specified color and size.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>Allocation minimum for the specified color and size</returns>
		internal int GetSizeMinimum (HdrColorBin aColor, int aSizeRID)
		{
			return aColor.GetSizeMinimum(aSizeRID);
		}

		/// <summary>
		/// Sets size allocation minimum for the specified color and size.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <param name="aMinimum">Minimum value</param>
		public void SetSizeMinimum (int aColorCodeRID, int aSizeRID, int aMinimum)
		{
			SetSizeMinimum (GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aMinimum);
		}

		internal void SetSizeMinimum(HdrColorBin aColor, int aSizeRID, int aMinimum)
		{
			aColor.SetSizeMinimum (aSizeRID, aMinimum);
		}	
		#endregion BulkSizeMinimum
		
		#region BulkSizeMaximum
		/// <summary>
		/// Gets the bulk size allocation Maximum for the specified color and size.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>Allocation Maximum for the specified color and size</returns>
		public int GetSizeMaximum (int aColorCodeRID, int aSizeRID)
		{
			return GetSizeMaximum (GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID);
		}

		/// <summary>
		/// Gets the bulk size allocation Maximum for the specified color and size.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>Allocation Maximum for the specified color and size</returns>
		internal int GetSizeMaximum (HdrColorBin aColor, int aSizeRID)
		{
			return aColor.GetSizeMaximum(aSizeRID);
		}

		/// <summary>
		/// Sets size allocation Maximum for the specified color and size.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <param name="aMaximum">Maximum value</param>
		public void SetSizeMaximum (int aColorCodeRID, int aSizeRID, int aMaximum)
		{
			SetSizeMaximum (GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aMaximum);
		}

		internal void SetSizeMaximum(HdrColorBin aColor, int aSizeRID, int aMaximum)
		{
			aColor.SetSizeMaximum (aSizeRID, aMaximum);
		}	
		#endregion BulkSizeMaximum

		#region BulkSizeMultiple
		/// <summary>
		/// Gets the bulk size allocation Multiple for the specified color and size.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>Allocation Multiple for the specified color and size</returns>
		public int GetSizeMultiple (int aColorCodeRID, int aSizeRID)
		{
			return GetSizeMultiple (GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID);
		}

		/// <summary>
		/// Gets the bulk size allocation Multiple for the specified color and size.
		/// </summary>
		/// <param name="aColor">HdrColorBin that describes the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <returns>Allocation Multiple for the specified color and size</returns>
		internal int GetSizeMultiple (HdrColorBin aColor, int aSizeRID)
		{
			return aColor.GetSizeMultiple(aSizeRID);
		}

		/// <summary>
		/// Sets size allocation Multiple for the specified color and size.
		/// </summary>
		/// <param name="aColorCodeRID">Database RID for the color</param>
		/// <param name="aSizeRID">Database RID for the width-size</param>
		/// <param name="aMultiple">Multiple value</param>
		public void SetSizeMultiple (int aColorCodeRID, int aSizeRID, int aMultiple)
		{
			SetSizeMultiple (GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aMultiple);
		}

		internal void SetSizeMultiple(HdrColorBin aColor, int aSizeRID, int aMultiple)
		{
			aColor.SetSizeMultiple (aSizeRID, aMultiple);
		}	
		#endregion BulkSizeMultiple
		#endregion BulkSize
		#endregion Bulk

		#region WorkUpBulkSizeBuy
		public bool WorkUpBulkSizeBuy(AllocationProfile aAllocationProfile)
		{
			if (aAllocationProfile == null)
			{
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					if (!ap.WorkUpBulkSizeBuy)
					{
						return false;
					}
				}
				return true;
			}
			return aAllocationProfile.WorkUpBulkSizeBuy;
		}
		#endregion WorkUpSizeBuy

		#region IntransitUpdateFlag
		public bool GetUpdatesStyleIntransitForAll(AllocationProfile aAllocationProfile, GeneralComponent aComponent)
		{
			if (aAllocationProfile == null)
			{
				return GetUpdatesStyleIntransitForAll(aComponent);
			}
			return aAllocationProfile.StyleIntransitUpdated;
		}
		public bool GetUpdatesStyleIntransitForAll(GeneralComponent gc)
		{
			switch (gc.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.BulkColors.Count > 0 &&
							!ap.StyleIntransitUpdated)
						{
							return false;
						}
					}
					return true;
				}
				case(eComponentType.AllGenericPacks):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.GenericPackCount > 0 &&
							!ap.StyleIntransitUpdated)
						{
							return false;
						}
					}
					return true;
				}
				case(eComponentType.AllNonGenericPacks):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.NonGenericPackCount > 0 &&
							!ap.StyleIntransitUpdated)
						{
							return false;
						}
					}
					return true;
				}
				case(eComponentType.AllPacks):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.Packs.Count > 0)
						{
							if (!ap.StyleIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.AllSizes):
				{
					throw new MIDException(eErrorLevel.fatal,
						(int)eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize));
				}
				case(eComponentType.Bulk):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.BulkColors.Count > 0)
						{
							if (!ap.StyleIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.ColorAndSize):
				{
					AllocationColorSizeComponent colorSizeComponent = (AllocationColorSizeComponent)gc;
					if (colorSizeComponent.ColorComponent.ComponentType == eComponentType.SpecificColor)
					{
						AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)colorSizeComponent.ColorComponent;
						if (colorSizeComponent.SizeComponent.ComponentType == eComponentType.SpecificSize)
						{
							AllocationColorOrSizeComponent sizeComponent = (AllocationColorOrSizeComponent)colorSizeComponent.SizeComponent;
							foreach (AllocationProfile ap in this.SubtotalMembers)
							{
								if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
								{
									HdrColorBin apColor = ap.GetHdrColorBin(colorComponent.ColorRID);
									if (apColor.SizeIsInColor(sizeComponent.SizeRID))
									{
										if (!ap.StyleIntransitUpdated)
										{
											return false;
										}
									}
								}
							}
							return true;
						}
						else if (colorSizeComponent.SizeComponent.ComponentType == eComponentType.SpecificSizePrimaryDim)
						{
							AllocationColorOrSizeComponent sizeComponent = (AllocationColorOrSizeComponent)colorSizeComponent.SizeComponent;
							SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
							foreach (AllocationProfile ap in this.SubtotalMembers)
							{
								if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
								{
									HdrColorBin apColor = ap.GetHdrColorBin(colorComponent.ColorRID);
									foreach (SizeCodeProfile scp in scl)
									{
										if (apColor.SizeIsInColor(scp.Key))
										{
											if (!ap.StyleIntransitUpdated)
											{
												return false;
											}
										}
									}
								}
							}
							return true;
						}
						else if (colorSizeComponent.SizeComponent.ComponentType == eComponentType.SpecificSizeSecondaryDim)
						{
							AllocationColorOrSizeComponent sizeComponent = (AllocationColorOrSizeComponent)colorSizeComponent.SizeComponent;
							SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
							foreach (AllocationProfile ap in this.SubtotalMembers)
							{
								if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
								{
									HdrColorBin apColor = ap.GetHdrColorBin(colorComponent.ColorRID);
									foreach (SizeCodeProfile scp in scl)
									{
										if (apColor.SizeIsInColor(scp.Key))
										{
											if (!ap.StyleIntransitUpdated)
											{
												return false;
											}
										}
									}
								}
							}
							return true;
						}
						else
						{
							// assume all sizes
							return GetUpdatesStyleIntransitForAll(colorSizeComponent.ColorComponent);
						}
					}
					else
					{
						// assume all colors
						foreach (HdrColorBin hcb in this.BulkColors.Values)
						{
							AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, hcb.ColorCodeRID);
							if (!GetUpdatesStyleIntransitForAll(colorComponent))
							{
								return false;
							}
						}
						return true;
					}
				}
				case(eComponentType.DetailType):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.DetailTypeUnitsToAllocate > 0)
						{
							if (!ap.StyleIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.GenericType):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.GenericUnitsToAllocate > 0)
						{
							if (!ap.StyleIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.SpecificColor):
				{
					AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)gc;
					HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.BulkColorIsOnHeader(hcb.ColorCodeRID))
						{
							if (!ap.StyleIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.SpecificPack):
				{
					AllocationPackComponent packComponent = (AllocationPackComponent)gc;
					PackHdr ph = this.GetSubtotalPackHdr(packComponent.PackName);
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.PackIsOnHeader(ph.PackName) &&
							(ap.GetPackHdr(ph.PackName)).SubtotalPackName == ph.SubtotalPackName)
						{
							if (!ap.StyleIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.SpecificSize):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize));
				}
				case(eComponentType.Total):
				{
					return this.AllMembersUpdateStyleIntransit;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_UnknownComponentType,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		public bool GetUpdatesSizeIntransitForAll(GeneralComponent gc)
		{
			switch (gc.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (!ap.BulkSizeIntransitUpdated)
						{
							return false;
						}
					}
					return true;
				}
				case(eComponentType.AllGenericPacks):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_PacksDoNotUpdateBulkIntransit,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_PacksDoNotUpdateBulkIntransit));
				}
				case(eComponentType.AllNonGenericPacks):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_PacksDoNotUpdateBulkIntransit,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_PacksDoNotUpdateBulkIntransit));
				}
				case(eComponentType.AllPacks):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_PacksDoNotUpdateBulkIntransit,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_PacksDoNotUpdateBulkIntransit));
				}
				case(eComponentType.AllSizes):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize));
				}
				case(eComponentType.Bulk):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.BulkColors.Count > 0)
						{
							if (!ap.BulkSizeIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.ColorAndSize):
				{
					AllocationColorSizeComponent colorSizeComponent = (AllocationColorSizeComponent)gc;
					if (colorSizeComponent.ColorComponent.ComponentType == eComponentType.SpecificColor)
					{
						AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)colorSizeComponent.ColorComponent;
						if (colorSizeComponent.SizeComponent.ComponentType == eComponentType.SpecificSize)
						{
							AllocationColorOrSizeComponent sizeComponent = (AllocationColorOrSizeComponent)colorSizeComponent.SizeComponent;
							foreach (AllocationProfile ap in this.SubtotalMembers)
							{
								if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
								{
									HdrColorBin apColor = ap.GetHdrColorBin(colorComponent.ColorRID);
									if (apColor.SizeIsInColor(sizeComponent.SizeRID))
									{
										if (!ap.BulkSizeIntransitUpdated)
										{
											return false;
										}
									}
								}
							}
							return true;
						}
						else if (colorSizeComponent.SizeComponent.ComponentType == eComponentType.SpecificSizePrimaryDim)
						{
							AllocationColorOrSizeComponent sizeComponent = (AllocationColorOrSizeComponent)colorSizeComponent.SizeComponent;
							SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
							foreach (AllocationProfile ap in this.SubtotalMembers)
							{
								if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
								{
									HdrColorBin apColor = ap.GetHdrColorBin(colorComponent.ColorRID);
									foreach (SizeCodeProfile scp in scl)
									{
										if (apColor.SizeIsInColor(scp.Key))
										{
											if (!ap.BulkSizeIntransitUpdated)
											{
												return false;
											}
										}
									}
								}
							}
							return true;
						}
						else if (colorSizeComponent.SizeComponent.ComponentType == eComponentType.SpecificSizeSecondaryDim)
						{
							AllocationColorOrSizeComponent sizeComponent = (AllocationColorOrSizeComponent)colorSizeComponent.SizeComponent;
							SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
							foreach (AllocationProfile ap in this.SubtotalMembers)
							{
								if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
								{
									HdrColorBin apColor = ap.GetHdrColorBin(colorComponent.ColorRID);
									foreach (SizeCodeProfile scp in scl)
									{
										if (apColor.SizeIsInColor(scp.Key))
										{
											if (!ap.BulkSizeIntransitUpdated)
											{
												return false;
											}
										}
									}
								}
							}
							return true;
						}
						else
						{
							// assume all sizes
							foreach (AllocationProfile ap in this.SubtotalMembers)
							{
								if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
								{
									if (!ap.BulkSizeIntransitUpdated)
									{
										return false;
									}
									break;
								}
							}
							return true;
						}
					}
					else
					{
						// assume all colors
						foreach (HdrColorBin hcb in this.BulkColors.Values)
						{
							AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, hcb.ColorCodeRID);
							if (!GetUpdatesStyleIntransitForAll(colorComponent))
							{
								return false;
							}
						}
						return true;
					}
				}
				case(eComponentType.DetailType):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.DetailTypeUnitsToAllocate > 0)
						{
							if (!ap.BulkSizeIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.GenericType):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.GenericUnitsToAllocate > 0)
						{
							if (!ap.BulkSizeIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.SpecificColor):
				{
					AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)gc;
					HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.BulkColorIsOnHeader(hcb.ColorCodeRID))
						{
							if (!ap.BulkSizeIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.SpecificPack):
				{
					AllocationPackComponent packComponent = (AllocationPackComponent)gc;
					PackHdr ph = this.GetSubtotalPackHdr(packComponent.PackName);
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.PackIsOnHeader(ph.PackName))
						{
							if (!ap.BulkSizeIntransitUpdated)
							{
								return false;
							}
						}
					}
					return true;
				}
				case(eComponentType.SpecificSize):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize));
				}
				case(eComponentType.Total):
				{
					return this.AllMembersUpdateBulkSizeIntransit;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_UnknownComponentType,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}
		#endregion IntransitUpdateFlag

		#region ResetVelocity
		/// <summary>
		/// Reset velocity so that variables are recalculated
		/// </summary>
		internal void ResetVelocity(bool rereadBasis)	// Issue 4778 stodd
		{
			this._velocityBasisInTransit = null;
			this._velocityBasisOnHand = null;
			this._velocityStoreAvgWklySales = null;
			this._velocityStoreAvgWklyStock = null;
			this._velocityStoreGradeIDX_Chain = null;
			this._velocityStoreGradeIDX_Set = null;
			this._velocityStyleRID = Include.NoRID;
			this._loadVelocityBasisInTransit = true;
			this._loadVelocityBasisOnHand = true;
            this._loadVelocityBasisImoHistory = true; // TT#1401 - JEllis - Urban Virtual Store pt 34
			this._loadVelocityStyleInTransit = true;
			// BEGIN Issue 4778 stodd 10.8.2007
			if (rereadBasis)
			{
				this.VelocityStoreBasisSales = null;
				this.VelocityStoreBasisStock = null;
			}
			// END Issue 4778
		}
		#endregion ResetVelocity

		#region RedoIntransitPctToTotal
		public void RedoIntransitPctToTotal()
		{
			this._storeListSizeIntransitPctToColorHash = null;
			this._storeListSizeOHplusITPctToColorHash = null;
			this._storeSizeIntransitPctToColorHash = null;
			this._storeSizeOHplusITPctToColorHash = null;
		}
		#endregion RedoIntransitPctToTotal

		#region Stores
		#region StoreDimension
		/// <summary>
		/// Sets the store count store dimension
		/// </summary>
		/// <param name="aStoreCount">Number of stores.</param>
		internal void SetStoreDimension(int aStoreCount)
		{
			if (aStoreCount < 1)
			{
				//throw new MIDException (eErrorLevel.warning,  // MID track 5374 Workflow Errors do not stop Process
				throw new MIDException (eErrorLevel.severe,     // MID Track 5374 Workflow Errors do not stop process
					(int)eMIDTextCode.msg_NumberOfStoresCannotBeLessThan1,
					this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_NumberOfStoresCannotBeLessThan1));
			}
			else
			{
				_subtotalTotal = new SubtotalAllocatedBaseBin[aStoreCount];
				_subtotalGenericType = new SubtotalAllocatedBaseBin[aStoreCount];
				_subtotalTotalGenericUnitsAllocated = new int[aStoreCount];
                _subtotalTotalGenericItemUnitsAllocated = new int[aStoreCount]; // TT#1401 - JEllis - Urban Reservation Stores pt 2
				_subtotalDetailType = new SubtotalAllocatedBaseBin[aStoreCount];
				_subtotalTotalNonGenericUnitsAllocated = new int[aStoreCount];
                _subtotalTotalNonGenericItemUnitsAllocated = new int[aStoreCount]; // TT#1401 - JEllis - Urban Reservation Stores pt 2
                _subtotalBulk = new SubtotalAllocatedBaseBin[aStoreCount];
				// _subtotalBulkColorTotalUnitsAllocated = new int[aStoreCount];  // MID Track 3326 Cannot manually key size qty when no secondary dimension
				_subtotalTotal.Initialize();
				_subtotalGenericType.Initialize();
				_subtotalTotalGenericUnitsAllocated.Initialize();
                _subtotalTotalGenericItemUnitsAllocated.Initialize(); // TT#1401 - JEllis - Urban Reservation Stores pt 2
                _subtotalDetailType.Initialize();
				_subtotalTotalNonGenericUnitsAllocated.Initialize();
                _subtotalTotalNonGenericItemUnitsAllocated.Initialize(); // TT#1401 - JEllis - Urban Reservation Stores pt 2
                _subtotalBulk.Initialize();
				// _subtotalBulkColorTotalUnitsAllocated.Initialize(); // MID Track 3326 Cannot manually key size qty when no secondary dimension
				for (int i = 0; i < aStoreCount; ++i)
				{
					// Note:  for subtotals maximums are initialized to zero and minimums to largest
					//        possible value because when an allocation profile is added to the total
					//        the maximum or minimum will be adjusted to reflect that allocation profile
					_subtotalTotal[i].Minimum =
						_subtotalTotal[i].LargestMaximum;
					_subtotalGenericType[i].Minimum =
						_subtotalGenericType[i].LargestMaximum;
					_subtotalDetailType[i].Minimum =
						_subtotalDetailType[i].LargestMaximum;
					_subtotalBulk[i].Minimum =
						_subtotalBulk[i].LargestMaximum;
				}
				foreach (PackHdr p in _subtotalPacks.Values)
				{
					p.SetStoreDimension(aStoreCount, true);
				}
				foreach (HdrColorBin c in _bulkColors.Values)
				{
					c.SetStoreDimension(aStoreCount, true);
				}
			}
		}
		#endregion StoreDimension

		#region StoreIndexRID
		/// <summary>
		/// Gets store index value for store RID.
		/// </summary>
		/// <param name="aStoreRID">RID identifier for the store.</param>
		/// <returns>Store Index associated with the storeRID</returns>
		public Index_RID StoreIndex(int aStoreRID)
		{
			Index_RID sIndexRID = Transaction.StoreIndexRID(aStoreRID);
			if (sIndexRID.RID == Include.UndefinedStoreRID)
			{
				// begin MID Track 4214 Identify stores in error messages
				throw new MIDException (eErrorLevel.severe,
					(int)(eMIDTextCode.msg_StoreRIDNotFound),
					string.Format(this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_StoreRIDNotFound,false),aStoreRID.ToString()));
				//throw new MIDException(eErrorLevel.severe,
				//	(int)(eMIDTextCode.msg_StoreRIDNotFound),
				//	this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_StoreRIDNotFound));
				// end MID Track 4214 Identify stores in error messages
			}
			return sIndexRID;
		}
		#endregion StoreIndexRID
		// begin MID Track 3880 Add Ship Day Variable to Style and size Reviews
		#region StoreShipDay
		//================//
		// Store Ship Day //
		//================//
		/// <summary>
		/// Gets Store Ship Day
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile (null returns ship day for first header in subtotal)</param>
		/// <param name="aStoreRID">RID identifier for the store.</param>
		/// <returns>The need day (day used to calculate need) for the store.</returns>
		public DateTime GetStoreShipDay (AllocationProfile aAllocationProfile, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
                // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                if (SubtotalMembers.Count == 0
                    && AssortmentProfile != null)
                {
                    return AssortmentProfile.GetStoreShipDay(StoreIndex(aStoreRID));
                }
                // end TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
				return ((AllocationProfile)this.SubtotalMembers[0]).GetStoreShipDay(StoreIndex(aStoreRID));
			}
			return aAllocationProfile.GetStoreShipDay(StoreIndex(aStoreRID));
		}
		#endregion StoreShipDay
		#region StoreNeedday
		//================//
		// Store Need Day //
		//================//
		/// <summary>
		/// Gets Store Need Day
		/// </summary>
		/// <param name="aStoreRID">RID identifier for the store.</param>
		/// <returns>The need day (day used to calculate need) for the store.</returns>
		public DateTime GetStoreNeedDay (int aStoreRID) 
		{
			return GetStoreNeedDay (StoreIndex(aStoreRID)); 
		}
		
		// begin MID Track 4291 add Fill variables to size review
		/// <summary>
		/// Gets Store Need Day
		/// </summary>
		/// <param name="aStore">Index_RID identifier for the store.</param>
		/// <returns>The need day (day used to calculate need) for the store.</returns>
		public DateTime GetStoreNeedDay (Index_RID aStore) 
		{
			return GetStoreNeedDay (null, aStore); 
		}

		/// <summary>
		/// Gets Store Need Day
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile to use to resolve need day (when null, the first header in subtotal is used</param>
		/// <param name="aStoreRID">RID identifier for the store.</param>
		/// <returns>The need day (day used to calculate need) for the store.</returns>
		public DateTime GetStoreNeedDay (AllocationProfile aAllocationProfile, int aStoreRID) // MID Track 4291 add fill variables to size review
		{
			return GetStoreNeedDay (aAllocationProfile, StoreIndex(aStoreRID)); // MID Track 4291 add fill variables to size review
		}
		// end MID Track 4291 add Fill Variables to size review

		/// <summary>
		/// Gets Store Need Day
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile to use to resolve need day (when null, the first header in subtotal is used</param>
		/// <param name="aStore">Index_RID identifier for the store.</param>
		/// <returns>The need day for the store.</returns>
		internal DateTime GetStoreNeedDay (AllocationProfile aAllocationProfile, Index_RID aStore) // MID Track 4291 add fill variables to size review
		{
			if (EndDay == Include.UndefinedDate)
			{
				// begin MID Track 4291 add fill variables to size review
				AllocationProfile ap;
				if (aAllocationProfile != null)
				{
					ap = aAllocationProfile;
				}
				else
				{
                    // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    if (SubtotalMembers.Count == 0
                        && AssortmentProfile != null)
                    {
                        DateTime needDaya = AssortmentProfile.GetStoreLastNeedDay(eAllocationSummaryNode.Total, aStore);
                        if (needDaya == Include.UndefinedDate)
                        {
                            return AssortmentProfile.GetStoreShipDay(aStore);
                        }
                        return needDaya;
                    }
                    // end  TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
					ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
				}
				//AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
				//if (ap == null)
				//{
				//}
				// end MID Track 4291 add fill variables to size review
				DateTime needDay = ap.GetStoreLastNeedDay(eAllocationSummaryNode.Total, aStore);
				if (needDay == Include.UndefinedDate)
				{
					return ap.GetStoreShipDay(aStore);
				}
				return needDay;
			}
			return EndDay;
		}
		#endregion StoreNeedDay

		// BEGIN MID Track #2230   Display Current Week-to-Day Sales on Sku Review
		#region StoreWeekToDaySales
		/// <summary>
		/// Gets Store Week To Day Sales for the current sales week.
		/// </summary>
		/// <param name="aIKT">Array of the Key types for the sales to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreRID">RID identifying the store.</param>
		/// <returns>Week To Day Sales for the requested store.</returns>
		public int GetStoreWeekToDaySales(ArrayList aIKT, int aStoreRID)
		{
			return GetStoreWeekToDaySales(aIKT, StoreIndex(aStoreRID));
		}


		/// <summary>
		/// Gets Store Week To Day Sales for the current sales week.
		/// </summary>
		/// <param name="aIKT">Array of the Key types for the sales to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStore">Index_RID describing the store.</param>
		/// <returns>Week To Day Sales for the requested store.</returns>
		public int GetStoreWeekToDaySales(ArrayList aIKT, Index_RID aStore)
		{
			int weekToDaySales = 0;
			foreach (IntransitKeyType ikt in aIKT)
			{
				weekToDaySales += GetStoreWeekToDaySales(ikt, aStore.RID);
			}
			return weekToDaySales;
		}


		/// <summary>
		/// Gets Store Week To Day Sales for the current sales week.
		/// </summary>
		/// <param name="aIKT">Key type of the sales to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStore">Index_RID describing the store.</param>
		/// <returns>Week To Day Sales for the requested store.</returns>
		public int GetStoreWeekToDaySales(IntransitKeyType aIKT, Index_RID aStore)
		{
			return GetStoreWeekToDaySales(aIKT, aStore.RID);
		}

		/// <summary>
		/// Gets Store Week To Day Sales for the current sales week.
		/// </summary>
		/// <param name="aIKT">Key type of the sales to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreRID">RID for the store.</param>
		/// <returns>WeekToDay Sales for the requested store.</returns>
		public int GetStoreWeekToDaySales(IntransitKeyType aIKT, int aStoreRID)
		{
			return GetStoreWeekToDaySales(aIKT, aStoreRID, this.OnHandHnRID);
		}
		private int GetStoreWeekToDaySales(IntransitKeyType aIKT, int aStoreRID, int aOnHandHnRID)
		{
			return 
				(int)this.Transaction.GetStoreWeekToDaySales(aOnHandHnRID, Include.UndefinedDate, aIKT, aStoreRID, null);
			// NOTE:  WeekToDaySales is always the current week to day sales for the "current week"

			//			DateTime beginDay = BeginDay;
			//			if (beginDay == Include.UndefinedDate)
			//			{
			//				return 
			//					(int)this.Transaction.GetStoreWeekToDaySales(aOnHandHnRID, beginDay, aIKT, aStoreRID);
			//			}
			//			double adjustedWeekToDaySales = 
			//				((double)this.Transaction.GetStoreWeekToDaySales(this.PlanHnRID, beginDay, aIKT, aStoreRID) 
			//				* PlanFactor) / 100.0d;
			//			if (adjustedOnHand < 0)
			//			{
			//				return (int)(adjustedOnHand - .5d);  // rounding to nearest integer
			//			}
			//			return (int)(adjustedOnHand + .5d);
		}
		#endregion StoreWeekToDaySales
		// END MID Track #2230   Display Current Week-to-Day Sales on Sku Review

		#region StoreOnHand
		/// <summary>
		/// Gets Store OnHand
		/// </summary>
		/// <param name="aIKT">Array of the Key types for the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreRID">RID identifying the store.</param>
		/// <returns>OnHand for the requested store.</returns>
		public int GetStoreOnHand(ArrayList aIKT, int aStoreRID)
		{
			return GetStoreOnHand(null, aIKT, StoreIndex(aStoreRID));
		}
		/// <summary>
		/// Gets Store OnHand
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile--used when there is a potential for planned size onhand</param>
		/// <param name="aIKT">Array of the Key types for the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreRID">RID identifying the store.</param>
		/// <returns>OnHand for the requested store.</returns>
		public int GetStoreOnHand(AllocationProfile aAllocationProfile, ArrayList aIKT, int aStoreRID)
		{
			return GetStoreOnHand(aAllocationProfile, aIKT, StoreIndex(aStoreRID));
		}
		/// <summary>
		/// Gets Store OnHand
		/// </summary>
		/// <param name="aIKT">Array of the Key types for the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStore">Index_RID describing the store.</param>
		/// <returns>OnHand for the requested store.</returns>
		public int GetStoreOnHand(ArrayList aIKT, Index_RID aStore)
		{
			return GetStoreOnHand(null, aIKT, aStore);
		}

		/// <summary>
		/// Gets Store OnHand
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile--used when there is a potential of getting planned future size onhand</param>
		/// <param name="aIKT">Array of the Key types for the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStore">Index_RID describing the store.</param>
		/// <returns>OnHand for the requested store.</returns>
		public int GetStoreOnHand(AllocationProfile aAllocationProfile, ArrayList aIKT, Index_RID aStore)
		{
			int onHand = 0;
			foreach (IntransitKeyType ikt in aIKT)
			{
				onHand += GetStoreOnHand(aAllocationProfile, ikt, aStore.RID);
			}
			return onHand;
		}
		/// <summary>
		/// Gets Store OnHand
		/// </summary>
		/// <param name="aIKT">Key type of the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStore">Index_RID describing the store.</param>
		/// <returns>OnHand for the requested store.</returns>
		public int GetStoreOnHand(IntransitKeyType aIKT, Index_RID aStore)
		{
			return GetStoreOnHand(null, aIKT, aStore.RID);
		}

		/// <summary>
		/// Gets Store OnHand
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile--used when there is the potential for future planned size onhand</param>
		/// <param name="aIKT">Key type of the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStore">Index_RID describing the store.</param>
		/// <returns>OnHand for the requested store.</returns>
		public int GetStoreOnHand(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, Index_RID aStore)
		{
			return GetStoreOnHand(aAllocationProfile, aIKT, aStore.RID);
		}
		/// <summary>
		/// Gets Store OnHand
		/// </summary>
		/// <param name="aIKT">Key type of the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreRID">RID for the store.</param>
		/// <returns>OnHand for the requested store.</returns>
		public int GetStoreOnHand(IntransitKeyType aIKT, int aStoreRID)
		{
			return GetStoreOnHand(null, aIKT, aStoreRID, this.OnHandHnRID);
		}
		/// <summary>
		/// Gets Store OnHand
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile to use in the event future planned size onhand is requested</param>
		/// <param name="aIKT">Key type of the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreRID">RID for the store.</param>
		/// <returns>OnHand for the requested store.</returns>
		public int GetStoreOnHand(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, int aStoreRID)
		{
			return GetStoreOnHand(aAllocationProfile, aIKT, aStoreRID, this.OnHandHnRID);
		}
		private int GetStoreOnHand(IntransitKeyType aIKT, int aStoreRID, int aOnHandHnRID)
		{
			return GetStoreOnHand(null, aIKT, aStoreRID, aOnHandHnRID);
		}

		private int GetStoreOnHand(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, int aStoreRID, int aOnHandHnRID)
		{
			DateTime beginDay = BeginDay;
			if (beginDay == Include.UndefinedDate)
			{
				return 
					(int)this.Transaction.GetStoreOnHand(aAllocationProfile, aOnHandHnRID, beginDay, aIKT, aStoreRID);
			}
			double adjustedOnHand = 
				((double)this.Transaction.GetStoreOnHand(aAllocationProfile, this.PlanHnRID, beginDay, aIKT, aStoreRID) 
				* PlanFactor) / 100.0d;
			if (adjustedOnHand < 0)
			{
				return (int)(adjustedOnHand - .5d);  // rounding to nearest integer
			}
			return (int)(adjustedOnHand + .5d);
		}
		#endregion StoreOnHand

		#region StoreInTransit
		/// <summary>
		/// Gets specified intransit for the specified store(using the begin/end day and OnHandHnRID associated with this subtotal). 
		/// </summary>
		/// <param name="aIKT">Array of Intransit Key Types to retrieve: total, color or size</param>
		/// <param name="aStoreRID">RID of the store</param>
		/// <returns>Intransit for the specified store.</returns>
		public int GetStoreInTransit(ArrayList aIKT, int aStoreRID)
		{
			int intransit = 0;
			foreach (IntransitKeyType ikt in aIKT)
			{
				intransit += GetStoreInTransit(ikt, aStoreRID, this.OnHandHnRID);
			}
			return intransit;
		}

		/// <summary>
		/// Gets specified intransit for the specified store(using the begin/end day and OnHandHnRID associated with this subtotal). 
		/// </summary>
		/// <param name="aIKT">Identifies type of intransit to retrieve: total, color or size</param>
		/// <param name="aStoreRID">RID of the store</param>
		/// <returns>Intransit for the specified store.</returns>
		public int GetStoreInTransit(IntransitKeyType aIKT, int aStoreRID)
		{
			return GetStoreInTransit(aIKT, aStoreRID, this.OnHandHnRID);
		}
		public int GetStoreInTransit(IntransitKeyType aIKT, int aStoreRID, int aOnHandHnRID)
		{
            //IntransitKeyType[] iktArray = new IntransitKeyType[1];  // TT#4345 - MD - Jellis - GA VSW calculated incorrectly
            //iktArray[0] = aIKT;                                     // TT#4345 - MD - Jellis - GA VSW calculated incorrectly    
			// MID Change j.ellis previously only loaded intransit once; changed to recognize when to load it for an RID.
            // begin TT#4345 - MD - Jellis - GA VSW calculated incorrectly
            //if (LoadIntransit  // MID change j.ellis  delay build of subtotal until info requested
            //   || ((ApplicationSessionTransaction)Transaction).GetIntransitReader().SetDayRangeForRID(aOnHandHnRID))
            if (LoadIntransit)
                // end TT#4345 - MD - Jellis - GA VSW Calculated incorrectly
			{
				DayProfile startDay;
				if (this.BeginDay == Include.UndefinedDate)
				{
					startDay = ((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.CurrentDate;
				}
				else
				{
					startDay = 	((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.GetDay(this.BeginDay);
				}
				int[] storeFromDay = new int[this._allStoreList.Count];
				int[] storeToDay = new int[this._allStoreList.Count];
				//				int storeRID;
				//				for (int i=0; i<this._allStoreList.Count; i++)
				//				{
				//					storeRID = ((StoreProfile)this._allStoreList.ArrayList[i]).Key;
				Index_RID[] storeIndexRID = this.Transaction.StoreIndexRIDArray();
				if (storeIndexRID.Length != this._allStoreList.Count)
				{
					throw new MIDException(eErrorLevel.fatal,
						(int)eMIDTextCode.msg_al_StoreIndexRIDOutOfSync,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_StoreIndexRIDOutOfSync));
				}
				for (int i=0; i<storeIndexRID.Length; i++)
				{
					storeFromDay[i] = startDay.YearDay;
					storeToDay[i] = ((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.GetDay(this.GetStoreNeedDay(storeIndexRID[i])).YearDay;
				}
                // begin TT#4345 - MD - JEllis - GA VSW calculated incorrectly
                Horizon_ID horizonID = new Horizon_ID(startDay.Date, EndDay);
                _storeSalesITHorizon = new StoreSalesITHorizon(Transaction, horizonID, storeFromDay, storeToDay);
                //((ApplicationSessionTransaction)Transaction).GetIntransitReader().SetStoreIT_DayRange(_allStoreList, aOnHandHnRID, storeFromDay, storeToDay);  // MID Change j.ellis: previously used wrong onhandrid instead of one provided
				// end TT#4345 - MD - Jellis - GA VSW calculated incorrectly
                _loadIntransit = false;
			}
            // begin TT#4345 - MD - Jellis - GA VSW calculated incorrectly
            return GetStoreInTransit(aIKT, aStoreRID, aOnHandHnRID, _storeSalesITHorizon);
        }
        public int GetStoreInTransit(IntransitKeyType aIKT, int aStoreRID, int aOnHandHnRID, StoreSalesITHorizon aStoreSalesITHorizon)
        {
            IntransitKeyType[] iktArray = new IntransitKeyType[1];
            iktArray[0] = aIKT;
            // end TT#4345 - MD - Jellis - GA VSW calcualted incorrectly
			return ((ApplicationSessionTransaction)Transaction).GetStoreInTransit(
				aOnHandHnRID,
                aStoreSalesITHorizon, // TT#4345 - MD - Jellis - GA VSW Calculated incorrectly
				iktArray,
				aStoreRID);
		}
		#endregion StoreInTransit

		// BEGIN TT#1401 - stodd - add resevation stores (IMO)
        // changed "StoreIMOHistory" to "StoreImoHistory" -- TT#1401 - JEllis - Urban Reservation Store pt 7
        // begin TT#1055 - MD - JEllis - Size Need on Size Review does not Include effect of VSW Onhand
		#region StoreImoHistory
        public int GetStoreImoHistory(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
        {
            ArrayList IKT_Array = ((ApplicationSessionTransaction)Transaction).GetSizeIntransitKeyTypes(aComponent);
            int imoHistory = 0;
            foreach (IntransitKeyType ikt in IKT_Array)
            {
                imoHistory += GetStoreImoHistory(aAllocationProfile, ikt, aStoreRID);
            }
            return imoHistory;
        }
        // end TT#1055 - MD - JEllis - Size Need on Size Review does not Include effect of VSW Onhand

        //BEGIN TT#4262-VStuart-Velocity-VSW On Hand at the plan level is used when calculating ship up to, wos and fwos-MID
        //public int GetStoreImoHistory(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, int aStoreRID)
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        return GetStoreImoHistory(aIKT, aStoreRID, BeginDay, OnHandHnRID);
        //    }
        //    return GetStoreImoHistory(aIKT, aStoreRID, aAllocationProfile.BeginDay, aAllocationProfile.OnHandHnRID);
        //}

        // Begin TT#5026 - JSmith - Question about Size Alternates
        //public int GetStoreImoHistory(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, int aStoreRID, int aHN_Rid = Include.NoRID)
        public int GetStoreImoHistory(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, int aStoreRID, int aHN_Rid = Include.NoRID, bool aIncludeAlternateSizes = false)
        // End TT#5026 - JSmith - Question about Size Alternates
        {
            if (aAllocationProfile == null)
            {
                if (aHN_Rid == Include.NoRID)
                { 
                    aHN_Rid = OnHandHnRID; 
                }
                return GetStoreImoHistory(aIKT, aStoreRID, BeginDay, aHN_Rid);
            }
            if (aHN_Rid == Include.NoRID)
            { 
                aHN_Rid = aAllocationProfile.OnHandHnRID; 
            }
            // Begin TT#5026 - JSmith - Question about Size Alternates
            //return GetStoreImoHistory(aIKT, aStoreRID, aAllocationProfile.BeginDay, aHN_Rid);
            int storeImoHistory = GetStoreImoHistory(aIKT, aStoreRID, aAllocationProfile.BeginDay, aHN_Rid);
            if (aIncludeAlternateSizes)
            {
                // Begin TT#1954-MD - JSmith - Assortment
                if (aAllocationProfile.ContainsBulkColorCodeRID(aIKT.ColorRID))
                {
                // End TT#1954-MD - JSmith - Assortment
                    ArrayList altSizeCodeList = aAllocationProfile.GetAlternateSizeCodes(aStoreRID, aIKT.ColorRID, aIKT.SizeRID);
                    if (altSizeCodeList.Count > 1)
                    {
                        foreach (SizeCodeProfile altSizeCode in altSizeCodeList)
                        {
                            if (altSizeCode.Key != aIKT.SizeRID)
                            {
                                IntransitKeyType ikt = new IntransitKeyType(aIKT.ColorRID, altSizeCode.Key);
                                storeImoHistory += GetStoreImoHistory(ikt, aStoreRID, aAllocationProfile.BeginDay, aHN_Rid);
                            }
                        }
                    }
                // Begin TT#1954-MD - JSmith - Assortment
                }
                // End TT#1954-MD - JSmith - Assortment
            }
            return storeImoHistory;
            // End TT#5026 - JSmith - Question about Size Alternates
        }
        //END TT#4262-VStuart-Velocity-VSW On Hand at the plan level is used when calculating ship up to, wos and fwos-MID

        //BEGIN TT#4262-VStuart-Velocity-VSW On Hand at the plan level is used when calculating ship up to, wos and fwos-MID
        /// <summary>
		/// Gets specified IMO History for the specified store. 
		/// </summary>
		/// <param name="aIKT">Array of IMO Key Types to retrieve: total, color or size</param>
		/// <param name="aStoreRID">RID of the store</param>
		/// <returns>IMO for the specified store.</returns>
        //public int GetStoreImoHistory(ArrayList aIKT, int aStoreRID, DateTime aHorizonBeginDate)
        //{
        //    int IMO = 0;
        //    foreach (IntransitKeyType ikt in aIKT)
        //    {
        //        IMO += GetStoreImoHistory(ikt, aStoreRID, aHorizonBeginDate, this.OnHandHnRID);
        //    }
        //    return IMO;
        //}

        public int GetStoreImoHistory(ArrayList aIKT, int aStoreRID, DateTime aHorizonBeginDate, int aHN_Rid = Include.NoRID)
        {
            int IMO = 0;
            foreach (IntransitKeyType ikt in aIKT)
            {
                if (aHN_Rid == Include.NoRID)
                {
                    aHN_Rid = this.OnHandHnRID;
                }
                IMO += GetStoreImoHistory(ikt, aStoreRID, aHorizonBeginDate, aHN_Rid);
            }
            return IMO;
        }
        //END TT#4262-VStuart-Velocity-VSW On Hand at the plan level is used when calculating ship up to, wos and fwos-MID

		/// <summary>
		/// Gets specified IMO History for the specified store. 
		/// </summary>
		/// <param name="aIKT">Identifies type of IMO to retrieve: total, color or size</param>
		/// <param name="aStoreRID">RID of the store</param>
		/// <returns>IMO for the specified store.</returns>
		public int GetStoreImoHistory(IntransitKeyType aIKT, int aStoreRID, DateTime aHorizonBeginDate)
		{
            return GetStoreImoHistory(aIKT, aStoreRID, aHorizonBeginDate, this.OnHandHnRID);
		}
		public int GetStoreImoHistory(IntransitKeyType aIKT, int aStoreRID, DateTime aHorizonBeginDate, int aOnHandHnRID)
		{
            // begin TT#1401 - JEllis - Urban Reservation Stores pt 7
            return ((ApplicationSessionTransaction)Transaction).GetStoreImoHistory(
                aOnHandHnRID,
                aHorizonBeginDate,
                aIKT,
                aStoreRID);
            //IntransitKeyType[] iktArray = new IntransitKeyType[1];
            //iktArray[0] = aIKT;
            //return ((ApplicationSessionTransaction)Transaction).GetStoreIMO(
            //    aOnHandHnRID,
            //    iktArray,
            //    aStoreRID);
            // end TT#1401 - JEllis - Urban Reservation Stores pt 7
		}
		#endregion StoreImoHistory
		// END TT#1401 - stodd - add resevation stores (IMO)

		#region StoreSalesPlan
		public int GetStoreSalesPlan(int aStoreRID)
		{
			DayProfile startDay;
			if (this.BeginDay == Include.UndefinedDate)
			{
				startDay = ((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.CurrentDate;
			}
			else
			{
				startDay = 	((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.GetDay(this.BeginDay);
			}

			return this.Transaction.GetStoreOTSSalesPlan(
				aStoreRID,
				this.PlanHnRID,
                GetCubeEligibilityNode(),
				startDay,
				this.Transaction.SAB.ApplicationServerSession.Calendar.GetDay(GetStoreNeedDay(aStoreRID)),
				this.PlanFactor);
		}
		/// <summary>
		/// Gets the Fill Sales Plan for a given store
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aColorComponent">Color Component</param>
		/// <param name="aStoreRID">Store RID</param>
		/// <param name="aReturnSales">True: Store sales basis plan returned; False: Store Stock basis plan returned</param>
		/// <returns></returns>
		public int GetStoreFillSizeBasisPlan(AllocationProfile aAllocationProfile, GeneralComponent aColorComponent, int aStoreRID, bool aReturnSales)
		{
			int fillSizePlan = 0;
			if (aAllocationProfile == null)
			{
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					fillSizePlan += ap.GetStoreFillSizeBasisPlan(aColorComponent, aStoreRID, aReturnSales);
				}
			}
			else
			{
				fillSizePlan = aAllocationProfile.GetStoreFillSizeBasisPlan (aColorComponent, aStoreRID, aReturnSales);
			}
			return fillSizePlan;
		}
		#endregion StoreSalesPlan

		#region StoreStockPlan
		public int GetStoreStockPlan(int aStoreRID)
		{
			return this.Transaction.GetStoreOTSStockPlan(
				aStoreRID,
				this.PlanHnRID,
                GetCubeEligibilityNode(),
				this.Transaction.SAB.ApplicationServerSession.Calendar.GetDay(this.GetStoreNeedDay(aStoreRID)),
				this.PlanFactor);
		}
		#endregion StoreStockPlan

		#region StoreNeed
		public double GetStoreUnitNeed(int aStoreRID)
		{
			GeneralComponent gc = new GeneralComponent(eGeneralComponentType.Total);
			IntransitKeyType ikt = new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize);
            // Begin TT#4330 - JSmith - VSW Header Need-Need % in style review includes VSW On Hands.  Do not expect the VSW On Hand to be included when allocating a VSW header.
            // Do not include VSW if the first selected header is a VSW header
            if (_allocationProfileList != null &&
                _allocationProfileList.Count > 0 &&
                ((AllocationProfile)_allocationProfileList[0]).HeaderType == eHeaderType.IMO)
            {
                // Begin TT#2031-MD - JSmith - Need % after a Redo appears incorrect.
                // Do not include allocated quantities for Assortment
                if (AssortmentProfile != null)
                {
                    return Need.UnitNeed(
                        GetStoreSalesPlan(aStoreRID) + GetStoreStockPlan(aStoreRID),
                        // Begin TT#1991-MD - JSmith - Current On Hand checked or unchecked can get the same values.  Would expect them to be different.
                        //GetStoreOnHand(ikt, aStoreRID),
                        //GetStoreInTransit(ikt, aStoreRID),
                        AssortmentProfile.AssortmentIncludeOnhand ? GetStoreOnHand(ikt, aStoreRID) : 0,
                        AssortmentProfile.AssortmentIncludeIntransit ? GetStoreInTransit(ikt, aStoreRID) : 0,
                        // End TT#1991-MD - JSmith - Current On Hand checked or unchecked can get the same values.  Would expect them to be different.
						// Begin TT#2079-MD - JSmith - Process Need on a PH after processing the Need in Unts and the Need % do not change.
						//0);
                        this.GetStoreQtyAllocatedNotIntransit(gc, aStoreRID));
						// End TT#2079-MD - JSmith - Process Need on a PH after processing the Need in Unts and the Need % do not change.
                }
                // End TT#2031-MD - JSmith - Need % after a Redo appears incorrect.

                return Need.UnitNeed(
                GetStoreSalesPlan(aStoreRID) + GetStoreStockPlan(aStoreRID),
                GetStoreOnHand(ikt, aStoreRID),
                GetStoreInTransit(ikt, aStoreRID),
                this.GetStoreQtyAllocatedNotIntransit(gc, aStoreRID));
            }
            // End TT#4330 - JSmith - VSW Header Need-Need % in style review includes VSW On Hands.  Do not expect the VSW On Hand to be included when allocating a VSW header.

            // Begin TT#2031-MD - JSmith - Need % after a Redo appears incorrect.
            // Do not include allocated quantities for Assortment
            if (AssortmentProfile != null)
            {
                return Need.UnitNeed(
                GetStoreSalesPlan(aStoreRID) + GetStoreStockPlan(aStoreRID),
                // Begin TT#1991-MD - JSmith - Current On Hand checked or unchecked can get the same values.  Would expect them to be different.
                //GetStoreOnHand(ikt, aStoreRID) + GetStoreImoHistory(null, ikt, aStoreRID),
                //GetStoreInTransit(ikt, aStoreRID),
                AssortmentProfile.AssortmentIncludeOnhand ? GetStoreOnHand(ikt, aStoreRID) + GetStoreImoHistory(null, ikt, aStoreRID) : 0,
                AssortmentProfile.AssortmentIncludeIntransit ? GetStoreInTransit(ikt, aStoreRID) : 0,
                // End TT#1991-MD - JSmith - Current On Hand checked or unchecked can get the same values.  Would expect them to be different.
                // Begin TT#2079-MD - JSmith - Process Need on a PH after processing the Need in Unts and the Need % do not change.
				//0);
				this.GetStoreQtyAllocatedNotIntransit(gc, aStoreRID));
				// End TT#2079-MD - JSmith - Process Need on a PH after processing the Need in Unts and the Need % do not change.
            }
            // End TT#2031-MD - JSmith - Need % after a Redo appears incorrect.

			return Need.UnitNeed(
				GetStoreSalesPlan(aStoreRID) + GetStoreStockPlan(aStoreRID),
                GetStoreOnHand(ikt, aStoreRID) + GetStoreImoHistory(null, ikt, aStoreRID),   // TT#1401 - JEllis - Urban Reservation Store pt 11
				GetStoreInTransit(ikt, aStoreRID),
				this.GetStoreQtyAllocatedNotIntransit(gc, aStoreRID));
		}
		public double GetStorePercentNeed(int aStoreRID)
		{
			return Need.PctUnitNeed(
				GetStoreUnitNeed(aStoreRID),
				GetStoreSalesPlan(aStoreRID) + GetStoreStockPlan(aStoreRID));
		}
		#endregion StoreNeed

		#region StoreVisible
		/// <summary>
		/// Indicates whether a store may be displayed.
		/// </summary>
		internal bool StoreIsVisible(int aStoreRID)
		{
			return StoreIsVisible(StoreIndex(aStoreRID));
		}
		internal bool StoreIsVisible(Index_RID aStore)
		{
            // begin TT#1401 - JEllis - Urban Reservation Store pt 11
            if (!GetIncludeStoreInAllocation(aStore))
            {
                return false;
            }
            // end TT#1401 - JEllis - Urban Reservation Store pt 11
			// BEGIN Issue 5727 stodd
			// Added the try-catch to catch the outdated filter exception
			try
			{
				if (!AllocationFilteredStoreList.Contains(aStore.RID))
				{
					return false;
				}
			}
			catch (MIDException ex)
			{
				if (ex.ErrorNumber == (int)eMIDTextCode.msg_FilterInvalid)	
					return false;
				else
					throw;
			}
			// END Issue 5727
			if (this.Transaction.AllocationIncludeIneligibleStores)
			{
				return true;
			}
			if (this.GetStoreIsEligible(aStore) == true)
			{
				return true;
			}
			return (this.GetStoreQtyAllocated(eAllocationSummaryNode.Total, aStore) > 0);
		}
		#endregion StoreIsVisible

		#region StoreEligibility
		/// <summary>
		/// Loads Eligibility (assumes ship days already loaded).
		/// </summary>
		private void DetermineEligibility()
		{
			ProfileList allStoreList = (ProfileList)this.Transaction.GetMasterProfileList(eProfileType.Store);
			_storeIsEligible = new bool[allStoreList.Count];
			_storeIsEligible.Initialize();
			StoreWeekEligibilityProfile swep;
			StoreWeekEligibilityList swel = new StoreWeekEligibilityList(eProfileType.StoreEligibility);
			
			if (this.EndDay != Include.UndefinedDate)
			{
                // if using external eligibility, use the eligibility of the first header selected
                if (this.Transaction.GlobalOptions.UseExternalEligibilityAllocation
                    && this._allocationProfileList.ArrayList.Count > 0)
                {
                    AllocationProfile ap = (AllocationProfile)this._allocationProfileList.ArrayList[0];
                    foreach (StoreProfile sp in (ProfileList)this.Transaction.GetMasterProfileList(eProfileType.Store))
                    {
                        this.SetStoreIsEligible(sp.Key, ap.GetStoreIsEligible(sp.Key));
                    }
                }
                else
                {
                    WeekProfile wp = this.Transaction.SAB.ApplicationServerSession.Calendar.GetWeek(this.EndDay);
                    foreach (StoreProfile sp in allStoreList)
                    {
                        swep = new StoreWeekEligibilityProfile(sp.Key);
                        swep.YearWeek = wp.YearWeek;
                        swel.Add(swep);
                    }
                    swel = ((ApplicationSessionTransaction)Transaction).GetStoreEligibilityForStock(
                        eRequestingApplication.Allocation,
                        this.EligibilityHnRID,
                        swel
                        );
                    foreach (StoreWeekEligibilityProfile sep in swel)
                    {
                        this.SetStoreIsEligible(sep.Key, sep.StoreIsEligible);
                    }
                }
			}
			else
			{
				if (this.SubtotalMembers.Count == 0)
				{
                    // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                    if (AssortmentProfile != null)
                    {
                        if (PlanHnRID == AssortmentProfile.PlanHnRID)
                        {
                            foreach (StoreProfile sp in (ProfileList)this.Transaction.GetMasterProfileList(eProfileType.Store))
                            {
                                this.SetStoreIsEligible(sp.Key, AssortmentProfile.GetStoreIsEligible(sp.Key));
                            }
                        }
                        else
                        {
                            foreach (StoreProfile sp in (ProfileList)this.Transaction.GetMasterProfileList(eProfileType.Store))
                            {
                                if (AssortmentProfile.GetStoreShipDay(sp.Key) == Include.UndefinedDate)
                                {
                                    this.SetStoreIsEligible(sp.Key, false);
                                }
                                else
                                {
                                    swep = new StoreWeekEligibilityProfile(sp.Key);
                                    swep.YearWeek = (this.Transaction.SAB.ApplicationServerSession.Calendar.GetWeek(AssortmentProfile.GetStoreShipDay(sp.Key)).Key);
                                    swel.Add(swep);
                                }
                            }
                            swel = ((ApplicationSessionTransaction)Transaction).GetStoreEligibilityForStock(
                                eRequestingApplication.Allocation, 
                                this.EligibilityHnRID, 
                                swel
                                );
                            foreach (StoreWeekEligibilityProfile sep in swel)
                            {
                                this.SetStoreIsEligible(sep.Key, sep.StoreIsEligible);
                            }
                        }
                    }
                    // end  TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
					throw new MIDException(eErrorLevel.fatal,
						(int)eMIDTextCode.msg_al_SubtotalHasNoMembers,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalHasNoMembers));
				}
				AllocationProfile ap = (AllocationProfile)this._allocationProfileList.ArrayList[0];

				if (this.PlanHnRID == ap.PlanHnRID)
				{
					foreach (StoreProfile sp in (ProfileList)this.Transaction.GetMasterProfileList(eProfileType.Store))
					{
						this.SetStoreIsEligible(sp.Key, ap.GetStoreIsEligible(sp.Key));
					}
				}
				else
				{
					foreach (StoreProfile sp in (ProfileList)this.Transaction.GetMasterProfileList(eProfileType.Store))
					{
						if (ap.GetStoreShipDay(sp.Key) == Include.UndefinedDate)
						{
							this.SetStoreIsEligible(sp.Key, false);
						}
						else
						{
							swep = new StoreWeekEligibilityProfile(sp.Key);
							swep.YearWeek = (this.Transaction.SAB.ApplicationServerSession.Calendar.GetWeek(ap.GetStoreShipDay(sp.Key)).Key);
							swel.Add(swep);
						}
					}
					swel = ((ApplicationSessionTransaction)Transaction).GetStoreEligibilityForStock(
                        eRequestingApplication.Allocation, 
                        this.EligibilityHnRID, 
                        swel
                        );
					foreach (StoreWeekEligibilityProfile sep in swel)
					{
						this.SetStoreIsEligible(sep.Key, sep.StoreIsEligible);
					}
				}
			}
		}
		private bool GetStoreIsEligible(int aStoreRID)
		{
			return GetStoreIsEligible(StoreIndex(aStoreRID));
		}
		private bool GetStoreIsEligible(Index_RID aStore)
		{
			if (_storeIsEligible == null)
			{
				DetermineEligibility();
			}
			return _storeIsEligible[aStore.Index];
		}
		private void SetStoreIsEligible(int aStoreRID, bool aFlagValue)
		{
			SetStoreIsEligible(StoreIndex(aStoreRID), aFlagValue);
		}
		private void SetStoreIsEligible(Index_RID aStore, bool aFlagValue)
		{
			_storeIsEligible[aStore.Index] = aFlagValue;
		}

        public int GetCubeEligibilityNode()
        {
            if (this.Transaction.GlobalOptions.UseExternalEligibilityAllocation)
            {
                return EligibilityHnRID;
            }
            // if not using external eligibility, do not set the eligibility node so it will process as before
            else
            {
                return Include.Undefined;
            }
        }
		#endregion StoreEligibility

        // begin TT#1401 - JEllis - Urban Reservation Store pt 11
        #region Store Included In Allocation
        /// <summary>
        /// Gets Store's include in allocation flag value.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aStoreRID">RID identifier for the store</param>
        /// <returns>True if store included in header allocation, false if not.</returns>
        public bool GetIncludeStoreInAllocation(AllocationProfile aAllocationProfile, int aStoreRID)
        {
            if (aAllocationProfile == null)
            {
                return GetIncludeStoreInAllocation(aStoreRID);
            }
            return aAllocationProfile.GetIncludeStoreInAllocation(StoreIndex(aStoreRID));
        }
        /// <summary>
        /// Gets Store's include in allocation flag value.
        /// </summary>
        /// <param name="aStoreRID">RID identifier for the store</param>
        /// <returns>True if store included in header allocation, false if not.</returns>
        internal bool GetIncludeStoreInAllocation(int aStoreRID)
        {
            return GetIncludeStoreInAllocation(StoreIndex(aStoreRID));
        }
        /// <summary>
        /// Gets Store's include in allocation flag value.
        /// </summary>
        /// <param name="aStore">Index_RID identifier for the store</param>
        /// <returns>True if store included in header allocation for all selected headers, false if not.</returns>
        internal bool GetIncludeStoreInAllocation(Index_RID aStore) 
        {
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28A
                //if (!ap.GetIncludeStoreInAllocation(aStore))
                //{
                //    return false;
                //}
                if (ap.GetIncludeStoreInAllocation(aStore))
                {
                    return true;
                }
                // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28A
            }
            return false;  // TT#1401 - JEllis - Urban Virutal Store Warehouse pt 28A
        }
        #endregion Store Included In Allocation
        // end TT#1401 - JEllis - Urban Reservation Store pt 11

		#region StoreGrades
		/// <summary>
		/// Gets the store grade code
		/// </summary>
		/// <param name="aStoreRID">RID of the store</param>
		/// <returns>Grade code associated with the store</returns>
		public string GetStoreGrade(int aStoreRID)
		{
			return GetStoreGrade(StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets the store grade code
		/// </summary>
		/// <param name="aStore">Index_RID that identifies the store</param>
		/// <returns>Grade code associated with the store</returns>
		internal string GetStoreGrade(Index_RID aStore)
		{
		//BEGIN TT#703 -MD- DOConnell Receive Argument Out of Range exception when draging a header onto an assortment while the Style View Screen is open
    		//if (this.GetStoreIsEligible(aStore))
                //{
                    //return ((AllocationGradeBin)this.GradeList[GetStoreGradeIdx(aStore)]).Grade;
                //}
                //return " ";
			try
            {
                if (this.GetStoreIsEligible(aStore))
                {
                    return ((AllocationGradeBin)this.GradeList[GetStoreGradeIdx(aStore)]).Grade;
                }
                return " ";
            }
            catch
            {
                try
                {
                    DetermineStoreGrades();
                    if (this.GetStoreIsEligible(aStore))
                    {
                        return ((AllocationGradeBin)this.GradeList[GetStoreGradeIdx(aStore)]).Grade;
                    }
                    return " ";
                }
                catch
                {
                    throw;
                }
            }
			//END TT#703 -MD- DOConnell Receive Argument Out of Range exception when draging a header onto an assortment while the Style View Screen is open
		}

		/// <summary>
		/// Gets the store grade index
		/// </summary>
		/// <param name="aStoreRID">RID of the store</param>
		/// <returns>Grade index associated with the store</returns>
		public int GetStoreGradeIdx(int aStoreRID)
		{
			return GetStoreGradeIdx(StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets the store grade index
		/// </summary>
		/// <param name="aStore">Index_RID that identifies the store</param>
		/// <returns>Grade index associated with the store</returns>
		internal int GetStoreGradeIdx(Index_RID aStore)
		{
			if (this._gradeIndex == null)
			{
				DetermineStoreGrades();
			}
			return _gradeIndex[aStore.Index];
		}

        // Begin TT#2308 - JEllis - Port fix TT#2305 to version 4.0 
		// Following is accomplished by fix TT#887 (property:  LoadGrades--true or false)
        //// Begin TT#2305 - JEllis - FL Balance not observing Size multiple pt 2
        //internal void ResetStoreGrades()
        //{
        //    _gradeIndex = null;
        //}
        //// end TT#2305 - JEllis - FL Balance not observing Size Multiple pt 2
        // end TT#2308 = JEllis - Port fix TT#2305 to version 4.0
		/// <summary>
		/// Determines Store Grades for this subtotal 
		/// </summary>
		internal void DetermineStoreGrades()
		{
			_gradeIndex = new int[this.StoreDimension];
			_gradeIndex.Initialize();
			if (this.GradeList.Count < 1)
			{
				//throw new MIDException (eErrorLevel.warning,  // MID track 5374 Workflow Errors do not stop Process
				throw new MIDException (eErrorLevel.severe,     // MID Track 5374 Workflow Errors do not stop process
					(int)eMIDTextCode.msg_NoGradeDefinition,
					this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_NoGradeDefinition));
			}
			GradeStoreBin[] _gradeStoreBin = new GradeStoreBin[this.StoreDimension];

			// BEGIN MID Track # 2539 Grades not same in OTS and ALlocation
//			Index_RID ir;
//			foreach (StoreProfile sp in _allStoreList)
//			{
//				ir = StoreIndex(sp.Key);
//				if (sp.Key == ((ApplicationSessionTransaction)this.Transaction).ReserveStore.RID)
//				{
//					_gradeStoreBin[ir.Index].StoreEligible = false;
//				}
//				else
//				{
//					_gradeStoreBin[ir.Index].StoreEligible = this.GetStoreIsEligible(ir);
//				}
//				_gradeStoreBin[ir.Index].StoreGradeUnits = 0;
//				_gradeStoreBin[ir.Index].StoreKey = ir.RID;				
//			}
			// END MID Track # 2539
			WeekProfile wp;

			if (BeginDay == Include.UndefinedDate)
			{
				wp = ((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.CurrentWeek;
			}
			else
			{
				wp = ((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.GetWeek(BeginDay);
			}
			// BEGIN MID Track # 2539 Grades not same in OTS and ALlocation
			WeekProfile endWeek;
			if (this.GradeWeekCount > 0)
			{
				endWeek = Transaction.SAB.ApplicationServerSession.Calendar.GetWeek(Transaction.SAB.ApplicationServerSession.Calendar.AddWeeks(wp.Key, this.GradeWeekCount - 1));
			}
			else
			{
				endWeek = wp;
			}

            SortedList storeAttributeSet = GetStoreAttributeSets();   // TT#618 - RMatelic - Allocation Override - Add Attribute Sets (#35)

			Index_RID ir;
			foreach (StoreProfile sp in _allStoreList)
			{
				ir = StoreIndex(sp.Key);
//				if (sp.Key == ((ApplicationSessionTransaction)this.Transaction).ReserveStore.RID)
//				{
//					_gradeStoreBin[ir.Index].StoreEligible = false;
//				}
//				else
//				{
					_gradeStoreBin[ir.Index].StoreEligible = 
						this.Transaction.GetStoreEligibilityForSalesInWeekRange(
                            eRequestingApplication.Allocation, 
                            ir.RID, 
                            EligibilityHnRID, 
                            wp.YearWeek, 
                            endWeek.YearWeek
                            );
//				}
				_gradeStoreBin[ir.Index].StoreGradeUnits = 0;
				_gradeStoreBin[ir.Index].StoreKey = ir.RID;
                // Begin TT#618 - RMatelic - Allocation Override - Add Attribute Sets (#35)
                if (storeAttributeSet.Count > 0)
                {
                    _gradeStoreBin[ir.Index].StoreSglRID = (int)storeAttributeSet[ir.RID];  
                }
                else
                {
                    _gradeStoreBin[ir.Index].StoreSglRID = Include.AllStoreGroupLevelRID;
                }
			}   // End TT#618

			// END MID Track # 2539

			PlanCube storePlanCube = ((ApplicationSessionTransaction)Transaction).GetAllocationPlanCube(
				PlanHnRID,
                GetCubeEligibilityNode(),
				Include.UndefinedDate,
				Include.UndefinedDate);

			PlanCellReference planCellRef = new PlanCellReference((PlanCube)storePlanCube);
			planCellRef[eProfileType.Version] = Include.FV_ActionRID;
			planCellRef[eProfileType.HierarchyNode] = PlanHnRID;
			planCellRef[eProfileType.QuantityVariable] = ((ApplicationSessionTransaction)Transaction).PlanComputations.PlanQuantityVariables.ValueQuantity.Key;
			if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(PlanHnRID).OTSPlanLevelType)
			{
				planCellRef[eProfileType.Variable] = ((ApplicationSessionTransaction)Transaction).PlanComputations.PlanVariables.SalesRegPromoUnitsVariable.Key;
			}
			else
			{
				planCellRef[eProfileType.Variable] = ((ApplicationSessionTransaction)Transaction).PlanComputations.PlanVariables.SalesTotalUnitsVariable.Key;
			}
			ArrayList storePlanValues;

			for(int i = 0; i < this.GradeWeekCount; i++)
			{
				planCellRef[eProfileType.Week] = (((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.ConvertToStaticWeek(wp, i)).Key;
				//				storePlanValues = planCellRef.GetCellRefArray((ProfileList)this.Transaction.GetMasterProfileList(eProfileType.Store));
				storePlanValues = planCellRef.GetCellRefArray(this._allStoreList);
				PlanCellReference aStorePlanValue;
				for(int j = 0;  j < this.StoreDimension; j++)
				{
					aStorePlanValue = (PlanCellReference)storePlanValues[j];
					// BEGIN MID Track #2539 Grade Not Same
					if (aStorePlanValue.CurrentCellValue > 0)
					{
						_gradeStoreBin[j].StoreGradeUnits += aStorePlanValue.CurrentCellValue;
					}
					// END MID Track #2539
				}
			}
            // Begin TT#618 - RMatelic - Allocation Override - Add Attribute Sets (#35)
            //double[] aGradeBoundary = new double[this.GradeList.Count];
            //for (int i = 0; i < this.GradeList.Count; i++)
            //{
            //    aGradeBoundary[i] = ((AllocationGradeBin)GradeList[i]).LowBoundary;
            //}
            //_gradeIndex = StoreGrade.GetGradeIndex(aGradeBoundary, _gradeStoreBin);

            Hashtable setBoundaryHT = new Hashtable();
            SortedList boundarySL;
            double gradeBoundary;
            int sglRID;
            for (int i = 0; i < this.GradeList.Count; i++)
            {
                gradeBoundary = ((AllocationGradeBin)GradeList[i]).LowBoundary;
                sglRID = ((AllocationGradeBin)GradeList[i]).GradeSglRID;
                if (setBoundaryHT.ContainsKey(sglRID))
                {
                    boundarySL = (SortedList)setBoundaryHT[sglRID];
                    if (!boundarySL.ContainsKey(gradeBoundary))
                    {
                        boundarySL.Add(gradeBoundary, i);
                    }
                }
                else
                {
                    boundarySL = new SortedList();
                    boundarySL.Add(gradeBoundary, i);
                    setBoundaryHT.Add(sglRID, boundarySL);
                }
            }
            _gradeIndex = StoreGrade.GetGradeIndex(setBoundaryHT, _gradeStoreBin);
            // End  TT#618
		}

        // Begin TT#618 - RMatelic - Allocation Override - Add Attribute Sets (#35)
        private SortedList GetStoreAttributeSets()
        {
            SortedList storeSets = new SortedList();
            if (this.SubtotalName == this.Transaction.GrandTotalName
                && this.Transaction.NeedAnalysisFrom1stHeader) //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                //&& this.SubtotalMembers.Count > 0) //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
            {
                // begin TT#1154 - MD - Jellis  -  Group Allocation Infinite  Loop When Going to SIze Analysis
                if (SubtotalMembers.Count > 0)
                {
                    // end TT#1154 - MD- Jellis -  Group Allocation Infinite  Loop When Going to SIze Analysis
                    AllocationProfile ap = (AllocationProfile)this.SubtotalMembers.ArrayList[0];
                    ProfileList storeGroupList = StoreMgmt.StoreGroup_GetLevelListViewList(ap.GradeSG_RID, true); //SAB.StoreServerSession.GetStoreGroupLevelListViewList(ap.GradeSG_RID, true);
                    foreach (StoreGroupLevelListViewProfile groupLevelProf in storeGroupList)
                    {
                        foreach (StoreProfile storeProf in groupLevelProf.Stores)
                        {
                            storeSets.Add(storeProf.Key, groupLevelProf.Key);
                        }
                    }
                    // begin TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
                }
                else if (AssortmentProfile != null)
                {
                    ProfileList storeGroupList = StoreMgmt.StoreGroup_GetLevelListViewList(AssortmentProfile.GradeSG_RID, true); //SAB.StoreServerSession.GetStoreGroupLevelListViewList(AssortmentProfile.GradeSG_RID, true);
                    foreach (StoreGroupLevelListViewProfile groupLevelProf in storeGroupList)
                    {
                        foreach (StoreProfile storeProf in groupLevelProf.Stores)
                        {
                            storeSets.Add(storeProf.Key, groupLevelProf.Key);
                        }
                    }
                }
                    // end  TT#1154 - MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
            }    
            return storeSets;
        }
        // End TT#618
		#endregion StoreGrades

		#region StoreLocked
		//===================//
		// Locked Audit Flag //
		//===================//
		#region GetStoreLocked
		/// <summary>
		/// Gets Store Locked Audit Flag value for specified store on specified component on specified AllocationProfile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Locked Flag Value for the store for the specified component on the specified AllocationProfile.</returns>
		public bool GetStoreLocked(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return this.GetStoreLocked(aComponent, aStoreRID);
			}
			return aAllocationProfile.GetStoreLocked(aComponent, aStoreRID);
		}

		/// <summary>
		/// Gets Store Locked Audit Flag value for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Locked Flag Value for the store for the specified component.</returns>
		public bool GetStoreLocked(GeneralComponent aComponent, int aStoreRID)
		{
			return GetStoreLocked(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Locked Audit Flag value for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Locked Flag Value for the store for the specified component.</returns>
        public bool GetStoreLocked(GeneralComponent aComponent, Index_RID aStore) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			bool lockFlag;
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetStoreLocked(eAllocationSummaryNode.BulkColorTotal, aStore);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetStoreLocked(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (GetStoreLocked(eAllocationSummaryNode.DetailType, aStore))
					{
						return GetStoreLocked(eAllocationSummaryNode.DetailType, aStore);
					}
					lockFlag = true;
					foreach (PackHdr ph in this.SubtotalPacks.Values)
					{
						if (!ph.GenericPack)
						{
							if (!GetStoreLocked(ph, aStore))
							{
								lockFlag = false;
							}
						}
					}
					return lockFlag; 
				}
				case (eComponentType.AllPacks):
				{
					lockFlag = true;
					foreach (PackHdr ph in this.SubtotalPacks.Values)
					{
						if (!GetStoreLocked(ph, aStore))
						{
							lockFlag = false;
						}
					}
					return lockFlag;
				}
				case (eComponentType.AllSizes):
				{
					lockFlag = true;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
						{
							if (!GetStoreLocked(hsb, aStore))
							{
								lockFlag = false;
							}
						}
					}
					return lockFlag;
				}
				case (eComponentType.Bulk):
				{
					return GetStoreLocked (eAllocationSummaryNode.Bulk, aStore);
				}
				case (eComponentType.ColorAndSize):
				{
					lockFlag = true;
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											if (!GetStoreLocked(hsb, aStore))
											{
												lockFlag = false;
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										if (hcb.SizeIsInColor(sizeComponent.SizeRID))
										{
											if (!GetStoreLocked(hcb, sizeComponent.SizeRID, aStore))
											{
												lockFlag = false;
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;   // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (!GetStoreLocked(hcb, scp.Key, aStore))
												{
													lockFlag = false;
													break;
												}
											}
										}
										if (lockFlag == false)
										{
											break;
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (!GetStoreLocked(hcb, scp.Key, aStore))
												{
													lockFlag = false;
													break;
												}
											}
										}
										if (lockFlag == false)
										{
											break;
										}
									}
									break;
								}
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										foreach(HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
										{
											if (!GetStoreLocked(hsb, aStore))
											{
												lockFlag = false;
											}
										}
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											if(!GetStoreLocked(colorComponent.ColorRID, sizeComponent.SizeRID, aStore))
											{
												lockFlag = false;
											}
										}
										break;
									}
									// BEGIN MID Track #2412 Unknown Component
									case (eComponentType.SpecificSizePrimaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor (scp.Key))
											{
												if(!GetStoreLocked(hcb,scp.Key, aStore))
												{
													lockFlag = false;
												}
											}
										}
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor (scp.Key))
											{
												if(!GetStoreLocked(hcb,scp.Key, aStore))
												{
													lockFlag = false;
												}
											}
										}
										break;
									}
									// END MID Track #2412 Unknown Component
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					return lockFlag;
				}
				case (eComponentType.DetailType):
				{
					return GetStoreLocked(eAllocationSummaryNode.DetailType, aStore);
				}
				case (eComponentType.GenericType):
				{
					return GetStoreLocked(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetStoreLocked(colorComponent.ColorRID, aStore);
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					lockFlag = true;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						if (hcb.SizeIsInColor(sizeComponent.SizeRID))
						{
							if (!GetStoreLocked(hcb, sizeComponent.SizeRID, aStore))
							{
								lockFlag = false;
							}
						}
					}
					return lockFlag;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetStoreLocked (packComponent.PackName, aStore);
				}
				case (eComponentType.Total):
				{
					return GetStoreLocked (eAllocationSummaryNode.Total, aStore);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
		public bool GetStoreLocked(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
		{
			return GetStoreLocked(aAllocationSummaryNode, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
        public bool GetStoreLocked(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (!ap.GetStoreLocked(aAllocationSummaryNode, aStore))
				{
					return false;
				}
			}
			return true;
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
		public bool GetStoreLocked(string aSubtotalPackName, int aStoreRID)
		{
			return GetStoreLocked(aSubtotalPackName, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
        public bool GetStoreLocked(string aSubtotalPackName, Index_RID aStore) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			return GetStoreLocked(GetSubtotalPackHdr(aSubtotalPackName), aStore);
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
        public bool GetStoreLocked(PackHdr aSubtotalPack, Index_RID aStore) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aSubtotalPack.PackName))
				{
					if (!ap.GetStoreLocked(aSubtotalPack.PackName, aStore))
					{
						return false;
					}
				}
			}
			return true;
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
		public bool GetStoreLocked(int aColorCodeRID, int aStoreRID)
		{
			return GetStoreLocked(aColorCodeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
        public bool GetStoreLocked(int aColorCodeRID, Index_RID aStore) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			return GetStoreLocked(this.GetSubtotalHdrColorBin(aColorCodeRID), aStore);
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
        public bool GetStoreLocked(HdrColorBin aColor, Index_RID aStore) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					if (!ap.GetStoreLocked(aColor.ColorCodeRID, aStore))
					{
						return false;
					}
				}
			}
			return true;
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
		public bool GetStoreLocked(int aColorCodeRID, int aSizeRID, int aStoreRID)
		{
			return GetStoreLocked(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
        public bool GetStoreLocked(int aColorCodeRID, int aSizeRID, Index_RID aStore) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			return GetStoreLocked(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
        public bool GetStoreLocked(HdrColorBin aColor, int aSizeRID, Index_RID aStore) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			return GetStoreLocked(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store Locked; false otherwise.</returns>
        public bool GetStoreLocked(HdrSizeBin aSize, Index_RID aStore) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			HdrColorBin hcb;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
				{
					hcb = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (hcb.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
					{
                        if (!ap.GetStoreLocked(hcb, aSize.SizeCodeRID, aStore)) // Assortment: color/size changes
						{
							return false;
						}
					}
				}
			}
			return true;
		}
		#endregion GetStoreLocked

		#region SetStoreLocked
		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified node of the specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the allocation component.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store is Locked; false otherwise.</param>
		public void SetStoreLocked (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, bool aFlagValue)
		{
			if (aAllocationProfile == null)
			{
				this.SetStoreLocked(aComponent, aStoreRID, aFlagValue);
			}
			else
			{
				aAllocationProfile.SetStoreLocked(aComponent, aStoreRID, aFlagValue);
			}
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aComponent">Description of the allocation component.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store is Locked; false otherwise.</param>
		public void SetStoreLocked(GeneralComponent aComponent, int aStoreRID, bool aFlagValue)
		{
			SetStoreLocked(aComponent, StoreIndex(aStoreRID), aFlagValue);
		}

		/// <summary>
		/// Gets Store Locked audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aComponent">Description of the allocation component.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store is Locked; false otherwise.</param>
        public void SetStoreLocked(GeneralComponent aComponent, Index_RID aStore, bool aFlagValue) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					SetStoreLocked(eAllocationSummaryNode.BulkColorTotal, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.AllGenericPacks):
				{
					SetStoreLocked(eAllocationSummaryNode.GenericType, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.AllNonGenericPacks):
				{
					foreach (PackHdr ph in this.SubtotalPacks.Values)
					{
						if (!ph.GenericPack)
						{
							SetStoreLocked(ph, aStore, aFlagValue, eDistributeChange.ToAll);
						}
					}
					break;
				}
				case (eComponentType.AllPacks):
				{
					foreach (PackHdr ph in SubtotalPacks.Values)
					{
						SetStoreLocked(ph, aStore, aFlagValue, eDistributeChange.ToAll);
					}
					break;
				}
				case (eComponentType.AllSizes):
				{
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
						{
							SetStoreLocked(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
						}
					}
					break;
				}
				case (eComponentType.Bulk):
				{
					SetStoreLocked (eAllocationSummaryNode.Bulk, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.ColorAndSize):
				{
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											SetStoreLocked(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										if (hcb.SizeIsInColor(sizeComponent.SizeRID))
										{
											SetStoreLocked(hcb, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
										}
									}
									break;
								}
								// BEGIN MID Track #2412 Unknown Component
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor (scp.Key))
											{
												SetStoreLocked(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor (scp.Key))
											{
												SetStoreLocked(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}
									}
									break;
								}
								// END MID Track #2412 Unknown Component
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										foreach(HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
										{
											SetStoreLocked(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
										}
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											SetStoreLocked(colorComponent.ColorRID, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
										}
										break;
									}
									// BEGIN MID Track #2412 Unknown Component
									case (eComponentType.SpecificSizePrimaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor (scp.Key))
											{
												SetStoreLocked(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}										
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor (scp.Key))
											{
												SetStoreLocked(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}										
										break;
									}
									// END MID Track #2412 Unknown Component
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					break;
				}
				case (eComponentType.DetailType):
				{
					SetStoreLocked(eAllocationSummaryNode.DetailType, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.GenericType):
				{
					SetStoreLocked(eAllocationSummaryNode.GenericType, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					SetStoreLocked(colorComponent.ColorRID, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						if (hcb.SizeIsInColor(sizeComponent.SizeRID))
						{
							SetStoreLocked(hcb, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
						}
					}
					break;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					SetStoreLocked (packComponent.PackName, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.Total):
				{
					SetStoreLocked (eAllocationSummaryNode.Total, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		public void SetStoreLocked(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, bool aFlagValue)
		{
			SetStoreLocked(aAllocationSummaryNode, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
        public void SetStoreLocked(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore,  // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
			bool aFlagValue, eDistributeChange aDistributeChange)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				ap.SetStoreLocked(aAllocationSummaryNode, aStore, aFlagValue, aDistributeChange);
			}
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		public void SetStoreLocked(string aSubtotalPackName, int aStoreRID, bool aFlagValue)
		{
			SetStoreLocked(aSubtotalPackName, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how to distrubute the change to parent and children nodes.</param>
        public void SetStoreLocked(string aSubtotalPackName, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			SetStoreLocked(GetSubtotalPackHdr(aSubtotalPackName), aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how to reflect change in parent and children nodes</param>
        public void SetStoreLocked(PackHdr aSubtotalPack, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aSubtotalPack.PackName))
				{
					ap.SetStoreLocked(aSubtotalPack.PackName, aStore, aFlagValue, aDistributeChange);
				}
			}
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		public void SetStoreLocked(int aColorCodeRID, int aStoreRID, bool aFlagValue)
		{
			SetStoreLocked(aColorCodeRID, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes.</param>
        public void SetStoreLocked(int aColorCodeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			SetStoreLocked(this.GetSubtotalHdrColorBin(aColorCodeRID), aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
        public void SetStoreLocked(HdrColorBin aColor, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					ap.SetStoreLocked(aColor.ColorCodeRID, aStore, aFlagValue, aDistributeChange);
				}
			}
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified color-size node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		public void SetStoreLocked(int aColorCodeRID, int aSizeRID, int aStoreRID, bool aFlagValue)
		{
			SetStoreLocked(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
        public void SetStoreLocked(int aColorCodeRID, int aSizeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			SetStoreLocked(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be refleted in parent and children nodes</param>
        public void SetStoreLocked(HdrColorBin aColor, int aSizeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			SetStoreLocked(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store Locked audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store Locked; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes.</param>
        public void SetStoreLocked(HdrSizeBin aSize, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			HdrColorBin hcb;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
				{
					hcb = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (hcb.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
					{
                        ap.SetStoreLocked(hcb, aSize.SizeCodeRID, aStore, aFlagValue, aDistributeChange); // Assortment: color/size changes
					}
				}
			}
		}
		#endregion SetStoreLocked
		#endregion StoreLocked
	
		#region StoreTempLock
		//=====================//
		// TempLock Audit Flag //
		//=====================//
		#region GetStoreTempLock
		/// <summary>
		/// Gets Store TempLock Audit Flag value for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>TempLock Flag Value for the store for the specified component.</returns>
		public bool GetStoreTempLock(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreTempLock(aComponent, StoreIndex(aStoreRID));
			}
			return GetStoreTempLock(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store TempLock Audit Flag value for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>TempLock Flag Value for the store for the specified component.</returns>
		internal bool GetStoreTempLock(GeneralComponent aComponent, Index_RID aStore)
		{
			bool lockFlag;
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetStoreTempLock(eAllocationSummaryNode.BulkColorTotal, aStore);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetStoreTempLock(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (GetStoreTempLock(eAllocationSummaryNode.DetailType, aStore))
					{
						return GetStoreTempLock(eAllocationSummaryNode.DetailType, aStore);
					}
					lockFlag = true;
					foreach (PackHdr ph in this.SubtotalPacks.Values)
					{
						if (!ph.GenericPack)
						{
							if (!GetStoreTempLock(ph, aStore))
							{
								lockFlag = false;
							}
						}
					}
					return lockFlag; 
				}
				case (eComponentType.AllPacks):
				{
					lockFlag = true;
					foreach (PackHdr ph in this.SubtotalPacks.Values)
					{
						if (!GetStoreTempLock(ph, aStore))
						{
							lockFlag = false;
						}
					}
					return lockFlag;
				}
				case (eComponentType.AllSizes):
				{
					lockFlag = true;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
						{
							if (GetStoreTempLock(hsb, aStore))
							{
								lockFlag = false;
							}
						}
					}
					return lockFlag;
				}
				case (eComponentType.Bulk):
				{
					return GetStoreTempLock (eAllocationSummaryNode.Bulk, aStore);
				}
				case (eComponentType.ColorAndSize):
				{
					lockFlag = true;
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											if (!GetStoreTempLock(hsb, aStore))
											{
												lockFlag = false;
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										if (hcb.SizeIsInColor(sizeComponent.SizeRID))
										{
											if (!GetStoreTempLock(hcb, sizeComponent.SizeRID, aStore))
											{
												lockFlag = false;
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (!GetStoreTempLock(hcb, scp.Key, aStore))
												{
													lockFlag = false;
													break;
												}
											}
										}
										if (lockFlag == false)
										{
											break;
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (!GetStoreTempLock(hcb, scp.Key, aStore))
												{
													lockFlag = false;
													break;
												}
											}
										}
										if (lockFlag == false)
										{
											break;
										}
									}
									break;
								}
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color;   // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										foreach(HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
										{
											if (!GetStoreTempLock(hsb, aStore))
											{
												lockFlag = false;
											}
										}
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											if(!GetStoreTempLock(colorComponent.ColorRID, sizeComponent.SizeRID, aStore))
											{
												lockFlag = false;
											}
										}
										break;
									}
									// BEGIN MID Track #2412 Unknown Component
									case (eComponentType.SpecificSizePrimaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (!GetStoreTempLock(hcb, scp.Key, aStore))
												{
													lockFlag = false;
													break;
												}
											}
										}
										if (lockFlag == false)
										{
											break;
										}
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (!GetStoreTempLock(hcb, scp.Key, aStore))
												{
													lockFlag = false;
													break;
												}
											}
										}
										if (lockFlag == false)
										{
											break;
										}
										break;
									}
									// END MID Track #2412 Unknown Component
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					return lockFlag;
				}
				case (eComponentType.DetailType):
				{
					return GetStoreTempLock(eAllocationSummaryNode.DetailType, aStore);
				}
				case (eComponentType.GenericType):
				{
					return GetStoreTempLock(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetStoreTempLock(colorComponent.ColorRID, aStore);
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					lockFlag = true;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						if (hcb.SizeIsInColor(sizeComponent.SizeRID))
						{
							if (!GetStoreTempLock(hcb, sizeComponent.SizeRID, aStore))
							{
								lockFlag = false;
							}
						}
					}
					return lockFlag;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetStoreTempLock (packComponent.PackName, aStore);
				}
				case (eComponentType.Total):
				{
					return GetStoreTempLock (eAllocationSummaryNode.Total, aStore);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		public bool GetStoreTempLock(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
		{
			return GetStoreTempLock(aAllocationSummaryNode, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		internal bool GetStoreTempLock(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (!ap.GetStoreTempLock(aAllocationSummaryNode, aStore))
				{
					return false;
				}
			}
			return true;
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		public bool GetStoreTempLock(string aSubtotalPackName, int aStoreRID)
		{
			return GetStoreTempLock(aSubtotalPackName, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		internal bool GetStoreTempLock(string aSubtotalPackName, Index_RID aStore)
		{
			return GetStoreTempLock(GetSubtotalPackHdr(aSubtotalPackName), aStore);
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		internal bool GetStoreTempLock(PackHdr aSubtotalPack, Index_RID aStore)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aSubtotalPack.PackName))
				{
					if (!ap.GetStoreTempLock(aSubtotalPack.PackName, aStore))
					{
						return false;
					}
				}
			}
			return true;
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		public bool GetStoreTempLock(int aColorCodeRID, int aStoreRID)
		{
			return GetStoreTempLock(aColorCodeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		internal bool GetStoreTempLock(int aColorCodeRID, Index_RID aStore)
		{
			return GetStoreTempLock(this.GetSubtotalHdrColorBin(aColorCodeRID), aStore);
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		internal bool GetStoreTempLock(HdrColorBin aColor, Index_RID aStore)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					if (!ap.GetStoreTempLock(aColor.ColorCodeRID, aStore))
					{
						return false;
					}
				}
			}
			return true;
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		public bool GetStoreTempLock(int aColorCodeRID, int aSizeRID, int aStoreRID)
		{
			return GetStoreTempLock(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		internal bool GetStoreTempLock(int aColorCodeRID, int aSizeRID, Index_RID aStore)
		{
			return GetStoreTempLock(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		internal bool GetStoreTempLock(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
		{
			return GetStoreTempLock(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store TempLock; false otherwise.</returns>
		internal bool GetStoreTempLock(HdrSizeBin aSize, Index_RID aStore)
		{
			HdrColorBin hcb;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
				{
					hcb = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (hcb.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
					{
                        if (!ap.GetStoreTempLock(hcb, aSize.SizeCodeRID, aStore)) // Assortment: color/size changes
						{
							return false;
						}
					}
				}
			}
			return true;
		}
		#endregion GetStoreTempLock

		#region Set StoreTempLock
		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified node of a specified allocation profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the allocation component.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store is TempLock; false otherwise.</param>
		public void SetStoreTempLock(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, bool aFlagValue)
		{
			if (aAllocationProfile == null)
			{
				SetStoreTempLock(aComponent, StoreIndex(aStoreRID), aFlagValue);
			}
			else
			{
				aAllocationProfile.SetStoreTempLock(aComponent, StoreIndex(aStoreRID), aFlagValue);
			}
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aComponent">Description of the allocation component.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store is TempLock; false otherwise.</param>
		public void SetStoreTempLock(GeneralComponent aComponent, int aStoreRID, bool aFlagValue)
		{
			SetStoreTempLock(aComponent, StoreIndex(aStoreRID), aFlagValue);
		}

		/// <summary>
		/// Gets Store TempLock audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aComponent">Description of the allocation component.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store is TempLock; false otherwise.</param>
		internal void SetStoreTempLock(GeneralComponent aComponent, Index_RID aStore, bool aFlagValue)
		{
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					SetStoreTempLock(eAllocationSummaryNode.BulkColorTotal, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.AllGenericPacks):
				{
					SetStoreTempLock(eAllocationSummaryNode.GenericType, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.AllNonGenericPacks):
				{
					foreach (PackHdr ph in this.SubtotalPacks.Values)
					{
						if (!ph.GenericPack)
						{
							SetStoreTempLock(ph, aStore, aFlagValue, eDistributeChange.ToAll);
						}
					}
					break;
				}
				case (eComponentType.AllPacks):
				{
					foreach (PackHdr ph in SubtotalPacks.Values)
					{
						SetStoreTempLock(ph, aStore, aFlagValue, eDistributeChange.ToAll);
					}
					break;
				}
				case (eComponentType.AllSizes):
				{
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
						{
							SetStoreTempLock(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
						}
					}
					break;
				}
				case (eComponentType.Bulk):
				{
					SetStoreTempLock (eAllocationSummaryNode.Bulk, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.ColorAndSize):
				{
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											SetStoreTempLock(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										if (hcb.SizeIsInColor(sizeComponent.SizeRID))
										{
											SetStoreTempLock(hcb, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
										}
									}
									break;
								}
								// BEGIN MID Track #2412 Unknown Component
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{											
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												SetStoreTempLock(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{											
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												SetStoreTempLock(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}
									}
									break;
								}
								// END MID Track #2412 Unknown Component
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										foreach(HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
										{
											SetStoreTempLock(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
										}
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											SetStoreTempLock(colorComponent.ColorRID, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
										}
										break;
									}
									// BEGIN MID Track #2412 Unknown Component
									case (eComponentType.SpecificSizePrimaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);											
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												SetStoreTempLock(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);											
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												SetStoreTempLock(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}
										break;
									}
									// END MID Track #2412 Unknown Component
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					break;
				}
				case (eComponentType.DetailType):
				{
					SetStoreTempLock(eAllocationSummaryNode.DetailType, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.GenericType):
				{
					SetStoreTempLock(eAllocationSummaryNode.GenericType, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					SetStoreTempLock(colorComponent.ColorRID, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						if (hcb.SizeIsInColor(sizeComponent.SizeRID))
						{
							SetStoreTempLock(hcb, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
						}
					}
					break;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					SetStoreTempLock (packComponent.PackName, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.Total):
				{
					SetStoreTempLock (eAllocationSummaryNode.Total, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		public void SetStoreTempLock(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, bool aFlagValue)
		{
			SetStoreTempLock(aAllocationSummaryNode, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		internal void SetStoreTempLock(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore, 
			bool aFlagValue, eDistributeChange aDistributeChange)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				ap.SetStoreTempLock(aAllocationSummaryNode, aStore, aFlagValue, aDistributeChange);
			}
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		public void SetStoreTempLock(string aSubtotalPackName, int aStoreRID, bool aFlagValue)
		{
			SetStoreTempLock(aSubtotalPackName, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how to distrubute the change to parent and children nodes.</param>
		internal void SetStoreTempLock(string aSubtotalPackName, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			SetStoreTempLock(GetSubtotalPackHdr(aSubtotalPackName), aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how to reflect change in parent and children nodes</param>
		internal void SetStoreTempLock(PackHdr aSubtotalPack, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aSubtotalPack.PackName))
				{
					ap.SetStoreTempLock(aSubtotalPack.PackName, aStore, aFlagValue, aDistributeChange);
				}
			}
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		public void SetStoreTempLock(int aColorCodeRID, int aStoreRID, bool aFlagValue)
		{
			SetStoreTempLock(aColorCodeRID, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes.</param>
		internal void SetStoreTempLock(int aColorCodeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			SetStoreTempLock(this.GetSubtotalHdrColorBin(aColorCodeRID), aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
		internal void SetStoreTempLock(HdrColorBin aColor, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					ap.SetStoreTempLock(aColor.ColorCodeRID, aStore, aFlagValue, aDistributeChange);
				}
			}
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified color-size node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		public void SetStoreTempLock(int aColorCodeRID, int aSizeRID, int aStoreRID, bool aFlagValue)
		{
			SetStoreTempLock(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
		internal void SetStoreTempLock(int aColorCodeRID, int aSizeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			SetStoreTempLock(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be refleted in parent and children nodes</param>
		internal void SetStoreTempLock(HdrColorBin aColor, int aSizeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			SetStoreTempLock(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store TempLock audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes.</param>
		internal void SetStoreTempLock(HdrSizeBin aSize, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			HdrColorBin hcb;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
				{
					hcb = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (hcb.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
					{
                        ap.SetStoreTempLock(hcb, aSize.SizeCodeRID, aStore, aFlagValue, aDistributeChange); // Assortment: color/size changes
					}
				}
			}
		}
		#endregion SetStoreTempLock

        // begin TT#1401 - Urban Reservation Stores pt 2
        #region GetStoreItemTempLock
        /// <summary>
        /// Gets Store TempLock Audit Flag value for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>TempLock Flag Value for the store for the specified component.</returns>
        public bool GetStoreItemTempLock(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
        {
            if (aAllocationProfile == null)
            {
                return GetStoreItemTempLock(aComponent, StoreIndex(aStoreRID));
            }
            return GetStoreItemTempLock(aComponent, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store TempLock Audit Flag value for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>TempLock Flag Value for the store for the specified component.</returns>
        internal bool GetStoreItemTempLock(GeneralComponent aComponent, Index_RID aStore)
        {
            bool lockFlag;
            AllocationPackComponent packComponent;
            AllocationColorOrSizeComponent colorComponent;
            AllocationColorOrSizeComponent sizeComponent;
            switch (aComponent.ComponentType)
            {
                case (eComponentType.AllColors):
                    {
                        return GetStoreItemTempLock(eAllocationSummaryNode.BulkColorTotal, aStore);
                    }
                case (eComponentType.AllGenericPacks):
                    {
                        return GetStoreItemTempLock(eAllocationSummaryNode.GenericType, aStore);
                    }
                case (eComponentType.AllNonGenericPacks):
                    {
                        if (GetStoreItemTempLock(eAllocationSummaryNode.DetailType, aStore))
                        {
                            return GetStoreItemTempLock(eAllocationSummaryNode.DetailType, aStore);
                        }
                        lockFlag = true;
                        foreach (PackHdr ph in this.SubtotalPacks.Values)
                        {
                            if (!ph.GenericPack)
                            {
                                if (!GetStoreItemTempLock(ph, aStore))
                                {
                                    lockFlag = false;
                                }
                            }
                        }
                        return lockFlag;
                    }
                case (eComponentType.AllPacks):
                    {
                        lockFlag = true;
                        foreach (PackHdr ph in this.SubtotalPacks.Values)
                        {
                            if (!GetStoreItemTempLock(ph, aStore))
                            {
                                lockFlag = false;
                            }
                        }
                        return lockFlag;
                    }
                case (eComponentType.AllSizes):
                    {
                        lockFlag = true;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                            {
                                if (GetStoreItemTempLock(hsb, aStore))
                                {
                                    lockFlag = false;
                                }
                            }
                        }
                        return lockFlag;
                    }
                case (eComponentType.Bulk):
                    {
                        return GetStoreItemTempLock(eAllocationSummaryNode.Bulk, aStore);
                    }
                case (eComponentType.ColorAndSize):
                    {
                        lockFlag = true;
                        AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
                        GeneralComponent color = acs.ColorComponent;
                        GeneralComponent size = acs.SizeComponent;
                        switch (color.ComponentType)
                        {
                            case (eComponentType.AllColors):
                                {
                                    switch (size.ComponentType)
                                    {
                                        case (eComponentType.AllSizes):
                                            {
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                                                    {
                                                        if (!GetStoreItemTempLock(hsb, aStore))
                                                        {
                                                            lockFlag = false;
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSize):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size; 
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        if (!GetStoreItemTempLock(hcb, sizeComponent.SizeRID, aStore))
                                                        {
                                                            lockFlag = false;
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizePrimaryDim):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            if (!GetStoreItemTempLock(hcb, scp.Key, aStore))
                                                            {
                                                                lockFlag = false;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    if (lockFlag == false)
                                                    {
                                                        break;
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizeSecondaryDim):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            if (!GetStoreItemTempLock(hcb, scp.Key, aStore))
                                                            {
                                                                lockFlag = false;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    if (lockFlag == false)
                                                    {
                                                        break;
                                                    }
                                                }
                                                break;
                                            }
                                        default:
                                            {
                                                throw new MIDException(eErrorLevel.severe,
                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                            }
                                    }
                                    break;
                                }
                            case (eComponentType.SpecificColor):
                                {
                                    colorComponent = (AllocationColorOrSizeComponent)color;   
                                    if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
                                    {
                                        switch (size.ComponentType)
                                        {
                                            case (eComponentType.AllSizes):
                                                {
                                                    foreach (HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
                                                    {
                                                        if (!GetStoreItemTempLock(hsb, aStore))
                                                        {
                                                            lockFlag = false;
                                                        }
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSize):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size; 
                                                    if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        if (!GetStoreItemTempLock(colorComponent.ColorRID, sizeComponent.SizeRID, aStore))
                                                        {
                                                            lockFlag = false;
                                                        }
                                                    }
                                                    break;
                                                }
                                            // BEGIN MID Track #2412 Unknown Component
                                            case (eComponentType.SpecificSizePrimaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            if (!GetStoreItemTempLock(hcb, scp.Key, aStore))
                                                            {
                                                                lockFlag = false;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    if (lockFlag == false)
                                                    {
                                                        break;
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizeSecondaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            if (!GetStoreItemTempLock(hcb, scp.Key, aStore))
                                                            {
                                                                lockFlag = false;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    if (lockFlag == false)
                                                    {
                                                        break;
                                                    }
                                                    break;
                                                }
                                            default:
                                                {
                                                    throw new MIDException(eErrorLevel.severe,
                                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                                }
                                        }
                                    }
                                    break;
                                }
                            default:
                                {
                                    throw new MIDException(eErrorLevel.severe,
                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                }
                        }
                        return lockFlag;
                    }
                case (eComponentType.DetailType):
                    {
                        return GetStoreItemTempLock(eAllocationSummaryNode.DetailType, aStore);
                    }
                case (eComponentType.GenericType):
                    {
                        return GetStoreItemTempLock(eAllocationSummaryNode.GenericType, aStore);
                    }
                case (eComponentType.SpecificColor):
                    {
                        colorComponent = (AllocationColorOrSizeComponent)aComponent;
                        return GetStoreItemTempLock(colorComponent.ColorRID, aStore);
                    }
                case (eComponentType.SpecificSize):
                    {
                        sizeComponent = (AllocationColorOrSizeComponent)aComponent;
                        lockFlag = true;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                            {
                                if (!GetStoreItemTempLock(hcb, sizeComponent.SizeRID, aStore))
                                {
                                    lockFlag = false;
                                }
                            }
                        }
                        return lockFlag;
                    }
                case (eComponentType.SpecificPack):
                    {
                        packComponent = (AllocationPackComponent)aComponent;
                        return GetStoreItemTempLock(packComponent.PackName, aStore);
                    }
                case (eComponentType.Total):
                    {
                        return GetStoreItemTempLock(eAllocationSummaryNode.Total, aStore);
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                    }
            }
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        public bool GetStoreItemTempLock(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
        {
            return GetStoreItemTempLock(aAllocationSummaryNode, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        internal bool GetStoreItemTempLock(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
        {
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (!ap.GetStoreItemTempLock(aAllocationSummaryNode, aStore))
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        public bool GetStoreItemTempLock(string aSubtotalPackName, int aStoreRID)
        {
            return GetStoreItemTempLock(aSubtotalPackName, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        internal bool GetStoreItemTempLock(string aSubtotalPackName, Index_RID aStore)
        {
            return GetStoreItemTempLock(GetSubtotalPackHdr(aSubtotalPackName), aStore);
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPack">Pack header object where store resides.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        internal bool GetStoreItemTempLock(PackHdr aSubtotalPack, Index_RID aStore)
        {
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (ap.PackIsOnHeader(aSubtotalPack.PackName))
                {
                    if (!ap.GetStoreItemTempLock(aSubtotalPack.PackName, aStore))
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        public bool GetStoreItemTempLock(int aColorCodeRID, int aStoreRID)
        {
            return GetStoreItemTempLock(aColorCodeRID, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        internal bool GetStoreItemTempLock(int aColorCodeRID, Index_RID aStore)
        {
            return GetStoreItemTempLock(this.GetSubtotalHdrColorBin(aColorCodeRID), aStore);
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        internal bool GetStoreItemTempLock(HdrColorBin aColor, Index_RID aStore)
        {
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
                {
                    if (!ap.GetStoreItemTempLock(aColor.ColorCodeRID, aStore))
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        public bool GetStoreItemTempLock(int aColorCodeRID, int aSizeRID, int aStoreRID)
        {
            return GetStoreItemTempLock(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        internal bool GetStoreItemTempLock(int aColorCodeRID, int aSizeRID, Index_RID aStore)
        {
            return GetStoreItemTempLock(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        internal bool GetStoreItemTempLock(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
        {
            return GetStoreItemTempLock(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>True when store TempLock; false otherwise.</returns>
        internal bool GetStoreItemTempLock(HdrSizeBin aSize, Index_RID aStore)
        {
            HdrColorBin hcb;
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
                {
                    hcb = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (hcb.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
                    {
                        if (!ap.GetStoreItemTempLock(hcb, aSize.SizeCodeRID, aStore)) // Assortment: color/size changes
                        {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        #endregion GetStoreItemTempLock

        #region Set StoreItemTempLock
        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified node of a specified allocation profile.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aComponent">Description of the allocation component.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <param name="aFlagValue">True when store is TempLock; false otherwise.</param>
        public void SetStoreItemTempLock(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, bool aFlagValue)
        {
            if (aAllocationProfile == null)
            {
                SetStoreItemTempLock(aComponent, StoreIndex(aStoreRID), aFlagValue);
            }
            else
            {
                aAllocationProfile.SetStoreItemTempLock(aComponent, StoreIndex(aStoreRID), aFlagValue);
            }
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified node.
        /// </summary>
        /// <param name="aComponent">Description of the allocation component.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <param name="aFlagValue">True when store is TempLock; false otherwise.</param>
        public void SetStoreItemTempLock(GeneralComponent aComponent, int aStoreRID, bool aFlagValue)
        {
            SetStoreItemTempLock(aComponent, StoreIndex(aStoreRID), aFlagValue);
        }

        /// <summary>
        /// Gets Store TempLock audit flag for specified store on specified node.
        /// </summary>
        /// <param name="aComponent">Description of the allocation component.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <param name="aFlagValue">True when store is TempLock; false otherwise.</param>
        internal void SetStoreItemTempLock(GeneralComponent aComponent, Index_RID aStore, bool aFlagValue)
        {
            AllocationPackComponent packComponent;
            AllocationColorOrSizeComponent colorComponent;
            AllocationColorOrSizeComponent sizeComponent;
            switch (aComponent.ComponentType)
            {
                case (eComponentType.AllColors):
                    {
                        SetStoreItemTempLock(eAllocationSummaryNode.BulkColorTotal, aStore, aFlagValue, eDistributeChange.ToAll);
                        break;
                    }
                case (eComponentType.AllGenericPacks):
                    {
                        SetStoreItemTempLock(eAllocationSummaryNode.GenericType, aStore, aFlagValue, eDistributeChange.ToAll);
                        break;
                    }
                case (eComponentType.AllNonGenericPacks):
                    {
                        foreach (PackHdr ph in this.SubtotalPacks.Values)
                        {
                            if (!ph.GenericPack)
                            {
                                SetStoreItemTempLock(ph, aStore, aFlagValue, eDistributeChange.ToAll);
                            }
                        }
                        break;
                    }
                case (eComponentType.AllPacks):
                    {
                        foreach (PackHdr ph in SubtotalPacks.Values)
                        {
                            SetStoreItemTempLock(ph, aStore, aFlagValue, eDistributeChange.ToAll);
                        }
                        break;
                    }
                case (eComponentType.AllSizes):
                    {
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                            {
                                SetStoreItemTempLock(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
                            }
                        }
                        break;
                    }
                case (eComponentType.Bulk):
                    {
                        SetStoreItemTempLock(eAllocationSummaryNode.Bulk, aStore, aFlagValue, eDistributeChange.ToAll);
                        break;
                    }
                case (eComponentType.ColorAndSize):
                    {
                        AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
                        GeneralComponent color = acs.ColorComponent;
                        GeneralComponent size = acs.SizeComponent;
                        switch (color.ComponentType)
                        {
                            case (eComponentType.AllColors):
                                {
                                    switch (size.ComponentType)
                                    {
                                        case (eComponentType.AllSizes):
                                            {
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                                                    {
                                                        SetStoreItemTempLock(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSize):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        SetStoreItemTempLock(hcb, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizePrimaryDim):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            SetStoreItemTempLock(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizeSecondaryDim):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            SetStoreItemTempLock(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        default:
                                            {
                                                throw new MIDException(eErrorLevel.severe,
                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                            }
                                    }
                                    break;
                                }
                            case (eComponentType.SpecificColor):
                                {
                                    colorComponent = (AllocationColorOrSizeComponent)color;  
                                    if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
                                    {
                                        switch (size.ComponentType)
                                        {
                                            case (eComponentType.AllSizes):
                                                {
                                                    foreach (HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
                                                    {
                                                        SetStoreItemTempLock(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSize):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
                                                    if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        SetStoreItemTempLock(colorComponent.ColorRID, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizePrimaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            SetStoreItemTempLock(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
                                                        }
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizeSecondaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            SetStoreItemTempLock(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
                                                        }
                                                    }
                                                    break;
                                                }
                                            default:
                                                {
                                                    throw new MIDException(eErrorLevel.severe,
                                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                                }
                                        }
                                    }
                                    break;
                                }
                            default:
                                {
                                    throw new MIDException(eErrorLevel.severe,
                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                }
                        }
                        break;
                    }
                case (eComponentType.DetailType):
                    {
                        SetStoreItemTempLock(eAllocationSummaryNode.DetailType, aStore, aFlagValue, eDistributeChange.ToAll);
                        break;
                    }
                case (eComponentType.GenericType):
                    {
                        SetStoreItemTempLock(eAllocationSummaryNode.GenericType, aStore, aFlagValue, eDistributeChange.ToAll);
                        break;
                    }
                case (eComponentType.SpecificColor):
                    {
                        colorComponent = (AllocationColorOrSizeComponent)aComponent;
                        SetStoreItemTempLock(colorComponent.ColorRID, aStore, aFlagValue, eDistributeChange.ToAll);
                        break;
                    }
                case (eComponentType.SpecificSize):
                    {
                        sizeComponent = (AllocationColorOrSizeComponent)aComponent;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                            {
                                SetStoreItemTempLock(hcb, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
                            }
                        }
                        break;
                    }
                case (eComponentType.SpecificPack):
                    {
                        packComponent = (AllocationPackComponent)aComponent;
                        SetStoreItemTempLock(packComponent.PackName, aStore, aFlagValue, eDistributeChange.ToAll);
                        break;
                    }
                case (eComponentType.Total):
                    {
                        SetStoreItemTempLock(eAllocationSummaryNode.Total, aStore, aFlagValue, eDistributeChange.ToAll);
                        break;
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                    }
            }
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        public void SetStoreItemTempLock(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, bool aFlagValue)
        {
            SetStoreItemTempLock(aAllocationSummaryNode, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        internal void SetStoreItemTempLock(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore,
            bool aFlagValue, eDistributeChange aDistributeChange)
        {
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                ap.SetStoreItemTempLock(aAllocationSummaryNode, aStore, aFlagValue, aDistributeChange);
            }
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        public void SetStoreItemTempLock(string aSubtotalPackName, int aStoreRID, bool aFlagValue)
        {
            SetStoreItemTempLock(aSubtotalPackName, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        /// <param name="aDistributeChange">Indicates how to distrubute the change to parent and children nodes.</param>
        internal void SetStoreItemTempLock(string aSubtotalPackName, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
        {
            SetStoreItemTempLock(GetSubtotalPackHdr(aSubtotalPackName), aStore, aFlagValue, aDistributeChange);
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPack">Pack header object where store resides.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        /// <param name="aDistributeChange">Indicates how to reflect change in parent and children nodes</param>
        internal void SetStoreItemTempLock(PackHdr aSubtotalPack, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
        {
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (ap.PackIsOnHeader(aSubtotalPack.PackName))
                {
                    ap.SetStoreItemTempLock(aSubtotalPack.PackName, aStore, aFlagValue, aDistributeChange);
                }
            }
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        public void SetStoreItemTempLock(int aColorCodeRID, int aStoreRID, bool aFlagValue)
        {
            SetStoreItemTempLock(aColorCodeRID, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        /// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes.</param>
        internal void SetStoreItemTempLock(int aColorCodeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
        {
            SetStoreItemTempLock(this.GetSubtotalHdrColorBin(aColorCodeRID), aStore, aFlagValue, aDistributeChange);
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        /// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
        internal void SetStoreItemTempLock(HdrColorBin aColor, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
        {
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
                {
                    ap.SetStoreItemTempLock(aColor.ColorCodeRID, aStore, aFlagValue, aDistributeChange);
                }
            }
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified color-size node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        public void SetStoreItemTempLock(int aColorCodeRID, int aSizeRID, int aStoreRID, bool aFlagValue)
        {
            SetStoreItemTempLock(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        /// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
        internal void SetStoreItemTempLock(int aColorCodeRID, int aSizeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
        {
            SetStoreItemTempLock(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore, aFlagValue, aDistributeChange);
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        /// <param name="aDistributeChange">Indicates how the change should be refleted in parent and children nodes</param>
        internal void SetStoreItemTempLock(HdrColorBin aColor, int aSizeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
        {
            SetStoreItemTempLock(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore, aFlagValue, aDistributeChange);
        }

        /// <summary>
        /// Sets Store TempLock audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aFlagValue">True when store TempLock; false otherwise.</param>
        /// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes.</param>
        internal void SetStoreItemTempLock(HdrSizeBin aSize, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
        {
            HdrColorBin hcb;
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
                {
                    hcb = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (hcb.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
                    {
                        ap.SetStoreItemTempLock(hcb, aSize.SizeCodeRID, aStore, aFlagValue, aDistributeChange); // Assortment: color/size changes
                    }
                }
            }
        }
        #endregion SetStoreItemTempLock
        // end TT#1401 - Urban Reservation Stores pt 2
		#endregion StoreTempLock

		#region StoreOut
		//================//
		// Out Audit Flag //
		//================//
		#region GetStoreOut
		/// <summary>
		/// Gets Store Out Audit Flag value for specified store on specified component of a specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Out Flag Value for the store for the specified component.</returns>
		public bool GetStoreOut(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreOut(aComponent, StoreIndex(aStoreRID));
			}
			return aAllocationProfile.GetStoreOut(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Out Audit Flag value for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Out Flag Value for the store for the specified component.</returns>
		public bool GetStoreOut(GeneralComponent aComponent, int aStoreRID)
		{
			return GetStoreOut(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Out Audit Flag value for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Out Flag Value for the store for the specified component.</returns>
		internal bool GetStoreOut(GeneralComponent aComponent, Index_RID aStore)
		{
			bool lockFlag;
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetStoreOut(eAllocationSummaryNode.BulkColorTotal, aStore);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetStoreOut(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (GetStoreOut(eAllocationSummaryNode.DetailType, aStore))
					{
						return GetStoreOut(eAllocationSummaryNode.DetailType, aStore);
					}
					lockFlag = true;
					foreach (PackHdr ph in this.SubtotalPacks.Values)
					{
						if (!ph.GenericPack)
						{
							if (!GetStoreOut(ph, aStore))
							{
								lockFlag = false;
							}
						}
					}
					return lockFlag; 
				}
				case (eComponentType.AllPacks):
				{
					lockFlag = true;
					foreach (PackHdr ph in this.SubtotalPacks.Values)
					{
						if (!GetStoreOut(ph, aStore))
						{
							lockFlag = false;
						}
					}
					return lockFlag;
				}
				case (eComponentType.AllSizes):
				{
					lockFlag = true;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
						{
							if (GetStoreOut(hsb, aStore))
							{
								lockFlag = false;
							}
						}
					}
					return lockFlag;
				}
				case (eComponentType.Bulk):
				{
					return GetStoreOut (eAllocationSummaryNode.Bulk, aStore);
				}
				case (eComponentType.ColorAndSize):
				{
					lockFlag = true;
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											if (!GetStoreOut(hsb, aStore))
											{
												lockFlag = false;
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										if (hcb.SizeIsInColor(sizeComponent.SizeRID))
										{
											if (!GetStoreOut(hcb, sizeComponent.SizeRID, aStore))
											{
												lockFlag = false;
												break;
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (!GetStoreOut(hcb, scp.Key, aStore))
												{
													lockFlag = false;
													break;
												}
											}
										}
										if (lockFlag == false)
										{
											break;
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color 
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (!GetStoreOut(hcb, scp.Key, aStore))
												{
													lockFlag = false;
													break;
												}
											}
										}
										if (lockFlag == false)
										{
											break;
										}
									}
									break;
								}
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color 
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										foreach(HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
										{
											if (!GetStoreOut(hsb, aStore))
											{
												lockFlag = false;
											}
										}
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											if(!GetStoreOut(colorComponent.ColorRID, sizeComponent.SizeRID, aStore))
											{
												lockFlag = false;
											}
										}
										break;
									}
									// BEGIN MID Track #2412 Unknown Component
									case (eComponentType.SpecificSizePrimaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (!GetStoreOut(hcb, scp.Key, aStore))
												{
													lockFlag = false;
													break;
												}
											}
										}										
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (!GetStoreOut(hcb, scp.Key, aStore))
												{
													lockFlag = false;
													break;
												}
											}
										}										
										break;
									}
									// END MID Track #2412 Unknown Component
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					return lockFlag;
				}
				case (eComponentType.DetailType):
				{
					return GetStoreOut(eAllocationSummaryNode.DetailType, aStore);
				}
				case (eComponentType.GenericType):
				{
					return GetStoreOut(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetStoreOut(colorComponent.ColorRID, aStore);
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					lockFlag = true;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						if (hcb.SizeIsInColor(sizeComponent.SizeRID))
						{
							if (!GetStoreOut(hcb, sizeComponent.SizeRID, aStore))
							{
								lockFlag = false;
							}
						}
					}
					return lockFlag;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetStoreOut (packComponent.PackName, aStore);
				}
				case (eComponentType.Total):
				{
					return GetStoreOut (eAllocationSummaryNode.Total, aStore);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		public bool GetStoreOut(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
		{
			return GetStoreOut(aAllocationSummaryNode, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		internal bool GetStoreOut(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (!ap.GetStoreOut(aAllocationSummaryNode, aStore))
				{
					return false;
				}
			}
			return true;
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		public bool GetStoreOut(string aSubtotalPackName, int aStoreRID)
		{
			return GetStoreOut(aSubtotalPackName, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		internal bool GetStoreOut(string aSubtotalPackName, Index_RID aStore)
		{
			return GetStoreOut(GetSubtotalPackHdr(aSubtotalPackName), aStore);
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		internal bool GetStoreOut(PackHdr aSubtotalPack, Index_RID aStore)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aSubtotalPack.PackName))
				{
					if (!ap.GetStoreOut(aSubtotalPack.PackName, aStore))
					{
						return false;
					}
				}
			}
			return true;
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		public bool GetStoreOut(int aColorCodeRID, int aStoreRID)
		{
			return GetStoreOut(aColorCodeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		internal bool GetStoreOut(int aColorCodeRID, Index_RID aStore)
		{
			return GetStoreOut(this.GetSubtotalHdrColorBin(aColorCodeRID), aStore);
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		internal bool GetStoreOut(HdrColorBin aColor, Index_RID aStore)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					if (!ap.GetStoreOut(aColor.ColorCodeRID, aStore))
					{
						return false;
					}
				}
			}
			return true;
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		public bool GetStoreOut(int aColorCodeRID, int aSizeRID, int aStoreRID)
		{
			return GetStoreOut(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		internal bool GetStoreOut(int aColorCodeRID, int aSizeRID, Index_RID aStore)
		{
			return GetStoreOut(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		internal bool GetStoreOut(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
		{
			return GetStoreOut(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>True when store Out; false otherwise.</returns>
		internal bool GetStoreOut(HdrSizeBin aSize, Index_RID aStore)
		{
			HdrColorBin hcb;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
				{
					hcb = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (hcb.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
					{
                        if (!ap.GetStoreOut(hcb, aSize.SizeCodeRID, aStore)) // Assortment: color/size changes
						{
							return false;
						}
					}
				}
			}
			return true;
		}
		#endregion GetStoreOut

		#region SetStoreOut
		/// <summary>
		/// Sets Store Out audit flag for specified store on specified node of a specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the allocation component.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store is out; false otherwise.</param>
		public void SetStoreOut(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, bool aFlagValue)
		{
			if (aAllocationProfile == null)
			{
				SetStoreOut(aComponent, StoreIndex(aStoreRID), aFlagValue);
			}
			else
			{
				aAllocationProfile.SetStoreOut(aComponent, StoreIndex(aStoreRID), aFlagValue);
			}
		}


		/// <summary>
		/// Sets Store Out audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aComponent">Description of the allocation component.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store is out; false otherwise.</param>
		public void SetStoreOut(GeneralComponent aComponent, int aStoreRID, bool aFlagValue)
		{
			SetStoreOut(aComponent, StoreIndex(aStoreRID), aFlagValue);
		}

		/// <summary>
		/// Gets Store Out audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aComponent">Description of the allocation component.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store is out; false otherwise.</param>
		internal void SetStoreOut(GeneralComponent aComponent, Index_RID aStore, bool aFlagValue)
		{
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					SetStoreOut(eAllocationSummaryNode.BulkColorTotal, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.AllGenericPacks):
				{
					SetStoreOut(eAllocationSummaryNode.GenericType, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.AllNonGenericPacks):
				{
					foreach (PackHdr ph in this.SubtotalPacks.Values)
					{
						if (!ph.GenericPack)
						{
							SetStoreOut(ph, aStore, aFlagValue, eDistributeChange.ToAll);
						}
					}
					break;
				}
				case (eComponentType.AllPacks):
				{
					foreach (PackHdr ph in SubtotalPacks.Values)
					{
						SetStoreOut(ph, aStore, aFlagValue, eDistributeChange.ToAll);
					}
					break;
				}
				case (eComponentType.AllSizes):
				{
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
						{
							SetStoreOut(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
						}
					}
					break;
				}
				case (eComponentType.Bulk):
				{
					SetStoreOut (eAllocationSummaryNode.Bulk, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.ColorAndSize):
				{
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (HdrColorBin hcb in this.BulkColors.Values)
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											SetStoreOut(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color 
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										if (hcb.SizeIsInColor(sizeComponent.SizeRID))
										{
											SetStoreOut(hcb, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
										}
									}
									break;
								}
								// BEGIN MID Track #2412 Unknown Component
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												SetStoreOut(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												SetStoreOut(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}
									}
									break;
								}
								// END MID Track #2412 Unknown Component
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										foreach(HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
										{
											SetStoreOut(hsb, aStore, aFlagValue, eDistributeChange.ToAll);
										}
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											SetStoreOut(colorComponent.ColorRID, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
										}
										break;
									}
									// BEGIN MID Track #2412 Unknown Component
									case (eComponentType.SpecificSizePrimaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												SetStoreOut(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												SetStoreOut(hcb, scp.Key, aStore, aFlagValue, eDistributeChange.ToAll);
											}
										}
										break;
									}
									// END MID Track #2412 Unknown Component
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					break;
				}
				case (eComponentType.DetailType):
				{
					SetStoreOut(eAllocationSummaryNode.DetailType, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.GenericType):
				{
					SetStoreOut(eAllocationSummaryNode.GenericType, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					SetStoreOut(colorComponent.ColorRID, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						if (hcb.SizeIsInColor(sizeComponent.SizeRID))
						{
							SetStoreOut(hcb, sizeComponent.SizeRID, aStore, aFlagValue, eDistributeChange.ToAll);
						}
					}
					break;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					SetStoreOut (packComponent.PackName, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				case (eComponentType.Total):
				{
					SetStoreOut (eAllocationSummaryNode.Total, aStore, aFlagValue, eDistributeChange.ToAll);
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		public void SetStoreOut(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, bool aFlagValue)
		{
			SetStoreOut(aAllocationSummaryNode, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		internal void SetStoreOut(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore, 
			bool aFlagValue, eDistributeChange aDistributeChange)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				ap.SetStoreOut(aAllocationSummaryNode, aStore, aFlagValue, aDistributeChange);
			}
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		public void SetStoreOut(string aSubtotalPackName, int aStoreRID, bool aFlagValue)
		{
			SetStoreOut(aSubtotalPackName, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how to distrubute the change to parent and children nodes.</param>
		internal void SetStoreOut(string aSubtotalPackName, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			SetStoreOut(GetSubtotalPackHdr(aSubtotalPackName), aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how to reflect change in parent and children nodes</param>
		internal void SetStoreOut(PackHdr aSubtotalPack, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aSubtotalPack.PackName))
				{
					ap.SetStoreOut(aSubtotalPack.PackName, aStore, aFlagValue, aDistributeChange);
				}
			}
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		public void SetStoreOut(int aColorCodeRID, int aStoreRID, bool aFlagValue)
		{
			SetStoreOut(aColorCodeRID, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes.</param>
		internal void SetStoreOut(int aColorCodeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			SetStoreOut(this.GetSubtotalHdrColorBin(aColorCodeRID), aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
		internal void SetStoreOut(HdrColorBin aColor, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					ap.SetStoreOut(aColor.ColorCodeRID, aStore, aFlagValue, aDistributeChange);
				}
			}
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified color-size node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		public void SetStoreOut(int aColorCodeRID, int aSizeRID, int aStoreRID, bool aFlagValue)
		{
			SetStoreOut(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aFlagValue, eDistributeChange.ToAll);
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
		internal void SetStoreOut(int aColorCodeRID, int aSizeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			SetStoreOut(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be refleted in parent and children nodes</param>
		internal void SetStoreOut(HdrColorBin aColor, int aSizeRID, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			SetStoreOut(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore, aFlagValue, aDistributeChange);
		}

		/// <summary>
		/// Sets Store Out audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aFlagValue">True when store Out; false otherwise.</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes.</param>
		internal void SetStoreOut(HdrSizeBin aSize, Index_RID aStore, bool aFlagValue, eDistributeChange aDistributeChange)
		{
			HdrColorBin hcb;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
				{
					hcb = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (hcb.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
					{
                        ap.SetStoreOut(hcb, aSize.SizeCodeRID, aStore, aFlagValue, aDistributeChange); // Assortment: color/size changes
					}
				}
			}
		}
		#endregion SetStoreOut
		#endregion StoreOut

		#region StoreOrigQtyAllocated
		#region GetStoreOrigQtyAllocated
		//=============================//
		// Original Quantity Allocated //
		//=============================//
		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified component of a specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Original Quantity Allocated to the store for the specified component.</returns>
		public int GetStoreOrigQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreOrigQtyAllocated(aComponent, StoreIndex(aStoreRID));
			}
			else
			{
				return aAllocationProfile.GetStoreOrigQtyAllocated(aComponent, StoreIndex(aStoreRID));
			}
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Original Quantity Allocated to the store for the specified component.</returns>
		public int GetStoreOrigQtyAllocated(GeneralComponent aComponent, int aStoreRID)
		{
			return GetStoreOrigQtyAllocated(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Original Quantity Allocated to the store for the specified component.</returns>
		internal int GetStoreOrigQtyAllocated(GeneralComponent aComponent, Index_RID aStore)
		{
			int allocated = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				allocated += ap.GetStoreOrigQtyAllocated(aComponent, aStore);
			}
			return allocated;
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		public int GetStoreOrigQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
		{
			return GetStoreOrigQtyAllocated(aAllocationSummaryNode, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreOrigQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
		{
			int allocated = 0;
			foreach(AllocationProfile ap in this.SubtotalMembers)
			{
				allocated += ap.GetStoreOrigQtyAllocated(aAllocationSummaryNode, aStore);
			}
			return allocated;
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		public int GetStoreOrigQtyAllocated(string aPackName, int aStoreRID)
		{
			return GetStoreOrigQtyAllocated(aPackName, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreOrigQtyAllocated(string aPackName, Index_RID aStore)
		{
			return GetStoreOrigQtyAllocated(GetSubtotalPackHdr(aPackName), aStore);
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreOrigQtyAllocated(PackHdr aPack, Index_RID aStore)
		{
			int allocated = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aPack.PackName))
				{
					allocated += ap.GetStoreOrigQtyAllocated(aPack.PackName, aStore);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		public int GetStoreOrigQtyAllocated(int aColorRID, int aStoreRID)
		{
			return GetStoreOrigQtyAllocated(aColorRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreOrigQtyAllocated(int aColorRID, Index_RID aStore)
		{
			return GetStoreOrigQtyAllocated(GetSubtotalHdrColorBin(aColorRID), aStore);
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreOrigQtyAllocated(HdrColorBin aColor, Index_RID aStore)
		{
			int allocated = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					allocated += ap.GetStoreOrigQtyAllocated(aColor.ColorCodeRID, aStore);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		public int GetStoreOrigQtyAllocated(int aColorRID, int aSizeRID, int aStoreRID)
		{
			return GetStoreOrigQtyAllocated(aColorRID, aSizeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreOrigQtyAllocated(int aColorRID, int aSizeRID, Index_RID aStore)
		{
			return GetStoreOrigQtyAllocated(GetSubtotalHdrColorBin(aColorRID), aSizeRID, aStore);
		}

		/// <summary>
		/// Gets Store Original Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Original Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreOrigQtyAllocated(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
		{
			int allocated = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					HdrColorBin color = ap.GetHdrColorBin(aColor.ColorCodeRID);
					if (color.SizeIsInColor(aSizeRID))
					{
						allocated += ap.GetStoreOrigQtyAllocated(color.GetSizeBin(aSizeRID), aStore);
					}
				}
			}
			return allocated;
		}
		#endregion GetStoreOrigQtyAllocated
		#endregion StoreOrigQtyAllocated
		
		#region StoreQuantityAllocated
		#region GetStoreQtyAllocated
		//====================//
		// Quantity Allocated //
		//====================//
		/// <summary>
		/// Gets Store Subtotal Quantity Allocated for specified store on specified component of the specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Allocated to the store for the specified component.</returns>
		public int GetStoreQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreQtyAllocated(aComponent, StoreIndex(aStoreRID));
			}
			if (aComponent.ComponentType == eComponentType.SpecificPack)
			{
				AllocationPackComponent apc = (AllocationPackComponent)aComponent;
				if (!aAllocationProfile.PackIsOnHeader(apc.PackName))
				{
					return 0;
				}
			}
			if (aComponent.ComponentType == eComponentType.SpecificColor)
			{
				AllocationColorOrSizeComponent acsc = (AllocationColorOrSizeComponent)aComponent;
				if (!aAllocationProfile.BulkColorIsOnHeader(acsc.ColorRID))
				{
					return 0;
				}
			}
			return aAllocationProfile.GetStoreQtyAllocated(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Subtotal Quantity Allocated for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Allocated to the store for the specified component.</returns>
		public int GetStoreQtyAllocated(GeneralComponent aComponent, int aStoreRID)
		{
			return GetStoreQtyAllocated(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Subtotal Quantity Allocated for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Allocated to the store for the specified component.</returns>
		internal int GetStoreQtyAllocated(GeneralComponent aComponent, Index_RID aStore)
		{
			int allocated;
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetStoreQtyAllocated(eAllocationSummaryNode.BulkColorTotal, aStore);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							(GetStoreQtyAllocated (eAllocationSummaryNode.DetailSubType, aStore)
							- GetStoreQtyAllocated (eAllocationSummaryNode.Bulk, aStore));
					}
					return GetStoreQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore);
				}
				case (eComponentType.AllPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							GetStoreQtyAllocated (eAllocationSummaryNode.GenericType, aStore)
							+ GetStoreQtyAllocated (eAllocationSummaryNode.DetailSubType, aStore)
							- GetStoreQtyAllocated (eAllocationSummaryNode.Bulk, aStore);
					}
					return
						GetStoreQtyAllocated (eAllocationSummaryNode.GenericType, aStore)
						+ GetStoreQtyAllocated (eAllocationSummaryNode.DetailSubType, aStore);
				}
				case (eComponentType.AllSizes):
				{
					allocated = 0;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
						{
							allocated += this.GetStoreQtyAllocated(hsb, aStore);
						}
					}
					return allocated;
				}
				case (eComponentType.Bulk):
				{
					return GetStoreQtyAllocated (eAllocationSummaryNode.Bulk, aStore);
				}
				case (eComponentType.ColorAndSize):
				{
					allocated = 0;
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											allocated += GetStoreQtyAllocated(hsb, aStore);
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										if (hcb.SizeIsInColor(sizeComponent.SizeRID))
										{
											allocated += GetStoreQtyAllocated(hcb, sizeComponent.SizeRID, aStore);
										}
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												allocated += GetStoreQtyAllocated(hcb, scp.Key, aStore);
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												allocated += GetStoreQtyAllocated(hcb, scp.Key, aStore);
											}
										}
									}
									break;
								}
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color;
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										foreach(HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
										{
											allocated += GetStoreQtyAllocated(hsb, aStore);
										}
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											allocated += GetStoreQtyAllocated(colorComponent.ColorRID, sizeComponent.SizeRID, aStore);
										}
										break;
									}
									// BEGIN MID Track #2412 Unknown Component
									case (eComponentType.SpecificSizePrimaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach(SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												allocated += GetStoreQtyAllocated(hcb, scp.Key,aStore);
											}
										}
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach(SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												allocated += GetStoreQtyAllocated(hcb, scp.Key,aStore);
											}
										}
										break;
									}
									// END MID Track #2412 Unknown Component
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					return allocated;
				}
				case (eComponentType.DetailType):
				{
					return GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, aStore);
				}
				case (eComponentType.GenericType):
				{
					return GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetStoreQtyAllocated(colorComponent.ColorRID, aStore);
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					allocated = 0;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						if (hcb.SizeIsInColor(sizeComponent.SizeRID))
						{
							allocated += GetStoreQtyAllocated(hcb, sizeComponent.SizeRID, aStore);
						}
					}
					return allocated;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetStoreQtyAllocated (packComponent.PackName, aStore);
				}
				case (eComponentType.Total):
				{
					return GetStoreQtyAllocated (eAllocationSummaryNode.Total, aStore);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		public int GetStoreQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
		{
			return GetStoreQtyAllocated(aAllocationSummaryNode, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			switch (aAllocationSummaryNode)
			{
				case (eAllocationSummaryNode.Total):
				{
					return _subtotalTotal[aStore.Index].QtyAllocated;
				}
				case (eAllocationSummaryNode.Type):
				{
					return (_subtotalGenericType[aStore.Index].QtyAllocated
						+ _subtotalDetailType[aStore.Index].QtyAllocated);
				}
				case(eAllocationSummaryNode.GenericType):
				{
					return _subtotalGenericType[aStore.Index].QtyAllocated;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					return _subtotalDetailType[aStore.Index].QtyAllocated;
				}
				case(eAllocationSummaryNode.DetailSubType):
				{
					if (BulkIsDetail)
					{
						return (_subtotalTotalNonGenericUnitsAllocated[aStore.Index]
							+ _subtotalBulk[aStore.Index].QtyAllocated);
					}
					else
					{
						return _subtotalTotalNonGenericUnitsAllocated[aStore.Index];
					}
				}
				case(eAllocationSummaryNode.Bulk):
				{
					return _subtotalBulk[aStore.Index].QtyAllocated;
				}
				case(eAllocationSummaryNode.BulkColorTotal):
				{
                    // Begin MID Track 3326 Cannot manually key size qty when no secondary dimension
					// return _subtotalBulkColorTotalUnitsAllocated[aStore.Index]; 
					int colorUnits = 0;
					foreach (HdrColorBin hcb in this.BulkColors.Values)
					{
						colorUnits += this.GetStoreQtyAllocated(hcb, aStore);
					}
					return colorUnits;
					// End MID Track 3326 Cannot manually key size qty when no secondary dimension
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		public int GetStoreQtyAllocated(string aSubtotalPackName, int aStoreRID)
		{
			return GetStoreQtyAllocated(aSubtotalPackName, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreQtyAllocated(string aSubtotalPackName, Index_RID aStore)
		{
			return GetStoreQtyAllocated(GetSubtotalPackHdr(aSubtotalPackName), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore)
		{
			return aSubtotalPack.GetStorePacksAllocated(aStore.Index);
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		public int GetStoreQtyAllocated(int aColorCodeRID, int aStoreRID)
		{
			return GetStoreQtyAllocated(aColorCodeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreQtyAllocated(int aColorCodeRID, Index_RID aStore)
		{
			return GetStoreQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreQtyAllocated(HdrColorBin aColor, Index_RID aStore)
		{
			return aColor.GetStoreUnitsAllocated(aStore.Index);
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		public int GetStoreQtyAllocated(int aColorCodeRID, int aSizeRID, int aStoreRID)
		{
			return GetStoreQtyAllocated(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreQtyAllocated(int aColorCodeRID, int aSizeRID, Index_RID aStore)
		{
			return GetStoreQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreQtyAllocated(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
		{
			return GetStoreQtyAllocated(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Allocated to the store for the specified node.</returns>
		internal int GetStoreQtyAllocated(HdrSizeBin aSize, Index_RID aStore)
		{
			return aSize.GetStoreSizeUnitsAllocated(aStore.Index);
		}
		#endregion GetStoreQtyAllocated

		#region SetStoreQtyAllocated
		/// <summary>
		/// Sets Store Subtotal Quantity Allocated for specified store on specified component of the specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <returns>True when update successful; False otherwise</returns>
		/// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
		public bool SetStoreQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, int aQtyAllocated)
		{
			if (aAllocationProfile == null)
			{
				return SetStoreQtyAllocated(aComponent, aStoreRID, aQtyAllocated);
			}
			if (aAllocationProfile.SetStoreQtyAllocated(aComponent, aStoreRID, aQtyAllocated) == eAllocationUpdateStatus.Successful)
			{
				return true;
			}
			return false;
		}


		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <returns>True when update successful; False otherwise</returns>
		/// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
		public bool SetStoreQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, int aQtyAllocated)
		{
			Index_RID storeIndexRID = StoreIndex(aStoreRID);
			return SetStoreQtyAllocated(aAllocationSummaryNode, storeIndexRID, aQtyAllocated, 
				eDistributeChange.ToAll, true);
		}

		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
		/// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
		/// <returns>True when update is successful; false otherwise.</returns>
		internal bool SetStoreQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, 
			Index_RID aStore, int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
		{
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
            //return SetStoreQtyAllocated(
            //    aAllocationSummaryNode,
            //    aStore,
            //    aQtyAllocated,
            //    aDistributeChange,
            //    aIsManual,
            //    false);
        //}

        ///// <summary>
        ///// Sets Store Quantity Allocated for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aQtyAllocated">Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        ///// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        ///// <param name="aAddNewMember">True indicates quantity resulted from adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //private bool SetStoreQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, 
        //    Index_RID aStore, int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
		// end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
			GeneralComponent gc;
			switch (aAllocationSummaryNode)
			{
				case(eAllocationSummaryNode.Bulk):
				{
					gc = new GeneralComponent(eGeneralComponentType.Bulk);
					break;
				}
				case(eAllocationSummaryNode.BulkColorTotal):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_QtyAloctdBulkColorTotalSummaryReadOnly),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdBulkColorTotalSummaryReadOnly));
				}
				case(eAllocationSummaryNode.DetailSubType):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_QtyAloctdDetailSubTypeSummaryReadOnly),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdDetailSubTypeSummaryReadOnly));
				}
				case(eAllocationSummaryNode.DetailType):
				{
					gc = new GeneralComponent(eGeneralComponentType.DetailType);
					break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					gc = new GeneralComponent(eGeneralComponentType.GenericType);
					break;
				}
				case(eAllocationSummaryNode.Total):
				{
					gc = new GeneralComponent(eGeneralComponentType.Total);
					break;
				}
				case(eAllocationSummaryNode.Type):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_QtyAloctdTypeSummaryReadOnly),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdTypeSummaryReadOnly));
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
            return SetStoreQtyAllocated(gc, aStore, aQtyAllocated, aDistributeChange, aIsManual);  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
            //return SetStoreQtyAllocated(gc, aStore, aQtyAllocated, aDistributeChange, aIsManual, aAddNewMember); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
		}

		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified node.
		/// </summary>
		/// <param name="aGeneralComponent">Allocation summary node.</param>
		/// <param name="aStoreRID">Index_RID for store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <returns>True when update is successful; false otherwise.</returns>
		/// <remarks>Values entered via this instance of the method are assumed to be manually keyed.</remarks>
		public bool SetStoreQtyAllocated(GeneralComponent aGeneralComponent, 
			int aStoreRID, int aQtyAllocated)
		{
			if (aGeneralComponent.ComponentType == eComponentType.ColorAndSize)
			{
				return SetStoreQtyAllocated(
					aGeneralComponent, 
					StoreIndex(aStoreRID), 
					aQtyAllocated, 
					eDistributeChange.ToNone, 
					true);
			}
			else if (aGeneralComponent.ComponentType == eComponentType.SpecificColor // MID Track 3326 Cannot manually key size qty when no secondary dimension 
				|| aGeneralComponent.ComponentType == eComponentType.AllColors)      // MID Track 3326 Cannot manually key size qty when no secondary dimension
			{
				return SetStoreQtyAllocated(
					aGeneralComponent, 
					StoreIndex(aStoreRID), 
					aQtyAllocated, 
					eDistributeChange.ToParent, 
					true);
			}
			return SetStoreQtyAllocated(
				aGeneralComponent, 
				StoreIndex(aStoreRID), 
				aQtyAllocated, 
				eDistributeChange.ToAll, 
				true);
		}

		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified node.
		/// </summary>
		/// <param name="aGeneralComponent">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
		/// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
		/// <returns>True when update is successful; false otherwise</returns>
		internal bool SetStoreQtyAllocated(GeneralComponent aGeneralComponent, 
			Index_RID aStore, int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
		{
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
        //    return SetStoreQtyAllocated(
        //        aGeneralComponent,
        //        aStore,
        //        aQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}
		
        ///// <summary>
        ///// Sets Store Quantity Allocated for specified store on specified node.
        ///// </summary>
        ///// <param name="aGeneralComponent">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aQtyAllocated">Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        ///// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        ///// <param name="aAddNewMember">True indicates a new allocation profile is being added to the subtotal, false indicates otherwise.</param>
        ///// <returns>True when update is successful; false otherwise</returns>
        //private bool SetStoreQtyAllocated(GeneralComponent aGeneralComponent, 
        //    Index_RID aStore, int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
			bool success = true;
			if (aDistributeChange == eDistributeChange.ToNone)
			{
				AllocationColorOrSizeComponent color;
				AllocationColorOrSizeComponent size;
				switch (aGeneralComponent.ComponentType)
				{
					case(eComponentType.AllColors):
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_al_AllColorAllocatedReadOnly,
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllColorAllocatedReadOnly));
					}
					case(eComponentType.AllGenericPacks):
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_al_AllGenericPacksAllocatedReadOnly,
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllGenericPacksAllocatedReadOnly));
					}
					case(eComponentType.AllNonGenericPacks):
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_al_AllNonGenericPacksAllocatedReadOnly,
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllNonGenericPacksAllocatedReadOnly));
					}
					case(eComponentType.AllPacks):
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_al_AllPacksAllocatedReadOnly,
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllPacksAllocatedReadOnly));
					}
					case(eComponentType.AllSizes):
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_al_AllSizesAllocatedReadOnly,
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizesAllocatedReadOnly));
					}
					case(eComponentType.Bulk):
					{
                        //if (!aAddNewMember   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F 
                        if (!BuildingSubtotals  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                            && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
							&& aQtyAllocated < this.GetStoreQtyLocked(eAllocationSummaryNode.Bulk, aStore))
						{
							success = false;
						}
						else
						{
							this._subtotalBulk[aStore.Index].QtyAllocated = aQtyAllocated;
						}
						break;
					}
					case(eComponentType.ColorAndSize):
					{
						AllocationColorSizeComponent colorSize = (AllocationColorSizeComponent)aGeneralComponent;
						switch (colorSize.ColorComponent.ComponentType)
						{
							case (eComponentType.AllColors):
							{
								// Begin MID Track 3326 Cannot manually key size qty when no secondary dimension
								//throw new MIDException(eErrorLevel.warning,
								//	(int)eMIDTextCode.msg_al_AllColorAllocatedReadOnly,
								//	_session.Audit.GetText(eMIDTextCode.msg_al_AllColorAllocatedReadOnly));
								
								return SpreadStoreAllColorSizeToColorSize(colorSize.SizeComponent, aStore, aQtyAllocated, aDistributeChange, aIsManual);
								// End MID Track 3326 Cannot manually key size qty when no secondary dimension
							}
							case (eComponentType.SpecificColor):
							{
								color = (AllocationColorOrSizeComponent)colorSize.ColorComponent;
								if (this.BulkColorIsOnSubtotal(color.ColorRID))
								{
									switch (colorSize.SizeComponent.ComponentType)
									{
										case (eComponentType.AllSizes):
										{
											throw new MIDException(eErrorLevel.warning,
												(int)eMIDTextCode.msg_al_AllSizesAllocatedReadOnly,
												this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizesAllocatedReadOnly));
										}
										case (eComponentType.SpecificSize):
										{
											size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
											if (this.GetSubtotalHdrColorBin(color.ColorRID).SizeIsInColor(size.SizeRID))
											{
												return SetStoreQtyAllocated(
													color.ColorRID,
													size.SizeRID,
													aStore,
													aQtyAllocated,
													aDistributeChange,
													aIsManual);
											}
											return false;
										}
										case (eComponentType.SpecificSizePrimaryDim):
										{
											size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
											SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(size.PrimarySizeDimRID);
											return SpreadStoreQtyAcrossSizes(color.ColorRID, scl, aStore, aQtyAllocated);
										}
										case (eComponentType.SpecificSizeSecondaryDim):
										{
											size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
											SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(size.SecondarySizeDimRID);
											return SpreadStoreQtyAcrossSizes(color.ColorRID, scl, aStore, aQtyAllocated);
										}
										default:
										{
											throw new MIDException(eErrorLevel.severe,
												(int)(eMIDTextCode.msg_al_UnknownComponentType),
												this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
										}
									}

								}
								return false;
							}
							default:
							{
								throw new MIDException(eErrorLevel.severe,
									(int)(eMIDTextCode.msg_al_UnknownComponentType),
									this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
							}
						}
					}
					case(eComponentType.DetailType):
					{
                        //if (!aAddNewMember  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                        if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                            && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
							&& aQtyAllocated < this.GetStoreQtyLocked(eAllocationSummaryNode.DetailType, aStore))
						{
							success = false;
						}
						else
						{
							this._subtotalDetailType[aStore.Index].QtyAllocated = aQtyAllocated;
						}
						break;
					}
					case(eComponentType.GenericType):
					{
                        //if (!aAddNewMember  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                        if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                            && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                            && aQtyAllocated < this.GetStoreQtyLocked(eAllocationSummaryNode.GenericType, aStore))
						{
							success = false;
						}
						else
						{
							this._subtotalGenericType[aStore.Index].QtyAllocated = aQtyAllocated;
						}
						break;
					}
					case(eComponentType.SpecificColor):
					{
						color = (AllocationColorOrSizeComponent)aGeneralComponent;
                        success = SetStoreQtyAllocated(this.GetSubtotalHdrColorBin(color.ColorRID), aStore, aQtyAllocated, aDistributeChange, aIsManual); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                        //success = SetStoreQtyAllocated(this.GetSubtotalHdrColorBin(color.ColorRID), aStore, aQtyAllocated, aDistributeChange, aIsManual, aAddNewMember); // TT#1401 - JEllis - Urban Virtual Store warehouse pt 28F
						break;
					}
					case(eComponentType.SpecificPack):
					{
						AllocationPackComponent pack = (AllocationPackComponent)aGeneralComponent;
                        success = SetStoreQtyAllocated(this.GetSubtotalPackHdr(pack.PackName), aStore, aQtyAllocated, aDistributeChange, aIsManual);  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                        //success = SetStoreQtyAllocated(this.GetSubtotalPackHdr(pack.PackName), aStore, aQtyAllocated, aDistributeChange, aIsManual, aAddNewMember); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
						break;
					}
					case(eComponentType.SpecificSize):
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize,
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize));
					}
					case(eComponentType.Total):
					{
                        //if (!aAddNewMember  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                        if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                            && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                            && aQtyAllocated < this.GetStoreQtyLocked(eAllocationSummaryNode.Total, aStore))
						{
							success = false;
						}
						else
						{
							this._subtotalTotal[aStore.Index].QtyAllocated = aQtyAllocated;
						}
						break;
					}
					default:
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_al_UnknownComponentType,
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
					}
				}
			}
			else
			{
				success = SpreadStoreSubtotalToHeaders(
					aGeneralComponent,
					aStore,
					aQtyAllocated,
					aDistributeChange,
					aIsManual);
			}
			return success;
		}
		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aQtyAllocated">Quantity Allocated.</param>
		/// <returns>True when update is successful; false otherwise</returns>
		/// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
		public bool SetStoreQtyAllocated(string aSubtotalPackName, int aStoreRID, int aQtyAllocated)
		{
			return SetStoreQtyAllocated(aSubtotalPackName, StoreIndex(aStoreRID), aQtyAllocated, eDistributeChange.ToAll, true);
		}

		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
		/// <param name="aIsManual">True: Indicates this is a manually keyed value.</param> 
		/// <returns>True when update is successful; false otherwise.</returns>
		internal bool SetStoreQtyAllocated(string aSubtotalPackName, Index_RID aStore, int aQtyAllocated, 
			eDistributeChange aDistributeChange, bool aIsManual)
		{
			return SetStoreQtyAllocated(GetSubtotalPackHdr(aSubtotalPackName), aStore, aQtyAllocated, aDistributeChange, aIsManual);
		}

		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aQtyAllocated">Quantity Allocated.</param>
		/// <param name="aDistributeChange">Indicates how to apply the new value to the parent and/or children components of this component.</param>
		/// <param name="aIsManual">True: indicates this is a manually keyed value.</param>
		/// <returns>True when update is successful; false otherwise.</returns>
		internal bool SetStoreQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore, 
			int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
		{
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
        //    return SetStoreQtyAllocated(
        //        aSubtotalPack,
        //        aStore,
        //        aQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Quantity Allocated for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aQtyAllocated">Quantity Allocated.</param>
        ///// <param name="aDistributeChange">Indicates how to apply the new value to the parent and/or children components of this component.</param>
        ///// <param name="aIsManual">True: indicates this is a manually keyed value.</param>
        ///// <param name="aAddNewMember">True: indicates quantity is result of adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //private bool SetStoreQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore, 
        //    int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
			bool success = true;
			if (aDistributeChange == eDistributeChange.ToNone)
			{
                //if (!aAddNewMember  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                    && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                    && aQtyAllocated < this.GetStoreQtyLocked(aSubtotalPack, aStore))
				{
					success = false;
				}
				else
				{
					if (aSubtotalPack.GenericPack)
					{
						this._subtotalGenericType[aStore.Index].QtyAllocated -=
							aSubtotalPack.GetStorePacksAllocated(aStore.Index)
							* aSubtotalPack.PackMultiple;
						//						this._genericTotal.SetQtyAllocated
						//							(this.GenericTypeUnitsAllocated 
						//							- aSubtotalPack.GetStorePacksAllocated(aStore.Index) * aSubtotalPack.PackMultiple);
					}
					else
					{
						this._subtotalTotalNonGenericUnitsAllocated[aStore.Index] -=
							aSubtotalPack.GetStorePacksAllocated(aStore.Index)
							* aSubtotalPack.PackMultiple;
					}
					aSubtotalPack.SetStorePacksAllocated(aStore.Index, aQtyAllocated);
					if (aSubtotalPack.GenericPack)
					{
						this._subtotalGenericType[aStore.Index].QtyAllocated +=
							aSubtotalPack.GetStorePacksAllocated(aStore.Index)
							* aSubtotalPack.PackMultiple;
						//						this._genericTotal.SetQtyAllocated
						//							(this.GenericTypeUnitsAllocated 
						//							+ aSubtotalPack.GetStorePacksAllocated(aStore.Index) * aSubtotalPack.PackMultiple);
					}
					else
					{
						this._subtotalTotalNonGenericUnitsAllocated[aStore.Index] +=
							aSubtotalPack.GetStorePacksAllocated(aStore.Index)
							* aSubtotalPack.PackMultiple;
					}
				}
			}
			else
			{
				AllocationPackComponent apc = new AllocationPackComponent(aSubtotalPack.PackName);
				success = SpreadStoreSubtotalToHeaders(
					apc,
					aStore,
					aQtyAllocated,
					aDistributeChange,
					aIsManual);
			}
			return success;
		}

		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <returns>True when update is successful; false otherwise.</returns>
		/// <remarks>
		/// <para>
		/// Values interfaced via this method instance are assumed to be manually specified by the user.
		/// </para><para>
		/// Also, Values interfaced via this method instance are assumed to be applied to parent nodes but not children nodes.
		/// </para>
		/// </remarks>
		public bool SetStoreQtyAllocated(int aColorCodeRID, int aStoreRID, int aQtyAllocated)
		{
			return SetStoreQtyAllocated(aColorCodeRID, StoreIndex(aStoreRID), aQtyAllocated, eDistributeChange.ToParent, true);
		}
	
		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <param name="aDistributeChange">Indicates how to process the changed value on the parent and children components of this component.</param>
		/// <param name="aIsManual">True: indicates this a value keyed directly by the user; false indicates this value was not keyed by the user.</param>
		/// <returns>True when update is successful; false otherwise.</returns>
		internal bool SetStoreQtyAllocated(int aColorCodeRID, Index_RID aStore, int aQtyAllocated,
			eDistributeChange aDistributeChange, bool aIsManual)
		{
			return SetStoreQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aStore, aQtyAllocated, aDistributeChange, aIsManual);
		}

		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <param name="aDistributeChange">Indicates how to apply the new value to parent and children components.</param>
		/// <param name="aIsManual">True: Indicates a manually keyed value by the user.</param>
		/// <returns>True when update is successful; false otherwise.</returns>
		internal bool SetStoreQtyAllocated(HdrColorBin aColor, Index_RID aStore, 
			int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
		{
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
        //    return SetStoreQtyAllocated(
        //        aColor,
        //        aStore,
        //        aQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aQtyAllocated">Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how to apply the new value to parent and children components.</param>
        ///// <param name="aIsManual">True: Indicates a manually keyed value by the user.</param>
        ///// <param name="aAddNewMember">True: Indicates quantity is result of adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //private bool SetStoreQtyAllocated(HdrColorBin aColor, Index_RID aStore, 
        //    int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
			bool success = true;
            //if (!aAddNewMember  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
            if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                && aQtyAllocated < this.GetStoreQtyLocked(aColor, aStore))
			{
				success = false;
			}
			else
			{
				if (aDistributeChange == eDistributeChange.ToNone)
				{
					aColor.SetStoreUnitsAllocated(aStore.Index, aQtyAllocated);
				}
				else
				{
					AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColor.ColorCodeRID);
					success = SpreadStoreSubtotalToHeaders(
						colorComponent,
						aStore,
						aQtyAllocated,
						aDistributeChange,
						aIsManual);
				}
				aColor.SetReCalcStoreTotalSizePctToColor(aStore.Index,true);
				if (this._storeListSizePctToColorHash.Contains(aColor.ColorCodeRID))
				{
					this._storeListSizePctToColorHash.Remove(aColor.ColorCodeRID);
				}
			}
			return success;
		}

		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified color-size node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aQtyAllocated">Quantity Allocated.</param>
		/// <returns>True when update is successful; false otherwise.</returns>
		/// <remarks>
		/// <para>
		/// Values interfaced via this method instance are assumed to be manually specified by the user.
		/// </para>
		/// </remarks>
		public bool SetStoreQtyAllocated(int aColorCodeRID, int aSizeRID, int aStoreRID, int aQtyAllocated)
		{
			return SetStoreQtyAllocated(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aQtyAllocated, eDistributeChange.ToNone, true);
		}

		/// <summary>
		/// Sets Store Quantity Allocated audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <param name="aDistributeChange">Indicates how the quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
		/// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
		/// <returns>True when update is successful; false otherwise.</returns>
		internal bool SetStoreQtyAllocated(int aColorCodeRID, int aSizeRID, Index_RID aStore, 
			int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
		{
			return SetStoreQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore, 
				aQtyAllocated, aDistributeChange, aIsManual);
		}

		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aQtyAllocated">Quantity Allocated.</param>
		/// <param name="aDistributeChange">Indicates how the quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
		/// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
		/// <returns>True when update is successful; false otherwise.</returns>
		internal bool SetStoreQtyAllocated(HdrColorBin aColor, int aSizeRID, Index_RID aStore, 
			int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
		{
			return SetStoreQtyAllocated(GetSubtotalHdrSizeBin(aColor, aSizeRID),
				aStore, aQtyAllocated, aDistributeChange, aIsManual);
		}

		/// <summary>
		/// Sets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <param name="aDistributeChange">Indicates how the quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
		/// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
		/// <returns>True when update is successful; false otherwise.</returns>
		internal bool SetStoreQtyAllocated(HdrSizeBin aSize, Index_RID aStore, 
			int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
		{
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
        //    return SetStoreQtyAllocated(
        //        aSize,
        //        aStore,
        //        aQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aQtyAllocated">Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how the quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        ///// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        ///// <param name="aAddNewMember">True indicates quantity is result of adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreQtyAllocated(HdrSizeBin aSize, Index_RID aStore, 
        //    int aQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
			bool success = true;
            if (!BuildingSubtotals                                         // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
			    && aQtyAllocated < this.GetStoreQtyLocked(aSize, aStore)) // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
			{
				success = false;
			}
			else
			{
				if (aDistributeChange == eDistributeChange.ToNone)
				{
					aSize.SetStoreSizeUnitsAllocated(aStore.Index, aQtyAllocated);
				}
				else
				{
					AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aSize.Color.ColorCodeRID);
                    AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSize.SizeCodeRID); // Assortment: color/size changes
					AllocationColorSizeComponent colorSizeComponent = new AllocationColorSizeComponent(colorComponent, sizeComponent);
					success = SpreadStoreSubtotalToHeaders(
						colorSizeComponent,
						aStore,
						aQtyAllocated,
						aDistributeChange,
						aIsManual);
				}
				aSize.Color.SetReCalcStoreTotalSizePctToColor(aStore.Index,true);
				if (this._storeListSizePctToColorHash.Contains(aSize.Color.ColorCodeRID))
				{
					this._storeListSizePctToColorHash.Remove(aSize.Color.ColorCodeRID);
				}
			}
			return success;
		}
		#endregion SetStoreQtyAllocated

        // begin TT#1401 - JEllis - Urban Reservation Stores pt 2
        #region GetStoreItemQtyAllocated
        /// <summary>
        /// Gets Store Subtotal Item Quantity Allocated for specified store on specified component of the specified Allocation Profile.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified component.</returns>
        public int GetStoreItemQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
        {
            if (aAllocationProfile == null)
            {
                return GetStoreItemQtyAllocated(aComponent, StoreIndex(aStoreRID));
            }
            if (aComponent.ComponentType == eComponentType.SpecificPack)
            {
                AllocationPackComponent apc = (AllocationPackComponent)aComponent;
                if (!aAllocationProfile.PackIsOnHeader(apc.PackName))
                {
                    return 0;
                }
            }
            if (aComponent.ComponentType == eComponentType.SpecificColor)
            {
                AllocationColorOrSizeComponent acsc = (AllocationColorOrSizeComponent)aComponent;
                if (!aAllocationProfile.BulkColorIsOnHeader(acsc.ColorRID))
                {
                    return 0;
                }
            }
            return aAllocationProfile.GetStoreItemQtyAllocated(aComponent, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Subtotal Item Quantity Allocated for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified component.</returns>
        public int GetStoreItemQtyAllocated(GeneralComponent aComponent, int aStoreRID)
        {
            return GetStoreItemQtyAllocated(aComponent, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Subtotal Item Quantity Allocated for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified component.</returns>
        internal int GetStoreItemQtyAllocated(GeneralComponent aComponent, Index_RID aStore)
        {
            int allocated;
            AllocationPackComponent packComponent;
            AllocationColorOrSizeComponent colorComponent;
            AllocationColorOrSizeComponent sizeComponent;
            switch (aComponent.ComponentType)
            {
                case (eComponentType.AllColors):
                    {
                        return GetStoreItemQtyAllocated(eAllocationSummaryNode.BulkColorTotal, aStore);
                    }
                case (eComponentType.AllGenericPacks):
                    {
                        return GetStoreItemQtyAllocated(eAllocationSummaryNode.GenericType, aStore);
                    }
                case (eComponentType.AllNonGenericPacks):
                    {
                        if (this.BulkIsDetail)
                        {
                            return
                                (GetStoreItemQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore)
                                - GetStoreItemQtyAllocated(eAllocationSummaryNode.Bulk, aStore));
                        }
                        return GetStoreItemQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore);
                    }
                case (eComponentType.AllPacks):
                    {
                        if (this.BulkIsDetail)
                        {
                            return
                                GetStoreItemQtyAllocated(eAllocationSummaryNode.GenericType, aStore)
                                + GetStoreItemQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore)
                                - GetStoreItemQtyAllocated(eAllocationSummaryNode.Bulk, aStore);
                        }
                        return
                            GetStoreItemQtyAllocated(eAllocationSummaryNode.GenericType, aStore)
                            + GetStoreItemQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore);
                    }
                case (eComponentType.AllSizes):
                    {
                        allocated = 0;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                            {
                                allocated += this.GetStoreItemQtyAllocated(hsb, aStore);
                            }
                        }
                        return allocated;
                    }
                case (eComponentType.Bulk):
                    {
                        return GetStoreItemQtyAllocated(eAllocationSummaryNode.Bulk, aStore);
                    }
                case (eComponentType.ColorAndSize):
                    {
                        allocated = 0;
                        AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
                        GeneralComponent color = acs.ColorComponent;
                        GeneralComponent size = acs.SizeComponent;
                        switch (color.ComponentType)
                        {
                            case (eComponentType.AllColors):
                                {
                                    switch (size.ComponentType)
                                    {
                                        case (eComponentType.AllSizes):
                                            {
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                                                    {
                                                        allocated += GetStoreItemQtyAllocated(hsb, aStore);
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSize):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        allocated += GetStoreItemQtyAllocated(hcb, sizeComponent.SizeRID, aStore);
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizePrimaryDim):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
                                                SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            allocated += GetStoreItemQtyAllocated(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizeSecondaryDim):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
                                                SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            allocated += GetStoreItemQtyAllocated(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        default:
                                            {
                                                throw new MIDException(eErrorLevel.severe,
                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                            }
                                    }
                                    break;
                                }
                            case (eComponentType.SpecificColor):
                                {
                                    colorComponent = (AllocationColorOrSizeComponent)color;
                                    if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
                                    {
                                        switch (size.ComponentType)
                                        {
                                            case (eComponentType.AllSizes):
                                                {
                                                    foreach (HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
                                                    {
                                                        allocated += GetStoreItemQtyAllocated(hsb, aStore);
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSize):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;
                                                    if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        allocated += GetStoreItemQtyAllocated(colorComponent.ColorRID, sizeComponent.SizeRID, aStore);
                                                    }
                                                    break;
                                                }
                                            // BEGIN MID Track #2412 Unknown Component
                                            case (eComponentType.SpecificSizePrimaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            allocated += GetStoreItemQtyAllocated(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizeSecondaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            allocated += GetStoreItemQtyAllocated(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                    break;
                                                }
                                            // END MID Track #2412 Unknown Component
                                            default:
                                                {
                                                    throw new MIDException(eErrorLevel.severe,
                                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                                }
                                        }
                                    }
                                    break;
                                }
                            default:
                                {
                                    throw new MIDException(eErrorLevel.severe,
                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                }
                        }
                        return allocated;
                    }
                case (eComponentType.DetailType):
                    {
                        return GetStoreItemQtyAllocated(eAllocationSummaryNode.DetailType, aStore);
                    }
                case (eComponentType.GenericType):
                    {
                        return GetStoreItemQtyAllocated(eAllocationSummaryNode.GenericType, aStore);
                    }
                case (eComponentType.SpecificColor):
                    {
                        colorComponent = (AllocationColorOrSizeComponent)aComponent;
                        return GetStoreItemQtyAllocated(colorComponent.ColorRID, aStore);
                    }
                case (eComponentType.SpecificSize):
                    {
                        sizeComponent = (AllocationColorOrSizeComponent)aComponent;
                        allocated = 0;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                            {
                                allocated += GetStoreItemQtyAllocated(hcb, sizeComponent.SizeRID, aStore);
                            }
                        }
                        return allocated;
                    }
                case (eComponentType.SpecificPack):
                    {
                        packComponent = (AllocationPackComponent)aComponent;
                        return GetStoreItemQtyAllocated(packComponent.PackName, aStore);
                    }
                case (eComponentType.Total):
                    {
                        return GetStoreItemQtyAllocated(eAllocationSummaryNode.Total, aStore);
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                    }
            }
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        public int GetStoreItemQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
        {
            return GetStoreItemQtyAllocated(aAllocationSummaryNode, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreItemQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
        {
            // BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
            // END MID Change j.ellis Delay subtotal build until request for info.
            // begin TT#1401 - Jellis -Urban Virtual Store Warehouse pt 30
            if (_buildItemSubtotals)
            {
                CalculateItemSubtotals();
            }
            switch (aAllocationSummaryNode)
            {
                case (eAllocationSummaryNode.Total):
                    {
                        return _subtotalTotal[aStore.Index].ItemQtyAllocated;
                    }
                case (eAllocationSummaryNode.Type):
                    {
                        return (_subtotalGenericType[aStore.Index].ItemQtyAllocated
                            + _subtotalDetailType[aStore.Index].ItemQtyAllocated);
                    }
                case (eAllocationSummaryNode.GenericType):
                    {
                        return _subtotalGenericType[aStore.Index].ItemQtyAllocated;
                    }
                case (eAllocationSummaryNode.DetailType):
                    {
                        return _subtotalDetailType[aStore.Index].ItemQtyAllocated;
                    }
                case (eAllocationSummaryNode.DetailSubType):
                    {
                        if (BulkIsDetail)
                        {
                            return (_subtotalTotalNonGenericItemUnitsAllocated[aStore.Index]
                                + _subtotalBulk[aStore.Index].ItemQtyAllocated);
                        }
                        else
                        {
                            return _subtotalTotalNonGenericItemUnitsAllocated[aStore.Index];
                        }
                    }
                case (eAllocationSummaryNode.Bulk):
                    {
                        return _subtotalBulk[aStore.Index].ItemQtyAllocated;
                    }
                case (eAllocationSummaryNode.BulkColorTotal):
                    {
                        int colorItemUnits = 0;
                        foreach (HdrColorBin hcb in this.BulkColors.Values)
                        {
                            colorItemUnits += this.GetStoreItemQtyAllocated(hcb, aStore);
                        }
                        return colorItemUnits;
                        // End MID Track 3326 Cannot manually key size qty when no secondary dimension
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
                    }
            }
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        public int GetStoreItemQtyAllocated(string aSubtotalPackName, int aStoreRID)
        {
            return GetStoreItemQtyAllocated(aSubtotalPackName, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreItemQtyAllocated(string aSubtotalPackName, Index_RID aStore)
        {
            return GetStoreItemQtyAllocated(GetSubtotalPackHdr(aSubtotalPackName), aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPack">Pack header object where store resides.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreItemQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore)
        {
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 30
            if (_buildSubtotal)
            {
                BuildSubtotal();
            }
            if (_buildItemSubtotals)
            {
                CalculateItemSubtotals();
            }
            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 30
            return aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        public int GetStoreItemQtyAllocated(int aColorCodeRID, int aStoreRID)
        {
            return GetStoreItemQtyAllocated(aColorCodeRID, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreItemQtyAllocated(int aColorCodeRID, Index_RID aStore)
        {
            return GetStoreItemQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreItemQtyAllocated(HdrColorBin aColor, Index_RID aStore)
        {
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 30
            if (_buildSubtotal)
            {
                BuildSubtotal();
            }
            if (_buildItemSubtotals)
            {
                CalculateItemSubtotals();
            }
            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 30
            return aColor.GetStoreItemUnitsAllocated(aStore.Index);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        public int GetStoreItemQtyAllocated(int aColorCodeRID, int aSizeRID, int aStoreRID)
        {
            return GetStoreItemQtyAllocated(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreItemQtyAllocated(int aColorCodeRID, int aSizeRID, Index_RID aStore)
        {
            return GetStoreItemQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreItemQtyAllocated(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
        {
            return GetStoreItemQtyAllocated(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreItemQtyAllocated(HdrSizeBin aSize, Index_RID aStore)
        {
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 30
            if (_buildSubtotal)
            {
                BuildSubtotal();
            }
            if (_buildItemSubtotals)
            {
                CalculateItemSubtotals();
            }
            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 30
            return aSize.GetStoreSizeItemUnitsAllocated(aStore.Index);
        }
        #endregion GetStoreItemQtyAllocated

        #region SetStoreItemQtyAllocated
        /// <summary>
        /// Sets Store Subtotal Item Quantity Allocated for specified store on specified component of the specified Allocation Profile.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <returns>True when update successful; False otherwise</returns>
        /// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        public bool SetStoreItemQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, int aItemQtyAllocated)
        {
            if (aAllocationProfile == null)
            {
                return SetStoreItemQtyAllocated(aComponent, aStoreRID, aItemQtyAllocated);
            }
            if (aAllocationProfile.SetStoreItemQtyAllocated(aComponent, aStoreRID, aItemQtyAllocated) == eAllocationUpdateStatus.Successful)
            {
                return true;
            }
            return false;
        }


        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <returns>True when update successful; False otherwise</returns>
        /// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        public bool SetStoreItemQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, int aItemQtyAllocated)
        {
            Index_RID storeIndexRID = StoreIndex(aStoreRID);
            return SetStoreItemQtyAllocated(aAllocationSummaryNode, storeIndexRID, aItemQtyAllocated,
                eDistributeChange.ToAll, true);
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        /// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        /// <returns>True when update is successful; false otherwise.</returns>
        internal bool SetStoreItemQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode,
            Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        {
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
        //    return SetStoreItemQtyAllocated(
        //        aAllocationSummaryNode,
        //        aStore,
        //        aItemQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        ///// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        ///// <param name="aAddNewMember">True indicates Item Quantity resulted from adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //private bool SetStoreItemQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode,
        //    Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
            GeneralComponent gc;
            switch (aAllocationSummaryNode)
            {
                case (eAllocationSummaryNode.Bulk):
                    {
                        gc = new GeneralComponent(eGeneralComponentType.Bulk);
                        break;
                    }
                case (eAllocationSummaryNode.BulkColorTotal):
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_QtyAloctdBulkColorTotalSummaryReadOnly),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdBulkColorTotalSummaryReadOnly));
                    }
                case (eAllocationSummaryNode.DetailSubType):
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_QtyAloctdDetailSubTypeSummaryReadOnly),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdDetailSubTypeSummaryReadOnly));
                    }
                case (eAllocationSummaryNode.DetailType):
                    {
                        gc = new GeneralComponent(eGeneralComponentType.DetailType);
                        break;
                    }
                case (eAllocationSummaryNode.GenericType):
                    {
                        gc = new GeneralComponent(eGeneralComponentType.GenericType);
                        break;
                    }
                case (eAllocationSummaryNode.Total):
                    {
                        gc = new GeneralComponent(eGeneralComponentType.Total);
                        break;
                    }
                case (eAllocationSummaryNode.Type):
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_QtyAloctdTypeSummaryReadOnly),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdTypeSummaryReadOnly));
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
                    }
            }
            return SetStoreItemQtyAllocated(gc, aStore, aItemQtyAllocated, aDistributeChange, aIsManual);  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
            //return SetStoreItemQtyAllocated(gc, aStore, aItemQtyAllocated, aDistributeChange, aIsManual, aAddNewMember); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified node.
        /// </summary>
        /// <param name="aGeneralComponent">Allocation summary node.</param>
        /// <param name="aStoreRID">Index_RID for store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <returns>True when update is successful; false otherwise.</returns>
        /// <remarks>Values entered via this instance of the method are assumed to be manually keyed.</remarks>
        public bool SetStoreItemQtyAllocated(GeneralComponent aGeneralComponent,
            int aStoreRID, int aItemQtyAllocated)
        {
            if (aGeneralComponent.ComponentType == eComponentType.ColorAndSize)
            {
                return SetStoreItemQtyAllocated(
                    aGeneralComponent,
                    StoreIndex(aStoreRID),
                    aItemQtyAllocated,
                    eDistributeChange.ToNone,
                    true);
            }
            else if (aGeneralComponent.ComponentType == eComponentType.SpecificColor // MID Track 3326 Cannot manually key size qty when no secondary dimension 
                || aGeneralComponent.ComponentType == eComponentType.AllColors)      // MID Track 3326 Cannot manually key size qty when no secondary dimension
            {
                return SetStoreItemQtyAllocated(
                    aGeneralComponent,
                    StoreIndex(aStoreRID),
                    aItemQtyAllocated,
                    eDistributeChange.ToParent,
                    true);
            }
            return SetStoreItemQtyAllocated(
                aGeneralComponent,
                StoreIndex(aStoreRID),
                aItemQtyAllocated,
                eDistributeChange.ToAll,
                true);
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified node.
        /// </summary>
        /// <param name="aGeneralComponent">Allocation summary node.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        /// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        /// <returns>True when update is successful; false otherwise</returns>
        internal bool SetStoreItemQtyAllocated(GeneralComponent aGeneralComponent,
            Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        {
            // begin TT#1401 - Urban Virtual Store Warehouse pt 28F
        //    return SetStoreItemQtyAllocated(
        //        aGeneralComponent,
        //        aStore,
        //        aItemQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified node.
        ///// </summary>
        ///// <param name="aGeneralComponent">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        ///// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        ///// <param name="aAddNewMember">True indicates a new allocation profile is being added to the subtotal, false indicates otherwise.</param>
        ///// <returns>True when update is successful; false otherwise</returns>
        //private bool SetStoreItemQtyAllocated(GeneralComponent aGeneralComponent,
        //    Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
            // end TT#1401 - Urban Virtual Store Warehouse pt 28F
            bool success = true;
            if (aDistributeChange == eDistributeChange.ToNone)
            {
                AllocationColorOrSizeComponent color;
                AllocationColorOrSizeComponent size;
                switch (aGeneralComponent.ComponentType)
                {
                    case (eComponentType.AllColors):
                        {
                            throw new MIDException(eErrorLevel.severe,
                                (int)eMIDTextCode.msg_al_AllColorAllocatedReadOnly,
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllColorAllocatedReadOnly));
                        }
                    case (eComponentType.AllGenericPacks):
                        {
                            throw new MIDException(eErrorLevel.severe,
                                (int)eMIDTextCode.msg_al_AllGenericPacksAllocatedReadOnly,
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllGenericPacksAllocatedReadOnly));
                        }
                    case (eComponentType.AllNonGenericPacks):
                        {
                            throw new MIDException(eErrorLevel.severe,
                                (int)eMIDTextCode.msg_al_AllNonGenericPacksAllocatedReadOnly,
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllNonGenericPacksAllocatedReadOnly));
                        }
                    case (eComponentType.AllPacks):
                        {
                            throw new MIDException(eErrorLevel.severe,
                                (int)eMIDTextCode.msg_al_AllPacksAllocatedReadOnly,
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllPacksAllocatedReadOnly));
                        }
                    case (eComponentType.AllSizes):
                        {
                            throw new MIDException(eErrorLevel.severe,
                                (int)eMIDTextCode.msg_al_AllSizesAllocatedReadOnly,
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizesAllocatedReadOnly));
                        }
                    case (eComponentType.Bulk):
                        {
                            //if (!aAddNewMember    // TT#1401 - JEllis - URban Vitual Store Warehouse Pt 28F
                            if (!BuildingSubtotals // TT#1401 - JEllis - URban Virtual Store Warehouse pt 28F
                                && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                                && aItemQtyAllocated < this.GetStoreItemQtyLocked(eAllocationSummaryNode.Bulk, aStore))
                            {
                                success = false;
                            }
                            else
                            {
                                this._subtotalBulk[aStore.Index].ItemQtyAllocated = aItemQtyAllocated;
                            }
                            break;
                        }
                    case (eComponentType.ColorAndSize):
                        {
                            AllocationColorSizeComponent colorSize = (AllocationColorSizeComponent)aGeneralComponent;
                            switch (colorSize.ColorComponent.ComponentType)
                            {
                                case (eComponentType.AllColors):
                                    {
                                        return SpreadStoreAllColorSizeItemToColorSize(colorSize.SizeComponent, aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
                                    }
                                case (eComponentType.SpecificColor):
                                    {
                                        color = (AllocationColorOrSizeComponent)colorSize.ColorComponent;
                                        if (this.BulkColorIsOnSubtotal(color.ColorRID))
                                        {
                                            switch (colorSize.SizeComponent.ComponentType)
                                            {
                                                case (eComponentType.AllSizes):
                                                    {
                                                        throw new MIDException(eErrorLevel.warning,
                                                            (int)eMIDTextCode.msg_al_AllSizesAllocatedReadOnly,
                                                            this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizesAllocatedReadOnly));
                                                    }
                                                case (eComponentType.SpecificSize):
                                                    {
                                                        size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
                                                        if (this.GetSubtotalHdrColorBin(color.ColorRID).SizeIsInColor(size.SizeRID))
                                                        {
                                                            return SetStoreItemQtyAllocated(
                                                                color.ColorRID,
                                                                size.SizeRID,
                                                                aStore,
                                                                aItemQtyAllocated,
                                                                aDistributeChange,
                                                                aIsManual);
                                                        }
                                                        return false;
                                                    }
                                                case (eComponentType.SpecificSizePrimaryDim):
                                                    {
                                                        size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
                                                        SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(size.PrimarySizeDimRID);
                                                        return SpreadStoreItemQtyAcrossSizes(color.ColorRID, scl, aStore, aItemQtyAllocated);
                                                    }
                                                case (eComponentType.SpecificSizeSecondaryDim):
                                                    {
                                                        size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
                                                        SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(size.SecondarySizeDimRID);
                                                        return SpreadStoreItemQtyAcrossSizes(color.ColorRID, scl, aStore, aItemQtyAllocated);
                                                    }
                                                default:
                                                    {
                                                        throw new MIDException(eErrorLevel.severe,
                                                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                            this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                                    }
                                            }

                                        }
                                        return false;
                                    }
                                default:
                                    {
                                        throw new MIDException(eErrorLevel.severe,
                                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                            this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                    }
                            }
                        }
                    case (eComponentType.DetailType):
                        {
                            //if (!aAddNewMember  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                            if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                                && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                                && aItemQtyAllocated < this.GetStoreItemQtyLocked(eAllocationSummaryNode.DetailType, aStore))
                            {
                                success = false;
                            }
                            else
                            {
                                this._subtotalDetailType[aStore.Index].ItemQtyAllocated = aItemQtyAllocated;  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
                            }
                            break;
                        }
                    case (eComponentType.GenericType):
                        {
                            //if (!aAddNewMember  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                            if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                                && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                                && aItemQtyAllocated < this.GetStoreItemQtyLocked(eAllocationSummaryNode.GenericType, aStore))
                            {
                                success = false;
                            }
                            else
                            {
                                this._subtotalGenericType[aStore.Index].ItemQtyAllocated = aItemQtyAllocated; // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
                            }
                            break;
                        }
                    case (eComponentType.SpecificColor):
                        {
                            color = (AllocationColorOrSizeComponent)aGeneralComponent;
                            success = SetStoreItemQtyAllocated(this.GetSubtotalHdrColorBin(color.ColorRID), aStore, aItemQtyAllocated, aDistributeChange, aIsManual);  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                            //success = SetStoreItemQtyAllocated(this.GetSubtotalHdrColorBin(color.ColorRID), aStore, aItemQtyAllocated, aDistributeChange, aIsManual, aAddNewMember); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                            break;
                        }
                    case (eComponentType.SpecificPack):
                        {
                            AllocationPackComponent pack = (AllocationPackComponent)aGeneralComponent;
                            success = SetStoreItemQtyAllocated(this.GetSubtotalPackHdr(pack.PackName), aStore, aItemQtyAllocated, aDistributeChange, aIsManual);  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                            //success = SetStoreItemQtyAllocated(this.GetSubtotalPackHdr(pack.PackName), aStore, aItemQtyAllocated, aDistributeChange, aIsManual, aAddNewMember); // TT#1401 - JEllis - JEllis - Urban Virtual Store Warehouse pt 28F
                            break;
                        }
                    case (eComponentType.SpecificSize):
                        {
                            throw new MIDException(eErrorLevel.severe,
                                (int)eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize,
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize));
                        }
                    case (eComponentType.Total):
                        {
                            //if (!aAddNewMember  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                            if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                               && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                                && aItemQtyAllocated < this.GetStoreItemQtyLocked(eAllocationSummaryNode.Total, aStore))
                            {
                                success = false;
                            }
                            else
                            {
                                this._subtotalTotal[aStore.Index].ItemQtyAllocated = aItemQtyAllocated;  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
                            }
                            break;
                        }
                    default:
                        {
                            throw new MIDException(eErrorLevel.severe,
                                (int)eMIDTextCode.msg_al_UnknownComponentType,
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                        }
                }
            }
            else
            {
                success = SpreadStoreSubtotalItemToHeaders(
                    aGeneralComponent,
                    aStore,
                    aItemQtyAllocated,
                    aDistributeChange,
                    aIsManual);
            }
            return success;
        }
        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        /// <returns>True when update is successful; false otherwise</returns>
        /// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        public bool SetStoreItemQtyAllocated(string aSubtotalPackName, int aStoreRID, int aItemQtyAllocated)
        {
            return SetStoreItemQtyAllocated(aSubtotalPackName, StoreIndex(aStoreRID), aItemQtyAllocated, eDistributeChange.ToAll, true);
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Subtotal Pack name.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
        /// <param name="aIsManual">True: Indicates this is a manually keyed value.</param> 
        /// <returns>True when update is successful; false otherwise.</returns>
        internal bool SetStoreItemQtyAllocated(string aSubtotalPackName, Index_RID aStore, int aItemQtyAllocated,
            eDistributeChange aDistributeChange, bool aIsManual)
        {
            return SetStoreItemQtyAllocated(GetSubtotalPackHdr(aSubtotalPackName), aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        /// <param name="aDistributeChange">Indicates how to apply the new value to the parent and/or children components of this component.</param>
        /// <param name="aIsManual">True: indicates this is a manually keyed value.</param>
        /// <returns>True when update is successful; false otherwise.</returns>
        internal bool SetStoreItemQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore,
            int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        {
            // begin TT#1401 - JELlis - Urban Virtual Store Warehouse pt 28F
        //    return SetStoreItemQtyAllocated(
        //        aSubtotalPack,
        //        aStore,
        //        aItemQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        ///// <param name="aDistributeChange">Indicates how to apply the new value to the parent and/or children components of this component.</param>
        ///// <param name="aIsManual">True: indicates this is a manually keyed value.</param>
        ///// <param name="aAddNewMember">True: indicates Item Quantity is result of adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //private bool SetStoreItemQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
            bool success = true;
            if (aDistributeChange == eDistributeChange.ToNone)
            {
                //if (!aAddNewMember  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                    && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                    && aItemQtyAllocated < this.GetStoreItemQtyLocked(aSubtotalPack, aStore))
                {
                    success = false;
                }
                else
                {
                    if (aSubtotalPack.GenericPack)
                    {
                        this._subtotalGenericType[aStore.Index].ItemQtyAllocated -=
                            aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
                            * aSubtotalPack.PackMultiple;
                    }
                    else
                    {
                        this._subtotalTotalNonGenericItemUnitsAllocated[aStore.Index] -=
                            aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
                            * aSubtotalPack.PackMultiple;
                    }
                    aSubtotalPack.SetStoreItemPacksAllocated(aStore.Index, aItemQtyAllocated); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                    if (aSubtotalPack.GenericPack)
                    {
                        this._subtotalGenericType[aStore.Index].ItemQtyAllocated +=
                            aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
                            * aSubtotalPack.PackMultiple;
                    }
                    else
                    {
                        this._subtotalTotalNonGenericItemUnitsAllocated[aStore.Index] +=
                            aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
                            * aSubtotalPack.PackMultiple;
                    }
                }
            }
            else
            {
                AllocationPackComponent apc = new AllocationPackComponent(aSubtotalPack.PackName);
                success = SpreadStoreSubtotalItemToHeaders(
                    apc,
                    aStore,
                    aItemQtyAllocated,
                    aDistributeChange,
                    aIsManual);
            }
            return success;
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <returns>True when update is successful; false otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Values interfaced via this method instance are assumed to be manually specified by the user.
        /// </para><para>
        /// Also, Values interfaced via this method instance are assumed to be applied to parent nodes but not children nodes.
        /// </para>
        /// </remarks>
        public bool SetStoreItemQtyAllocated(int aColorCodeRID, int aStoreRID, int aItemQtyAllocated)
        {
            return SetStoreItemQtyAllocated(aColorCodeRID, StoreIndex(aStoreRID), aItemQtyAllocated, eDistributeChange.ToParent, true);
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <param name="aDistributeChange">Indicates how to process the changed value on the parent and children components of this component.</param>
        /// <param name="aIsManual">True: indicates this a value keyed directly by the user; false indicates this value was not keyed by the user.</param>
        /// <returns>True when update is successful; false otherwise.</returns>
        internal bool SetStoreItemQtyAllocated(int aColorCodeRID, Index_RID aStore, int aItemQtyAllocated,
            eDistributeChange aDistributeChange, bool aIsManual)
        {
            return SetStoreItemQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <param name="aDistributeChange">Indicates how to apply the new value to parent and children components.</param>
        /// <param name="aIsManual">True: Indicates a manually keyed value by the user.</param>
        /// <returns>True when update is successful; false otherwise.</returns>
        internal bool SetStoreItemQtyAllocated(HdrColorBin aColor, Index_RID aStore,
            int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        {
            // begin TT#1401 - JEllis - Virtual Store Warehouse pt 28F
        //    return SetStoreItemQtyAllocated(
        //        aColor,
        //        aStore,
        //        aItemQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how to apply the new value to parent and children components.</param>
        ///// <param name="aIsManual">True: Indicates a manually keyed value by the user.</param>
        ///// <param name="aAddNewMember">True: Indicates Item Quantity is result of adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //private bool SetStoreItemQtyAllocated(HdrColorBin aColor, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
            // end TT#1401 - JEllis - Virtual Store Warehouse pt 28F
            bool success = true;
            //if (!aAddNewMember  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
            if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                && aItemQtyAllocated < this.GetStoreItemQtyLocked(aColor, aStore))
            {
                success = false;
            }
            else
            {
                if (aDistributeChange == eDistributeChange.ToNone)
                {
                    aColor.SetStoreItemUnitsAllocated(aStore.Index, aItemQtyAllocated);
                }
                else
                {
                    AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColor.ColorCodeRID);
                    success = SpreadStoreSubtotalItemToHeaders(   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
                        colorComponent,
                        aStore,
                        aItemQtyAllocated,
                        aDistributeChange,
                        aIsManual);
                }
                if (this._storeListSizePctToColorHash.Contains(aColor.ColorCodeRID))
                {
                    this._storeListSizePctToColorHash.Remove(aColor.ColorCodeRID);
                }
            }
            return success;
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified color-size node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        /// <returns>True when update is successful; false otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Values interfaced via this method instance are assumed to be manually specified by the user.
        /// </para>
        /// </remarks>
        public bool SetStoreItemQtyAllocated(int aColorCodeRID, int aSizeRID, int aStoreRID, int aItemQtyAllocated)
        {
            return SetStoreItemQtyAllocated(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aItemQtyAllocated, eDistributeChange.ToNone, true);
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated audit flag for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        /// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        /// <returns>True when update is successful; false otherwise.</returns>
        internal bool SetStoreItemQtyAllocated(int aColorCodeRID, int aSizeRID, Index_RID aStore,
            int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        {
            return SetStoreItemQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore,
                aItemQtyAllocated, aDistributeChange, aIsManual);
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        /// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        /// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        /// <returns>True when update is successful; false otherwise.</returns>
        internal bool SetStoreItemQtyAllocated(HdrColorBin aColor, int aSizeRID, Index_RID aStore,
            int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        {
            return SetStoreItemQtyAllocated(GetSubtotalHdrSizeBin(aColor, aSizeRID),
                aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        }

        /// <summary>
        /// Sets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        /// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        /// <returns>True when update is successful; false otherwise.</returns>
        internal bool SetStoreItemQtyAllocated(HdrSizeBin aSize, Index_RID aStore,
            int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        {
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
        //    return SetStoreItemQtyAllocated(
        //        aSize,
        //        aStore,
        //        aItemQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        ///// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        ///// <param name="aAddNewMember">True indicates Item Quantity is result of adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreItemQtyAllocated(HdrSizeBin aSize, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
            // end TT#1401 - JEllis - Urban Virtual Store warehouse pt 28F
            bool success = true;
            if (!BuildingSubtotals // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                && !_buildingItemSubtotals // TT#2344 - JEllis - AnF - VSW Subtotals Broken
                && aItemQtyAllocated < this.GetStoreItemQtyLocked(aSize, aStore))  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
            {
                success = false;
            }
            else
            {
                if (aDistributeChange == eDistributeChange.ToNone)
                {
                    aSize.SetStoreSizeItemUnitsAllocated(aStore.Index, aItemQtyAllocated); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28D
                }
                else
                {
                    AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aSize.Color.ColorCodeRID);
                    AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSize.SizeCodeRID); // Assortment: color/size changes
                    AllocationColorSizeComponent colorSizeComponent = new AllocationColorSizeComponent(colorComponent, sizeComponent);
                    success = SpreadStoreSubtotalItemToHeaders(
                        colorSizeComponent,
                        aStore,
                        aItemQtyAllocated,
                        aDistributeChange,
                        aIsManual);
                }
                aSize.Color.SetReCalcStoreTotalSizePctToColor(aStore.Index, true);
            }
            return success;
        }
        #endregion SetStoreItemQtyAllocated
        // end TT#1401 - JEllis - Urban Reservation Stores pt 2
		#endregion StoreQuantityAllocated

		#region StoreIMOQuantityAllocated
		// begin TT#1401 - STodd - Urban Reservation Stores
        // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
        // re-wrote the "Get" Imo methods to use fact that IMO = Units Allocated = Item Allocated.
        #region GetStoreImoQtyAllocated
        /// <summary>
        /// Gets Store Subtotal Item Quantity Allocated for specified store on specified component of the specified Allocation Profile.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified component.</returns>
        public int GetStoreImoQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
        {
            if (aAllocationProfile == null)
            {
                return GetStoreImoQtyAllocated(aComponent, StoreIndex(aStoreRID));
            }
            if (aComponent.ComponentType == eComponentType.SpecificPack)
            {
                AllocationPackComponent apc = (AllocationPackComponent)aComponent;
                if (!aAllocationProfile.PackIsOnHeader(apc.PackName))
                {
                    return 0;
                }
            }
            if (aComponent.ComponentType == eComponentType.SpecificColor)
            {
                AllocationColorOrSizeComponent acsc = (AllocationColorOrSizeComponent)aComponent;
                if (!aAllocationProfile.BulkColorIsOnHeader(acsc.ColorRID))
                {
                    return 0;
                }
            }
            return aAllocationProfile.GetStoreImoQtyAllocated(aComponent, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Subtotal Item Quantity Allocated for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified component.</returns>
        public int GetStoreImoQtyAllocated(GeneralComponent aComponent, int aStoreRID)
        {
            return GetStoreImoQtyAllocated(aComponent, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Subtotal Item Quantity Allocated for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified component.</returns>
        internal int GetStoreImoQtyAllocated(GeneralComponent aComponent, Index_RID aStore)
        {
            int allocated;
            AllocationPackComponent packComponent;
            AllocationColorOrSizeComponent colorComponent;
            AllocationColorOrSizeComponent sizeComponent;
            switch (aComponent.ComponentType)
            {
                case (eComponentType.AllColors):
                    {
                        return GetStoreImoQtyAllocated(eAllocationSummaryNode.BulkColorTotal, aStore);
                    }
                case (eComponentType.AllGenericPacks):
                    {
                        return GetStoreImoQtyAllocated(eAllocationSummaryNode.GenericType, aStore);
                    }
                case (eComponentType.AllNonGenericPacks):
                    {
                        if (this.BulkIsDetail)
                        {
                            return
                                (GetStoreImoQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore)
                                - GetStoreImoQtyAllocated(eAllocationSummaryNode.Bulk, aStore));
                        }
                        return GetStoreImoQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore);
                    }
                case (eComponentType.AllPacks):
                    {
                        if (this.BulkIsDetail)
                        {
                            return
                                GetStoreImoQtyAllocated(eAllocationSummaryNode.GenericType, aStore)
                                + GetStoreImoQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore)
                                - GetStoreImoQtyAllocated(eAllocationSummaryNode.Bulk, aStore);
                        }
                        return
                            GetStoreImoQtyAllocated(eAllocationSummaryNode.GenericType, aStore)
                            + GetStoreImoQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore);
                    }
                case (eComponentType.AllSizes):
                    {
                        allocated = 0;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                            {
                                allocated += this.GetStoreImoQtyAllocated(hsb, aStore);
                            }
                        }
                        return allocated;
                    }
                case (eComponentType.Bulk):
                    {
                        return GetStoreImoQtyAllocated(eAllocationSummaryNode.Bulk, aStore);
                    }
                case (eComponentType.ColorAndSize):
                    {
                        allocated = 0;
                        AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
                        GeneralComponent color = acs.ColorComponent;
                        GeneralComponent size = acs.SizeComponent;
                        switch (color.ComponentType)
                        {
                            case (eComponentType.AllColors):
                                {
                                    switch (size.ComponentType)
                                    {
                                        case (eComponentType.AllSizes):
                                            {
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                                                    {
                                                        allocated += GetStoreImoQtyAllocated(hsb, aStore);
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSize):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        allocated += GetStoreImoQtyAllocated(hcb, sizeComponent.SizeRID, aStore);
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizePrimaryDim):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;
                                                SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            allocated += GetStoreImoQtyAllocated(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizeSecondaryDim):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;
                                                SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            allocated += GetStoreImoQtyAllocated(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        default:
                                            {
                                                throw new MIDException(eErrorLevel.severe,
                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                            }
                                    }
                                    break;
                                }
                            case (eComponentType.SpecificColor):
                                {
                                    colorComponent = (AllocationColorOrSizeComponent)color;
                                    if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
                                    {
                                        switch (size.ComponentType)
                                        {
                                            case (eComponentType.AllSizes):
                                                {
                                                    foreach (HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
                                                    {
                                                        allocated += GetStoreImoQtyAllocated(hsb, aStore);
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSize):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;
                                                    if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        allocated += GetStoreImoQtyAllocated(colorComponent.ColorRID, sizeComponent.SizeRID, aStore);
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizePrimaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            allocated += GetStoreImoQtyAllocated(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizeSecondaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            allocated += GetStoreImoQtyAllocated(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                    break;
                                                }
                                            default:
                                                {
                                                    throw new MIDException(eErrorLevel.severe,
                                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                                }
                                        }
                                    }
                                    break;
                                }
                            default:
                                {
                                    throw new MIDException(eErrorLevel.severe,
                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                }
                        }
                        return allocated;
                    }
                case (eComponentType.DetailType):
                    {
                        return GetStoreImoQtyAllocated(eAllocationSummaryNode.DetailType, aStore);
                    }
                case (eComponentType.GenericType):
                    {
                        return GetStoreImoQtyAllocated(eAllocationSummaryNode.GenericType, aStore);
                    }
                case (eComponentType.SpecificColor):
                    {
                        colorComponent = (AllocationColorOrSizeComponent)aComponent;
                        return GetStoreImoQtyAllocated(colorComponent.ColorRID, aStore);
                    }
                case (eComponentType.SpecificSize):
                    {
                        sizeComponent = (AllocationColorOrSizeComponent)aComponent;
                        allocated = 0;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                            {
                                allocated += GetStoreImoQtyAllocated(hcb, sizeComponent.SizeRID, aStore);
                            }
                        }
                        return allocated;
                    }
                case (eComponentType.SpecificPack):
                    {
                        packComponent = (AllocationPackComponent)aComponent;
                        return GetStoreImoQtyAllocated(packComponent.PackName, aStore);
                    }
                case (eComponentType.Total):
                    {
                        return GetStoreImoQtyAllocated(eAllocationSummaryNode.Total, aStore);
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                    }
            }
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        public int GetStoreImoQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
        {
            return GetStoreImoQtyAllocated(aAllocationSummaryNode, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreImoQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
        {
            // begin TT#1041 - MD - Jellis - Get Qty Cannot be Negative Message
            //if (_buildSubtotal)
            //{
            //    this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            //}
            // end TT#1041 - MD - Jellis - Get Qty Cannot be Negative Message

            int imoQtyAllocated =
                GetStoreQtyAllocated(aAllocationSummaryNode, aStore)
                - GetStoreItemQtyAllocated(aAllocationSummaryNode, aStore);
            if (imoQtyAllocated < 0)
            {
                throw new MIDException(
                    eErrorLevel.severe,
                    (int)eMIDTextCode.msg_QtyAllocatedCannotBeNeg,
                    MIDText.GetTextOnly(eMIDTextCode.msg_QtyAllocatedCannotBeNeg) 
                    + ": " + GetType().Name
                    + " 'GetStoreImoQtyAllocated' for eAllocationSummaryNode");

            }
            return imoQtyAllocated;
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
            //switch (aAllocationSummaryNode)
            //{
            //    case (eAllocationSummaryNode.Total):
            //        {
            //            return _subtotalTotal[aStore.Index].ImoQtyAllocated;
            //        }
            //    case (eAllocationSummaryNode.Type):
            //        {
            //            return (_subtotalGenericType[aStore.Index].ImoQtyAllocated
            //                + _subtotalDetailType[aStore.Index].ImoQtyAllocated);
            //        }
            //    case (eAllocationSummaryNode.GenericType):
            //        {
            //            return _subtotalGenericType[aStore.Index].ImoQtyAllocated;
            //        }
            //    case (eAllocationSummaryNode.DetailType):
            //        {
            //            return _subtotalDetailType[aStore.Index].ImoQtyAllocated;
            //        }
            //    case (eAllocationSummaryNode.DetailSubType):
            //        {
            //            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
            //            if (BulkIsDetail)
            //            {
            //                return (_subtotalTotalNonGenericUnitsAllocated[aStore.Index]
            //                        - _subtotalTotalNonGenericItemUnitsAllocated[aStore.Index])
            //                        + _subtotalBulk[aStore.Index].ImoQtyAllocated;
            //            }
            //            else
            //            {
            //                return _subtotalBulk[aStore.Index].ImoQtyAllocated;
            //            }
            //            //if (BulkIsDetail)
            //            //{
            //            //    return (_subtotalTotalNonGenericItemUnitsAllocated[aStore.Index]	// TT#1401 - stodd - ?????????? 
            //            //        + _subtotalBulk[aStore.Index].ImoQtyAllocated);
            //            //}
            //            //else
            //            //{
            //            //    return _subtotalTotalNonGenericItemUnitsAllocated[aStore.Index];	// TT#1401 - stodd - ?????????? 
            //            //}
            //            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
            //        }
            //    case (eAllocationSummaryNode.Bulk):
            //        {
            //            return _subtotalBulk[aStore.Index].ImoQtyAllocated;
            //        }
            //    case (eAllocationSummaryNode.BulkColorTotal):
            //        {
            //            int colorItemUnits = 0;
            //            foreach (HdrColorBin hcb in this.BulkColors.Values)
            //            {
            //                colorItemUnits += this.GetStoreImoQtyAllocated(hcb, aStore);
            //            }
            //            return colorItemUnits;
            //        }
            //    default:
            //        {
            //            throw new MIDException(eErrorLevel.severe,
            //                (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
            //                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
            //        }
            //}
            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        public int GetStoreImoQtyAllocated(string aSubtotalPackName, int aStoreRID)
        {
            return GetStoreImoQtyAllocated(aSubtotalPackName, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreImoQtyAllocated(string aSubtotalPackName, Index_RID aStore)
        {
            return GetStoreImoQtyAllocated(GetSubtotalPackHdr(aSubtotalPackName), aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPack">Pack header object where store resides.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreImoQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore)
        {
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
            //return aSubtotalPack.GetStoreImoPacksAllocated(aStore.Index);  // TT#1401 - JEllis - Urban Reservation Store pt 8
            // begin TT#1041 - MD - Jellis - Get Qty Cannot be Negative Message
            //int imoQtyAllocated =
            //    aSubtotalPack.GetStorePacksAllocated(aStore.Index)
            //       - aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index);
            int imoQtyAllocated =
                GetStoreQtyAllocated(aSubtotalPack, aStore)
                - GetStoreItemQtyAllocated(aSubtotalPack, aStore);
            // end TT#1041 - MD- Jellis - Get Qty Cannot be Negative Message
            if (imoQtyAllocated < 0)
            {
                throw new MIDException(
                    eErrorLevel.severe,
                    (int)eMIDTextCode.msg_QtyAllocatedCannotBeNeg,
                    MIDText.GetTextOnly(eMIDTextCode.msg_QtyAllocatedCannotBeNeg)
                    + ": " + GetType().Name
                    + " 'GetStoreImoQtyAllocated' for PackHdr");

            }
            return imoQtyAllocated;
            // end TT#1401 - JEllis - URban Virtual Store Warehouse pt 28C
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        public int GetStoreImoQtyAllocated(int aColorCodeRID, int aStoreRID)
        {
            return GetStoreImoQtyAllocated(aColorCodeRID, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreImoQtyAllocated(int aColorCodeRID, Index_RID aStore)
        {
            return GetStoreImoQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreImoQtyAllocated(HdrColorBin aColor, Index_RID aStore)
        {
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
            //return aColor.GetStoreImoUnitsAllocated(aStore.Index);
            // begin TT#1041 - MD - Jellis - Get Qty Cannot be Negative
            //int imoQtyAllocated =
            //    aColor.GetStoreUnitsAllocated(aStore.Index)
            //       - aColor.GetStoreItemUnitsAllocated(aStore.Index);
            int imoQtyAllocated =
                GetStoreQtyAllocated(aColor, aStore)
                - GetStoreItemQtyAllocated(aColor, aStore);
            // end TT#1041 - MD- Jellis - Get Qty Cannot be Negative
            if (imoQtyAllocated < 0)
            {
                throw new MIDException(
                    eErrorLevel.severe,
                    (int)eMIDTextCode.msg_QtyAllocatedCannotBeNeg,
                    MIDText.GetTextOnly(eMIDTextCode.msg_QtyAllocatedCannotBeNeg)
                    + ": " + GetType().Name
                    + " 'GetStoreImoQtyAllocated' for HdrColorBin");

            }
            return imoQtyAllocated;
            // end TT#1401 - JEllis - Urban Virutal Store Warehouse pt 28C
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        public int GetStoreImoQtyAllocated(int aColorCodeRID, int aSizeRID, int aStoreRID)
        {
            return GetStoreImoQtyAllocated(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreImoQtyAllocated(int aColorCodeRID, int aSizeRID, Index_RID aStore)
        {
            return GetStoreImoQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreImoQtyAllocated(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
        {
            return GetStoreImoQtyAllocated(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Allocated to the store for the specified node.</returns>
        internal int GetStoreImoQtyAllocated(HdrSizeBin aSize, Index_RID aStore)
        {
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
            //return aSize.GetStoreSizeImoUnitsAllocated(aStore.Index);
            // begin TT#1041 - MD - Jellis - Get Msg Qty Cannot Be Negative
            //int imoQtyAllocated =
                //aSize.GetStoreSizeUnitsAllocated(aStore.Index)
                //- aSize.GetStoreSizeItemUnitsAllocated(aStore.Index);
            int imoQtyAllocated =
                GetStoreQtyAllocated(aSize, aStore)
                - GetStoreItemQtyAllocated(aSize, aStore);
            // end TT#1041 - MD - Jellis - Get Msg Qty Cannot Be Negative
            if (imoQtyAllocated < 0)
            {
                throw new MIDException(
                    eErrorLevel.severe,
                    (int)eMIDTextCode.msg_QtyAllocatedCannotBeNeg,
                    MIDText.GetTextOnly(eMIDTextCode.msg_QtyAllocatedCannotBeNeg)
                    + ": " + GetType().Name
                    + " 'GetStoreImoQtyAllocated' for HdrSizeBin");

            }
            return imoQtyAllocated;
            // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
        }
        #endregion GetStoreImoQtyAllocated
        // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C

        //#region SetStoreImoQtyAllocated
        ///// <summary>
        ///// Sets Store Subtotal Item Quantity Allocated for specified store on specified component of the specified Allocation Profile.
        ///// </summary>
        ///// <param name="aAllocationProfile">Allocation Profile</param>
        ///// <param name="aComponent">Description of the component</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <returns>True when update successful; False otherwise</returns>
        ///// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        //public bool SetStoreImoQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, int aItemQtyAllocated)
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        return SetStoreImoQtyAllocated(aComponent, aStoreRID, aItemQtyAllocated);
        //    }
        //    if (aAllocationProfile.SetStoreImoQtyAllocated(aComponent, aStoreRID, aItemQtyAllocated) == eAllocationUpdateStatus.Successful)
        //    {
        //        return true;
        //    }
        //    return false;
        //}


        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <returns>True when update successful; False otherwise</returns>
        ///// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        //public bool SetStoreImoQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, int aItemQtyAllocated)
        //{
        //    Index_RID storeIndexRID = StoreIndex(aStoreRID);
        //    return SetStoreImoQtyAllocated(aAllocationSummaryNode, storeIndexRID, aItemQtyAllocated,
        //        eDistributeChange.ToAll, true);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        ///// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreImoQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode,
        //    Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        //{
        //    return SetStoreImoQtyAllocated(
        //        aAllocationSummaryNode,
        //        aStore,
        //        aItemQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        ///// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        ///// <param name="aAddNewMember">True indicates Item Quantity resulted from adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //private bool SetStoreImoQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode,
        //    Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
        //    GeneralComponent gc;
        //    switch (aAllocationSummaryNode)
        //    {
        //        case (eAllocationSummaryNode.Bulk):
        //            {
        //                gc = new GeneralComponent(eGeneralComponentType.Bulk);
        //                break;
        //            }
        //        case (eAllocationSummaryNode.BulkColorTotal):
        //            {
        //                throw new MIDException(eErrorLevel.severe,
        //                    (int)(eMIDTextCode.msg_al_QtyAloctdBulkColorTotalSummaryReadOnly),
        //                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdBulkColorTotalSummaryReadOnly));
        //            }
        //        case (eAllocationSummaryNode.DetailSubType):
        //            {
        //                throw new MIDException(eErrorLevel.severe,
        //                    (int)(eMIDTextCode.msg_al_QtyAloctdDetailSubTypeSummaryReadOnly),
        //                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdDetailSubTypeSummaryReadOnly));
        //            }
        //        case (eAllocationSummaryNode.DetailType):
        //            {
        //                gc = new GeneralComponent(eGeneralComponentType.DetailType);
        //                break;
        //            }
        //        case (eAllocationSummaryNode.GenericType):
        //            {
        //                gc = new GeneralComponent(eGeneralComponentType.GenericType);
        //                break;
        //            }
        //        case (eAllocationSummaryNode.Total):
        //            {
        //                gc = new GeneralComponent(eGeneralComponentType.Total);
        //                break;
        //            }
        //        case (eAllocationSummaryNode.Type):
        //            {
        //                throw new MIDException(eErrorLevel.severe,
        //                    (int)(eMIDTextCode.msg_al_QtyAloctdTypeSummaryReadOnly),
        //                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdTypeSummaryReadOnly));
        //            }
        //        default:
        //            {
        //                throw new MIDException(eErrorLevel.severe,
        //                    (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
        //                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
        //            }
        //    }
        //    return SetStoreImoQtyAllocated(gc, aStore, aItemQtyAllocated, aDistributeChange, aIsManual, aAddNewMember);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified node.
        ///// </summary>
        ///// <param name="aGeneralComponent">Allocation summary node.</param>
        ///// <param name="aStoreRID">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        ///// <remarks>Values entered via this instance of the method are assumed to be manually keyed.</remarks>
        //public bool SetStoreImoQtyAllocated(GeneralComponent aGeneralComponent,
        //    int aStoreRID, int aItemQtyAllocated)
        //{
        //    if (aGeneralComponent.ComponentType == eComponentType.ColorAndSize)
        //    {
        //        return SetStoreImoQtyAllocated(
        //            aGeneralComponent,
        //            StoreIndex(aStoreRID),
        //            aItemQtyAllocated,
        //            eDistributeChange.ToNone,
        //            true);
        //    }
        //    else if (aGeneralComponent.ComponentType == eComponentType.SpecificColor // MID Track 3326 Cannot manually key size qty when no secondary dimension 
        //        || aGeneralComponent.ComponentType == eComponentType.AllColors)      // MID Track 3326 Cannot manually key size qty when no secondary dimension
        //    {
        //        return SetStoreImoQtyAllocated(
        //            aGeneralComponent,
        //            StoreIndex(aStoreRID),
        //            aItemQtyAllocated,
        //            eDistributeChange.ToParent,
        //            true);
        //    }
        //    return SetStoreImoQtyAllocated(
        //        aGeneralComponent,
        //        StoreIndex(aStoreRID),
        //        aItemQtyAllocated,
        //        eDistributeChange.ToAll,
        //        true);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified node.
        ///// </summary>
        ///// <param name="aGeneralComponent">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        ///// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        ///// <returns>True when update is successful; false otherwise</returns>
        //internal bool SetStoreImoQtyAllocated(GeneralComponent aGeneralComponent,
        //    Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        //{
        //    return SetStoreImoQtyAllocated(
        //        aGeneralComponent,
        //        aStore,
        //        aItemQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified node.
        ///// </summary>
        ///// <param name="aGeneralComponent">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        ///// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        ///// <param name="aAddNewMember">True indicates a new allocation profile is being added to the subtotal, false indicates otherwise.</param>
        ///// <returns>True when update is successful; false otherwise</returns>
        //private bool SetStoreImoQtyAllocated(GeneralComponent aGeneralComponent,
        //    Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
        //    bool success = true;
        //    if (aDistributeChange == eDistributeChange.ToNone)
        //    {
        //        AllocationColorOrSizeComponent color;
        //        AllocationColorOrSizeComponent size;
        //        switch (aGeneralComponent.ComponentType)
        //        {
        //            case (eComponentType.AllColors):
        //                {
        //                    throw new MIDException(eErrorLevel.severe,
        //                        (int)eMIDTextCode.msg_al_AllColorAllocatedReadOnly,
        //                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllColorAllocatedReadOnly));
        //                }
        //            case (eComponentType.AllGenericPacks):
        //                {
        //                    throw new MIDException(eErrorLevel.severe,
        //                        (int)eMIDTextCode.msg_al_AllGenericPacksAllocatedReadOnly,
        //                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllGenericPacksAllocatedReadOnly));
        //                }
        //            case (eComponentType.AllNonGenericPacks):
        //                {
        //                    throw new MIDException(eErrorLevel.severe,
        //                        (int)eMIDTextCode.msg_al_AllNonGenericPacksAllocatedReadOnly,
        //                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllNonGenericPacksAllocatedReadOnly));
        //                }
        //            case (eComponentType.AllPacks):
        //                {
        //                    throw new MIDException(eErrorLevel.severe,
        //                        (int)eMIDTextCode.msg_al_AllPacksAllocatedReadOnly,
        //                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllPacksAllocatedReadOnly));
        //                }
        //            case (eComponentType.AllSizes):
        //                {
        //                    throw new MIDException(eErrorLevel.severe,
        //                        (int)eMIDTextCode.msg_al_AllSizesAllocatedReadOnly,
        //                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizesAllocatedReadOnly));
        //                }
        //            case (eComponentType.Bulk):
        //                {
        //                    if (!aAddNewMember
        //                        && aItemQtyAllocated < this.GetStoreImoQtyLocked(eAllocationSummaryNode.Bulk, aStore))
        //                    {
        //                        success = false;
        //                    }
        //                    else
        //                    {
        //                        this._subtotalBulk[aStore.Index].ItemQtyAllocated = aItemQtyAllocated;
        //                    }
        //                    break;
        //                }
        //            case (eComponentType.ColorAndSize):
        //                {
        //                    AllocationColorSizeComponent colorSize = (AllocationColorSizeComponent)aGeneralComponent;
        //                    switch (colorSize.ColorComponent.ComponentType)
        //                    {
        //                        case (eComponentType.AllColors):
        //                            {
        //                                return SpreadStoreAllColorSizeItemToColorSize(colorSize.SizeComponent, aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        //                            }
        //                        case (eComponentType.SpecificColor):
        //                            {
        //                                color = (AllocationColorOrSizeComponent)colorSize.ColorComponent;
        //                                if (this.BulkColorIsOnSubtotal(color.ColorRID))
        //                                {
        //                                    switch (colorSize.SizeComponent.ComponentType)
        //                                    {
        //                                        case (eComponentType.AllSizes):
        //                                            {
        //                                                throw new MIDException(eErrorLevel.warning,
        //                                                    (int)eMIDTextCode.msg_al_AllSizesAllocatedReadOnly,
        //                                                    this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizesAllocatedReadOnly));
        //                                            }
        //                                        case (eComponentType.SpecificSize):
        //                                            {
        //                                                size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
        //                                                if (this.GetSubtotalHdrColorBin(color.ColorRID).SizeIsInColor(size.SizeRID))
        //                                                {
        //                                                    return SetStoreImoQtyAllocated(
        //                                                        color.ColorRID,
        //                                                        size.SizeRID,
        //                                                        aStore,
        //                                                        aItemQtyAllocated,
        //                                                        aDistributeChange,
        //                                                        aIsManual);
        //                                                }
        //                                                return false;
        //                                            }
        //                                        case (eComponentType.SpecificSizePrimaryDim):
        //                                            {
        //                                                size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
        //                                                SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(size.PrimarySizeDimRID);
        //                                                return SpreadStoreImoQtyAcrossSizes(color.ColorRID, scl, aStore, aItemQtyAllocated);
        //                                            }
        //                                        case (eComponentType.SpecificSizeSecondaryDim):
        //                                            {
        //                                                size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
        //                                                SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(size.SecondarySizeDimRID);
        //                                                return SpreadStoreImoQtyAcrossSizes(color.ColorRID, scl, aStore, aItemQtyAllocated);
        //                                            }
        //                                        default:
        //                                            {
        //                                                throw new MIDException(eErrorLevel.severe,
        //                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                                                    this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                                            }
        //                                    }

        //                                }
        //                                return false;
        //                            }
        //                        default:
        //                            {
        //                                throw new MIDException(eErrorLevel.severe,
        //                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                                    this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                            }
        //                    }
        //                }
        //            case (eComponentType.DetailType):
        //                {
        //                    if (!aAddNewMember
        //                        && aItemQtyAllocated < this.GetStoreImoQtyLocked(eAllocationSummaryNode.DetailType, aStore))
        //                    {
        //                        success = false;
        //                    }
        //                    else
        //                    {
        //                        this._subtotalDetailType[aStore.Index].QtyAllocated = aItemQtyAllocated;
        //                    }
        //                    break;
        //                }
        //            case (eComponentType.GenericType):
        //                {
        //                    if (!aAddNewMember
        //                        && aItemQtyAllocated < this.GetStoreImoQtyLocked(eAllocationSummaryNode.GenericType, aStore))
        //                    {
        //                        success = false;
        //                    }
        //                    else
        //                    {
        //                        this._subtotalGenericType[aStore.Index].QtyAllocated = aItemQtyAllocated;
        //                    }
        //                    break;
        //                }
        //            case (eComponentType.SpecificColor):
        //                {
        //                    color = (AllocationColorOrSizeComponent)aGeneralComponent;
        //                    success = SetStoreImoQtyAllocated(this.GetSubtotalHdrColorBin(color.ColorRID), aStore, aItemQtyAllocated, aDistributeChange, aIsManual, aAddNewMember);
        //                    break;
        //                }
        //            case (eComponentType.SpecificPack):
        //                {
        //                    AllocationPackComponent pack = (AllocationPackComponent)aGeneralComponent;
        //                    success = SetStoreImoQtyAllocated(this.GetSubtotalPackHdr(pack.PackName), aStore, aItemQtyAllocated, aDistributeChange, aIsManual, aAddNewMember);
        //                    break;
        //                }
        //            case (eComponentType.SpecificSize):
        //                {
        //                    throw new MIDException(eErrorLevel.severe,
        //                        (int)eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize,
        //                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize));
        //                }
        //            case (eComponentType.Total):
        //                {
        //                    if (!aAddNewMember
        //                        && aItemQtyAllocated < this.GetStoreImoQtyLocked(eAllocationSummaryNode.Total, aStore))
        //                    {
        //                        success = false;
        //                    }
        //                    else
        //                    {
        //                        this._subtotalTotal[aStore.Index].QtyAllocated = aItemQtyAllocated;
        //                    }
        //                    break;
        //                }
        //            default:
        //                {
        //                    throw new MIDException(eErrorLevel.severe,
        //                        (int)eMIDTextCode.msg_al_UnknownComponentType,
        //                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                }
        //        }
        //    }
        //    else
        //    {
        //        success = SpreadStoreSubtotalItemToHeaders(
        //            aGeneralComponent,
        //            aStore,
        //            aItemQtyAllocated,
        //            aDistributeChange,
        //            aIsManual);
        //    }
        //    return success;
        //}
        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPackName">Pack name.</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        ///// <returns>True when update is successful; false otherwise</returns>
        ///// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        //public bool SetStoreImoQtyAllocated(string aSubtotalPackName, int aStoreRID, int aItemQtyAllocated)
        //{
        //    return SetStoreImoQtyAllocated(aSubtotalPackName, StoreIndex(aStoreRID), aItemQtyAllocated, eDistributeChange.ToAll, true);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPackName">Subtotal Pack name.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
        ///// <param name="aIsManual">True: Indicates this is a manually keyed value.</param> 
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreImoQtyAllocated(string aSubtotalPackName, Index_RID aStore, int aItemQtyAllocated,
        //    eDistributeChange aDistributeChange, bool aIsManual)
        //{
        //    return SetStoreImoQtyAllocated(GetSubtotalPackHdr(aSubtotalPackName), aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        ///// <param name="aDistributeChange">Indicates how to apply the new value to the parent and/or children components of this component.</param>
        ///// <param name="aIsManual">True: indicates this is a manually keyed value.</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreImoQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        //{
        //    return SetStoreImoQtyAllocated(
        //        aSubtotalPack,
        //        aStore,
        //        aItemQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        ///// <param name="aDistributeChange">Indicates how to apply the new value to the parent and/or children components of this component.</param>
        ///// <param name="aIsManual">True: indicates this is a manually keyed value.</param>
        ///// <param name="aAddNewMember">True: indicates Item Quantity is result of adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //private bool SetStoreImoQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
        //    bool success = true;
        //    if (aDistributeChange == eDistributeChange.ToNone)
        //    {
        //        if (!aAddNewMember
        //            && aItemQtyAllocated < this.GetStoreImoQtyLocked(aSubtotalPack, aStore))
        //        {
        //            success = false;
        //        }
        //        else
        //        {
        //            if (aSubtotalPack.GenericPack)
        //            {
        //                this._subtotalGenericType[aStore.Index].ItemQtyAllocated -=
        //                    aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
        //                    * aSubtotalPack.PackMultiple;
        //            }
        //            else
        //            {
        //                this._subtotalTotalNonGenericItemUnitsAllocated[aStore.Index] -=
        //                    aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
        //                    * aSubtotalPack.PackMultiple;
        //            }
        //            aSubtotalPack.SetStorePacksAllocated(aStore.Index, aItemQtyAllocated);
        //            if (aSubtotalPack.GenericPack)
        //            {
        //                this._subtotalGenericType[aStore.Index].ItemQtyAllocated +=
        //                    aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
        //                    * aSubtotalPack.PackMultiple;
        //            }
        //            else
        //            {
        //                this._subtotalTotalNonGenericItemUnitsAllocated[aStore.Index] +=
        //                    aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
        //                    * aSubtotalPack.PackMultiple;
        //            }
        //        }
        //    }
        //    else
        //    {
        //        AllocationPackComponent apc = new AllocationPackComponent(aSubtotalPack.PackName);
        //        success = SpreadStoreSubtotalItemToHeaders(
        //            apc,
        //            aStore,
        //            aItemQtyAllocated,
        //            aDistributeChange,
        //            aIsManual);
        //    }
        //    return success;
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color.</param>
        ///// <param name="aStoreRID">RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        ///// <remarks>
        ///// <para>
        ///// Values interfaced via this method instance are assumed to be manually specified by the user.
        ///// </para><para>
        ///// Also, Values interfaced via this method instance are assumed to be applied to parent nodes but not children nodes.
        ///// </para>
        ///// </remarks>
        //public bool SetStoreImoQtyAllocated(int aColorCodeRID, int aStoreRID, int aItemQtyAllocated)
        //{
        //    return SetStoreImoQtyAllocated(aColorCodeRID, StoreIndex(aStoreRID), aItemQtyAllocated, eDistributeChange.ToParent, true);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how to process the changed value on the parent and children components of this component.</param>
        ///// <param name="aIsManual">True: indicates this a value keyed directly by the user; false indicates this value was not keyed by the user.</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreImoQtyAllocated(int aColorCodeRID, Index_RID aStore, int aItemQtyAllocated,
        //    eDistributeChange aDistributeChange, bool aIsManual)
        //{
        //    return SetStoreImoQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how to apply the new value to parent and children components.</param>
        ///// <param name="aIsManual">True: Indicates a manually keyed value by the user.</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreImoQtyAllocated(HdrColorBin aColor, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        //{
        //    return SetStoreImoQtyAllocated(
        //        aColor,
        //        aStore,
        //        aItemQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how to apply the new value to parent and children components.</param>
        ///// <param name="aIsManual">True: Indicates a manually keyed value by the user.</param>
        ///// <param name="aAddNewMember">True: Indicates Item Quantity is result of adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //private bool SetStoreImoQtyAllocated(HdrColorBin aColor, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
        //    bool success = true;
        //    if (!aAddNewMember
        //        && aItemQtyAllocated < this.GetStoreImoQtyLocked(aColor, aStore))
        //    {
        //        success = false;
        //    }
        //    else
        //    {
        //        if (aDistributeChange == eDistributeChange.ToNone)
        //        {
        //            aColor.SetStoreItemUnitsAllocated(aStore.Index, aItemQtyAllocated);
        //        }
        //        else
        //        {
        //            AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColor.ColorCodeRID);
        //            success = SpreadStoreSubtotalToHeaders(
        //                colorComponent,
        //                aStore,
        //                aItemQtyAllocated,
        //                aDistributeChange,
        //                aIsManual);
        //        }
        //        if (this._storeListSizePctToColorHash.Contains(aColor.ColorCodeRID))
        //        {
        //            this._storeListSizePctToColorHash.Remove(aColor.ColorCodeRID);
        //        }
        //    }
        //    return success;
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified color-size node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStoreRID">RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        ///// <remarks>
        ///// <para>
        ///// Values interfaced via this method instance are assumed to be manually specified by the user.
        ///// </para>
        ///// </remarks>
        //public bool SetStoreImoQtyAllocated(int aColorCodeRID, int aSizeRID, int aStoreRID, int aItemQtyAllocated)
        //{
        //    return SetStoreImoQtyAllocated(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aItemQtyAllocated, eDistributeChange.ToNone, true);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated audit flag for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        ///// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreImoQtyAllocated(int aColorCodeRID, int aSizeRID, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        //{
        //    return SetStoreImoQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore,
        //        aItemQtyAllocated, aDistributeChange, aIsManual);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        ///// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        ///// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreImoQtyAllocated(HdrColorBin aColor, int aSizeRID, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        //{
        //    return SetStoreImoQtyAllocated(GetSubtotalHdrSizeBin(aColor, aSizeRID),
        //        aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        ///// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreImoQtyAllocated(HdrSizeBin aSize, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        //{
        //    return SetStoreImoQtyAllocated(
        //        aSize,
        //        aStore,
        //        aItemQtyAllocated,
        //        aDistributeChange,
        //        aIsManual,
        //        false);
        //}

        ///// <summary>
        ///// Sets Store Item Quantity Allocated for specified store on specified color node.
        ///// </summary>
        ///// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        ///// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        ///// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        ///// <param name="aAddNewMember">True indicates Item Quantity is result of adding a new member; false otherwise</param>
        ///// <returns>True when update is successful; false otherwise.</returns>
        //internal bool SetStoreImoQtyAllocated(HdrSizeBin aSize, Index_RID aStore,
        //    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        //{
        //    bool success = true;
        //    if (aItemQtyAllocated < this.GetStoreImoQtyLocked(aSize, aStore))
        //    {
        //        success = false;
        //    }
        //    else
        //    {
        //        if (aDistributeChange == eDistributeChange.ToNone)
        //        {
        //            aSize.SetStoreSizeUnitsAllocated(aStore.Index, aItemQtyAllocated);
        //        }
        //        else
        //        {
        //            AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aSize.Color.ColorCodeRID);
        //            AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSize.SizeCodeRID); // Assortment: color/size changes
        //            AllocationColorSizeComponent colorSizeComponent = new AllocationColorSizeComponent(colorComponent, sizeComponent);
        //            success = SpreadStoreSubtotalItemToHeaders(
        //                colorSizeComponent,
        //                aStore,
        //                aItemQtyAllocated,
        //                aDistributeChange,
        //                aIsManual);
        //        }
        //        aSize.Color.SetReCalcStoreTotalSizePctToColor(aStore.Index, true);
        //    }
        //    return success;
        //}
        //#endregion SetStoreImoQtyAllocated
        // end TT#1401 - Stodd - Urban Reservation Stores
		#endregion StoreIMOQuantityAllocated


		#region StoreIMOMaxValue
        // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
        /// <summary>
        /// Gets Store Subtotal Item Max Value for specified store on specified component of the specified Allocation Profile.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Max Value to the store for the specified component.</returns>
        public int GetStoreImoMaxValue(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
        {
            if (aAllocationProfile == null)
            {
                return 0;  // There is NO subtotal for the variable ImoMaxValue (it is not possible to combine the MAX values and get an accurate maximum value for a store across all selected headers)
            }
            if (aComponent.ComponentType == eComponentType.SpecificPack)
            {
                AllocationPackComponent apc = (AllocationPackComponent)aComponent;
                if (!aAllocationProfile.PackIsOnHeader(apc.PackName))
                {
                    return 0;
                }
            }
            if (aComponent.ComponentType == eComponentType.SpecificColor)
            {
                AllocationColorOrSizeComponent acsc = (AllocationColorOrSizeComponent)aComponent;
                if (!aAllocationProfile.BulkColorIsOnHeader(acsc.ColorRID))
                {
                    return 0;
                }
            }
            //return aAllocationProfile.GetStoreImoMaxValue(aComponent, StoreIndex(aStoreRID));
            return aAllocationProfile.GetStoreImoMaxValue(StoreIndex(aStoreRID));
        }    
        //// begin TT#1401 - STodd - Urban Reservation Stores
        //#region GetStoreImoMaxValue
        ///// <summary>
        ///// Gets Store Subtotal Item Max Value for specified store on specified component of the specified Allocation Profile.
        ///// </summary>
        ///// <param name="aAllocationProfile">Allocation Profile</param>
        ///// <param name="aComponent">Description of the component</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>Item Max Value to the store for the specified component.</returns>
        //public int GetStoreImoMaxValue(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        return GetStoreImoMaxValue(aComponent, StoreIndex(aStoreRID));
        //    }
        //    if (aComponent.ComponentType == eComponentType.SpecificPack)
        //    {
        //        AllocationPackComponent apc = (AllocationPackComponent)aComponent;
        //        if (!aAllocationProfile.PackIsOnHeader(apc.PackName))
        //        {
        //            return 0;
        //        }
        //    }
        //    if (aComponent.ComponentType == eComponentType.SpecificColor)
        //    {
        //        AllocationColorOrSizeComponent acsc = (AllocationColorOrSizeComponent)aComponent;
        //        if (!aAllocationProfile.BulkColorIsOnHeader(acsc.ColorRID))
        //        {
        //            return 0;
        //        }
        //    }
        //    //return aAllocationProfile.GetStoreImoMaxValue(aComponent, StoreIndex(aStoreRID));
        //    return aAllocationProfile.GetStoreImoMaxValue(StoreIndex(aStoreRID));
        //}

        ///// <summary>
        ///// Gets Store Subtotal IMO Max Value for specified store on specified component.
        ///// </summary>
        ///// <param name="aComponent">Description of the component</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>IMO Max Value to the store for the specified component.</returns>
        //public int GetStoreImoMaxValue(GeneralComponent aComponent, int aStoreRID)
        //{
        //    return GetStoreImoMaxValue(aComponent, StoreIndex(aStoreRID));
        //}

        ///// <summary>
        ///// Gets Store Subtotal IMO Max Value for specified store on specified component.
        ///// </summary>
        ///// <param name="aComponent">Description of the component</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>IMO Max Value to the store for the specified component.</returns>
        //internal int GetStoreImoMaxValue(GeneralComponent aComponent, Index_RID aStore)
        //{
        //    int allocated;
        //    AllocationPackComponent packComponent;
        //    AllocationColorOrSizeComponent colorComponent;
        //    AllocationColorOrSizeComponent sizeComponent;
        //    switch (aComponent.ComponentType)
        //    {
        //        case (eComponentType.AllColors):
        //            {
        //                return GetStoreImoMaxValue(eAllocationSummaryNode.BulkColorTotal, aStore);
        //            }
        //        case (eComponentType.AllGenericPacks):
        //            {
        //                return GetStoreImoMaxValue(eAllocationSummaryNode.GenericType, aStore);
        //            }
        //        case (eComponentType.AllNonGenericPacks):
        //            {
        //                if (this.BulkIsDetail)
        //                {
        //                    return
        //                        (GetStoreImoMaxValue(eAllocationSummaryNode.DetailSubType, aStore)
        //                        - GetStoreImoMaxValue(eAllocationSummaryNode.Bulk, aStore));
        //                }
        //                return GetStoreImoMaxValue(eAllocationSummaryNode.DetailSubType, aStore);
        //            }
        //        case (eComponentType.AllPacks):
        //            {
        //                if (this.BulkIsDetail)
        //                {
        //                    return
        //                        GetStoreImoMaxValue(eAllocationSummaryNode.GenericType, aStore)
        //                        + GetStoreImoMaxValue(eAllocationSummaryNode.DetailSubType, aStore)
        //                        - GetStoreImoMaxValue(eAllocationSummaryNode.Bulk, aStore);
        //                }
        //                return
        //                    GetStoreImoMaxValue(eAllocationSummaryNode.GenericType, aStore)
        //                    + GetStoreImoMaxValue(eAllocationSummaryNode.DetailSubType, aStore);
        //            }
        //        case (eComponentType.AllSizes):
        //            {
        //                allocated = 0;
        //                foreach (HdrColorBin hcb in BulkColors.Values)
        //                {
        //                    foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
        //                    {
        //                        allocated += this.GetStoreImoMaxValue(hsb, aStore);
        //                    }
        //                }
        //                return allocated;
        //            }
        //        case (eComponentType.Bulk):
        //            {
        //                return GetStoreImoMaxValue(eAllocationSummaryNode.Bulk, aStore);
        //            }
        //        case (eComponentType.ColorAndSize):
        //            {
        //                allocated = 0;
        //                AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
        //                GeneralComponent color = acs.ColorComponent;
        //                GeneralComponent size = acs.SizeComponent;
        //                switch (color.ComponentType)
        //                {
        //                    case (eComponentType.AllColors):
        //                        {
        //                            switch (size.ComponentType)
        //                            {
        //                                case (eComponentType.AllSizes):
        //                                    {
        //                                        foreach (HdrColorBin hcb in BulkColors.Values)
        //                                        {
        //                                            foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
        //                                            {
        //                                                allocated += GetStoreImoMaxValue(hsb, aStore);
        //                                            }
        //                                        }
        //                                        break;
        //                                    }
        //                                case (eComponentType.SpecificSize):
        //                                    {
        //                                        sizeComponent = (AllocationColorOrSizeComponent)size;
        //                                        foreach (HdrColorBin hcb in BulkColors.Values)
        //                                        {
        //                                            if (hcb.SizeIsInColor(sizeComponent.SizeRID))
        //                                            {
        //                                                allocated += GetStoreImoMaxValue(hcb, sizeComponent.SizeRID, aStore);
        //                                            }
        //                                        }
        //                                        break;
        //                                    }
        //                                case (eComponentType.SpecificSizePrimaryDim):
        //                                    {
        //                                        sizeComponent = (AllocationColorOrSizeComponent)size;
        //                                        SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
        //                                        foreach (HdrColorBin hcb in BulkColors.Values)
        //                                        {
        //                                            foreach (SizeCodeProfile scp in scl)
        //                                            {
        //                                                if (hcb.SizeIsInColor(scp.Key))
        //                                                {
        //                                                    allocated += GetStoreImoMaxValue(hcb, scp.Key, aStore);
        //                                                }
        //                                            }
        //                                        }
        //                                        break;
        //                                    }
        //                                case (eComponentType.SpecificSizeSecondaryDim):
        //                                    {
        //                                        sizeComponent = (AllocationColorOrSizeComponent)size;
        //                                        SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
        //                                        foreach (HdrColorBin hcb in BulkColors.Values)
        //                                        {
        //                                            foreach (SizeCodeProfile scp in scl)
        //                                            {
        //                                                if (hcb.SizeIsInColor(scp.Key))
        //                                                {
        //                                                    allocated += GetStoreImoMaxValue(hcb, scp.Key, aStore);
        //                                                }
        //                                            }
        //                                        }
        //                                        break;
        //                                    }
        //                                default:
        //                                    {
        //                                        throw new MIDException(eErrorLevel.severe,
        //                                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                                    }
        //                            }
        //                            break;
        //                        }
        //                    case (eComponentType.SpecificColor):
        //                        {
        //                            colorComponent = (AllocationColorOrSizeComponent)color;
        //                            if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
        //                            {
        //                                switch (size.ComponentType)
        //                                {
        //                                    case (eComponentType.AllSizes):
        //                                        {
        //                                            foreach (HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
        //                                            {
        //                                                allocated += GetStoreImoMaxValue(hsb, aStore);
        //                                            }
        //                                            break;
        //                                        }
        //                                    case (eComponentType.SpecificSize):
        //                                        {
        //                                            sizeComponent = (AllocationColorOrSizeComponent)size;
        //                                            if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
        //                                            {
        //                                                allocated += GetStoreImoMaxValue(colorComponent.ColorRID, sizeComponent.SizeRID, aStore);
        //                                            }
        //                                            break;
        //                                        }
        //                                    case (eComponentType.SpecificSizePrimaryDim):
        //                                        {
        //                                            sizeComponent = (AllocationColorOrSizeComponent)size;
        //                                            SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
        //                                            HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
        //                                            foreach (SizeCodeProfile scp in scl)
        //                                            {
        //                                                if (hcb.SizeIsInColor(scp.Key))
        //                                                {
        //                                                    allocated += GetStoreImoMaxValue(hcb, scp.Key, aStore);
        //                                                }
        //                                            }
        //                                            break;
        //                                        }
        //                                    case (eComponentType.SpecificSizeSecondaryDim):
        //                                        {
        //                                            sizeComponent = (AllocationColorOrSizeComponent)size;
        //                                            SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
        //                                            HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
        //                                            foreach (SizeCodeProfile scp in scl)
        //                                            {
        //                                                if (hcb.SizeIsInColor(scp.Key))
        //                                                {
        //                                                    allocated += GetStoreImoMaxValue(hcb, scp.Key, aStore);
        //                                                }
        //                                            }
        //                                            break;
        //                                        }
        //                                    default:
        //                                        {
        //                                            throw new MIDException(eErrorLevel.severe,
        //                                                (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                                        }
        //                                }
        //                            }
        //                            break;
        //                        }
        //                    default:
        //                        {
        //                            throw new MIDException(eErrorLevel.severe,
        //                                (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                        }
        //                }
        //                return allocated;
        //            }
        //        case (eComponentType.DetailType):
        //            {
        //                return GetStoreImoMaxValue(eAllocationSummaryNode.DetailType, aStore);
        //            }
        //        case (eComponentType.GenericType):
        //            {
        //                return GetStoreImoMaxValue(eAllocationSummaryNode.GenericType, aStore);
        //            }
        //        case (eComponentType.SpecificColor):
        //            {
        //                colorComponent = (AllocationColorOrSizeComponent)aComponent;
        //                return GetStoreImoMaxValue(colorComponent.ColorRID, aStore);
        //            }
        //        case (eComponentType.SpecificSize):
        //            {
        //                sizeComponent = (AllocationColorOrSizeComponent)aComponent;
        //                allocated = 0;
        //                foreach (HdrColorBin hcb in BulkColors.Values)
        //                {
        //                    if (hcb.SizeIsInColor(sizeComponent.SizeRID))
        //                    {
        //                        allocated += GetStoreImoMaxValue(hcb, sizeComponent.SizeRID, aStore);
        //                    }
        //                }
        //                return allocated;
        //            }
        //        case (eComponentType.SpecificPack):
        //            {
        //                packComponent = (AllocationPackComponent)aComponent;
        //                return GetStoreImoMaxValue(packComponent.PackName, aStore);
        //            }
        //        case (eComponentType.Total):
        //            {
        //                return GetStoreImoMaxValue(eAllocationSummaryNode.Total, aStore);
        //            }
        //        default:
        //            {
        //                throw new MIDException(eErrorLevel.severe,
        //                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //            }
        //    }
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //public int GetStoreImoMaxValue(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
        //{
        //    return GetStoreImoMaxValue(aAllocationSummaryNode, StoreIndex(aStoreRID));
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //internal int GetStoreImoMaxValue(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
        //{
        //    if (this._buildSubtotal)
        //    {
        //        this.RebuildSubtotal();
        //    }
        //    switch (aAllocationSummaryNode)
        //    {
        //        case (eAllocationSummaryNode.Total):
        //            {
        //                return _subtotalTotal[aStore.Index].ImoQtyAllocated;
        //            }
        //        case (eAllocationSummaryNode.Type):
        //            {
        //                return (_subtotalGenericType[aStore.Index].ImoQtyAllocated
        //                    + _subtotalDetailType[aStore.Index].ImoQtyAllocated);
        //            }
        //        case (eAllocationSummaryNode.GenericType):
        //            {
        //                return _subtotalGenericType[aStore.Index].ImoQtyAllocated;
        //            }
        //        case (eAllocationSummaryNode.DetailType):
        //            {
        //                return _subtotalDetailType[aStore.Index].ImoQtyAllocated;
        //            }
        //        case (eAllocationSummaryNode.DetailSubType):
        //            {
        //                if (BulkIsDetail)
        //                {
        //                    return (_subtotalTotalNonGenericImoUnitsAllocated[aStore.Index]	// TT#1401 - stodd - ?????????? // TT#1401 - JEllis - Urban Vitual Warehouse pt 28C
        //                        + _subtotalBulk[aStore.Index].ImoQtyAllocated);
        //                }
        //                else
        //                {
        //                    return _subtotalTotalNonGenericImoUnitsAllocated[aStore.Index];	// TT#1401 - stodd - ?????????? // TT#1401 - JEllis - Urban Virtual Warehouse pt 28C
        //                }
        //            }
        //        case (eAllocationSummaryNode.Bulk):
        //            {
        //                return _subtotalBulk[aStore.Index].ImoQtyAllocated;
        //            }
        //        case (eAllocationSummaryNode.BulkColorTotal):
        //            {
        //                int colorItemUnits = 0;
        //                foreach (HdrColorBin hcb in this.BulkColors.Values)
        //                {
        //                    colorItemUnits += this.GetStoreImoMaxValue(hcb, aStore);
        //                }
        //                return colorItemUnits;
        //            }
        //        default:
        //            {
        //                throw new MIDException(eErrorLevel.severe,
        //                    (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
        //                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
        //            }
        //    }
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPackName">Pack name.</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //public int GetStoreImoMaxValue(string aSubtotalPackName, int aStoreRID)
        //{
        //    return GetStoreImoMaxValue(aSubtotalPackName, StoreIndex(aStoreRID));
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPackName">Pack name.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //internal int GetStoreImoMaxValue(string aSubtotalPackName, Index_RID aStore)
        //{
        //    return GetStoreImoMaxValue(GetSubtotalPackHdr(aSubtotalPackName), aStore);
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPack">Pack header object where store resides.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //internal int GetStoreImoMaxValue(PackHdr aSubtotalPack, Index_RID aStore)
        //{
        //    return aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index);
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color.</param>
        ///// <param name="aStoreRID">RID for the store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //public int GetStoreImoMaxValue(int aColorCodeRID, int aStoreRID)
        //{
        //    return GetStoreImoMaxValue(aColorCodeRID, StoreIndex(aStoreRID));
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //internal int GetStoreImoMaxValue(int aColorCodeRID, Index_RID aStore)
        //{
        //    return GetStoreImoMaxValue(GetSubtotalHdrColorBin(aColorCodeRID), aStore);
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //internal int GetStoreImoMaxValue(HdrColorBin aColor, Index_RID aStore)
        //{
        //    return aColor.GetStoreItemUnitsAllocated(aStore.Index);
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStoreRID">RID for the store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //public int GetStoreImoMaxValue(int aColorCodeRID, int aSizeRID, int aStoreRID)
        //{
        //    return GetStoreImoMaxValue(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //internal int GetStoreImoMaxValue(int aColorCodeRID, int aSizeRID, Index_RID aStore)
        //{
        //    return GetStoreImoMaxValue(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //internal int GetStoreImoMaxValue(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
        //{
        //    return GetStoreImoMaxValue(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
        //}

        ///// <summary>
        ///// Gets Store IMO Max Value for specified store on specified color node.
        ///// </summary>
        ///// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>IMO Max Value to the store for the specified node.</returns>
        //internal int GetStoreImoMaxValue(HdrSizeBin aSize, Index_RID aStore)
        //{
        //    return aSize.GetStoreSizeItemUnitsAllocated(aStore.Index);
        //}
        //#endregion GetStoreImoMaxValue

        //#region SetStoreImoMaxValue
        /////// <summary>
        /////// Sets Store Subtotal IMO Max Value for specified store on specified component of the specified Allocation Profile.
        /////// </summary>
        /////// <param name="aAllocationProfile">Allocation Profile</param>
        /////// <param name="aComponent">Description of the component</param>
        /////// <param name="aStoreRID">RID for store</param>
        /////// <param name="aItemQtyAllocated">IMO Max Value</param>
        /////// <returns>True when update successful; False otherwise</returns>
        /////// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        ////public bool SetStoreImoQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, int aItemQtyAllocated)
        ////{
        ////    if (aAllocationProfile == null)
        ////    {
        ////        return SetStoreImoQtyAllocated(aComponent, aStoreRID, aItemQtyAllocated);
        ////    }
        ////    if (aAllocationProfile.SetStoreImoQtyAllocated(aComponent, aStoreRID, aItemQtyAllocated) == eAllocationUpdateStatus.Successful)
        ////    {
        ////        return true;
        ////    }
        ////    return false;
        ////}


        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified node.
        /////// </summary>
        /////// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /////// <param name="aStoreRID">RID for store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <returns>True when update successful; False otherwise</returns>
        /////// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        ////public bool SetStoreImoQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, int aItemQtyAllocated)
        ////{
        ////    Index_RID storeIndexRID = StoreIndex(aStoreRID);
        ////    return SetStoreImoQtyAllocated(aAllocationSummaryNode, storeIndexRID, aItemQtyAllocated,
        ////        eDistributeChange.ToAll, true);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified node.
        /////// </summary>
        /////// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /////// <param name="aStore">Index_RID for store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        /////// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////internal bool SetStoreImoQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode,
        ////    Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        ////{
        ////    return SetStoreImoQtyAllocated(
        ////        aAllocationSummaryNode,
        ////        aStore,
        ////        aItemQtyAllocated,
        ////        aDistributeChange,
        ////        aIsManual,
        ////        false);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified node.
        /////// </summary>
        /////// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /////// <param name="aStore">Index_RID for store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        /////// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        /////// <param name="aAddNewMember">True indicates Item Quantity resulted from adding a new member; false otherwise</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////private bool SetStoreImoQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode,
        ////    Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        ////{
        ////    GeneralComponent gc;
        ////    switch (aAllocationSummaryNode)
        ////    {
        ////        case (eAllocationSummaryNode.Bulk):
        ////            {
        ////                gc = new GeneralComponent(eGeneralComponentType.Bulk);
        ////                break;
        ////            }
        ////        case (eAllocationSummaryNode.BulkColorTotal):
        ////            {
        ////                throw new MIDException(eErrorLevel.severe,
        ////                    (int)(eMIDTextCode.msg_al_QtyAloctdBulkColorTotalSummaryReadOnly),
        ////                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdBulkColorTotalSummaryReadOnly));
        ////            }
        ////        case (eAllocationSummaryNode.DetailSubType):
        ////            {
        ////                throw new MIDException(eErrorLevel.severe,
        ////                    (int)(eMIDTextCode.msg_al_QtyAloctdDetailSubTypeSummaryReadOnly),
        ////                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdDetailSubTypeSummaryReadOnly));
        ////            }
        ////        case (eAllocationSummaryNode.DetailType):
        ////            {
        ////                gc = new GeneralComponent(eGeneralComponentType.DetailType);
        ////                break;
        ////            }
        ////        case (eAllocationSummaryNode.GenericType):
        ////            {
        ////                gc = new GeneralComponent(eGeneralComponentType.GenericType);
        ////                break;
        ////            }
        ////        case (eAllocationSummaryNode.Total):
        ////            {
        ////                gc = new GeneralComponent(eGeneralComponentType.Total);
        ////                break;
        ////            }
        ////        case (eAllocationSummaryNode.Type):
        ////            {
        ////                throw new MIDException(eErrorLevel.severe,
        ////                    (int)(eMIDTextCode.msg_al_QtyAloctdTypeSummaryReadOnly),
        ////                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_QtyAloctdTypeSummaryReadOnly));
        ////            }
        ////        default:
        ////            {
        ////                throw new MIDException(eErrorLevel.severe,
        ////                    (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
        ////                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
        ////            }
        ////    }
        ////    return SetStoreImoQtyAllocated(gc, aStore, aItemQtyAllocated, aDistributeChange, aIsManual, aAddNewMember);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified node.
        /////// </summary>
        /////// <param name="aGeneralComponent">Allocation summary node.</param>
        /////// <param name="aStoreRID">Index_RID for store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        /////// <remarks>Values entered via this instance of the method are assumed to be manually keyed.</remarks>
        ////public bool SetStoreImoQtyAllocated(GeneralComponent aGeneralComponent,
        ////    int aStoreRID, int aItemQtyAllocated)
        ////{
        ////    if (aGeneralComponent.ComponentType == eComponentType.ColorAndSize)
        ////    {
        ////        return SetStoreImoQtyAllocated(
        ////            aGeneralComponent,
        ////            StoreIndex(aStoreRID),
        ////            aItemQtyAllocated,
        ////            eDistributeChange.ToNone,
        ////            true);
        ////    }
        ////    else if (aGeneralComponent.ComponentType == eComponentType.SpecificColor // MID Track 3326 Cannot manually key size qty when no secondary dimension 
        ////        || aGeneralComponent.ComponentType == eComponentType.AllColors)      // MID Track 3326 Cannot manually key size qty when no secondary dimension
        ////    {
        ////        return SetStoreImoQtyAllocated(
        ////            aGeneralComponent,
        ////            StoreIndex(aStoreRID),
        ////            aItemQtyAllocated,
        ////            eDistributeChange.ToParent,
        ////            true);
        ////    }
        ////    return SetStoreImoQtyAllocated(
        ////        aGeneralComponent,
        ////        StoreIndex(aStoreRID),
        ////        aItemQtyAllocated,
        ////        eDistributeChange.ToAll,
        ////        true);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified node.
        /////// </summary>
        /////// <param name="aGeneralComponent">Allocation summary node.</param>
        /////// <param name="aStore">Index_RID for store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        /////// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        /////// <returns>True when update is successful; false otherwise</returns>
        ////internal bool SetStoreImoQtyAllocated(GeneralComponent aGeneralComponent,
        ////    Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        ////{
        ////    return SetStoreImoQtyAllocated(
        ////        aGeneralComponent,
        ////        aStore,
        ////        aItemQtyAllocated,
        ////        aDistributeChange,
        ////        aIsManual,
        ////        false);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified node.
        /////// </summary>
        /////// <param name="aGeneralComponent">Allocation summary node.</param>
        /////// <param name="aStore">Index_RID for store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how these units should be distributed to parent and children components.</param>
        /////// <param name="aIsManual">True indicates a manually key value; false indicate otherwise.</param>
        /////// <param name="aAddNewMember">True indicates a new allocation profile is being added to the subtotal, false indicates otherwise.</param>
        /////// <returns>True when update is successful; false otherwise</returns>
        ////private bool SetStoreImoQtyAllocated(GeneralComponent aGeneralComponent,
        ////    Index_RID aStore, int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        ////{
        ////    bool success = true;
        ////    if (aDistributeChange == eDistributeChange.ToNone)
        ////    {
        ////        AllocationColorOrSizeComponent color;
        ////        AllocationColorOrSizeComponent size;
        ////        switch (aGeneralComponent.ComponentType)
        ////        {
        ////            case (eComponentType.AllColors):
        ////                {
        ////                    throw new MIDException(eErrorLevel.severe,
        ////                        (int)eMIDTextCode.msg_al_AllColorAllocatedReadOnly,
        ////                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllColorAllocatedReadOnly));
        ////                }
        ////            case (eComponentType.AllGenericPacks):
        ////                {
        ////                    throw new MIDException(eErrorLevel.severe,
        ////                        (int)eMIDTextCode.msg_al_AllGenericPacksAllocatedReadOnly,
        ////                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllGenericPacksAllocatedReadOnly));
        ////                }
        ////            case (eComponentType.AllNonGenericPacks):
        ////                {
        ////                    throw new MIDException(eErrorLevel.severe,
        ////                        (int)eMIDTextCode.msg_al_AllNonGenericPacksAllocatedReadOnly,
        ////                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllNonGenericPacksAllocatedReadOnly));
        ////                }
        ////            case (eComponentType.AllPacks):
        ////                {
        ////                    throw new MIDException(eErrorLevel.severe,
        ////                        (int)eMIDTextCode.msg_al_AllPacksAllocatedReadOnly,
        ////                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllPacksAllocatedReadOnly));
        ////                }
        ////            case (eComponentType.AllSizes):
        ////                {
        ////                    throw new MIDException(eErrorLevel.severe,
        ////                        (int)eMIDTextCode.msg_al_AllSizesAllocatedReadOnly,
        ////                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizesAllocatedReadOnly));
        ////                }
        ////            case (eComponentType.Bulk):
        ////                {
        ////                    if (!aAddNewMember
        ////                        && aItemQtyAllocated < this.GetStoreImoQtyLocked(eAllocationSummaryNode.Bulk, aStore))
        ////                    {
        ////                        success = false;
        ////                    }
        ////                    else
        ////                    {
        ////                        this._subtotalBulk[aStore.Index].ItemQtyAllocated = aItemQtyAllocated;
        ////                    }
        ////                    break;
        ////                }
        ////            case (eComponentType.ColorAndSize):
        ////                {
        ////                    AllocationColorSizeComponent colorSize = (AllocationColorSizeComponent)aGeneralComponent;
        ////                    switch (colorSize.ColorComponent.ComponentType)
        ////                    {
        ////                        case (eComponentType.AllColors):
        ////                            {
        ////                                return SpreadStoreAllColorSizeItemToColorSize(colorSize.SizeComponent, aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        ////                            }
        ////                        case (eComponentType.SpecificColor):
        ////                            {
        ////                                color = (AllocationColorOrSizeComponent)colorSize.ColorComponent;
        ////                                if (this.BulkColorIsOnSubtotal(color.ColorRID))
        ////                                {
        ////                                    switch (colorSize.SizeComponent.ComponentType)
        ////                                    {
        ////                                        case (eComponentType.AllSizes):
        ////                                            {
        ////                                                throw new MIDException(eErrorLevel.warning,
        ////                                                    (int)eMIDTextCode.msg_al_AllSizesAllocatedReadOnly,
        ////                                                    this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizesAllocatedReadOnly));
        ////                                            }
        ////                                        case (eComponentType.SpecificSize):
        ////                                            {
        ////                                                size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
        ////                                                if (this.GetSubtotalHdrColorBin(color.ColorRID).SizeIsInColor(size.SizeRID))
        ////                                                {
        ////                                                    return SetStoreImoQtyAllocated(
        ////                                                        color.ColorRID,
        ////                                                        size.SizeRID,
        ////                                                        aStore,
        ////                                                        aItemQtyAllocated,
        ////                                                        aDistributeChange,
        ////                                                        aIsManual);
        ////                                                }
        ////                                                return false;
        ////                                            }
        ////                                        case (eComponentType.SpecificSizePrimaryDim):
        ////                                            {
        ////                                                size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
        ////                                                SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(size.PrimarySizeDimRID);
        ////                                                return SpreadStoreImoQtyAcrossSizes(color.ColorRID, scl, aStore, aItemQtyAllocated);
        ////                                            }
        ////                                        case (eComponentType.SpecificSizeSecondaryDim):
        ////                                            {
        ////                                                size = (AllocationColorOrSizeComponent)colorSize.SizeComponent;
        ////                                                SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(size.SecondarySizeDimRID);
        ////                                                return SpreadStoreImoQtyAcrossSizes(color.ColorRID, scl, aStore, aItemQtyAllocated);
        ////                                            }
        ////                                        default:
        ////                                            {
        ////                                                throw new MIDException(eErrorLevel.severe,
        ////                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
        ////                                                    this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        ////                                            }
        ////                                    }

        ////                                }
        ////                                return false;
        ////                            }
        ////                        default:
        ////                            {
        ////                                throw new MIDException(eErrorLevel.severe,
        ////                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
        ////                                    this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        ////                            }
        ////                    }
        ////                }
        ////            case (eComponentType.DetailType):
        ////                {
        ////                    if (!aAddNewMember
        ////                        && aItemQtyAllocated < this.GetStoreImoQtyLocked(eAllocationSummaryNode.DetailType, aStore))
        ////                    {
        ////                        success = false;
        ////                    }
        ////                    else
        ////                    {
        ////                        this._subtotalDetailType[aStore.Index].QtyAllocated = aItemQtyAllocated;
        ////                    }
        ////                    break;
        ////                }
        ////            case (eComponentType.GenericType):
        ////                {
        ////                    if (!aAddNewMember
        ////                        && aItemQtyAllocated < this.GetStoreImoQtyLocked(eAllocationSummaryNode.GenericType, aStore))
        ////                    {
        ////                        success = false;
        ////                    }
        ////                    else
        ////                    {
        ////                        this._subtotalGenericType[aStore.Index].QtyAllocated = aItemQtyAllocated;
        ////                    }
        ////                    break;
        ////                }
        ////            case (eComponentType.SpecificColor):
        ////                {
        ////                    color = (AllocationColorOrSizeComponent)aGeneralComponent;
        ////                    success = SetStoreImoQtyAllocated(this.GetSubtotalHdrColorBin(color.ColorRID), aStore, aItemQtyAllocated, aDistributeChange, aIsManual, aAddNewMember);
        ////                    break;
        ////                }
        ////            case (eComponentType.SpecificPack):
        ////                {
        ////                    AllocationPackComponent pack = (AllocationPackComponent)aGeneralComponent;
        ////                    success = SetStoreImoQtyAllocated(this.GetSubtotalPackHdr(pack.PackName), aStore, aItemQtyAllocated, aDistributeChange, aIsManual, aAddNewMember);
        ////                    break;
        ////                }
        ////            case (eComponentType.SpecificSize):
        ////                {
        ////                    throw new MIDException(eErrorLevel.severe,
        ////                        (int)eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize,
        ////                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SizeRequestRequiresColorAndSize));
        ////                }
        ////            case (eComponentType.Total):
        ////                {
        ////                    if (!aAddNewMember
        ////                        && aItemQtyAllocated < this.GetStoreImoQtyLocked(eAllocationSummaryNode.Total, aStore))
        ////                    {
        ////                        success = false;
        ////                    }
        ////                    else
        ////                    {
        ////                        this._subtotalTotal[aStore.Index].QtyAllocated = aItemQtyAllocated;
        ////                    }
        ////                    break;
        ////                }
        ////            default:
        ////                {
        ////                    throw new MIDException(eErrorLevel.severe,
        ////                        (int)eMIDTextCode.msg_al_UnknownComponentType,
        ////                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        ////                }
        ////        }
        ////    }
        ////    else
        ////    {
        ////        success = SpreadStoreSubtotalItemToHeaders(
        ////            aGeneralComponent,
        ////            aStore,
        ////            aItemQtyAllocated,
        ////            aDistributeChange,
        ////            aIsManual);
        ////    }
        ////    return success;
        ////}
        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified pack node.
        /////// </summary>
        /////// <param name="aSubtotalPackName">Pack name.</param>
        /////// <param name="aStoreRID">RID for store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        /////// <returns>True when update is successful; false otherwise</returns>
        /////// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        ////public bool SetStoreImoQtyAllocated(string aSubtotalPackName, int aStoreRID, int aItemQtyAllocated)
        ////{
        ////    return SetStoreImoQtyAllocated(aSubtotalPackName, StoreIndex(aStoreRID), aItemQtyAllocated, eDistributeChange.ToAll, true);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified pack node.
        /////// </summary>
        /////// <param name="aSubtotalPackName">Subtotal Pack name.</param>
        /////// <param name="aStore">Index_RID for store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how the change should be reflected in parent and children nodes</param>
        /////// <param name="aIsManual">True: Indicates this is a manually keyed value.</param> 
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////internal bool SetStoreImoQtyAllocated(string aSubtotalPackName, Index_RID aStore, int aItemQtyAllocated,
        ////    eDistributeChange aDistributeChange, bool aIsManual)
        ////{
        ////    return SetStoreImoQtyAllocated(GetSubtotalPackHdr(aSubtotalPackName), aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified pack node.
        /////// </summary>
        /////// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
        /////// <param name="aStore">Index_RID for store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        /////// <param name="aDistributeChange">Indicates how to apply the new value to the parent and/or children components of this component.</param>
        /////// <param name="aIsManual">True: indicates this is a manually keyed value.</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////internal bool SetStoreImoQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore,
        ////    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        ////{
        ////    return SetStoreImoQtyAllocated(
        ////        aSubtotalPack,
        ////        aStore,
        ////        aItemQtyAllocated,
        ////        aDistributeChange,
        ////        aIsManual,
        ////        false);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified pack node.
        /////// </summary>
        /////// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
        /////// <param name="aStore">Index_RID for store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        /////// <param name="aDistributeChange">Indicates how to apply the new value to the parent and/or children components of this component.</param>
        /////// <param name="aIsManual">True: indicates this is a manually keyed value.</param>
        /////// <param name="aAddNewMember">True: indicates Item Quantity is result of adding a new member; false otherwise</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////private bool SetStoreImoQtyAllocated(PackHdr aSubtotalPack, Index_RID aStore,
        ////    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        ////{
        ////    bool success = true;
        ////    if (aDistributeChange == eDistributeChange.ToNone)
        ////    {
        ////        if (!aAddNewMember
        ////            && aItemQtyAllocated < this.GetStoreImoQtyLocked(aSubtotalPack, aStore))
        ////        {
        ////            success = false;
        ////        }
        ////        else
        ////        {
        ////            if (aSubtotalPack.GenericPack)
        ////            {
        ////                this._subtotalGenericType[aStore.Index].ItemQtyAllocated -=
        ////                    aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
        ////                    * aSubtotalPack.PackMultiple;
        ////            }
        ////            else
        ////            {
        ////                this._subtotalTotalNonGenericItemUnitsAllocated[aStore.Index] -=
        ////                    aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
        ////                    * aSubtotalPack.PackMultiple;
        ////            }
        ////            aSubtotalPack.SetStorePacksAllocated(aStore.Index, aItemQtyAllocated);
        ////            if (aSubtotalPack.GenericPack)
        ////            {
        ////                this._subtotalGenericType[aStore.Index].ItemQtyAllocated +=
        ////                    aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
        ////                    * aSubtotalPack.PackMultiple;
        ////            }
        ////            else
        ////            {
        ////                this._subtotalTotalNonGenericItemUnitsAllocated[aStore.Index] +=
        ////                    aSubtotalPack.GetStoreItemPacksAllocated(aStore.Index)
        ////                    * aSubtotalPack.PackMultiple;
        ////            }
        ////        }
        ////    }
        ////    else
        ////    {
        ////        AllocationPackComponent apc = new AllocationPackComponent(aSubtotalPack.PackName);
        ////        success = SpreadStoreSubtotalItemToHeaders(
        ////            apc,
        ////            aStore,
        ////            aItemQtyAllocated,
        ////            aDistributeChange,
        ////            aIsManual);
        ////    }
        ////    return success;
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified color node.
        /////// </summary>
        /////// <param name="aColorCodeRID">RID for the color.</param>
        /////// <param name="aStoreRID">RID for the store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        /////// <remarks>
        /////// <para>
        /////// Values interfaced via this method instance are assumed to be manually specified by the user.
        /////// </para><para>
        /////// Also, Values interfaced via this method instance are assumed to be applied to parent nodes but not children nodes.
        /////// </para>
        /////// </remarks>
        ////public bool SetStoreImoQtyAllocated(int aColorCodeRID, int aStoreRID, int aItemQtyAllocated)
        ////{
        ////    return SetStoreImoQtyAllocated(aColorCodeRID, StoreIndex(aStoreRID), aItemQtyAllocated, eDistributeChange.ToParent, true);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified color node.
        /////// </summary>
        /////// <param name="aColorCodeRID">RID for the color.</param>
        /////// <param name="aStore">Index_RID for the store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how to process the changed value on the parent and children components of this component.</param>
        /////// <param name="aIsManual">True: indicates this a value keyed directly by the user; false indicates this value was not keyed by the user.</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////internal bool SetStoreImoQtyAllocated(int aColorCodeRID, Index_RID aStore, int aItemQtyAllocated,
        ////    eDistributeChange aDistributeChange, bool aIsManual)
        ////{
        ////    return SetStoreImoQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified color node.
        /////// </summary>
        /////// <param name="aColor">HdrColorBin for the color.</param>
        /////// <param name="aStore">Index_RID for the store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how to apply the new value to parent and children components.</param>
        /////// <param name="aIsManual">True: Indicates a manually keyed value by the user.</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////internal bool SetStoreImoQtyAllocated(HdrColorBin aColor, Index_RID aStore,
        ////    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        ////{
        ////    return SetStoreImoQtyAllocated(
        ////        aColor,
        ////        aStore,
        ////        aItemQtyAllocated,
        ////        aDistributeChange,
        ////        aIsManual,
        ////        false);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified color node.
        /////// </summary>
        /////// <param name="aColor">HdrColorBin for the color.</param>
        /////// <param name="aStore">Index_RID for the store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how to apply the new value to parent and children components.</param>
        /////// <param name="aIsManual">True: Indicates a manually keyed value by the user.</param>
        /////// <param name="aAddNewMember">True: Indicates Item Quantity is result of adding a new member; false otherwise</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////private bool SetStoreImoQtyAllocated(HdrColorBin aColor, Index_RID aStore,
        ////    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        ////{
        ////    bool success = true;
        ////    if (!aAddNewMember
        ////        && aItemQtyAllocated < this.GetStoreImoQtyLocked(aColor, aStore))
        ////    {
        ////        success = false;
        ////    }
        ////    else
        ////    {
        ////        if (aDistributeChange == eDistributeChange.ToNone)
        ////        {
        ////            aColor.SetStoreItemUnitsAllocated(aStore.Index, aItemQtyAllocated);
        ////        }
        ////        else
        ////        {
        ////            AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColor.ColorCodeRID);
        ////            success = SpreadStoreSubtotalToHeaders(
        ////                colorComponent,
        ////                aStore,
        ////                aItemQtyAllocated,
        ////                aDistributeChange,
        ////                aIsManual);
        ////        }
        ////        if (this._storeListSizePctToColorHash.Contains(aColor.ColorCodeRID))
        ////        {
        ////            this._storeListSizePctToColorHash.Remove(aColor.ColorCodeRID);
        ////        }
        ////    }
        ////    return success;
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified color-size node.
        /////// </summary>
        /////// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /////// <param name="aSizeRID">RID for the size.</param>
        /////// <param name="aStoreRID">RID for the store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        /////// <remarks>
        /////// <para>
        /////// Values interfaced via this method instance are assumed to be manually specified by the user.
        /////// </para>
        /////// </remarks>
        ////public bool SetStoreImoQtyAllocated(int aColorCodeRID, int aSizeRID, int aStoreRID, int aItemQtyAllocated)
        ////{
        ////    return SetStoreImoQtyAllocated(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aItemQtyAllocated, eDistributeChange.ToNone, true);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated audit flag for specified store on specified color node.
        /////// </summary>
        /////// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /////// <param name="aSizeRID">RID for the size.</param>
        /////// <param name="aStore">Index_RID for the store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        /////// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////internal bool SetStoreImoQtyAllocated(int aColorCodeRID, int aSizeRID, Index_RID aStore,
        ////    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        ////{
        ////    return SetStoreImoQtyAllocated(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore,
        ////        aItemQtyAllocated, aDistributeChange, aIsManual);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified color node.
        /////// </summary>
        /////// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /////// <param name="aSizeRID">RID for the size.</param>
        /////// <param name="aStore">Index_RID for the store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated.</param>
        /////// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        /////// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////internal bool SetStoreImoQtyAllocated(HdrColorBin aColor, int aSizeRID, Index_RID aStore,
        ////    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        ////{
        ////    return SetStoreImoQtyAllocated(GetSubtotalHdrSizeBin(aColor, aSizeRID),
        ////        aStore, aItemQtyAllocated, aDistributeChange, aIsManual);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified color node.
        /////// </summary>
        /////// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        /////// <param name="aStore">Index_RID for the store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        /////// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////internal bool SetStoreImoQtyAllocated(HdrSizeBin aSize, Index_RID aStore,
        ////    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual)
        ////{
        ////    return SetStoreImoQtyAllocated(
        ////        aSize,
        ////        aStore,
        ////        aItemQtyAllocated,
        ////        aDistributeChange,
        ////        aIsManual,
        ////        false);
        ////}

        /////// <summary>
        /////// Sets Store Item Quantity Allocated for specified store on specified color node.
        /////// </summary>
        /////// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        /////// <param name="aStore">Index_RID for the store</param>
        /////// <param name="aItemQtyAllocated">Item Quantity Allocated</param>
        /////// <param name="aDistributeChange">Indicates how the Item Quantity allocated is to be applied to parent nodes (there are no children nodes).</param>
        /////// <param name="aIsManual">True indicates the user manually keyed the value; false indicates otherwise.</param>
        /////// <param name="aAddNewMember">True indicates Item Quantity is result of adding a new member; false otherwise</param>
        /////// <returns>True when update is successful; false otherwise.</returns>
        ////internal bool SetStoreImoQtyAllocated(HdrSizeBin aSize, Index_RID aStore,
        ////    int aItemQtyAllocated, eDistributeChange aDistributeChange, bool aIsManual, bool aAddNewMember)
        ////{
        ////    bool success = true;
        ////    if (aItemQtyAllocated < this.GetStoreImoQtyLocked(aSize, aStore))
        ////    {
        ////        success = false;
        ////    }
        ////    else
        ////    {
        ////        if (aDistributeChange == eDistributeChange.ToNone)
        ////        {
        ////            aSize.SetStoreSizeUnitsAllocated(aStore.Index, aItemQtyAllocated);
        ////        }
        ////        else
        ////        {
        ////            AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aSize.Color.ColorCodeRID);
        ////            AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSize.SizeCodeRID); // Assortment: color/size changes
        ////            AllocationColorSizeComponent colorSizeComponent = new AllocationColorSizeComponent(colorComponent, sizeComponent);
        ////            success = SpreadStoreSubtotalItemToHeaders(
        ////                colorSizeComponent,
        ////                aStore,
        ////                aItemQtyAllocated,
        ////                aDistributeChange,
        ////                aIsManual);
        ////        }
        ////        aSize.Color.SetReCalcStoreTotalSizePctToColor(aStore.Index, true);
        ////    }
        ////    return success;
        ////}
        //#endregion SetStoreImoMaxValue
        //// end TT#1401 - Stodd - Urban Reservation Stores
        // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28C
		#endregion StoreIMOMaxValue


		#region StoreQuantityLocked
		//=================//
		// Quantity Locked //
		//=================//
		/// <summary>
		/// Gets Store Subtotal Quantity Locked Or Intransit for specified store on specified component of the specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified component.</returns>
		public int GetStoreQtyLocked(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreQtyLocked(aComponent, StoreIndex(aStoreRID));
			}
			Index_RID aStore = StoreIndex(aStoreRID);
			if (aAllocationProfile.StyleIntransitUpdated 
				|| aAllocationProfile.GetStoreLocked (aComponent, aStore)
				|| aAllocationProfile.GetStoreTempLock (aComponent, aStore))
			{
				return aAllocationProfile.GetStoreQtyAllocated(aComponent, aStore);
			}
			return 0;
		}


		/// <summary>
		/// Gets Store Subtotal Quantity Locked Or Intransit for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified component.</returns>
		public int GetStoreQtyLocked(GeneralComponent aComponent, int aStoreRID)
		{
			return GetStoreQtyLocked(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Subtotal Quantity Locked Or Intransit for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified component.</returns>
		internal int GetStoreQtyLocked(GeneralComponent aComponent, Index_RID aStore)
		{
			int locked;
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetStoreQtyLocked(eAllocationSummaryNode.BulkColorTotal, aStore);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetStoreQtyLocked(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							(GetStoreQtyLocked (eAllocationSummaryNode.DetailSubType, aStore)
							- GetStoreQtyLocked (eAllocationSummaryNode.Bulk, aStore));
					}
					return GetStoreQtyLocked(eAllocationSummaryNode.DetailSubType, aStore);
				}
				case (eComponentType.AllPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							GetStoreQtyLocked (eAllocationSummaryNode.GenericType, aStore)
							+ GetStoreQtyLocked (eAllocationSummaryNode.DetailSubType, aStore)
							- GetStoreQtyLocked (eAllocationSummaryNode.Bulk, aStore);
					}
					return
						GetStoreQtyLocked (eAllocationSummaryNode.GenericType, aStore)
						+ GetStoreQtyLocked (eAllocationSummaryNode.DetailSubType, aStore);
				}
				case (eComponentType.AllSizes):
				{
					locked = 0;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
						{
							locked += this.GetStoreQtyLocked(hsb, aStore);
						}
					}
					return locked;
				}
				case (eComponentType.Bulk):
				{
					return GetStoreQtyLocked (eAllocationSummaryNode.Bulk, aStore);
				}
				case (eComponentType.ColorAndSize):
				{
					locked = 0;
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											locked += GetStoreQtyLocked(hsb, aStore);
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										if (hcb.SizeIsInColor(sizeComponent.SizeRID))
										{
											locked += GetStoreQtyLocked(hcb, sizeComponent.SizeRID, aStore);
										}
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												locked += GetStoreQtyLocked(hcb, scp.Key, aStore);
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												locked += GetStoreQtyLocked(hcb, scp.Key, aStore);
											}
										}
									}
									break;
								}
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										foreach(HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
										{
											locked += GetStoreQtyLocked(hsb, aStore);
										}
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											locked += GetStoreQtyLocked(colorComponent.ColorRID, sizeComponent.SizeRID, aStore);
										}
										break;
									}
									// BEGIN MID Track #2412 Unknown Component
									case (eComponentType.SpecificSizePrimaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												locked += GetStoreQtyLocked(hcb, scp.Key, aStore);
											}
										}
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												locked += GetStoreQtyLocked(hcb, scp.Key, aStore);
											}
										}
										break;
									}
									// END MID Track #2412 Unknown Component
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					return locked;
				}
				case (eComponentType.DetailType):
				{
					return GetStoreQtyLocked(eAllocationSummaryNode.DetailType, aStore);
				}
				case (eComponentType.GenericType):
				{
					return GetStoreQtyLocked(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetStoreQtyLocked(colorComponent.ColorRID, aStore);
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					locked = 0;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						if (hcb.SizeIsInColor(sizeComponent.SizeRID))
						{
							locked += GetStoreQtyLocked(hcb, sizeComponent.SizeRID, aStore);
						}
					}
					return locked;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetStoreQtyLocked (packComponent.PackName, aStore);
				}
				case (eComponentType.Total):
				{
					return GetStoreQtyLocked (eAllocationSummaryNode.Total, aStore);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		public int GetStoreQtyLocked(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
		{
			return GetStoreQtyLocked(aAllocationSummaryNode, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		internal int GetStoreQtyLocked(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
		{
			int locked = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.StyleIntransitUpdated 
					|| ap.GetStoreLocked (aAllocationSummaryNode, aStore)
					|| ap.GetStoreTempLock (aAllocationSummaryNode, aStore))
				{
					locked += ap.GetStoreQtyAllocated(aAllocationSummaryNode, aStore);
				}
			}
			return locked;
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		public int GetStoreQtyLocked(string aSubtotalPackName, int aStoreRID)
		{
			return GetStoreQtyLocked(aSubtotalPackName, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		internal int GetStoreQtyLocked(string aSubtotalPackName, Index_RID aStore)
		{
			return GetStoreQtyLocked(GetSubtotalPackHdr(aSubtotalPackName), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		internal int GetStoreQtyLocked(PackHdr aSubtotalPack, Index_RID aStore)
		{
			int locked = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aSubtotalPack.PackName)
					&& ap.GetPackHdr(aSubtotalPack.PackName).PackMultiple == aSubtotalPack.PackMultiple)
				{
					PackHdr apPack = ap.GetPackHdr(aSubtotalPack.PackName);
					if (ap.StyleIntransitUpdated 
						|| ap.GetStoreLocked (apPack, aStore)
						|| ap.GetStoreTempLock (apPack, aStore))
					{
						locked += ap.GetStoreQtyAllocated(apPack, aStore);
					}
				}
			}
			return locked;
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		public int GetStoreQtyLocked(int aColorCodeRID, int aStoreRID)
		{
			return GetStoreQtyLocked(aColorCodeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		internal int GetStoreQtyLocked(int aColorCodeRID, Index_RID aStore)
		{
			return GetStoreQtyLocked(GetSubtotalHdrColorBin(aColorCodeRID), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		internal int GetStoreQtyLocked(HdrColorBin aColor, Index_RID aStore)
		{
			int locked = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					if (ap.StyleIntransitUpdated
						|| ap.GetStoreLocked(aColor.ColorCodeRID, aStore)
						|| ap.GetStoreTempLock(aColor.ColorCodeRID, aStore))
					{
						locked += ap.GetStoreQtyAllocated(aColor.ColorCodeRID, aStore);
					}
				}
			}
			return locked;
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		public int GetStoreQtyLocked(int aColorCodeRID, int aSizeRID, int aStoreRID)
		{
			return GetStoreQtyLocked(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		internal int GetStoreQtyLocked(int aColorCodeRID, int aSizeRID, Index_RID aStore)
		{
			return GetStoreQtyLocked(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		internal int GetStoreQtyLocked(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
		{
			return GetStoreQtyLocked(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Locked or Intransit for the store for the specified node.</returns>
		internal int GetStoreQtyLocked(HdrSizeBin aSize, Index_RID aStore)
		{
			int locked = 0;
			HdrColorBin apHcb;
			HdrSizeBin apHsb;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
				{
					apHcb = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (apHcb.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
					{
                        apHsb = apHcb.GetSizeBin(aSize.SizeCodeRID); // Assortment: color/size changes
						if (ap.BulkSizeIntransitUpdated
							|| ap.GetStoreLocked(apHsb, aStore)
							|| ap.GetStoreTempLock(apHsb, aStore))
						{
							locked += ap.GetStoreQtyAllocated(apHsb, aStore);
						}
					}
				}
			}
			return locked;       
		}
		#endregion StoreQuantityLocked

        // begin TT#1401 - JEllis - Urban Reservation Stores pt 2
        #region StoreItemQuantityLocked
        /// <summary>
        /// Gets Store Subtotal Item Quantity Locked Or Intransit for specified store on specified component of the specified Allocation Profile.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified component.</returns>
        public int GetStoreItemQtyLocked(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
        {
            if (aAllocationProfile == null)
            {
                return GetStoreItemQtyLocked(aComponent, StoreIndex(aStoreRID));
            }
            Index_RID aStore = StoreIndex(aStoreRID);
            if (aAllocationProfile.StyleIntransitUpdated
                || aAllocationProfile.GetStoreLocked(aComponent, aStore)
                || aAllocationProfile.GetStoreItemTempLock(aComponent, aStore))
            {
                return aAllocationProfile.GetStoreItemQtyAllocated(aComponent, aStore);
            }
            return 0;
        }


        /// <summary>
        /// Gets Store Subtotal Item Quantity Locked Or Intransit for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified component.</returns>
        public int GetStoreItemQtyLocked(GeneralComponent aComponent, int aStoreRID)
        {
            return GetStoreItemQtyLocked(aComponent, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Subtotal Item Quantity Locked Or Intransit for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified component.</returns>
        internal int GetStoreItemQtyLocked(GeneralComponent aComponent, Index_RID aStore)
        {
            int locked;
            AllocationPackComponent packComponent;
            AllocationColorOrSizeComponent colorComponent;
            AllocationColorOrSizeComponent sizeComponent;
            switch (aComponent.ComponentType)
            {
                case (eComponentType.AllColors):
                    {
                        return GetStoreItemQtyLocked(eAllocationSummaryNode.BulkColorTotal, aStore);
                    }
                case (eComponentType.AllGenericPacks):
                    {
                        return GetStoreItemQtyLocked(eAllocationSummaryNode.GenericType, aStore);
                    }
                case (eComponentType.AllNonGenericPacks):
                    {
                        if (this.BulkIsDetail)
                        {
                            return
                                (GetStoreItemQtyLocked(eAllocationSummaryNode.DetailSubType, aStore)
                                - GetStoreItemQtyLocked(eAllocationSummaryNode.Bulk, aStore));
                        }
                        return GetStoreItemQtyLocked(eAllocationSummaryNode.DetailSubType, aStore);
                    }
                case (eComponentType.AllPacks):
                    {
                        if (this.BulkIsDetail)
                        {
                            return
                                GetStoreItemQtyLocked(eAllocationSummaryNode.GenericType, aStore)
                                + GetStoreItemQtyLocked(eAllocationSummaryNode.DetailSubType, aStore)
                                - GetStoreItemQtyLocked(eAllocationSummaryNode.Bulk, aStore);
                        }
                        return
                            GetStoreItemQtyLocked(eAllocationSummaryNode.GenericType, aStore)
                            + GetStoreItemQtyLocked(eAllocationSummaryNode.DetailSubType, aStore);
                    }
                case (eComponentType.AllSizes):
                    {
                        locked = 0;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                            {
                                locked += this.GetStoreItemQtyLocked(hsb, aStore);
                            }
                        }
                        return locked;
                    }
                case (eComponentType.Bulk):
                    {
                        return GetStoreItemQtyLocked(eAllocationSummaryNode.Bulk, aStore);
                    }
                case (eComponentType.ColorAndSize):
                    {
                        locked = 0;
                        AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
                        GeneralComponent color = acs.ColorComponent;
                        GeneralComponent size = acs.SizeComponent;
                        switch (color.ComponentType)
                        {
                            case (eComponentType.AllColors):
                                {
                                    switch (size.ComponentType)
                                    {
                                        case (eComponentType.AllSizes):
                                            {
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                                                    {
                                                        locked += GetStoreItemQtyLocked(hsb, aStore);
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSize):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        locked += GetStoreItemQtyLocked(hcb, sizeComponent.SizeRID, aStore);
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizePrimaryDim):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            locked += GetStoreItemQtyLocked(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizeSecondaryDim):
                                            {
                                                sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            locked += GetStoreItemQtyLocked(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        default:
                                            {
                                                throw new MIDException(eErrorLevel.severe,
                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                            }
                                    }
                                    break;
                                }
                            case (eComponentType.SpecificColor):
                                {
                                    colorComponent = (AllocationColorOrSizeComponent)color;  
                                    if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
                                    {
                                        switch (size.ComponentType)
                                        {
                                            case (eComponentType.AllSizes):
                                                {
                                                    foreach (HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
                                                    {
                                                        locked += GetStoreItemQtyLocked(hsb, aStore);
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSize):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                    if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        locked += GetStoreItemQtyLocked(colorComponent.ColorRID, sizeComponent.SizeRID, aStore);
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizePrimaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            locked += GetStoreItemQtyLocked(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizeSecondaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            locked += GetStoreItemQtyLocked(hcb, scp.Key, aStore);
                                                        }
                                                    }
                                                    break;
                                                }
                                            default:
                                                {
                                                    throw new MIDException(eErrorLevel.severe,
                                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                                }
                                        }
                                    }
                                    break;
                                }
                            default:
                                {
                                    throw new MIDException(eErrorLevel.severe,
                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                }
                        }
                        return locked;
                    }
                case (eComponentType.DetailType):
                    {
                        return GetStoreItemQtyLocked(eAllocationSummaryNode.DetailType, aStore);
                    }
                case (eComponentType.GenericType):
                    {
                        return GetStoreItemQtyLocked(eAllocationSummaryNode.GenericType, aStore);
                    }
                case (eComponentType.SpecificColor):
                    {
                        colorComponent = (AllocationColorOrSizeComponent)aComponent;
                        return GetStoreItemQtyLocked(colorComponent.ColorRID, aStore);
                    }
                case (eComponentType.SpecificSize):
                    {
                        sizeComponent = (AllocationColorOrSizeComponent)aComponent;
                        locked = 0;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                            {
                                locked += GetStoreItemQtyLocked(hcb, sizeComponent.SizeRID, aStore);
                            }
                        }
                        return locked;
                    }
                case (eComponentType.SpecificPack):
                    {
                        packComponent = (AllocationPackComponent)aComponent;
                        return GetStoreItemQtyLocked(packComponent.PackName, aStore);
                    }
                case (eComponentType.Total):
                    {
                        return GetStoreItemQtyLocked(eAllocationSummaryNode.Total, aStore);
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                    }
            }
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        public int GetStoreItemQtyLocked(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
        {
            return GetStoreItemQtyLocked(aAllocationSummaryNode, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        internal int GetStoreItemQtyLocked(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
        {
            int locked = 0;
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (ap.StyleIntransitUpdated
                    || ap.GetStoreLocked(aAllocationSummaryNode, aStore)
                    || ap.GetStoreItemTempLock(aAllocationSummaryNode, aStore))
                {
                    locked += ap.GetStoreItemQtyAllocated(aAllocationSummaryNode, aStore);
                }
            }
            return locked;
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        public int GetStoreItemQtyLocked(string aSubtotalPackName, int aStoreRID)
        {
            return GetStoreItemQtyLocked(aSubtotalPackName, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Pack name.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        internal int GetStoreItemQtyLocked(string aSubtotalPackName, Index_RID aStore)
        {
            return GetStoreItemQtyLocked(GetSubtotalPackHdr(aSubtotalPackName), aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPack">Pack header object where store resides.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        internal int GetStoreItemQtyLocked(PackHdr aSubtotalPack, Index_RID aStore)
        {
            int locked = 0;
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (ap.PackIsOnHeader(aSubtotalPack.PackName)
                    && ap.GetPackHdr(aSubtotalPack.PackName).PackMultiple == aSubtotalPack.PackMultiple)
                {
                    PackHdr apPack = ap.GetPackHdr(aSubtotalPack.PackName);
                    if (ap.StyleIntransitUpdated
                        || ap.GetStoreLocked(apPack, aStore)
                        || ap.GetStoreItemTempLock(apPack, aStore))
                    {
                        locked += ap.GetStoreItemQtyAllocated(apPack, aStore);
                    }
                }
            }
            return locked;
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        public int GetStoreItemQtyLocked(int aColorCodeRID, int aStoreRID)
        {
            return GetStoreItemQtyLocked(aColorCodeRID, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        internal int GetStoreItemQtyLocked(int aColorCodeRID, Index_RID aStore)
        {
            return GetStoreItemQtyLocked(GetSubtotalHdrColorBin(aColorCodeRID), aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        internal int GetStoreItemQtyLocked(HdrColorBin aColor, Index_RID aStore)
        {
            int locked = 0;
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
                {
                    if (ap.StyleIntransitUpdated
                        || ap.GetStoreLocked(aColor.ColorCodeRID, aStore)
                        || ap.GetStoreItemTempLock(aColor.ColorCodeRID, aStore))
                    {
                        locked += ap.GetStoreItemQtyAllocated(aColor.ColorCodeRID, aStore);
                    }
                }
            }
            return locked;
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        public int GetStoreItemQtyLocked(int aColorCodeRID, int aSizeRID, int aStoreRID)
        {
            return GetStoreItemQtyLocked(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        internal int GetStoreItemQtyLocked(int aColorCodeRID, int aSizeRID, Index_RID aStore)
        {
            return GetStoreItemQtyLocked(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        internal int GetStoreItemQtyLocked(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
        {
            return GetStoreItemQtyLocked(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
        }

        /// <summary>
        /// Gets Store Item Quantity Allocated for specified store on specified color node.
        /// </summary>
        /// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Item Quantity Locked or Intransit for the store for the specified node.</returns>
        internal int GetStoreItemQtyLocked(HdrSizeBin aSize, Index_RID aStore)
        {
            int locked = 0;
            HdrColorBin apHcb;
            HdrSizeBin apHsb;
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
                {
                    apHcb = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (apHcb.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
                    {
                        apHsb = apHcb.GetSizeBin(aSize.SizeCodeRID); // Assortment: color/size changes
                        if (ap.BulkSizeIntransitUpdated
                            || ap.GetStoreLocked(apHsb, aStore)
                            || ap.GetStoreItemTempLock(apHsb, aStore))
                        {
                            locked += ap.GetStoreItemQtyAllocated(apHsb, aStore);
                        }
                    }
                }
            }
            return locked;
        }
        #endregion StoreItemQuantityLocked
        // end TT#1401 - JEllis - Urban Reservation Stores pt 2

		#region GetStoreQtyAllocatedByRule
		//============================//
		// Quantity Allocated By Rule //
		//============================//
		/// <summary>
		/// Gets Store Subtotal Quantity Allocated By Rule for specified store on specified component of the specified Allocation Profile.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified component.</returns>
		public int GetStoreQtyAllocatedByRule(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreQtyAllocatedByRule(aComponent, StoreIndex(aStoreRID));
			}
			return aAllocationProfile.GetStoreQtyAllocatedByRule(aComponent, StoreIndex(aStoreRID));
		}

		
		/// <summary>
		/// Gets Store Subtotal Quantity Allocated By Rule for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified component.</returns>
		public int GetStoreQtyAllocatedByRule(GeneralComponent aComponent, int aStoreRID)
		{
			return GetStoreQtyAllocatedByRule(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Subtotal Quantity Allocated By Rule for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified component.</returns>
		internal int GetStoreQtyAllocatedByRule(GeneralComponent aComponent, Index_RID aStore)
		{
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetStoreQtyAllocatedByRule(eAllocationSummaryNode.BulkColorTotal, aStore);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetStoreQtyAllocatedByRule(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							(GetStoreQtyAllocatedByRule (eAllocationSummaryNode.DetailSubType, aStore)
							- GetStoreQtyAllocatedByRule (eAllocationSummaryNode.Bulk, aStore));
					}
					return GetStoreQtyAllocatedByRule(eAllocationSummaryNode.DetailSubType, aStore);
				}
				case (eComponentType.AllPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							GetStoreQtyAllocatedByRule (eAllocationSummaryNode.GenericType, aStore)
							+ GetStoreQtyAllocatedByRule (eAllocationSummaryNode.DetailSubType, aStore)
							- GetStoreQtyAllocatedByRule (eAllocationSummaryNode.Bulk, aStore);
					}
					return
						GetStoreQtyAllocatedByRule (eAllocationSummaryNode.GenericType, aStore)
						+ GetStoreQtyAllocatedByRule (eAllocationSummaryNode.DetailSubType, aStore);
				}
				case (eComponentType.AllSizes):
				{
					throw new MIDException (eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_RuleNotTrackedBySize,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_RuleNotTrackedBySize));
				}
				case (eComponentType.Bulk):
				{
					return GetStoreQtyAllocatedByRule (eAllocationSummaryNode.Bulk, aStore);
				}
				case (eComponentType.ColorAndSize):
				{
					throw new MIDException (eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_RuleNotTrackedBySize,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_RuleNotTrackedBySize));
				}
				case (eComponentType.DetailType):
				{
					return GetStoreQtyAllocatedByRule(eAllocationSummaryNode.DetailType, aStore);
				}
				case (eComponentType.GenericType):
				{
					return GetStoreQtyAllocatedByRule(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetStoreQtyAllocatedByRule(colorComponent.ColorRID, aStore);
				}
				case (eComponentType.SpecificSize):
				{
					throw new MIDException (eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_RuleNotTrackedBySize,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_RuleNotTrackedBySize));
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetStoreQtyAllocatedByRule (packComponent.PackName, aStore);
				}
				case (eComponentType.Total):
				{
					return GetStoreQtyAllocatedByRule (eAllocationSummaryNode.Total, aStore);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Gets Store Quantity Allocated By Rule for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified node.</returns>
		public int GetStoreQtyAllocatedByRule(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
		{
			return GetStoreQtyAllocatedByRule(aAllocationSummaryNode, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated By Rule for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified node.</returns>
		internal int GetStoreQtyAllocatedByRule(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
		{
			int allocatedByRule = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				allocatedByRule += ap.GetStoreQtyAllocatedByRule(aAllocationSummaryNode, aStore);
			}
			return allocatedByRule;
		}

		/// <summary>
		/// Gets Store Quantity Allocated By Rule for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified node.</returns>
		public int GetStoreQtyAllocatedByRule(string aSubtotalPackName, int aStoreRID)
		{
			return GetStoreQtyAllocatedByRule(aSubtotalPackName, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated By Rule for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified node.</returns>
		internal int GetStoreQtyAllocatedByRule(string aSubtotalPackName, Index_RID aStore)
		{
			return GetStoreQtyAllocatedByRule(GetSubtotalPackHdr(aSubtotalPackName), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated By Rule for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified node.</returns>
		internal int GetStoreQtyAllocatedByRule(PackHdr aSubtotalPack, Index_RID aStore)
		{
			int allocatedByRule = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aSubtotalPack.PackName) &&
					ap.GetSubtotalPackName(aSubtotalPack.PackName) == aSubtotalPack.PackName)
				{
					allocatedByRule += ap.GetStoreQtyAllocatedByRule(aSubtotalPack.PackName, aStore);
				}
			}
			return allocatedByRule;
		}

		/// <summary>
		/// Gets Store Quantity Allocated By Rule for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified node.</returns>
		public int GetStoreQtyAllocatedByRule(int aColorCodeRID, int aStoreRID)
		{
			return GetStoreQtyAllocatedByRule(aColorCodeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated By Rule for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified node.</returns>
		internal int GetStoreQtyAllocatedByRule(int aColorCodeRID, Index_RID aStore)
		{
			return GetStoreQtyAllocatedByRule(GetSubtotalHdrColorBin(aColorCodeRID), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated By Rule for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Quantity Allocated By Rule to the store for the specified node.</returns>
		internal int GetStoreQtyAllocatedByRule(HdrColorBin aColor, Index_RID aStore)
		{
			int allocatedByRule = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					allocatedByRule += ap.GetStoreQtyAllocatedByRule(aColor.ColorCodeRID, aStore);
				}
			}
			return allocatedByRule;
		}
		#endregion GetStoreQtyAllocatedByRule

		#region GetStoreQtyAllocatedNotUpdtInTransit
		//===========================================//
		// Quantity Allocated Not Updating Intransit //
		//===========================================//
		/// <summary>
		/// Gets Store Subtotal Quantity Allocated for specified store on specified component that is not updating intransit.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Store's Quantity Allocated Not Updating intransit for the specified component.</returns>
		public int GetStoreQtyAllocatedNotIntransit(GeneralComponent aComponent, int aStoreRID)
		{
			return GetStoreQtyAllocatedNotIntransit(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Subtotal Quantity Allocated for specified store on specified component that is not updating intransit.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Store's Quantity Allocated Not Updating Intransit for the specified component.</returns>
		internal int GetStoreQtyAllocatedNotIntransit(GeneralComponent aComponent, Index_RID aStore)
		{
			int allocated;
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetStoreQtyAllocatedNotIntransit(eAllocationSummaryNode.BulkColorTotal, aStore);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetStoreQtyAllocatedNotIntransit(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							(GetStoreQtyAllocatedNotIntransit (eAllocationSummaryNode.DetailSubType, aStore)
							- GetStoreQtyAllocatedNotIntransit (eAllocationSummaryNode.Bulk, aStore));
					}
					return GetStoreQtyAllocatedNotIntransit(eAllocationSummaryNode.DetailSubType, aStore);
				}
				case (eComponentType.AllPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							GetStoreQtyAllocatedNotIntransit (eAllocationSummaryNode.GenericType, aStore)
							+ GetStoreQtyAllocatedNotIntransit (eAllocationSummaryNode.DetailSubType, aStore)
							- GetStoreQtyAllocatedNotIntransit (eAllocationSummaryNode.Bulk, aStore);
					}
					return
						GetStoreQtyAllocatedNotIntransit (eAllocationSummaryNode.GenericType, aStore)
						+ GetStoreQtyAllocatedNotIntransit (eAllocationSummaryNode.DetailSubType, aStore);
				}
				case (eComponentType.AllSizes):
				{
					allocated = 0;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
						{
							allocated += this.GetStoreQtyAllocatedNotIntransit(hsb, aStore);
						}
					}
					return allocated;
				}
				case (eComponentType.Bulk):
				{
					return GetStoreQtyAllocatedNotIntransit (eAllocationSummaryNode.Bulk, aStore);
				}
				case (eComponentType.ColorAndSize):
				{
					allocated = 0;
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											allocated += GetStoreQtyAllocatedNotIntransit(hsb, aStore);
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										if (hcb.SizeIsInColor(sizeComponent.SizeRID))
										{
											allocated += GetStoreQtyAllocatedNotIntransit(hcb, sizeComponent.SizeRID, aStore);
										}
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{ 
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												allocated += GetStoreQtyAllocatedNotIntransit(hcb, scp.Key, aStore);
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												allocated += GetStoreQtyAllocatedNotIntransit(hcb, scp.Key, aStore);
											}
										}
									}
									break;
								}
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										foreach(HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
										{
											allocated += GetStoreQtyAllocatedNotIntransit(hsb, aStore);
										}
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color 
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											allocated += GetStoreQtyAllocatedNotIntransit(colorComponent.ColorRID, sizeComponent.SizeRID, aStore);
										}
										break;
									}
									// BEGIN MID Track #2412 Unknown Component
									case (eComponentType.SpecificSizePrimaryDim):
									{ 
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												allocated += GetStoreQtyAllocatedNotIntransit(hcb, scp.Key, aStore);
											}
										}
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{ 
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												allocated += GetStoreQtyAllocatedNotIntransit(hcb, scp.Key, aStore);
											}
										}
										break;
									}
									// END MID Track #2412 Unknown Component
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					return allocated;
				}
				case (eComponentType.DetailType):
				{
					return GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, aStore);
				}
				case (eComponentType.GenericType):
				{
					return GetStoreQtyAllocatedNotIntransit(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetStoreQtyAllocatedNotIntransit(colorComponent.ColorRID, aStore);
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					allocated = 0;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						if (hcb.SizeIsInColor(sizeComponent.SizeRID))
						{
							allocated += GetStoreQtyAllocatedNotIntransit(hcb, sizeComponent.SizeRID, aStore);
						}
					}
					return allocated;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetStoreQtyAllocated (packComponent.PackName, aStore);
				}
				case (eComponentType.Total):
				{
					return GetStoreQtyAllocatedNotIntransit (eAllocationSummaryNode.Total, aStore);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

        // Begin TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.  
        private List<AllocationProfile> GetHeadersForStoreQtyAllocatedNotIntransit()
        {
            if (_headersForStoreQtyAllocatedNotIntransit == null)
            {
                _headersForStoreQtyAllocatedNotIntransit = new List<AllocationProfile>();
                bool containsAssortment = false;
                bool containsPlaceholder = false;
                foreach (AllocationProfile ap in this.SubtotalMembers)
                {
                    if (ap.HeaderType == eHeaderType.Assortment)
                    {
                        containsAssortment = true;
                    }
                    else if (ap.HeaderType == eHeaderType.Placeholder)
                    {
                        containsPlaceholder = true;
                    }
                }

                foreach (AllocationProfile ap in this.SubtotalMembers)
                {
                    // If both, use place holders only
                    if (containsAssortment
                        && containsPlaceholder)
                    {
                        if (ap.HeaderType == eHeaderType.Placeholder)
                        {
                            _headersForStoreQtyAllocatedNotIntransit.Add(ap);
                        }
                    }
                    // otherwise, use all headers
                    else
                    {
                        _headersForStoreQtyAllocatedNotIntransit.Add(ap);
                    }
                }
            }

            return _headersForStoreQtyAllocatedNotIntransit;
        }
        // End TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.  

		/// <summary>
		/// Gets Store Quantity Allocated but not intransit for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Store's Quantity Allocated but not intransit for the specified node.</returns>
		public int GetStoreQtyAllocatedNotIntransit(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
		{
			return GetStoreQtyAllocatedNotIntransit(aAllocationSummaryNode, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated but not intransit for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Store's Quantity Allocated Not Intransit for the specified node.</returns>
		internal int GetStoreQtyAllocatedNotIntransit(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
		{
			int allocated = 0;
            // Begin TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.  
            //foreach (AllocationProfile ap in this.SubtotalMembers)
            foreach (AllocationProfile ap in GetHeadersForStoreQtyAllocatedNotIntransit())
            // End TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.  
			{
				if (!ap.StyleIntransitUpdated)
				{
					allocated += ap.GetStoreQtyAllocated(aAllocationSummaryNode, aStore);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets Store Quantity Allocated but not intransit for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Store's Quantity Allocated not intransit for the specified node.</returns>
		public int GetStoreQtyAllocatedNotIntransit(string aSubtotalPackName, int aStoreRID)
		{
			return GetStoreQtyAllocatedNotIntransit(aSubtotalPackName, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated but not intransit for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Store's Quantity Allocated not intransit for  the specified node.</returns>
		internal int GetStoreQtyAllocatedNotIntransit(string aSubtotalPackName, Index_RID aStore)
		{
			return GetStoreQtyAllocatedNotIntransit(GetSubtotalPackHdr(aSubtotalPackName), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated but not intransit for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Store's Quantity Allocated but not intransit for the specified node.</returns>
		internal int GetStoreQtyAllocatedNotIntransit(PackHdr aSubtotalPack, Index_RID aStore)
		{
			int allocated = 0;
            // Begin TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.  
            //foreach (AllocationProfile ap in this.SubtotalMembers)
            foreach (AllocationProfile ap in GetHeadersForStoreQtyAllocatedNotIntransit())
            // End TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.
			{
				if (!ap.StyleIntransitUpdated)
				{
					if (ap.PackIsOnHeader(aSubtotalPack.PackName))
						allocated += ap.GetStoreQtyAllocated(aSubtotalPack.PackName, aStore);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets Store Quantity Allocated Not Intransit for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Store's Quantity Allocated not intransit for the specified node.</returns>
		public int GetStoreQtyAllocatedNotIntransit(int aColorCodeRID, int aStoreRID)
		{
			return GetStoreQtyAllocatedNotIntransit(aColorCodeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated Not Intransit for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Store's Quantity Allocated not intransit for the specified node.</returns>
		internal int GetStoreQtyAllocatedNotIntransit(int aColorCodeRID, Index_RID aStore)
		{
			return GetStoreQtyAllocatedNotIntransit(GetSubtotalHdrColorBin(aColorCodeRID), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated Not Intransit for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Store's Quantity Allocated not intransit for the specified node.</returns>
		internal int GetStoreQtyAllocatedNotIntransit(HdrColorBin aColor, Index_RID aStore)
		{
			int allocated = 0;
            // Begin TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.  
            //foreach (AllocationProfile ap in this.SubtotalMembers)
            foreach (AllocationProfile ap in GetHeadersForStoreQtyAllocatedNotIntransit())
            // End TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.
			{
				if (!ap.BulkColorIntransitUpdated)
				{
					allocated += ap.GetStoreQtyAllocated(aColor.ColorCodeRID, aStore);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets Store Quantity Allocated Not Intransit for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Store's Quantity Allocated but not intransit for the specified node.</returns>
		public int GetStoreQtyAllocatedNotIntransit(int aColorCodeRID, int aSizeRID, int aStoreRID)
		{
			return GetStoreQtyAllocatedNotIntransit(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Quantity Allocated but not intransit for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Store's Quantity Allocated but not intransit for the specified node.</returns>
		internal int GetStoreQtyAllocatedNotIntransit(int aColorCodeRID, int aSizeRID, Index_RID aStore)
		{
			return GetStoreQtyAllocatedNotIntransit(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated but not intransit for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Store's Quantity Allocated not intransit for the specified node.</returns>
		internal int GetStoreQtyAllocatedNotIntransit(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
		{
			return GetStoreQtyAllocatedNotIntransit(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
		}

		/// <summary>
		/// Gets Store Quantity Allocated but not intransit for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Store's Quantity Allocated but not intransit for the specified node.</returns>
		internal int GetStoreQtyAllocatedNotIntransit(HdrSizeBin aSize, Index_RID aStore)
		{
			int allocated = 0;
            // Begin TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.  
            //foreach (AllocationProfile ap in this.SubtotalMembers)
            foreach (AllocationProfile ap in GetHeadersForStoreQtyAllocatedNotIntransit())
            // End TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.
			{
				if (!ap.BulkSizeIntransitUpdated)
				{
                    allocated = +ap.GetStoreQtyAllocated(aSize.Color, aSize.SizeCodeRID, aStore); // Assortment: color/size changes
				}
			}
			return allocated;
		}
		#endregion GetStoreQtyAllocatedNotUpdtInTransit

		#region StoreSizeAllocatedPctToColorAllocated
		public double GetStoreSizeAllocatedPctToColorAllocated(
			AllocationProfile aAllocationProfile, AllocationColorSizeComponent aColorSize, Index_RID aStore)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreSizeAllocatedPctToColorAllocated(aColorSize, aStore);
			}
			return aAllocationProfile.GetStoreSizeAllocatedPctToColorAllocated(aColorSize, aStore);
		}
		private double GetStoreSizeAllocatedPctToColorAllocated(
			AllocationColorSizeComponent aColorSize, Index_RID aStore)
		{
			double percentToTotal = 0.0d;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			if (aColorSize.ColorComponent.ComponentType != eComponentType.SpecificColor)
			{
				return percentToTotal;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			}
			AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)aColorSize.ColorComponent;
			int colorRID = colorComponent.ColorRID;
			if (this.BulkColorIsOnSubtotal(colorRID))
			{
				HdrColorBin colorBin = this.GetSubtotalHdrColorBin(colorRID);
				if (colorBin.GetReCalcStoreTotalSizePctToColor(aStore.Index))
				{
					CalculateStoreSizeAllocatedPctToColor(colorBin, aStore);
				}
				switch (aColorSize.SizeComponent.ComponentType)
				{
					case (eComponentType.SpecificSize):
					{
						int sizeRID = ((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SizeRID;
						if (colorBin.SizeIsInColor(sizeRID))
						{
							percentToTotal = colorBin.GetSizeBin(sizeRID).GetStoreSizePctToColor(aStore.Index);
						}
						break;
					}
					case (eComponentType.SpecificSizePrimaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).PrimarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							if (colorBin.SizeIsInColor(scp.Key))
							{
								percentToTotal += colorBin.GetSizeBin(scp.Key).GetStoreSizePctToColor(aStore.Index);
							}
						}
						break;
					}
					case (eComponentType.SpecificSizeSecondaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SecondarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							if (colorBin.SizeIsInColor(scp.Key))
							{
								percentToTotal += colorBin.GetSizeBin(scp.Key).GetStoreSizePctToColor(aStore.Index);
							}
						}
						break;
					}
					case (eComponentType.AllSizes):
					{
						percentToTotal = colorBin.GetStoreTotalSizePctToColor(aStore.Index);
						break;
					}
					default:
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_UnknownSizeComponent,
							this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownSizeComponent));
					}
				}
			}
			return percentToTotal;
		}
		private void SetStoreSizeAllocatedPctToColorAllocated(
			HdrSizeBin aSize, Index_RID aStore, double aPercentToColor)
		{
			aSize.SetStoreSizePctToColor(aStore.Index, aPercentToColor);
		}
		private void SetStoreSizeTotalAllocatedPctToColorAllocated(
			HdrColorBin aColor, Index_RID aStore, double aPercentToColor)
		{
			aColor.SetStoreTotalSizePctToColor(aStore.Index, aPercentToColor);
		}
		private void CalculateStoreSizeAllocatedPctToColor(HdrColorBin colorBin, Index_RID aStore)
		{
			long totalValue = (long)this.GetStoreQtyAllocated(colorBin, aStore);
			long totalSizeValue = (long)colorBin.GetStoreColorTotalSizeAllocated(aStore.Index);
			long sizePercent;
			long decimalPrecision = (long)Math.Pow(10,Include.DecimalPositionsInStoreSizePctToColor);
			long newTotalPct = 0;
			if (totalValue > 0)
			{
				newTotalPct = 
					(long)(((double)totalSizeValue
					* (double)decimalPrecision * 100.0d
					/ (double) totalValue) + .5d);
			}
			this.SetStoreSizeTotalAllocatedPctToColorAllocated(colorBin, aStore, (double)((double)newTotalPct/(double)decimalPrecision));
			long sizeValue;
			foreach (HdrSizeBin sizeBin in colorBin.ColorSizes.Values)
			{
				if (totalSizeValue > 0)
				{
					sizeValue = this.GetStoreQtyAllocated (sizeBin, aStore);
					sizePercent = (long)
						(
						((double)sizeValue 
						* (double)newTotalPct
						/ (double) totalSizeValue
						) + .5d);
					this.SetStoreSizeAllocatedPctToColorAllocated(sizeBin, aStore, (double)((double)sizePercent/(double)decimalPrecision));
					totalSizeValue -= sizeValue;
					newTotalPct -= sizePercent;
				}                                                                                                                                                                                                                                          
			}
			colorBin.SetReCalcStoreTotalSizePctToColor(aStore.Index, false);
		}
		#endregion StoreSizeAllocatedPctToColorAllocated

		#region StoreSizeInTransitPctToColorInTransit
		/// <summary>
		/// Gets the size intransit percent to color total intransit for a given store.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile (currently ignored)</param>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreRID">Store  RID that identifies the store</param>
		/// <returns>Percent of size intransit to total color </returns>
		public double GetStoreSizeInTransitPctToColorInTransit(
			AllocationProfile aAllocationProfile, AllocationColorSizeComponent aColorSize, int aStoreRID)
		{
			return GetStoreSizeInTransitPctToColorInTransit(aColorSize, aStoreRID);
		}

		/// <summary>
		/// Gets the size intransit percent to color total intransit for a given store.
		/// </summary>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreRID">Store RID that identifies the store</param>
		/// <returns>Percent of size intransit to total color </returns>
		private double GetStoreSizeInTransitPctToColorInTransit(
			AllocationColorSizeComponent aColorSize, int aStoreRID)
		{
			double percentToTotal = 0.0d; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			if (aColorSize.ColorComponent.ComponentType != eComponentType.SpecificColor)
			{
				return percentToTotal; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			}
			AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)aColorSize.ColorComponent;
			if (_storeSizeIntransitPctToColorHash == null)
			{
				_storeSizeIntransitPctToColorHash = new Hashtable();
			}
			int colorRID = colorComponent.ColorRID;
			Hashtable sizePctToColorHash;
			if (_storeSizeIntransitPctToColorHash.Contains(aStoreRID))
			{
				sizePctToColorHash = (Hashtable)_storeSizeIntransitPctToColorHash[aStoreRID];
			}
			else
			{
				sizePctToColorHash = this.CalculateStoreSizeInTransitPctToColor(aStoreRID);
				_storeSizeIntransitPctToColorHash.Add(aStoreRID, sizePctToColorHash);
			}
			if (this.BulkColorIsOnSubtotal(colorRID))
			{
				HdrColorBin colorBin = this.GetSubtotalHdrColorBin(colorRID);
				IntransitKeyType sizeIKT;
				switch (aColorSize.SizeComponent.ComponentType)
				{
					case (eComponentType.SpecificSize):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID, 
							((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SizeRID
							);
						if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
						{
							percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						}
						break;
					}
					case (eComponentType.SpecificSizePrimaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).PrimarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.SpecificSizeSecondaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SecondarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.AllSizes):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID,
							Include.IntransitKeyTypeNoSize
							);
						percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						break;
					}
					default:
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_UnknownSizeComponent,
							this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownSizeComponent));
					}
				}
			}
			return percentToTotal;
		}
        
		/// <summary>
		/// Calculates the size intransit percent to color total intransit for a given store.
		/// </summary>
		/// <param name="aStoreRID">Store RID</param>
		/// <returns>Hashtable containing the color size intransit percents to color (key is the Intransit Key Type key identifying a color and a size--all sizes are represented by the no size intransit key type).</returns>
		private Hashtable CalculateStoreSizeInTransitPctToColor(int aStoreRID)
		{
			Hashtable colorSizeIntransitPctToColorHash = new Hashtable();
//Begin Track #4037 - JSmith - Optionally include dummy color in child list
			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color, eNodeSelectType.All); // MID Change j.Ellis Performance--cache ancestor and descendant data
//			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color); // MID Change j.Ellis Performance--cache ancestor and descendant data
//End Track #4037
			//HierarchyNodeList hnlColor = this.Transaction.SAB.HierarchyServerSession.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color); // MID Change j.Ellis Performance--cache ancestor and descendant data
			long sizeValue;
			long totalValue; 
			long totalSizeValue;
			foreach (HdrColorBin colorBin in this.BulkColors.Values)
			{
				IntransitKeyType iktColor = new IntransitKeyType(colorBin.ColorCodeRID, Include.IntransitKeyTypeNoSize);
				IntransitKeyType iktSize;
				totalValue = (long)this.GetStoreInTransit(iktColor, aStoreRID);
				totalSizeValue = 0;

				ArrayList iktArray = new ArrayList();
				ArrayList sizeValueArray = new ArrayList();
				foreach(HierarchyNodeProfile hnpColor in hnlColor)
				{
					if (hnpColor.ColorOrSizeCodeRID == colorBin.ColorCodeRID)
					{
						foreach (SizeCodeProfile sizeProfile in this._sizeList)
						{
							iktSize = new IntransitKeyType(colorBin.ColorCodeRID, sizeProfile.Key);
							sizeValue = (long)this.GetStoreInTransit(iktSize, aStoreRID);
							iktArray.Add(iktSize);
							sizeValueArray.Add(sizeValue);
							totalSizeValue += sizeValue;
						}
						break;
					}
				}

				long newTotalPct = 0;
				if (totalValue > 0)
				{
					newTotalPct = 
						(long)(((double)totalSizeValue
						* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision * 100.0d
						/ (double) totalValue) + .5d);
				}
				colorSizeIntransitPctToColorHash .Add(
					iktColor.IntransitTypeKey, 
					(double)((double)newTotalPct/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision ));
				long sizePercent;
				for (int i=0; i < iktArray.Count; i++)
				{
					iktSize = (IntransitKeyType)iktArray[i];
					sizeValue = (long)sizeValueArray[i];
					if (totalSizeValue > 0)
					{
						sizePercent = (long)
							(
							((double)sizeValue 
							* (double)newTotalPct
							/ (double) totalSizeValue
							) + .5d);
						colorSizeIntransitPctToColorHash.Add(
							iktSize.IntransitTypeKey, 
							(double)((double)sizePercent/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision));
						totalSizeValue -= sizeValue;
						newTotalPct -= sizePercent;
					}
					else
					{
						colorSizeIntransitPctToColorHash.Add(iktSize.IntransitTypeKey,0.0d);
					}                                                                                                                                                              
				}
			}
			return colorSizeIntransitPctToColorHash;
		}
		#endregion StoreSizeInTransitPctToColorIntransit

		#region StoreSizeOnHandPctToColorOnHand
		/// <summary>
		/// Gets the size onhand percent to color total onhand for a given store.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile (currently ignored)</param>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreRID">Store  RID that identifies the store</param>
		/// <returns>Percent of size onhand to total color </returns>
		public double GetStoreSizeOnHandPctToColorOnHand(
			AllocationProfile aAllocationProfile, AllocationColorSizeComponent aColorSize, int aStoreRID)
		{
			return GetStoreSizeOnHandPctToColorOnHand(aColorSize, aStoreRID);
		}

		/// <summary>
		/// Gets the size onhand percent to color total onhand for a given store.
		/// </summary>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreRID">Store RID that identifies the store</param>
		/// <returns>Percent of size onhand to total color </returns>
		private double GetStoreSizeOnHandPctToColorOnHand(
			AllocationColorSizeComponent aColorSize, int aStoreRID)
		{
			double percentToTotal = 0.0d;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			if (aColorSize.ColorComponent.ComponentType != eComponentType.SpecificColor)
			{
				return percentToTotal;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			}
			AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)aColorSize.ColorComponent;
			if (_storeSizeOnHandPctToColorHash == null)
			{
				_storeSizeOnHandPctToColorHash = new Hashtable();
			}
			int colorRID = colorComponent.ColorRID;
			Hashtable sizePctToColorHash;
			if (_storeSizeOnHandPctToColorHash.Contains(aStoreRID))
			{
				sizePctToColorHash = (Hashtable)_storeSizeOnHandPctToColorHash[aStoreRID];
			}
			else
			{
				sizePctToColorHash = this.CalculateStoreSizeOnHandPctToColor(aStoreRID);
				_storeSizeOnHandPctToColorHash.Add(aStoreRID, sizePctToColorHash);
			}
			if (this.BulkColorIsOnSubtotal(colorRID))
			{
				HdrColorBin colorBin = this.GetSubtotalHdrColorBin(colorRID);
				IntransitKeyType sizeIKT;
				switch (aColorSize.SizeComponent.ComponentType)
				{
					case (eComponentType.SpecificSize):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID, 
							((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SizeRID
							);
						if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
						{
							percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						}
						break;
					}
					case (eComponentType.SpecificSizePrimaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).PrimarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.SpecificSizeSecondaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SecondarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.AllSizes):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID,
							Include.IntransitKeyTypeNoSize
							);
						percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						break;
					}
					default:
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_UnknownSizeComponent,
							this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownSizeComponent));
					}
				}
			}
			return percentToTotal;
		}
        
		/// <summary>
		/// Calculates the size onhand percent to color total onhand for a given store.
		/// </summary>
		/// <param name="aStoreRID">Store RID</param>
		/// <returns>Hashtable containing the color size intransit percents to color (key is the Intransit Key Type key identifying a color and a size--all sizes are represented by the no size intransit key type).</returns>
		private Hashtable CalculateStoreSizeOnHandPctToColor(int aStoreRID)
		{
			Hashtable colorSizeOnHandPctToColorHash = new Hashtable();
//Begin Track #4037 - JSmith - Optionally include dummy color in child list
			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color, eNodeSelectType.All);  // MID Change j.ellis Performance--cache ancestor and descendant data
//			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color);  // MID Change j.ellis Performance--cache ancestor and descendant data
//End Track #4037
			//HierarchyNodeList hnlColor = this.Transaction.SAB.HierarchyServerSession.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color);  // MID Change j.ellis Performance--cache ancestor and descendant data
			long sizeValue;
			long totalValue; 
			long totalSizeValue;
			foreach (HdrColorBin colorBin in this.BulkColors.Values)
			{
				IntransitKeyType iktColor = new IntransitKeyType(colorBin.ColorCodeRID, Include.IntransitKeyTypeNoSize);
				IntransitKeyType iktSize;
				totalValue = (long)this.GetStoreOnHand(iktColor, aStoreRID);
				totalSizeValue = 0;

				ArrayList iktArray = new ArrayList();
				ArrayList sizeValueArray = new ArrayList();
				foreach(HierarchyNodeProfile hnpColor in hnlColor)
				{
					if (hnpColor.ColorOrSizeCodeRID == colorBin.ColorCodeRID)
					{
						foreach (SizeCodeProfile sizeProfile in this._sizeList)
						{
							iktSize = new IntransitKeyType(colorBin.ColorCodeRID, sizeProfile.Key);
							sizeValue = (long)this.GetStoreOnHand(iktSize, aStoreRID);
							iktArray.Add(iktSize);
							sizeValueArray.Add(sizeValue);
							totalSizeValue += sizeValue;
						}
						break;
					}
				}

				long newTotalPct = 0;
				if (totalValue > 0)
				{
					newTotalPct = 
						(long)(((double)totalSizeValue
						* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision * 100.0d
						/ (double) totalValue) + .5d);
				}
				colorSizeOnHandPctToColorHash .Add(
					iktColor.IntransitTypeKey, 
					(double)((double)newTotalPct/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision ));
				long sizePercent;
				for (int i=0; i < iktArray.Count; i++)
				{
					iktSize = (IntransitKeyType)iktArray[i];
					sizeValue = (long)sizeValueArray[i];
					if (totalSizeValue > 0)
					{
						sizePercent = (long)
							(
							((double)sizeValue 
							* (double)newTotalPct
							/ (double) totalSizeValue
							) + .5d);
						colorSizeOnHandPctToColorHash.Add(
							iktSize.IntransitTypeKey, 
							(double)((double)sizePercent/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision));
						totalSizeValue -= sizeValue;
						newTotalPct -= sizePercent;
					}
					else
					{
						colorSizeOnHandPctToColorHash.Add(iktSize.IntransitTypeKey,0.0d);
					}                                                                                                                                                              
				}
			}
			return colorSizeOnHandPctToColorHash;
		}
		#endregion StoreSizeOnHandPctToColorIntransit

		#region StoreSize_OHplusIT_PctToColorOHplusIT
		/// <summary>
		/// Gets the size OnHand plus Intransit percent to color total OnHand plus intransit for a given store.
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile (currently ignored)</param>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreRID">Store RID that identifies the store</param>
		/// <returns>Percent of size OnHand plus Intransit to total color </returns>
		public double GetStoreSize_OHplusIT_PctToColorOHplusIT(
			AllocationProfile aAllocationProfile, AllocationColorSizeComponent aColorSize, int aStoreRID)
		{
			return GetStoreSize_OHplusIT_PctToColorOHplusIT(aColorSize, aStoreRID);
		}
		/// <summary>
		/// Gets the size OnHand plus Intransit percent to color total OnHand plus intransit for a given store.
		/// </summary>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreRID">Store RID that identifies the store </param>
		/// <returns>Percent of size OnHand plus Intransit to total color </returns>
		private double GetStoreSize_OHplusIT_PctToColorOHplusIT(
			AllocationColorSizeComponent aColorSize, int aStoreRID)
		{
			double percentToTotal = 0.0d;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			if (aColorSize.ColorComponent.ComponentType != eComponentType.SpecificColor)
			{
				return percentToTotal;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			}
			AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)aColorSize.ColorComponent;
			if (_storeSizeOHplusITPctToColorHash == null)
			{
				_storeSizeOHplusITPctToColorHash = new Hashtable();
			}
			int colorRID = colorComponent.ColorRID;
			Hashtable sizePctToColorHash;
			if (_storeSizeOHplusITPctToColorHash.Contains(aStoreRID))
			{
				sizePctToColorHash = (Hashtable)_storeSizeOHplusITPctToColorHash[aStoreRID];
			}
			else
			{
				sizePctToColorHash = this.CalculateStoreSize_OHplusIT_PctToColor(aStoreRID);
				_storeSizeOHplusITPctToColorHash.Add(aStoreRID, sizePctToColorHash);
			}

			if (this.BulkColorIsOnSubtotal(colorRID))
			{

				HdrColorBin colorBin = this.GetSubtotalHdrColorBin(colorRID);
				IntransitKeyType sizeIKT;
				switch (aColorSize.SizeComponent.ComponentType)
				{
					case (eComponentType.SpecificSize):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID, 
							((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SizeRID
							);
						if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
						{
							percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						}
						break;
					}
					case (eComponentType.SpecificSizePrimaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).PrimarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.SpecificSizeSecondaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SecondarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.AllSizes):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID,
							Include.IntransitKeyTypeNoSize
							);
						percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						break;
					}
					default:
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_UnknownSizeComponent,
							this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownSizeComponent));
					}
				}
			}
			return percentToTotal;
		}
		/// <summary>
		/// Calculates the size OnHand plus intransit percent to color total OnHand plus intransit for a given store.
		/// </summary>
		/// <param name="aStoreRID">Store RID</param>
		/// <returns>Hashtable containing the color size onhand plus intransit percents to color (key is the Intransit Key Type key identifying a color and a size--all sizes are represented by the no size intransit key type).</returns>
		private Hashtable CalculateStoreSize_OHplusIT_PctToColor(int aStoreRID)
		{
			Hashtable colorSize_OHplustIT_PctToColorHash = new Hashtable();
//Begin Track #4037 - JSmith - Optionally include dummy color in child list
			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color, eNodeSelectType.All);  // MID Change j.ellis Performance--cache ancestor and descendant data
//			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color);  // MID Change j.ellis Performance--cache ancestor and descendant data
//End Track #4037
			//HierarchyNodeList hnlColor = this.Transaction.SAB.HierarchyServerSession.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color); // MID Change Performance--cache ancestor and descendant data
			long sizeValue;
			long totalValue; 
			long totalSizeValue;
			foreach (HdrColorBin colorBin in this.BulkColors.Values)
			{
				IntransitKeyType iktColor = new IntransitKeyType(colorBin.ColorCodeRID, Include.IntransitKeyTypeNoSize);
				IntransitKeyType iktSize;
				totalValue = 
					(long)this.GetStoreOnHand(iktColor, aStoreRID)
					+ (long)this.GetStoreInTransit(iktColor, aStoreRID);
				totalSizeValue = 0;

				ArrayList iktArray = new ArrayList();
				ArrayList sizeValueArray = new ArrayList();
				foreach(HierarchyNodeProfile hnpColor in hnlColor)
				{
					if (hnpColor.ColorOrSizeCodeRID == colorBin.ColorCodeRID)
					{
						foreach (SizeCodeProfile sizeProfile in this._sizeList)
						{
							iktSize = new IntransitKeyType(colorBin.ColorCodeRID, sizeProfile.Key);
							sizeValue = 
								(long)this.GetStoreOnHand(iktSize, aStoreRID)
								+ (long)this.GetStoreInTransit(iktSize, aStoreRID);
							iktArray.Add(iktSize);
							sizeValueArray.Add(sizeValue);
							totalSizeValue += sizeValue;
						}
						break;
					}
				}

				long newTotalPct = 0;
				if (totalValue > 0)
				{
					newTotalPct = 
						(long)(((double)totalSizeValue
						* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision * 100.0d
						/ (double) totalValue) + .5d);
				}
				colorSize_OHplustIT_PctToColorHash.Add(
					iktColor.IntransitTypeKey, 
					(double)((double)newTotalPct/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision ));
				long sizePercent;
				for (int i=0; i < iktArray.Count; i++)
				{
					iktSize = (IntransitKeyType)iktArray[i];
					sizeValue = (long)sizeValueArray[i];
					if (totalSizeValue > 0)
					{
						sizePercent = (long)
							(
							((double)sizeValue 
							* (double)newTotalPct
							/ (double) totalSizeValue
							) + .5d);
						colorSize_OHplustIT_PctToColorHash.Add(
							iktSize.IntransitTypeKey, 
							(double)((double)sizePercent/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision));
						totalSizeValue -= sizeValue;
						newTotalPct -= sizePercent;
					}
					else
					{
						colorSize_OHplustIT_PctToColorHash.Add(iktSize.IntransitTypeKey,0.0d);
					}                                                                                                                                                              
				}
			}
			return colorSize_OHplustIT_PctToColorHash;
		}
		#endregion StoreSize_OHplustIT_PctToColorOHplusIT

		#region StorePrimaryMaximum
		//=======================//
		// Store Primary Maximum //
		//=======================//
		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Primary Maximum to the store for the specified component.</returns>
		public int GetStorePrimaryMaximum(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return GetStorePrimaryMaximum(aComponent, StoreIndex(aStoreRID));
			}
			return aAllocationProfile.GetStorePrimaryMaximum(aComponent, aStoreRID);
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Primary Maximum to the store for the specified component.</returns>
		public int GetStorePrimaryMaximum(GeneralComponent aComponent, int aStoreRID)
		{
			return GetStorePrimaryMaximum(aComponent, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Primary Maximum to the store for the specified component.</returns>
		internal int GetStorePrimaryMaximum(GeneralComponent aComponent, Index_RID aStore)
		{
			int maximum;
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetStorePrimaryMaximum(eAllocationSummaryNode.BulkColorTotal, aStore);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetStorePrimaryMaximum(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (this.BulkIsDetail)
					{
						if (GetStorePrimaryMaximum(eAllocationSummaryNode.DetailSubType, aStore) <
							Include.LargestIntegerMaximum)
						{
							if (GetStorePrimaryMaximum (eAllocationSummaryNode.Bulk, aStore) <
								Include.LargestIntegerMaximum)
							{
								return 
									(GetStorePrimaryMaximum (eAllocationSummaryNode.DetailSubType, aStore)
									- GetStorePrimaryMaximum (eAllocationSummaryNode.Bulk, aStore));
							}
							return GetStorePrimaryMaximum (eAllocationSummaryNode.DetailSubType, aStore);
						}
						return GetStorePrimaryMaximum (eAllocationSummaryNode.DetailSubType, aStore);
					}
					return GetStorePrimaryMaximum(eAllocationSummaryNode.DetailSubType, aStore);
				}
				case (eComponentType.AllPacks):
				{
					if (this.BulkIsDetail)
					{
						if (GetStorePrimaryMaximum (eAllocationSummaryNode.GenericType, aStore) <
							Include.LargestIntegerMaximum)
						{
							if (GetStorePrimaryMaximum (eAllocationSummaryNode.DetailSubType, aStore) <
								Include.LargestIntegerMaximum)
							{
								if (GetStorePrimaryMaximum(eAllocationSummaryNode.Bulk, aStore) <
									Include.LargestIntegerMaximum)
								{
									return 
										GetStorePrimaryMaximum (eAllocationSummaryNode.GenericType, aStore)
										+ GetStorePrimaryMaximum (eAllocationSummaryNode.DetailSubType, aStore)
										- GetStorePrimaryMaximum (eAllocationSummaryNode.Bulk, aStore);
								}
								return 
									GetStorePrimaryMaximum (eAllocationSummaryNode.GenericType, aStore)
									+ GetStorePrimaryMaximum (eAllocationSummaryNode.DetailType, aStore);
							}
							return GetStorePrimaryMaximum (eAllocationSummaryNode.DetailSubType, aStore);
						}
						return GetStorePrimaryMaximum (eAllocationSummaryNode.GenericType, aStore);
					}
					if (GetStorePrimaryMaximum (eAllocationSummaryNode.GenericType, aStore) <
						Include.LargestIntegerMaximum)
					{
						if (GetStorePrimaryMaximum (eAllocationSummaryNode.DetailSubType, aStore) <
							Include.LargestIntegerMaximum)
						{
							return
								GetStorePrimaryMaximum (eAllocationSummaryNode.GenericType, aStore)
								+ GetStorePrimaryMaximum (eAllocationSummaryNode.DetailSubType, aStore);
						}
						return GetStorePrimaryMaximum (eAllocationSummaryNode.DetailSubType, aStore);
					}
					return GetStorePrimaryMaximum (eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.AllSizes):
				{
					maximum = 0;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
						{
							if (maximum < Include.LargestIntegerMaximum)
							{
								if (GetStorePrimaryMaximum(hsb, aStore) <
									Include.LargestIntegerMaximum)
								{
									maximum += GetStorePrimaryMaximum(hsb, aStore);
								}
								else
								{
									maximum = Include.LargestIntegerMaximum;
								}
							}
						}
					}
					return maximum;
				}
				case (eComponentType.Bulk):
				{
					return GetStorePrimaryMaximum (eAllocationSummaryNode.Bulk, aStore);
				}
				case (eComponentType.ColorAndSize):
				{
					maximum = 0;
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											if (maximum < Include.LargestIntegerMaximum)
											{
												if (GetStorePrimaryMaximum(hsb, aStore) <
													Include.LargestIntegerMaximum)
												{
													maximum += GetStorePrimaryMaximum(hsb, aStore);
												}
												else
												{
													maximum = Include.LargestIntegerMaximum;
												}
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										if (hcb.SizeIsInColor(sizeComponent.SizeRID))
										{
											if (maximum < Include.LargestIntegerMaximum)
											{
												if (GetStorePrimaryMaximum(hcb, sizeComponent.SizeRID, aStore) <
													Include.LargestIntegerMaximum)
												{
													maximum += GetStorePrimaryMaximum(hcb, sizeComponent.SizeRID, aStore);
												}
												else
												{
													maximum = Include.LargestIntegerMaximum;
												}
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (maximum < Include.LargestIntegerMaximum)
												{
													if (GetStorePrimaryMaximum(hcb, scp.Key, aStore) <
														Include.LargestIntegerMaximum)
													{
														maximum += GetStorePrimaryMaximum(hcb, scp.Key, aStore);
													}
													else
													{
														maximum = Include.LargestIntegerMaximum;
													}
												}
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (HdrColorBin hcb in BulkColors.Values)
									{
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (maximum < Include.LargestIntegerMaximum)
												{
													if (GetStorePrimaryMaximum(hcb, scp.Key, aStore) <
														Include.LargestIntegerMaximum)
													{
														maximum += GetStorePrimaryMaximum(hcb, scp.Key, aStore);
													}
													else
													{
														maximum = Include.LargestIntegerMaximum;
													}
												}
											}
										}
									}
									break;
								}
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
//							colorComponent = (AllocationColorOrSizeComponent)aComponent;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							colorComponent = (AllocationColorOrSizeComponent)color;       // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										foreach(HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
										{
											if (GetStorePrimaryMaximum(hsb, aStore) <
												Include.LargestIntegerMaximum)
											{
												maximum += GetStorePrimaryMaximum(hsb, aStore);
											}
											else
											{
												maximum = Include.LargestIntegerMaximum;
											}
										}
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											if (maximum < Include.LargestIntegerMaximum)
											{
												if (GetStorePrimaryMaximum(colorComponent.ColorRID, sizeComponent.SizeRID, aStore) <
													Include.LargestIntegerMaximum)
												{
													maximum += GetStorePrimaryMaximum(colorComponent.ColorRID, sizeComponent.SizeRID, aStore);
												}
												else
												{
													maximum = Include.LargestIntegerMaximum;
												}
											}
										}
										break;
									}
									// BEGIN MID Track #2412 Unknown Component
									case (eComponentType.SpecificSizePrimaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach(SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (maximum < Include.LargestIntegerMaximum)
												{
													if (GetStorePrimaryMaximum(hcb, scp.Key, aStore) <
														Include.LargestIntegerMaximum)
													{
														maximum += GetStorePrimaryMaximum(colorComponent.ColorRID, scp.Key, aStore);
													}
													else
													{
														maximum = Include.LargestIntegerMaximum;
														break;
													}
												}
												else
												{
													break;
												}
											}
										}
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										foreach(SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (maximum < Include.LargestIntegerMaximum)
												{
													if (GetStorePrimaryMaximum(hcb, scp.Key, aStore) <
														Include.LargestIntegerMaximum)
													{
														maximum += GetStorePrimaryMaximum(colorComponent.ColorRID, scp.Key, aStore);
													}
													else
													{
														maximum = Include.LargestIntegerMaximum;
														break;
													}
												}
												else
												{
													break;
												}
											}
										}
										break;
									}
									// END MID Track #2412 Unknown Component
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					return maximum;
				}
				case (eComponentType.DetailType):
				{
					return GetStorePrimaryMaximum(eAllocationSummaryNode.DetailType, aStore);
				}
				case (eComponentType.GenericType):
				{
					return GetStorePrimaryMaximum(eAllocationSummaryNode.GenericType, aStore);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetStorePrimaryMaximum(colorComponent.ColorRID, aStore);
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					maximum = 0;
					foreach (HdrColorBin hcb in BulkColors.Values)
					{
						if (hcb.SizeIsInColor(sizeComponent.SizeRID))
						{
							if (maximum < Include.LargestIntegerMaximum)
							{
								if (GetStorePrimaryMaximum (hcb, sizeComponent.SizeRID, aStore) <
									Include.LargestIntegerMaximum)
								{
									maximum += GetStorePrimaryMaximum(hcb, sizeComponent.SizeRID, aStore);
								}
								maximum = Include.LargestIntegerMaximum;
							}
						}
					}
					return maximum;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetStorePrimaryMaximum (packComponent.PackName, aStore);
				}
				case (eComponentType.Total):
				{
					return GetStorePrimaryMaximum (eAllocationSummaryNode.Total, aStore);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		public int GetStorePrimaryMaximum(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID)
		{
			return GetStorePrimaryMaximum(aAllocationSummaryNode, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		internal int GetStorePrimaryMaximum(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			// BEGIN MID Track #2798 Store Total Allocation cannot be modified when multiple headers selected
			if (this._buildMinMax)
			{
				this.BuildMinMax();
			}
			// END MID Track #2798 Store Total Allocation cannot be modified when multiple headers selected
			switch (aAllocationSummaryNode)
			{
				case (eAllocationSummaryNode.Total):
				{
					return _subtotalTotal[aStore.Index].PrimaryMaximum;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					return _subtotalGenericType[aStore.Index].PrimaryMaximum;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					return _subtotalDetailType[aStore.Index].PrimaryMaximum;
				}
				case(eAllocationSummaryNode.Bulk):
				case(eAllocationSummaryNode.BulkColorTotal): // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color 
				{
					return _subtotalBulk[aStore.Index].PrimaryMaximum;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		public int GetStorePrimaryMaximum(string aSubtotalPackName, int aStoreRID)
		{
			return GetStorePrimaryMaximum(aSubtotalPackName, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		internal int GetStorePrimaryMaximum(string aSubtotalPackName, Index_RID aStore)
		{
			return GetStorePrimaryMaximum(GetSubtotalPackHdr(aSubtotalPackName), aStore);
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		internal int GetStorePrimaryMaximum(PackHdr aSubtotalPack, Index_RID aStore)
		{
			// BEGIN MID Track #2798 Store Total Allocation cannot be modified when multiple headers selected
			if (this._buildMinMax)
			{
				this.BuildMinMax();
			}
			// END MID Track #2798 Store Total Allocation cannot be modified when multiple headers selected
			return aSubtotalPack.GetStorePackPrimaryMaximum(aStore.Index);
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		public int GetStorePrimaryMaximum(int aColorCodeRID, int aStoreRID)
		{
			return GetStorePrimaryMaximum(aColorCodeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		internal int GetStorePrimaryMaximum(int aColorCodeRID, Index_RID aStore)
		{
			return GetStorePrimaryMaximum(GetSubtotalHdrColorBin(aColorCodeRID), aStore);
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		internal int GetStorePrimaryMaximum(HdrColorBin aColor, Index_RID aStore)
		{
			// BEGIN MID Track #2798 Store Total Allocation cannot be modified when multiple headers selected
			if (this._buildMinMax)
			{
				this.BuildMinMax();
			}
			// END MID Track #2798 Store Total Allocation cannot be modified when multiple headers selected
			return aColor.GetStorePrimaryMaximum(aStore.Index);
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		public int GetStorePrimaryMaximum(int aColorCodeRID, int aSizeRID, int aStoreRID)
		{
			return GetStorePrimaryMaximum(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		internal int GetStorePrimaryMaximum(int aColorCodeRID, int aSizeRID, Index_RID aStore)
		{
			return GetStorePrimaryMaximum(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore);
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		internal int GetStorePrimaryMaximum(HdrColorBin aColor, int aSizeRID, Index_RID aStore)
		{
			return GetStorePrimaryMaximum(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore);
		}

		/// <summary>
		/// Gets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Primary Maximum to the store for the specified node.</returns>
		internal int GetStorePrimaryMaximum(HdrSizeBin aSize, Index_RID aStore)
		{
			// BEGIN MID Track #2798 Store Total Allocation cannot be modified when multiple headers selected
			if (this._buildMinMax)
			{
				this.BuildMinMax();
			}
			// END MID Track #2798 Store Total Allocation cannot be modified when multiple headers selected
			return aSize.GetStoreSizePrimaryMaximum(aStore.Index);
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum</param>
		public void SetStorePrimaryMaximum(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, int aPrimaryMaximum)
		{
			SetStorePrimaryMaximum(aAllocationSummaryNode, StoreIndex(aStoreRID), aPrimaryMaximum);
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum</param>
		internal void SetStorePrimaryMaximum(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore, int aPrimaryMaximum)
		{
			switch (aAllocationSummaryNode)
			{
				case (eAllocationSummaryNode.Total):
				{
					_subtotalTotal[aStore.Index].PrimaryMaximum = aPrimaryMaximum;
					break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					_subtotalGenericType[aStore.Index].PrimaryMaximum = aPrimaryMaximum;
					break;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					_subtotalDetailType[aStore.Index].PrimaryMaximum = aPrimaryMaximum;
					break;
				}
				case(eAllocationSummaryNode.Bulk):
				{
					_subtotalBulk[aStore.Index].PrimaryMaximum = aPrimaryMaximum;
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum.</param>
		public void SetStorePrimaryMaximum(string aSubtotalPackName, int aStoreRID, int aPrimaryMaximum)
		{
			SetStorePrimaryMaximum(aSubtotalPackName, StoreIndex(aStoreRID), aPrimaryMaximum);
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Subtotal Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum</param>
		internal void SetStorePrimaryMaximum(string aSubtotalPackName, Index_RID aStore, int aPrimaryMaximum)
		{
			SetStorePrimaryMaximum(GetSubtotalPackHdr(aSubtotalPackName), aStore, aPrimaryMaximum);
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum.</param>
		internal void SetStorePrimaryMaximum(PackHdr aSubtotalPack, Index_RID aStore, int aPrimaryMaximum)
		{
			aSubtotalPack.SetStorePackPrimaryMaximum(aStore.Index, aPrimaryMaximum);
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum</param>
		public void SetStorePrimaryMaximum(int aColorCodeRID, int aStoreRID, int aPrimaryMaximum)
		{
			SetStorePrimaryMaximum(aColorCodeRID, StoreIndex(aStoreRID), aPrimaryMaximum);
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum</param>
		internal void SetStorePrimaryMaximum(int aColorCodeRID, Index_RID aStore, int aPrimaryMaximum)
		{
            // begin TT#1166 - MD - Jellis - Color not in Bulk OR no stores in size analysis
            //if (BulkColors.Contains(aColorCodeRID))
            //{
            //    SetStorePrimaryMaximum((HdrColorBin)_bulkColors[aColorCodeRID], aStore, aPrimaryMaximum);
            //}
            //else
            //{
            //    throw new MIDException(eErrorLevel.severe,
            //        (int)(eMIDTextCode.msg_ColorNotDefinedInBulk),
            //        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_ColorNotDefinedInBulk));
            //}
            SetStorePrimaryMaximum(GetSubtotalHdrColorBin(aColorCodeRID), aStore, aPrimaryMaximum);
            // end TT#1166 - MD - Jellis - Color not in Bulk OR no stores in size analysis
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum</param>
		internal void SetStorePrimaryMaximum(HdrColorBin aColor, Index_RID aStore, int aPrimaryMaximum)
		{
			aColor.SetStorePrimaryMaximum(aStore.Index, aPrimaryMaximum);
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum.</param>
		public void SetStorePrimaryMaximum(int aColorCodeRID, int aSizeRID, int aStoreRID, int aPrimaryMaximum)
		{
			SetStorePrimaryMaximum(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aPrimaryMaximum);
		}

		/// <summary>
		/// Sets Store Primary Maximum audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum</param>
		internal void SetStorePrimaryMaximum(int aColorCodeRID, int aSizeRID, Index_RID aStore, int aPrimaryMaximum)
		{
			SetStorePrimaryMaximum(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore, aPrimaryMaximum);
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum.</param>
		internal void SetStorePrimaryMaximum(HdrColorBin aColor, int aSizeRID, Index_RID aStore, int aPrimaryMaximum)
		{
			SetStorePrimaryMaximum(aColor, GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore, aPrimaryMaximum);
		}

		/// <summary>
		/// Sets Store Primary Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides</param>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aPrimaryMaximum">Primary Maximum</param>
		internal void SetStorePrimaryMaximum(HdrColorBin aColor, HdrSizeBin aSize, Index_RID aStore, int aPrimaryMaximum)
		{
			aSize.SetStoreSizePrimaryMaximum(aStore.Index, aPrimaryMaximum);
		}		 
		#endregion StorePrimaryMaximum

		#region StoreGradeMaximum
		//=====================//
		// Store Grade Maximum //
        //=====================//
        // begin TT#1176 - MD - Jellis - Group Allocation Size Need not observing inv min max
        #region TryGetStoreGradeMaximum
        /// <summary>
        /// Gets Store Maximum for specified store on specified component.
        /// </summary>
        /// <param name="aAllocationProfile">AllocationProfile</param>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Maximum for the store for the specified component.</returns>
        public bool TryGetStoreMaximum(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, bool aAdjust, out int aStoreMaximum, out eMIDTextCode aStatusReasonCode)
        {
            if (aAllocationProfile == null)
            {
                return TryGetStoreMaximum(aComponent, StoreIndex(aStoreRID), aAdjust, out aStoreMaximum, out aStatusReasonCode);
            }
            return aAllocationProfile.TryGetStoreMaximum(aComponent, StoreIndex(aStoreRID), aAdjust, out aStoreMaximum, out aStatusReasonCode); 
        }

        /// <summary>
        /// Gets Store Maximum for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Maximum for the store for the specified component.</returns>
        public bool TryGetStoreMaximum(GeneralComponent aComponent, int aStoreRID, bool aAdjust, out int aStoreMaximum, out eMIDTextCode aStatusReasonCode) 
        {
            return TryGetStoreMaximum(aComponent, StoreIndex(aStoreRID), aAdjust, out aStoreMaximum, out aStatusReasonCode); 
        }

        /// <summary>
        /// Gets Store Maximum for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Maximum for the store for the specified component.</returns>
        internal bool TryGetStoreMaximum(GeneralComponent aComponent, Index_RID aStore, bool aAdjust, out int aStoreMaximum, out eMIDTextCode aStatusReasonCode)
        {
            AllocationPackComponent packComponent;
            AllocationColorOrSizeComponent colorComponent;
            AllocationColorOrSizeComponent sizeComponent;
            eMIDTextCode statusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
            switch (aComponent.ComponentType)
            {
                case (eComponentType.AllColors):
                    {
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.BulkColorTotal, aStore, aAdjust);
                        return true;
                    }
                case (eComponentType.AllGenericPacks):
                    {
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust);
                        return true;
                    }
                case (eComponentType.AllNonGenericPacks):
                    {
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        if (this.BulkIsDetail)
                        {
                            if (GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust)
                                < Include.LargestIntegerMaximum)                                       
                            {
                                if (GetStoreMaximum(eAllocationSummaryNode.Bulk, aStore, aAdjust) 
                                    < Include.LargestIntegerMaximum)                              
                                {
                                    aStoreMaximum = 
                                        (GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust) 
                                        - GetStoreMaximum(eAllocationSummaryNode.Bulk, aStore, aAdjust));
                                    return true;
                                }
                            }
                            aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust);
                            return true;
                        }
                        aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust);
                        return true;
                    }
                case (eComponentType.AllPacks):
                    {
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        if (this.BulkIsDetail)
                        {
                            if (GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust)
                                < Include.LargestIntegerMaximum)                                    
                            {
                                if (GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust) 
                                    < Include.LargestIntegerMaximum)                                      
                                {
                                    if (GetStoreMaximum(eAllocationSummaryNode.Bulk, aStore, aAdjust) 
                                        < Include.LargestIntegerMaximum)                              
                                    {
                                        aStoreMaximum =
                                            GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust) 
                                            + GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust) 
                                            - GetStoreMaximum(eAllocationSummaryNode.Bulk, aStore, aAdjust);
                                        return true;
                                    }
                                }
                                aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust);
                                return true;
                            }
                            aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust); 
                            return true;
                        }
                        if (GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust) 
                            < Include.LargestIntegerMaximum)                                     
                        {
                            if (GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust) 
                                < Include.LargestIntegerMaximum)                                     
                            {
                                aStoreMaximum = 
                                    GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust) 
                                    + GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust);
                                return true;
                            }
                            aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust);
                            return true;
                        }
                        aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust);
                        return true;
                    }
                case (eComponentType.AllSizes):
                    {
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        aStoreMaximum = 0;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                            {
                                if (aStoreMaximum <
                                    Include.LargestIntegerMaximum)
                                {
                                    if (GetStoreMaximum(hsb, aStore, aAdjust) 
                                        < Include.LargestIntegerMaximum)      
                                    {
                                        aStoreMaximum += GetStoreMaximum(hsb, aStore, aAdjust);
                                    }
                                    else
                                    {
                                        aStoreMaximum = Include.LargestIntegerMaximum;
                                    }
                                }
                            }
                        }
                        return true;
                    }
                case (eComponentType.Bulk):
                    {
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.Bulk, aStore, aAdjust);
                        return true;
                    }
                case (eComponentType.ColorAndSize):
                    {
                        aStoreMaximum = 0;
                        AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
                        GeneralComponent color = acs.ColorComponent;
                        GeneralComponent size = acs.SizeComponent;
                        HdrColorBin colorBin;
                        HdrSizeBin sizeBin;
                        switch (color.ComponentType)
                        {
                            case (eComponentType.AllColors):
                                {
                                    switch (size.ComponentType)
                                    {
                                        case (eComponentType.AllSizes):
                                            {
                                                aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                                                    {
                                                        if (aStoreMaximum < Include.LargestIntegerMaximum)
                                                        {
                                                            if (GetStoreMaximum(hsb, aStore, aAdjust) 
                                                                < Include.LargestIntegerMaximum)      
                                                            {
                                                                aStoreMaximum += GetStoreMaximum(hsb, aStore, aAdjust); 
                                                            }
                                                            else
                                                            {
                                                                aStoreMaximum = Include.LargestIntegerMaximum;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSize):
                                            {
                                                aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                                                sizeComponent = (AllocationColorOrSizeComponent)size; 
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    if (hcb.TryGetSizeBin(sizeComponent.SizeRID, out sizeBin, out statusReasonCode))
                                                    {
                                                        if (aStoreMaximum < Include.LargestIntegerMaximum)
                                                        {
                                                            if (GetStoreMaximum(sizeBin, aStore, aAdjust)
                                                                < Include.LargestIntegerMaximum)                             
                                                            {
                                                                aStoreMaximum += GetStoreMaximum(sizeBin, aStore, aAdjust);
                                                            }
                                                            else
                                                            {
                                                                aStoreMaximum = Include.LargestIntegerMaximum;
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizePrimaryDim):
                                            {
                                                aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                                                sizeComponent = (AllocationColorOrSizeComponent)size; 
                                                SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.TryGetSizeBin(scp.Key, out sizeBin, out statusReasonCode))
                                                        {
                                                            if (aStoreMaximum < Include.LargestIntegerMaximum)
                                                            {
                                                                if (GetStoreMaximum(sizeBin, aStore, aAdjust)
                                                                    < Include.LargestIntegerMaximum)              
                                                                {
                                                                    aStoreMaximum += GetStoreMaximum(sizeBin, aStore, aAdjust); 
                                                                }
                                                                else
                                                                {
                                                                    aStoreMaximum = Include.LargestIntegerMaximum;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizeSecondaryDim):
                                            {
                                                aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                                                sizeComponent = (AllocationColorOrSizeComponent)size; 
                                                SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                foreach (HdrColorBin hcb in BulkColors.Values)
                                                {
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.TryGetSizeBin(scp.Key, out sizeBin, out statusReasonCode))
                                                        {
                                                            if (aStoreMaximum < Include.LargestIntegerMaximum)
                                                            {
                                                                if (GetStoreMaximum(sizeBin, aStore, aAdjust) 
                                                                    < Include.LargestIntegerMaximum)   
                                                                {
                                                                    aStoreMaximum += GetStoreMaximum(sizeBin, aStore, aAdjust); 
                                                                }
                                                                else
                                                                {
                                                                    aStoreMaximum = Include.LargestIntegerMaximum;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        default:
                                            {
                                                throw new MIDException(eErrorLevel.severe,
                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                            }
                                    }
                                    break;
                                }
                            case (eComponentType.SpecificColor):
                                {
                                    colorComponent = (AllocationColorOrSizeComponent)color;
                                    aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                                    if (TryGetSubtotalHdrColorBin(colorComponent.ColorRID, out colorBin, out statusReasonCode))
                                    {
                                        switch (size.ComponentType)
                                        {
                                            case (eComponentType.AllSizes):
                                                {
                                                    foreach (HdrSizeBin hsb in colorBin.ColorSizes.Values)
                                                    {
                                                        if (aStoreMaximum < Include.LargestIntegerMaximum)
                                                        {
                                                            if (GetStoreMaximum(hsb, aStore, aAdjust)
                                                                < Include.LargestIntegerMaximum)    
                                                            {
                                                                aStoreMaximum += GetStoreMaximum(hsb, aStore, aAdjust); 
                                                            }
                                                            else
                                                            {
                                                                aStoreMaximum = Include.LargestIntegerMaximum;
                                                            }
                                                        }
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSize):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                    if (colorBin.TryGetSizeBin(sizeComponent.SizeRID, out sizeBin, out statusReasonCode))
                                                    {
                                                        if (aStoreMaximum < Include.LargestIntegerMaximum)
                                                        {
                                                            if (GetStoreMaximum(sizeBin, aStore, aAdjust) 
                                                                < Include.LargestIntegerMaximum)     
                                                            {
                                                                aStoreMaximum += GetStoreMaximum(sizeBin, aStore, aAdjust);
                                                            }
                                                            else
                                                            {
                                                                aStoreMaximum = Include.LargestIntegerMaximum;
                                                            }
                                                        }
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizePrimaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (colorBin.TryGetSizeBin(scp.Key, out sizeBin, out statusReasonCode))
                                                        {
                                                            if (aStoreMaximum < Include.LargestIntegerMaximum)
                                                            {
                                                                if (GetStoreMaximum(sizeBin, aStore, aAdjust) 
                                                                    < Include.LargestIntegerMaximum)             
                                                                {
                                                                    aStoreMaximum += GetStoreMaximum(sizeBin, aStore, aAdjust); 
                                                                }
                                                                else
                                                                {
                                                                    aStoreMaximum = Include.LargestIntegerMaximum;
                                                                    break;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizeSecondaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (colorBin.TryGetSizeBin(scp.Key, out sizeBin, out statusReasonCode))
                                                        {
                                                            if (aStoreMaximum < Include.LargestIntegerMaximum)
                                                            {
                                                                if (GetStoreMaximum(sizeBin, aStore, aAdjust)
                                                                    < Include.LargestIntegerMaximum)
                                                                {
                                                                    aStoreMaximum += GetStoreMaximum(sizeBin, aStore, aAdjust);
                                                                }
                                                                else
                                                                {
                                                                    aStoreMaximum = Include.LargestIntegerMaximum;
                                                                    break;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    break;
                                                }
                                            default:
                                                {
                                                    throw new MIDException(eErrorLevel.severe,
                                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                                }
                                        }
                                    }
                                    break;
                                }
                            default:
                                {
                                    throw new MIDException(eErrorLevel.severe,
                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                }
                        }
                        return true;
                    }
                case (eComponentType.DetailType):
                    {
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.DetailType, aStore, aAdjust);
                        return true;
                    }
                case (eComponentType.GenericType):
                    {
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust);
                        return true;
                    }
                case (eComponentType.SpecificColor):
                    {
                        colorComponent = (AllocationColorOrSizeComponent)aComponent;
                        return TryGetStoreMaximum(colorComponent.ColorRID, aStore, aAdjust, out aStoreMaximum, out aStatusReasonCode);
                    }
                case (eComponentType.SpecificSize):
                    {
                        sizeComponent = (AllocationColorOrSizeComponent)aComponent;
                        aStoreMaximum = 0;
                        HdrSizeBin sizeBin;
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        foreach (HdrColorBin hcb in BulkColors.Values)
                        {
                            if (hcb.TryGetSizeBin(sizeComponent.SizeRID, out sizeBin, out statusReasonCode))
                            {
                                if (aStoreMaximum < Include.LargestIntegerMaximum)
                                {
                                    if (GetStoreMaximum(sizeBin, aStore, aAdjust)
                                        < Include.LargestIntegerMaximum)                             
                                    {
                                        aStoreMaximum += GetStoreMaximum(sizeBin, aStore, aAdjust); 
                                    }
                                    else
                                    {
                                        aStoreMaximum = Include.LargestIntegerMaximum;
                                    }
                                }
                            }
                        }
                        return true;
                    }
                case (eComponentType.SpecificPack):
                    {
                        packComponent = (AllocationPackComponent)aComponent;
                        aStoreMaximum = GetStoreMaximum(packComponent.PackName, aStore, aAdjust);
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        return true;
                    }
                case (eComponentType.Total):
                    {
                        aStoreMaximum = GetStoreMaximum(eAllocationSummaryNode.Total, aStore, aAdjust);
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        return true;
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                    }
            }
        }

        /// <summary>
        /// Gets Store Maximum for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <returns>Maximum to the store for the specified node.</returns>
        public bool TryGetStoreMaximum(int aColorCodeRID, int aStoreRID, bool aAdjust, out int aStoreMaximum, out eMIDTextCode aStatusReasonCode)
        {
            return TryGetStoreMaximum(aColorCodeRID, StoreIndex(aStoreRID), aAdjust, out aStoreMaximum, out aStatusReasonCode); 
        }

        /// <summary>
        /// Gets Store Maximum for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Maximum to the store for the specified node.</returns>
        internal bool TryGetStoreMaximum(int aColorCodeRID, Index_RID aStore, bool aAdjust, out int aStoreMaximum, out eMIDTextCode aStatusReasonCode) 
        {
            HdrColorBin colorBin;
            if (TryGetSubtotalHdrColorBin(aColorCodeRID, out colorBin, out aStatusReasonCode))
            {
                aStoreMaximum = GetStoreMaximum(colorBin, aStore, aAdjust);
                return true;
            }
           aStoreMaximum = 0;
           return false;
        }


        /// <summary>
        /// Gets Store Maximum for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <returns>Maximum to the store for the specified node.</returns>
        public bool TryGetStoreMaximum(int aColorCodeRID, int aSizeRID, int aStoreRID, bool aAdjust, out int aStoreMaximum, out eMIDTextCode aStatusReasonCode)
        {
            return TryGetStoreMaximum(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aAdjust, out aStoreMaximum, out aStatusReasonCode);
        }

        /// <summary>
        /// Gets Store Maximum for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Maximum to the store for the specified node.</returns>
        internal bool TryGetStoreMaximum(int aColorCodeRID, int aSizeRID, Index_RID aStore, bool aAdjust, out int aStoreMaximum, out eMIDTextCode aStatusReasonCode) 
        {
            HdrColorBin colorBin;
            if (TryGetSubtotalHdrColorBin(aColorCodeRID, out colorBin, out aStatusReasonCode))
            {
                return TryGetStoreMaximum(colorBin, aSizeRID, aStore, aAdjust, out aStoreMaximum, out aStatusReasonCode);
            }
            aStoreMaximum = 0;
            return false;
        }

        /// <summary>
        /// Gets Store Maximum for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Maximum to the store for the specified node.</returns>
        internal bool TryGetStoreMaximum(HdrColorBin aColor, int aSizeRID, Index_RID aStore, bool aAdjust, out int aStoreMaximum, out eMIDTextCode aStatusReasonCode) 
        {
            HdrSizeBin sizeBin;
            if (TryGetSubtotalHdrSizeBin(aColor, aSizeRID, out sizeBin, out aStatusReasonCode))
            {
                aStoreMaximum = GetStoreMaximum(sizeBin, aStore, aAdjust);
                return true;
            }
            aStoreMaximum = 0;
            return false;
        }

        #endregion TryGetStoreGradeMaximum

        #region GetStoreGradeMaximum 
		/// <summary>
		/// Gets Store Maximum for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Maximum to the store for the specified node.</returns>
		public int GetStoreMaximum(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, bool aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
		{
            return GetStoreMaximum(aAllocationSummaryNode, StoreIndex(aStoreRID), aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
		}

		/// <summary>
		/// Gets Store Maximum for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Maximum to the store for the specified node.</returns>
		internal int GetStoreMaximum(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore, bool aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
		{
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   
            }
			if (_buildMinMax)
			{
				BuildMinMax();
			}
            if (aAdjust
                && AssortmentProfile != null)
            {
                switch (aAllocationSummaryNode)
                {
                    case (eAllocationSummaryNode.Total):
                        {
                            return Math.Max(0,
                                            _subtotalTotal[aStore.Index].Maximum
                                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                                            + GetStoreQtyAllocated(eAllocationSummaryNode.Total, aStore));
                        }
                    case (eAllocationSummaryNode.GenericType):
                        {
                            return Math.Max(0,
                                            _subtotalGenericType[aStore.Index].Maximum
                                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                                            + GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore));
                        }
                    case (eAllocationSummaryNode.DetailType):
                        {
                            return Math.Max(0,
                                           _subtotalDetailType[aStore.Index].Maximum
                                           - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                                           + GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, aStore));
                        }
                    case (eAllocationSummaryNode.Bulk):
                    case (eAllocationSummaryNode.BulkColorTotal): 
                        {
                            return Math.Max(0,
                                    _subtotalBulk[aStore.Index].Maximum
                                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                                    + GetStoreQtyAllocated(eAllocationSummaryNode.Bulk, aStore));
                        }
                    default:
                        {
                            throw new MIDException(eErrorLevel.severe,
                                (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
                        }
                }
            }
			switch (aAllocationSummaryNode)
			{
				case (eAllocationSummaryNode.Total):
				{
					return _subtotalTotal[aStore.Index].Maximum;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					return _subtotalGenericType[aStore.Index].Maximum;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					return _subtotalDetailType[aStore.Index].Maximum;
				}
				case(eAllocationSummaryNode.Bulk):
				case (eAllocationSummaryNode.BulkColorTotal):
				{
					return _subtotalBulk[aStore.Index].Maximum;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
		}

		/// <summary>
		/// Gets Store Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <returns>Maximum to the store for the specified node.</returns>
		public int GetStoreMaximum(string aSubtotalPackName, int aStoreRID, bool aAdjust) 
		{
            return GetStoreMaximum(aSubtotalPackName, StoreIndex(aStoreRID), aAdjust); 
		}

		/// <summary>
		/// Gets Store Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Maximum to the store for the specified node.</returns>
		internal int GetStoreMaximum(string aSubtotalPackName, Index_RID aStore, bool aAdjust)  
		{
            return GetStoreMaximum(GetSubtotalPackHdr(aSubtotalPackName), aStore, aAdjust); 
		}

		/// <summary>
		/// Gets Store Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <returns>Maximum to the store for the specified node.</returns>
		internal int GetStoreMaximum(PackHdr aSubtotalPack, Index_RID aStore, bool aAdjust) 
		{
            if (_buildSubtotal)
            {
                this.BuildSubtotal();
            }
			if (_buildMinMax)
			{
				BuildMinMax();
			}
            if (aAdjust
                && AssortmentProfile != null)
            {
                return Math.Max(0,
                            aSubtotalPack.GetStorePackMaximum(aStore.Index)
                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                            + aSubtotalPack.GetStorePacksAllocated(aStore.Index)
                              * aSubtotalPack.PackMultiple);
            }
			return aSubtotalPack.GetStorePackMaximum(aStore.Index);
		}


		/// <summary>
		/// Gets Store Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Maximum to the store for the specified node.</returns>
		internal int GetStoreMaximum(HdrColorBin aColor, Index_RID aStore, bool aAdjust) 
		{
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); 
            }
			if (_buildMinMax)
			{
				BuildMinMax();
			}
            if (aAdjust
                && AssortmentProfile != null)
            {
                return Math.Max(0,
                            aColor.GetStoreMaximum(aStore.Index)
                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                            + aColor.GetStoreUnitsAllocated(aStore.Index));
            }
			return aColor.GetStoreMaximum(aStore.Index);
		}


		/// <summary>
		/// Gets Store Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <returns>Maximum to the store for the specified node.</returns>
		internal int GetStoreMaximum(HdrSizeBin aSize, Index_RID aStore, bool aAdjust)
		{
            if (_buildSubtotal)
            {
                this.BuildSubtotal();  
            }
			if (_buildMinMax)
			{
				BuildMinMax();
			}
            if (aAdjust
                && AssortmentProfile != null)
            {
                return Math.Max(0,
                            aSize.GetStoreSizeMaximum(aStore.Index)
                            - AssortmentProfile.GetStoreSizeInventoryBasisAllocation(InventoryBasisRIDs, aSize.SizeCodeRID, aStore)
                            + aSize.GetStoreSizeUnitsAllocated(aStore.Index));
            }
			return aSize.GetStoreSizeMaximum(aStore.Index);
		}
        #endregion SetStoreGradeMaximum

        #region OBSOLETE CODE (TT#1176)
        //#region GetStoreGradeMaximum
        ///// <summary>
        ///// Gets Store Maximum for specified store on specified component.
        ///// </summary>
        ///// <param name="aAllocationProfile">AllocationProfile</param>
        ///// <param name="aComponent">Description of the component</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>Maximum for the store for the specified component.</returns>
        //public int GetStoreMaximum(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, bool aAdjust) // TT#1074 - MD _ Jellis - Group ALlocation - Inventory Min Max Broken
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        return GetStoreMaximum(aComponent, StoreIndex(aStoreRID), aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //    }
        //    return aAllocationProfile.GetStoreMaximum(aComponent, StoreIndex(aStoreRID), aAdjust);  // TT#1074 - MD - Jellis - Group ALlocation Inventory Min Max Broken
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified component.
        ///// </summary>
        ///// <param name="aComponent">Description of the component</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>Maximum for the store for the specified component.</returns>
        //public int GetStoreMaximum(GeneralComponent aComponent, int aStoreRID, bool aAdjust) // TT#1074 - MD - jellis - Group Allocation - Inventory Min Max Broken
        //{
        //    return GetStoreMaximum(aComponent, StoreIndex(aStoreRID), aAdjust); // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified component.
        ///// </summary>
        ///// <param name="aComponent">Description of the component</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>Maximum for the store for the specified component.</returns>
        //internal int GetStoreMaximum(GeneralComponent aComponent, Index_RID aStore, bool aAdjust) // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
        //{
        //    int maximum;
        //    AllocationPackComponent packComponent;
        //    AllocationColorOrSizeComponent colorComponent;
        //    AllocationColorOrSizeComponent sizeComponent;
        //    switch (aComponent.ComponentType)
        //    {
        //        case (eComponentType.AllColors):
        //            {
        //                return GetStoreMaximum(eAllocationSummaryNode.BulkColorTotal, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocatio Inventory Min Max Broken
        //            }
        //        case (eComponentType.AllGenericPacks):
        //            {
        //                return GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //            }
        //        case (eComponentType.AllNonGenericPacks):
        //            {
        //                if (this.BulkIsDetail)
        //                {
        //                    if (GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                        < Include.LargestIntegerMaximum)                                       // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                    {
        //                        if (GetStoreMaximum(eAllocationSummaryNode.Bulk, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                            < Include.LargestIntegerMaximum)                              // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                        {
        //                            return
        //                                (GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                - GetStoreMaximum(eAllocationSummaryNode.Bulk, aStore, aAdjust)); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                        }
        //                    }
        //                    return GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                }
        //                return GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //            }
        //        case (eComponentType.AllPacks):
        //            {
        //                if (this.BulkIsDetail)
        //                {
        //                    if (GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                        < Include.LargestIntegerMaximum)                                     // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                    {
        //                        if (GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                            < Include.LargestIntegerMaximum)                                       // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                        {
        //                            if (GetStoreMaximum(eAllocationSummaryNode.Bulk, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                < Include.LargestIntegerMaximum)                              // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                            {
        //                                return
        //                                    GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                    + GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                    - GetStoreMaximum(eAllocationSummaryNode.Bulk, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                            }
        //                        }
        //                        return GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust);// TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                    }
        //                    return GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                }
        //                if (GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                    < Include.LargestIntegerMaximum)                                     // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken 
        //                {
        //                    if (GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                        < Include.LargestIntegerMaximum)                                       // TT#1074 - MD - Jellis - Group ALlocation Inventory Min Max Broken
        //                    {
        //                        return
        //                            GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                            + GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                    }
        //                    return GetStoreMaximum(eAllocationSummaryNode.DetailSubType, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                }
        //                return GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //            }
        //        case (eComponentType.AllSizes):
        //            {
        //                maximum = 0;
        //                foreach (HdrColorBin hcb in BulkColors.Values)
        //                {
        //                    foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
        //                    {
        //                        if (maximum <
        //                            Include.LargestIntegerMaximum)
        //                        {
        //                            if (GetStoreMaximum(hsb, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                < Include.LargestIntegerMaximum)      // TT#1074 - MD - Jellis - Group ALlocation Inventory Min Max Broken
        //                            {
        //                                maximum += GetStoreMaximum(hsb, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                            }
        //                            else
        //                            {
        //                                maximum = Include.LargestIntegerMaximum;
        //                            }
        //                        }
        //                    }
        //                }
        //                return maximum;
        //            }
        //        case (eComponentType.Bulk):
        //            {
        //                return GetStoreMaximum(eAllocationSummaryNode.Bulk, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //            }
        //        case (eComponentType.ColorAndSize):
        //            {
        //                maximum = 0;
        //                AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
        //                GeneralComponent color = acs.ColorComponent;
        //                GeneralComponent size = acs.SizeComponent;
        //                switch (color.ComponentType)
        //                {
        //                    case (eComponentType.AllColors):
        //                        {
        //                            switch (size.ComponentType)
        //                            {
        //                                case (eComponentType.AllSizes):
        //                                    {
        //                                        foreach (HdrColorBin hcb in BulkColors.Values)
        //                                        {
        //                                            foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
        //                                            {
        //                                                if (maximum < Include.LargestIntegerMaximum)
        //                                                {
        //                                                    if (GetStoreMaximum(hsb, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                        < Include.LargestIntegerMaximum)      // TT#1074 - MD - Jellis - Group ALloation Inventory Min Max Broken
        //                                                    {
        //                                                        maximum += GetStoreMaximum(hsb, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        maximum = Include.LargestIntegerMaximum;
        //                                                    }
        //                                                }
        //                                            }
        //                                        }
        //                                        break;
        //                                    }
        //                                case (eComponentType.SpecificSize):
        //                                    {
        //                                        sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
        //                                        foreach (HdrColorBin hcb in BulkColors.Values)
        //                                        {
        //                                            if (hcb.SizeIsInColor(sizeComponent.SizeRID))
        //                                            {
        //                                                if (maximum < Include.LargestIntegerMaximum)
        //                                                {
        //                                                    if (GetStoreMaximum(hcb, sizeComponent.SizeRID, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                        < Include.LargestIntegerMaximum)                             // TT#1074 - MD - Jellis - Group ALlocation Inventory Min Max Broken
        //                                                    {
        //                                                        maximum += GetStoreMaximum(hcb, sizeComponent.SizeRID, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        maximum = Include.LargestIntegerMaximum;
        //                                                    }
        //                                                }
        //                                            }
        //                                        }
        //                                        break;
        //                                    }
        //                                case (eComponentType.SpecificSizePrimaryDim):
        //                                    {
        //                                        sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
        //                                        SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
        //                                        foreach (HdrColorBin hcb in BulkColors.Values)
        //                                        {
        //                                            foreach (SizeCodeProfile scp in scl)
        //                                            {
        //                                                if (hcb.SizeIsInColor(scp.Key))
        //                                                {
        //                                                    if (maximum < Include.LargestIntegerMaximum)
        //                                                    {
        //                                                        if (GetStoreMaximum(hcb, scp.Key, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                            < Include.LargestIntegerMaximum)               // TT#1074 - MD - Jellis - Group Alloation Inventory Min Max Broken
        //                                                        {
        //                                                            maximum += GetStoreMaximum(hcb, scp.Key, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                        }
        //                                                        else
        //                                                        {
        //                                                            maximum = Include.LargestIntegerMaximum;
        //                                                        }
        //                                                    }
        //                                                }
        //                                            }
        //                                        }
        //                                        break;
        //                                    }
        //                                case (eComponentType.SpecificSizeSecondaryDim):
        //                                    {
        //                                        sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
        //                                        SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
        //                                        foreach (HdrColorBin hcb in BulkColors.Values)
        //                                        {
        //                                            foreach (SizeCodeProfile scp in scl)
        //                                            {
        //                                                if (hcb.SizeIsInColor(scp.Key))
        //                                                {
        //                                                    if (maximum < Include.LargestIntegerMaximum)
        //                                                    {
        //                                                        if (GetStoreMaximum(hcb, scp.Key, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                            < Include.LargestIntegerMaximum)               // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                        {
        //                                                            maximum += GetStoreMaximum(hcb, scp.Key, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                        }
        //                                                        else
        //                                                        {
        //                                                            maximum = Include.LargestIntegerMaximum;
        //                                                        }
        //                                                    }
        //                                                }
        //                                            }
        //                                        }
        //                                        break;
        //                                    }
        //                                default:
        //                                    {
        //                                        throw new MIDException(eErrorLevel.severe,
        //                                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                                    }
        //                            }
        //                            break;
        //                        }
        //                    case (eComponentType.SpecificColor):
        //                        {
        //                            colorComponent = (AllocationColorOrSizeComponent)color;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
        //                            if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
        //                            {
        //                                switch (size.ComponentType)
        //                                {
        //                                    case (eComponentType.AllSizes):
        //                                        {
        //                                            foreach (HdrSizeBin hsb in this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
        //                                            {
        //                                                if (maximum < Include.LargestIntegerMaximum)
        //                                                {
        //                                                    if (GetStoreMaximum(hsb, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                        < Include.LargestIntegerMaximum)      // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken 
        //                                                    {
        //                                                        maximum += GetStoreMaximum(hsb, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        maximum = Include.LargestIntegerMaximum;
        //                                                    }
        //                                                }
        //                                            }
        //                                            break;
        //                                        }
        //                                    case (eComponentType.SpecificSize):
        //                                        {
        //                                            sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
        //                                            if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
        //                                            {
        //                                                if (maximum < Include.LargestIntegerMaximum)
        //                                                {
        //                                                    if (GetStoreMaximum(colorComponent.ColorRID, sizeComponent.SizeRID, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                        < Include.LargestIntegerMaximum)                                                 // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                    {
        //                                                        maximum += GetStoreMaximum(colorComponent.ColorRID, sizeComponent.SizeRID, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        maximum = Include.LargestIntegerMaximum;
        //                                                    }
        //                                                }
        //                                            }
        //                                            break;
        //                                        }
        //                                    // BEGIN MID Track #2412 Unknown Component
        //                                    case (eComponentType.SpecificSizePrimaryDim):
        //                                        {
        //                                            sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
        //                                            SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
        //                                            HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
        //                                            foreach (SizeCodeProfile scp in scl)
        //                                            {
        //                                                if (hcb.SizeIsInColor(scp.Key))
        //                                                {
        //                                                    if (maximum < Include.LargestIntegerMaximum)
        //                                                    {
        //                                                        if (GetStoreMaximum(hcb, scp.Key, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                            < Include.LargestIntegerMaximum)               // TT#1074 - MD - Jellis - Group ALlocation Inventory Min Max Broken
        //                                                        {
        //                                                            maximum += GetStoreMaximum(hcb, scp.Key, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                        }
        //                                                        else
        //                                                        {
        //                                                            maximum = Include.LargestIntegerMaximum;
        //                                                            break;
        //                                                        }
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        break;
        //                                                    }
        //                                                }
        //                                            }
        //                                            break;
        //                                        }
        //                                    case (eComponentType.SpecificSizeSecondaryDim):
        //                                        {
        //                                            sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
        //                                            SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
        //                                            HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
        //                                            foreach (SizeCodeProfile scp in scl)
        //                                            {
        //                                                if (hcb.SizeIsInColor(scp.Key))
        //                                                {
        //                                                    if (maximum < Include.LargestIntegerMaximum)
        //                                                    {
        //                                                        if (GetStoreMaximum(hcb, scp.Key, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                            < Include.LargestIntegerMaximum)   // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max broken
        //                                                        {
        //                                                            maximum += GetStoreMaximum(hcb, scp.Key, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                                        }
        //                                                        else
        //                                                        {
        //                                                            maximum = Include.LargestIntegerMaximum;
        //                                                            break;
        //                                                        }
        //                                                    }
        //                                                    else
        //                                                    {
        //                                                        break;
        //                                                    }
        //                                                }
        //                                            }
        //                                            break;
        //                                        }
        //                                    // END MID Track #2412 Unknown Component
        //                                    default:
        //                                        {
        //                                            throw new MIDException(eErrorLevel.severe,
        //                                                (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                                        }
        //                                }
        //                            }
        //                            break;
        //                        }
        //                    default:
        //                        {
        //                            throw new MIDException(eErrorLevel.severe,
        //                                (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                        }
        //                }
        //                return maximum;
        //            }
        //        case (eComponentType.DetailType):
        //            {
        //                return GetStoreMaximum(eAllocationSummaryNode.DetailType, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //            }
        //        case (eComponentType.GenericType):
        //            {
        //                return GetStoreMaximum(eAllocationSummaryNode.GenericType, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //            }
        //        case (eComponentType.SpecificColor):
        //            {
        //                colorComponent = (AllocationColorOrSizeComponent)aComponent;
        //                return GetStoreMaximum(colorComponent.ColorRID, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //            }
        //        case (eComponentType.SpecificSize):
        //            {
        //                sizeComponent = (AllocationColorOrSizeComponent)aComponent;
        //                maximum = 0;
        //                foreach (HdrColorBin hcb in BulkColors.Values)
        //                {
        //                    if (hcb.SizeIsInColor(sizeComponent.SizeRID))
        //                    {
        //                        if (maximum < Include.LargestIntegerMaximum)
        //                        {
        //                            if (GetStoreMaximum(hcb, sizeComponent.SizeRID, aStore, aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                                < Include.LargestIntegerMaximum)                             // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                            {
        //                                maximum += GetStoreMaximum(hcb, sizeComponent.SizeRID, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //                            }
        //                            else
        //                            {
        //                                maximum = Include.LargestIntegerMaximum;
        //                            }
        //                        }
        //                    }
        //                }
        //                return maximum;
        //            }
        //        case (eComponentType.SpecificPack):
        //            {
        //                packComponent = (AllocationPackComponent)aComponent;
        //                return GetStoreMaximum(packComponent.PackName, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //            }
        //        case (eComponentType.Total):
        //            {
        //                return GetStoreMaximum(eAllocationSummaryNode.Total, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //            }
        //        default:
        //            {
        //                throw new MIDException(eErrorLevel.severe,
        //                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //            }
        //    }
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //public int GetStoreMaximum(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, bool aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //{
        //    return GetStoreMaximum(aAllocationSummaryNode, StoreIndex(aStoreRID), aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //internal int GetStoreMaximum(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore, bool aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //{
        //    // BEGIN MID Change j.ellis Delay subtotal build until request for info.
        //    if (_buildSubtotal)
        //    {
        //        this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
        //    }
        //    // END MID Change j.ellis Delay subtotal build until request for info.
        //    // BEGIN MID Change j.ellis Delay Grades till needed			
        //    if (_buildMinMax)
        //    {
        //        BuildMinMax();
        //    }
        //    // END MID Change j.ellis Delay Grades till needed
        //    // begin TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
        //    //AssortmentProfile asrtP = ((AllocationProfile)SubtotalMembers[0]).AssortmentProfile; //  TT#1154- MD - Jellis - Group Allocation Infinite  Loop When Going to SIze Analysis
        //    if (aAdjust
        //        && AssortmentProfile != null)
        //    {
        //        switch (aAllocationSummaryNode)
        //        {
        //            case (eAllocationSummaryNode.Total):
        //                {
        //                    return Math.Max(0,
        //                                    _subtotalTotal[aStore.Index].Maximum
        //                                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                                    + GetStoreQtyAllocated(eAllocationSummaryNode.Total, aStore));
        //                }
        //            case (eAllocationSummaryNode.GenericType):
        //                {
        //                    return Math.Max(0,
        //                                    _subtotalGenericType[aStore.Index].Maximum
        //                                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                                    + GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore));
        //                }
        //            case (eAllocationSummaryNode.DetailType):
        //                {
        //                    return Math.Max(0,
        //                                   _subtotalDetailType[aStore.Index].Maximum
        //                                   - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                                   + GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, aStore));
        //                }
        //            case (eAllocationSummaryNode.Bulk):
        //            case (eAllocationSummaryNode.BulkColorTotal): // MID Track 3326 cannot manually key size qty when no secondary dimension
        //                {
        //                    return Math.Max(0,
        //                            _subtotalBulk[aStore.Index].Maximum
        //                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                            + GetStoreQtyAllocated(eAllocationSummaryNode.Bulk, aStore));
        //                }
        //            default:
        //                {
        //                    throw new MIDException(eErrorLevel.severe,
        //                        (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
        //                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
        //                }
        //        }
        //    }
        //    // end TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max - Broken
        //    switch (aAllocationSummaryNode)
        //    {
        //        case (eAllocationSummaryNode.Total):
        //            {
        //                return _subtotalTotal[aStore.Index].Maximum;
        //            }
        //        case (eAllocationSummaryNode.GenericType):
        //            {
        //                return _subtotalGenericType[aStore.Index].Maximum;
        //            }
        //        case (eAllocationSummaryNode.DetailType):
        //            {
        //                return _subtotalDetailType[aStore.Index].Maximum;
        //            }
        //        case (eAllocationSummaryNode.Bulk):
        //        case (eAllocationSummaryNode.BulkColorTotal): // MID Track 3326 cannot manually key size qty when no secondary dimension
        //            {
        //                return _subtotalBulk[aStore.Index].Maximum;
        //            }
        //        default:
        //            {
        //                throw new MIDException(eErrorLevel.severe,
        //                    (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
        //                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
        //            }
        //    }
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPackName">Pack name.</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //public int GetStoreMaximum(string aSubtotalPackName, int aStoreRID, bool aAdjust) // TT#1074 - MD - Jellis - Group ALlocation Inventory Min Max Broken
        //{
        //    return GetStoreMaximum(aSubtotalPackName, StoreIndex(aStoreRID), aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPackName">Pack name.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //internal int GetStoreMaximum(string aSubtotalPackName, Index_RID aStore, bool aAdjust)  // TT#1074  - MD - Jellis - Group ALlocation Inventory Min Max Broken
        //{
        //    return GetStoreMaximum(GetSubtotalPackHdr(aSubtotalPackName), aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPack">Pack header object where store resides.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //internal int GetStoreMaximum(PackHdr aSubtotalPack, Index_RID aStore, bool aAdjust) // TT#1074 - MD - Jellis - Group Allocation Invnetory Min Max Broken
        //{
        //    // BEGIN MID Change j.ellis Delay subtotal build until request for info.
        //    if (_buildSubtotal)
        //    {
        //        this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
        //    }
        //    // END MID Change j.ellis Delay subtotal build until request for info.
        //    // BEGIN MID Change j.ellis Delay Grades till needed			
        //    if (_buildMinMax)
        //    {
        //        BuildMinMax();
        //    }
        //    // END MID Change j.ellis Delay Grades till needed
        //    // begin TT#1074 - MD - Jellis - Group ALlocation Inventory min max broken
        //    if (aAdjust
        //        && AssortmentProfile != null)
        //    {
        //        return Math.Max(0,
        //                    aSubtotalPack.GetStorePackMaximum(aStore.Index)
        //                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                    + aSubtotalPack.GetStorePacksAllocated(aStore.Index)
        //                      * aSubtotalPack.PackMultiple);
        //    }
        //    // end TT#1074- MD - Jellis - Group Allocation Inventory Min Max broken
        //    return aSubtotalPack.GetStorePackMaximum(aStore.Index);
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color.</param>
        ///// <param name="aStoreRID">RID for the store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //public int GetStoreMaximum(int aColorCodeRID, int aStoreRID, bool aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //{
        //    return GetStoreMaximum(aColorCodeRID, StoreIndex(aStoreRID), aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //internal int GetStoreMaximum(int aColorCodeRID, Index_RID aStore, bool aAdjust) // TT#1074 - MD - Jellis - Group ALlocation Inventory Min Max Broken
        //{
        //    // begin TT#1166 - MD - Jellis - Color Not in Bulk OR No Stores in Analysis
        //    //if (BulkColors.Contains(aColorCodeRID))
        //    //{
        //    //    return GetStoreMaximum((HdrColorBin)_bulkColors[aColorCodeRID], aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //    //}
        //    //else
        //    //{
        //    //    throw new MIDException(eErrorLevel.severe,
        //    //        (int)(eMIDTextCode.msg_ColorNotDefinedInBulk),
        //    //        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_ColorNotDefinedInBulk));
        //    //}
        //    return GetStoreMaximum(GetSubtotalHdrColorBin(aColorCodeRID), aStore, aAdjust);
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //internal int GetStoreMaximum(HdrColorBin aColor, Index_RID aStore, bool aAdjust) // TT#1074 - MD - Jellis _ Group Allocation Inventory Min Max Broken
        //{
        //    // BEGIN MID Change j.ellis Delay subtotal build until request for info.
        //    if (_buildSubtotal)
        //    {
        //        this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
        //    }
        //    // END MID Change j.ellis Delay subtotal build until request for info.
        //    // BEGIN MID Change j.ellis Delay Grades till needed			
        //    if (_buildMinMax)
        //    {
        //        BuildMinMax();
        //    }
        //    // END MID Change j.ellis Delay Grades till needed
        //    // begin TT#1074 - MD - Jellis - Group ALlocation Inventory min max broken
        //    if (aAdjust
        //        && AssortmentProfile != null)
        //    {
        //        return Math.Max(0,
        //                    aColor.GetStoreMaximum(aStore.Index)
        //                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                    + aColor.GetStoreUnitsAllocated(aStore.Index));
        //    }
        //    // end TT#1074- MD - Jellis - Group Allocation Inventory Min Max broken
        //    return aColor.GetStoreMaximum(aStore.Index);
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStoreRID">RID for the store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //public int GetStoreMaximum(int aColorCodeRID, int aSizeRID, int aStoreRID, bool aAdjust) // TT#1074 - MD - Jellis - Group ALlocation Inventory Min Max Broken
        //{
        //    return GetStoreMaximum(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //internal int GetStoreMaximum(int aColorCodeRID, int aSizeRID, Index_RID aStore, bool aAdjust) // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //{
        //    // begin TT#1166 - MD - Jellis - Color not in Bulk OR No Stores in Size Analysis
        //    //if (BulkColors.Contains(aColorCodeRID))
        //    //{
        //    //    return GetStoreMaximum((HdrColorBin)_bulkColors[aColorCodeRID], aSizeRID, aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //    //}
        //    //else
        //    //{
        //    //    throw new MIDException(eErrorLevel.severe,
        //    //        (int)(eMIDTextCode.msg_ColorNotDefinedInBulk),
        //    //        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_ColorNotDefinedInBulk));
        //    //}
        //    return GetStoreMaximum(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore, aAdjust);
        //    // end TT#1166 - MD - JEllis - Color not in bulk OR no stores in size analysis
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //internal int GetStoreMaximum(HdrColorBin aColor, int aSizeRID, Index_RID aStore, bool aAdjust) // TT#1074 - MD -Jellis - Group ALlocation Inventory min Max Broken
        //{
        //    // begin TT#1166 - MD - Jellis - Color not in Bulk OR no stores in size analysis
        //    //if (aColor.ColorSizes.Contains(aSizeRID))
        //    //{
        //    //    return GetStoreMaximum((HdrSizeBin)aColor.ColorSizes[aSizeRID], aStore, aAdjust); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //    //}
        //    //else
        //    //{
        //    //    throw new MIDException(eErrorLevel.severe,
        //    //        (int)(eMIDTextCode.msg_SizeNotDefinedInBulkColor),
        //    //        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_SizeNotDefinedInBulkColor));
        //    //}
        //    return GetStoreMaximum(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore, aAdjust);
        //    // end TT#1166 - MD - Jellis - Color not in bulk OR no stores in size analysis
        //}

        ///// <summary>
        ///// Gets Store Maximum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>Maximum to the store for the specified node.</returns>
        //internal int GetStoreMaximum(HdrSizeBin aSize, Index_RID aStore, bool aAdjust) // TT#1074 - MD - Jellis - Group ALlocation Inventory Min Max Broken
        //{
        //    // BEGIN MID Change j.ellis Delay subtotal build until request for info.
        //    if (_buildSubtotal)
        //    {
        //        this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
        //    }
        //    // END MID Change j.ellis Delay subtotal build until request for info.
        //    // BEGIN MID Change j.ellis Delay Grades till needed			
        //    if (_buildMinMax)
        //    {
        //        BuildMinMax();
        //    }
        //    // END MID Change j.ellis Delay Grades till needed
        //    // begin TT#1074 - MD - Jellis - Group ALlocation Inventory min max broken
        //    if (aAdjust
        //        && AssortmentProfile != null)
        //    {
        //        return Math.Max(0,
        //                    aSize.GetStoreSizeMaximum(aStore.Index)
        //                    - AssortmentProfile.GetStoreSizeInventoryBasisAllocation(InventoryBasisRIDs, aSize.SizeCodeRID, aStore)
        //                    + aSize.GetStoreSizeUnitsAllocated(aStore.Index));
        //    }
        //    // end TT#1074- MD - Jellis - Group Allocation Inventory Min Max broken
        //    return aSize.GetStoreSizeMaximum(aStore.Index);
        //}
        //#endregion SetStoreGradeMaximum
        #endregion OBSOLETE CODE (TT#1176)
        // end TT#1176 - MD - Jellis - Group Allocation Size Need not observing inv min max

        #region SetStoreGradeMaximum
        /// <summary>
		/// Sets Store Maximum for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aMaximum">Maximum</param>
		public void SetStoreMaximum(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, int aMaximum)
		{
			SetStoreMaximum(aAllocationSummaryNode, StoreIndex(aStoreRID), aMaximum);
		}

		/// <summary>
		/// Sets Store Maximum for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aMaximum">Maximum</param>
		internal void SetStoreMaximum(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore, int aMaximum)
		{
			switch (aAllocationSummaryNode)
			{
				case (eAllocationSummaryNode.Total):
				{
					_subtotalTotal[aStore.Index].Maximum = aMaximum;
					break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					_subtotalGenericType[aStore.Index].Maximum = aMaximum;
					break;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					_subtotalDetailType[aStore.Index].Maximum = aMaximum;
					break;
				}
				case(eAllocationSummaryNode.Bulk):
				{
					_subtotalBulk[aStore.Index].Maximum = aMaximum;
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
		}

		/// <summary>
		/// Sets Store Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aMaximum">Maximum.</param>
		public void SetStoreMaximum(string aSubtotalPackName, int aStoreRID, int aMaximum)
		{
			SetStoreMaximum(aSubtotalPackName, StoreIndex(aStoreRID), aMaximum);
		}

		/// <summary>
		/// Sets Store Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aMaximum">Maximum</param>
		internal void SetStoreMaximum(string aSubtotalPackName, Index_RID aStore, int aMaximum)
		{
			SetStoreMaximum(GetSubtotalPackHdr(aSubtotalPackName), aStore, aMaximum);
		}

		/// <summary>
		/// Sets Store Maximum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aMaximum">Maximum.</param>
		internal void SetStoreMaximum(PackHdr aSubtotalPack, Index_RID aStore, int aMaximum)
		{
			aSubtotalPack.SetStorePackMaximum(aStore.Index, aMaximum);
		}

		/// <summary>
		/// Sets Store Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aMaximum">Maximum</param>
		public void SetStoreMaximum(int aColorCodeRID, int aStoreRID, int aMaximum)
		{
			SetStoreMaximum(aColorCodeRID, StoreIndex(aStoreRID), aMaximum);
		}

		/// <summary>
		/// Sets Store Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aMaximum">Maximum</param>
		internal void SetStoreMaximum(int aColorCodeRID, Index_RID aStore, int aMaximum)
		{
			SetStoreMaximum(GetSubtotalHdrColorBin(aColorCodeRID), aStore, aMaximum);
		}

		/// <summary>
		/// Sets Store Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aMaximum">Maximum</param>
		internal void SetStoreMaximum(HdrColorBin aColor, Index_RID aStore, int aMaximum)
		{
			aColor.SetStoreMaximum(aStore.Index, aMaximum);
		}

		/// <summary>
		/// Sets Store Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aMaximum">Maximum.</param>
		public void SetStoreMaximum(int aColorCodeRID, int aSizeRID, int aStoreRID, int aMaximum)
		{
			SetStoreMaximum(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aMaximum);
		}

		/// <summary>
		/// Sets Store Maximum audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aMaximum">Maximum</param>
		internal void SetStoreMaximum(int aColorCodeRID, int aSizeRID, Index_RID aStore, int aMaximum)
		{
			SetStoreMaximum(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore, aMaximum);
		}

		/// <summary>
		/// Sets Store Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aMaximum">Maximum.</param>
		internal void SetStoreMaximum(HdrColorBin aColor, int aSizeRID, Index_RID aStore, int aMaximum)
		{
			SetStoreMaximum(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore, aMaximum);
		}

		/// <summary>
		/// Sets Store Maximum for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aMaximum">Maximum</param>
		internal void SetStoreMaximum(HdrSizeBin aSize, Index_RID aStore, int aMaximum)
		{
			aSize.SetStoreSizeMaximum(aStore.Index, aMaximum);
		}
        #endregion SetStoreGradeMaximum
        #endregion StoreGradeMaximum

        #region StoreGradeMinimum
        //=====================//
		// Store Grade Minimum //
        //=====================//
        // begin TT#1176 - MD - Jellis - Group Allocation Size Need Not Observing Inv Min Max
        #region TryGetStoreGradeMinimum
        /// <summary>
        /// Try to get Store Minimum for specified store on specified component.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <param name="aStoreMinimum">Store Minimum when get is successful</param>
        /// <param name="aStatusReasonCode">Return=FALSE:  eMIDTextCode.msg_ColorNotDefinedInBulk or eMIDTextCode.msg_SizeNotDefinedInBulkColor; TRUE: eMIDTextCode.msg_TryGetSuccessful</param>
        /// <returns>TRUE: Minimum for the store on the specified node with aStatusReason = eMIDTextCode.Success; FALSE: aStatusReason = eMIDTextCode.msg_ColorNotDefinedInBulk or eMIDTextCode.msg_SizeNotDefinedInBulkColor</returns>
        public bool TryGetStoreMinimum(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, bool aAdjust, out int aStoreMinimum, out eMIDTextCode aStatusReasonCode)
        {
            if (aAllocationProfile == null)
            {
                return TryGetStoreMinimum(aComponent, StoreIndex(aStoreRID), aAdjust, out aStoreMinimum, out aStatusReasonCode);
            }
            return aAllocationProfile.TryGetStoreMinimum(aComponent, StoreIndex(aStoreRID), aAdjust, out aStoreMinimum, out aStatusReasonCode);
        }


        /// <summary>
        /// Gets Store Minimum for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <param name="aStoreMinimum">Store Minimum when get is successful</param>
        /// <param name="aStatusReasonCode">Return=FALSE:  eMIDTextCode.msg_ColorNotDefinedInBulk or eMIDTextCode.msg_SizeNotDefinedInBulkColor; TRUE: eMIDTextCode.msg_TryGetSuccessful</param>
        /// <returns>TRUE: Minimum for the store on the specified node with aStatusReason = eMIDTextCode.Success; FALSE: aStatusReason = eMIDTextCode.msg_ColorNotDefinedInBulk or eMIDTextCode.msg_SizeNotDefinedInBulkColor</returns>
        public bool TryGetStoreMinimum(GeneralComponent aComponent, int aStoreRID, bool aAdjust, out int aStoreMinimum, out eMIDTextCode aStatusReasonCode)
        {
            return TryGetStoreMinimum(aComponent, StoreIndex(aStoreRID), aAdjust, out aStoreMinimum, out aStatusReasonCode);
        }

        /// <summary>
        /// Gets Store Minimum for specified store on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <param name="aStoreMinimum">Store Minimum when get is successful</param>
        /// <param name="aStatusReasonCode">Return=FALSE:  eMIDTextCode.msg_ColorNotDefinedInBulk or eMIDTextCode.Color; TRUE: eMIDTextCode.msg_TryGetSuccessful</param>
        /// <returns>TRUE: Minimum for the store on the specified node with aStatusReason = eMIDTextCode.Success; FALSE: aStatusReason = eMIDTextCode.msg_ColorNotDefinedInBulk or eMIDTextCode.msg_SizeNotDefinedInBulkColor</returns>
        internal bool TryGetStoreMinimum(GeneralComponent aComponent, Index_RID aStore, bool aAdjust, out int aStoreMinimum, out eMIDTextCode aStatusReasonCode) 
        {
            AllocationPackComponent packComponent;
            AllocationColorOrSizeComponent colorComponent;
            SizeCodeList sizeCodeList;
            switch (aComponent.ComponentType)
            {
                case (eComponentType.AllColors):
                    {
                        aStoreMinimum = GetStoreMinimum(eAllocationSummaryNode.BulkColorTotal, aStore, aAdjust);
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        return true;
                    }
                case (eComponentType.AllGenericPacks):
                    {
                        aStoreMinimum = GetStoreMinimum(eAllocationSummaryNode.GenericType, aStore, aAdjust);
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        return true;
                    }
                case (eComponentType.AllNonGenericPacks):
                    {
                        aStoreMinimum = GetStoreMinimum(eAllocationSummaryNode.DetailType, aStore, aAdjust);
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        return true;
                    }
                case (eComponentType.AllPacks):
                    {
                        aStoreMinimum = GetStoreMinimum(eAllocationSummaryNode.Total, aStore, aAdjust);
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        return true;
                    }
                case (eComponentType.AllSizes):
                    {
                        throw new MIDException(eErrorLevel.severe, 
                            (int)eMIDTextCode.msg_al_MinimumNotTrackedForAllSizes,
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_MinimumNotTrackedForAllSizes));
                    }
                case (eComponentType.Bulk):
                    {
                        aStoreMinimum = GetStoreMinimum(eAllocationSummaryNode.Bulk, aStore, aAdjust);
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        return true;
                    }
                case (eComponentType.ColorAndSize):
                    {
                        AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
                        GeneralComponent color = acs.ColorComponent;
                        aStoreMinimum = int.MaxValue;
                        switch (color.ComponentType)
                        {
                            case (eComponentType.AllColors):
                                {
                                    switch (acs.SizeComponent.ComponentType)
                                    {
                                        case (eComponentType.AllSizes):
                                            {                                                
                                                foreach (AllocationProfile ap in this.SubtotalMembers)
                                                {
                                                    foreach (HdrColorBin hcb in ap.BulkColors.Values)
                                                    {
                                                        foreach (HdrSizeBin hsb in hcb.ColorSizes)
                                                        {
                                                            aStoreMinimum = Math.Min(aStoreMinimum, ap.GetStoreMinimum(hsb, aStore, aAdjust));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSize):
                                            {
                                                int sizeRID;
                                                foreach (AllocationProfile ap in this.SubtotalMembers)
                                                {
                                                    foreach (HdrColorBin hcb in ap.BulkColors.Values)
                                                    {
                                                        sizeRID = ((AllocationColorOrSizeComponent)acs.SizeComponent).SizeRID;
                                                        HdrSizeBin sizeBin = (HdrSizeBin)hcb.ColorSizes[sizeRID];
                                                        if (sizeBin != null)
                                                        {
                                                            aStoreMinimum = Math.Min(aStoreMinimum, ap.GetStoreMinimum(sizeBin, aStore, aAdjust));
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizePrimaryDim):
                                            {
                                                sizeCodeList = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)acs.SizeComponent).PrimarySizeDimRID);
                                                foreach (AllocationProfile ap in this.SubtotalMembers)
                                                {
                                                    foreach (HdrColorBin hcb in ap.BulkColors.Values)
                                                    {
                                                        foreach (SizeCodeProfile scp in sizeCodeList)
                                                        {
                                                            HdrSizeBin sizeBin = (HdrSizeBin)hcb.ColorSizes[scp.Key];
                                                            if (sizeBin != null)
                                                            {
                                                                aStoreMinimum = Math.Min(aStoreMinimum, ap.GetStoreMinimum(sizeBin, aStore, aAdjust));
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizeSecondaryDim):
                                            {
                                                sizeCodeList = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)acs.SizeComponent).SecondarySizeDimRID);
                                                foreach (AllocationProfile ap in this.SubtotalMembers)
                                                {
                                                    foreach (HdrColorBin hcb in ap.BulkColors.Values)
                                                    {
                                                        foreach (SizeCodeProfile scp in sizeCodeList)
                                                        {
                                                            HdrSizeBin sizeBin = (HdrSizeBin)hcb.ColorSizes[scp.Key];
                                                            if (sizeBin != null)
                                                            {
                                                                aStoreMinimum = Math.Min(aStoreMinimum, ap.GetStoreMinimum(sizeBin, aStore, aAdjust));
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        default:
                                            {
                                                throw new MIDException(eErrorLevel.severe,
                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                            }
                                    }
                                    aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                                    return true;
                                }
                            case (eComponentType.SpecificColor):
                                {
                                    colorComponent = (AllocationColorOrSizeComponent)color;
                                    switch (acs.SizeComponent.ComponentType)
                                    {
                                        case (eComponentType.AllSizes):
                                            {
                                                foreach (AllocationProfile ap in this.SubtotalMembers)
                                                {
                                                    HdrColorBin colorBin = (HdrColorBin)ap.BulkColors[colorComponent.ColorRID];
                                                    if (colorBin != null)
                                                    {
                                                        foreach (HdrSizeBin hsb in colorBin.ColorSizes)
                                                        {
                                                            aStoreMinimum = Math.Min(aStoreMinimum, ap.GetStoreMinimum(hsb, aStore, aAdjust));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSize):
                                            {
                                                int sizeRID;
                                                foreach (AllocationProfile ap in this.SubtotalMembers)
                                                {
                                                    HdrColorBin colorBin = (HdrColorBin)ap.BulkColors[colorComponent.ColorRID];
                                                    if (colorBin != null)
                                                    {
                                                        sizeRID = ((AllocationColorOrSizeComponent)acs.SizeComponent).SizeRID;
                                                        HdrSizeBin sizeBin = (HdrSizeBin)colorBin.ColorSizes[sizeRID];
                                                        if (sizeBin != null)
                                                        {
                                                            aStoreMinimum = Math.Min(aStoreMinimum, ap.GetStoreMinimum(sizeBin, aStore, aAdjust));
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizePrimaryDim):
                                            {
                                                sizeCodeList = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)acs.SizeComponent).PrimarySizeDimRID);
                                                foreach (AllocationProfile ap in this.SubtotalMembers)
                                                {
                                                    HdrColorBin colorBin = (HdrColorBin)ap.BulkColors[colorComponent.ColorRID];
                                                    if (colorBin != null)
                                                    {
                                                        foreach (SizeCodeProfile scp in sizeCodeList)
                                                        {
                                                            HdrSizeBin sizeBin = (HdrSizeBin)colorBin.ColorSizes[scp.Key];
                                                            if (sizeBin != null)
                                                            {
                                                                aStoreMinimum = Math.Min(aStoreMinimum, ap.GetStoreMinimum(sizeBin, aStore, aAdjust));
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizeSecondaryDim):
                                            {
                                                sizeCodeList = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)acs.SizeComponent).SecondarySizeDimRID);
                                                foreach (AllocationProfile ap in this.SubtotalMembers)
                                                {
                                                    HdrColorBin colorBin = (HdrColorBin)ap.BulkColors[colorComponent.ColorRID];
                                                    if (colorBin != null)
                                                    {
                                                        foreach (SizeCodeProfile scp in sizeCodeList)
                                                        {
                                                            HdrSizeBin sizeBin = (HdrSizeBin)colorBin.ColorSizes[scp.Key];
                                                            if (sizeBin != null)
                                                            {
                                                                aStoreMinimum = Math.Min(aStoreMinimum, ap.GetStoreMinimum(sizeBin, aStore, aAdjust));
                                                            }
                                                        }
                                                    }
                                                }
                                                break;
                                            }
                                        default:
                                            {
                                                throw new MIDException(eErrorLevel.severe,
                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                            }
                                    }
                                    aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                                    return true;
                                }
                            default:
                                {
                                    throw new MIDException(eErrorLevel.severe,
                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                }
                        }
                    }
                case (eComponentType.DetailType):
                    {
                        aStoreMinimum = GetStoreMinimum(eAllocationSummaryNode.DetailType, aStore, aAdjust);
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        return true;
                    }
                case (eComponentType.GenericType):
                    {
                        aStoreMinimum = GetStoreMinimum(eAllocationSummaryNode.Total, aStore, aAdjust);
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        return true;
                    }
                case (eComponentType.SpecificColor):
                    {
                        colorComponent = (AllocationColorOrSizeComponent)aComponent;
                        return TryGetStoreMinimum(colorComponent.ColorRID, aStore, aAdjust, out aStoreMinimum, out aStatusReasonCode); 
                    }
                case (eComponentType.SpecificSize):
                    {
                        throw new MIDException(eErrorLevel.severe, 
                            (int)eMIDTextCode.msg_al_MinimumNotTrackedForSizeAcrossColor,
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_MinimumNotTrackedForSizeAcrossColor));
                    }
                case (eComponentType.SpecificPack):
                    {
                        packComponent = (AllocationPackComponent)aComponent;
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        aStoreMinimum = GetStoreMinimum(packComponent.PackName, aStore, aAdjust);
                        return true;
                    }
                case (eComponentType.Total):
                    {
                        aStoreMinimum = GetStoreMinimum(eAllocationSummaryNode.Total, aStore, aAdjust);
                        aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
                        return true;
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                    }
            }
        }

        /// <summary>
        /// Gets Store Minimum for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <param name="aStoreMinimum">Store Minimum when get is successful</param>
        /// <param name="aStatusReasonCode">Return=FALSE:  eMIDTextCode.msg_ColorNotDefinedInBulk; TRUE: eMIDTextCode.msg_TryGetSuccessful</param>
        /// <returns>TRUE: Minimum for the store on the specified node with aStatusReason = eMIDTextCode.Success; FALSE: aStatusReason = eMIDTextCode.msg_ColorNotDefinedInBulk</returns>
        public bool TryGetStoreMinimum(int aColorCodeRID, int aStoreRID, bool aAdjust, out int aStoreMinimum, out eMIDTextCode aStatusReasonCode)  
        {
            return TryGetStoreMinimum(aColorCodeRID, StoreIndex(aStoreRID), aAdjust, out aStoreMinimum, out aStatusReasonCode); 
        }

        /// <summary>
        /// Gets Store Minimum for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aStoreMinimum">Store Minimum when get is successful</param>
        /// <param name="aStatusReasonCode">Return=FALSE:  eMIDTextCode.msg_ColorNotDefinedInBulk; TRUE: eMIDTextCode.msg_TryGetSuccessful</param>
        /// <returns>TRUE: Minimum for the store on the specified node with aStatusReason = eMIDTextCode.Success; FALSE: aStatusReason = eMIDTextCode.msg_ColorNotDefinedInBulk</returns>
        internal bool TryGetStoreMinimum(int aColorCodeRID, Index_RID aStore, bool aAdjust, out int aStoreMinimum, out eMIDTextCode aStatusReasonCode)
        {
            HdrColorBin colorBin = (HdrColorBin)BulkColors[aColorCodeRID];
            if (colorBin == null)
            {
                aStoreMinimum = 0;
                aStatusReasonCode = eMIDTextCode.msg_ColorNotDefinedInBulk;
                return false;
            }
            aStoreMinimum = GetStoreMinimum(colorBin, aStore, aAdjust);
            aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
            return true;
        }


        /// <summary>
        /// Gets Store Minimum for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreRID">RID for the store</param>
        /// <param name="aStoreMinimum">Store Minimum when get is successful</param>
        /// <param name="aStatusReasonCode">Return=FALSE:  eMIDTextCode.msg_ColorNotDefinedInBulk or eMIDTextCode.msg_SizeNotDefinedInBulkColor; TRUE: eMIDTextCode.msg_TryGetSuccessful</param>
        /// <returns>TRUE: Minimum for the store on the specified node with aStatusReason = eMIDTextCode.Success; FALSE: aStatusReason = eMIDTextCode.msg_ColorNotDefinedInBulk or eMIDTextCode.msg_SizeNotDefinedInBulkColor</returns>
        public bool TryGetStoreMinimum(int aColorCodeRID, int aSizeRID, int aStoreRID, bool aAdjust, out int aStoreMinimum, out eMIDTextCode aStatusReasonCode)
        {
            return TryGetStoreMinimum(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aAdjust, out aStoreMinimum, out aStatusReasonCode);
        }

        /// <summary>
        /// Gets Store Minimum for specified store on specified color node.
        /// </summary>
        /// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aStoreMinimum">Store Minimum when get is successful</param>
        /// <param name="aStatusReasonCode">Return=FALSE:  eMIDTextCode.msg_ColorNotDefinedInBulk or eMIDTextCode.msg_SizeNotDefinedInBulkColor; TRUE: eMIDTextCode.msg_TryGetSuccessful</param>
        /// <returns>TRUE: Minimum for the store on the specified node with aStatusReason = eMIDTextCode.Success; FALSE: aStatusReason = eMIDTextCode.msg_ColorNotDefinedInBulk or eMIDTextCode.msg_SizeNotDefinedInBulkColor</returns>
        internal bool TryGetStoreMinimum(int aColorCodeRID, int aSizeRID, Index_RID aStore, bool aAdjust, out int aStoreMinimum, out eMIDTextCode aStatusReasonCode) 
        {
            HdrColorBin colorBin = (HdrColorBin)BulkColors[aColorCodeRID];
            if (colorBin == null)
            {
                aStoreMinimum = 0;
                aStatusReasonCode = eMIDTextCode.msg_ColorNotDefinedInBulk;
                return false;
            }
            return TryGetStoreMinimum(colorBin, aSizeRID, aStore, aAdjust, out aStoreMinimum, out aStatusReasonCode);
        }

        /// <summary>
        /// Gets Store Minimum for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <param name="aStoreMinimum">Store Minimum when get is successful</param>
        /// <param name="aStatusReasonCode">Return=FALSE: eMIDTextCode.msg_SizeNotDefinedInBulkColor; TRUE: eMIDTextCode.msg_TryGetSuccessful</param>
        /// <returns>TRUE: Minimum for the store on the specified node with aStatusReason = eMIDTextCode.Success; FALSE: aStatusReason = eMIDTextCode.msg_SizeNotDefinedInBulkColor</returns>
        internal bool TryGetStoreMinimum(HdrColorBin aColor, int aSizeRID, Index_RID aStore, bool aAdjust, out int aStoreMinimum, out eMIDTextCode aStatusReasonCode)
        {
            HdrSizeBin sizeBin = (HdrSizeBin)aColor.ColorSizes[aSizeRID];
            if (sizeBin == null)
            {
                aStoreMinimum = 0;
                aStatusReasonCode = eMIDTextCode.msg_SizeNotDefinedInBulkColor;
            }
            aStoreMinimum =  GetStoreMinimum(sizeBin, aStore, aAdjust);
            aStatusReasonCode = eMIDTextCode.msg_al_TryGetSuccessful;
            return true;
        }
        #endregion TryGetStoreGradeMinimum

        #region GetStoreGradeMinimum
        /// <summary>
        /// Gets Store Minimum for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Minimum to the store for the specified node.</returns>
        public int GetStoreMinimum(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, bool aAdjust)
        {
            return GetStoreMinimum(aAllocationSummaryNode, StoreIndex(aStoreRID), aAdjust); 
        }

        /// <summary>
        /// Gets Store Minimum for specified store on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Minimum to the store for the specified node.</returns>
        internal int GetStoreMinimum(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore, bool aAdjust) 
        {
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); 
            }
            if (_buildMinMax)
            {
                BuildMinMax();
            }
            if (aAdjust
                && AssortmentProfile != null)
            {
                switch (aAllocationSummaryNode)
                {
                    case (eAllocationSummaryNode.Total):
                        {
                            return Math.Max(0,
                                            _subtotalTotal[aStore.Index].Minimum
                                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                                            + GetStoreQtyAllocated(eAllocationSummaryNode.Total, aStore));
                        }
                    case (eAllocationSummaryNode.GenericType):
                        {
                            return Math.Max(0,
                                            _subtotalGenericType[aStore.Index].Minimum
                                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                                            + GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore));
                        }
                    case (eAllocationSummaryNode.DetailType):
                        {
                            return Math.Max(0,
                                            _subtotalDetailType[aStore.Index].Minimum
                                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                                            + GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, aStore));
                        }
                    case (eAllocationSummaryNode.Bulk):
                    case (eAllocationSummaryNode.BulkColorTotal): 
                        {
                            return Math.Max(0,
                                            _subtotalBulk[aStore.Index].Minimum
                                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                                            + GetStoreQtyAllocated(eAllocationSummaryNode.Bulk, aStore));
                        }
                    default:
                        {
                            throw new MIDException(eErrorLevel.severe,
                                (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
                        }
                }
            }
            switch (aAllocationSummaryNode)
            {
                case (eAllocationSummaryNode.Total):
                    {
                        return _subtotalTotal[aStore.Index].Minimum;
                    }
                case (eAllocationSummaryNode.GenericType):
                    {
                        return _subtotalGenericType[aStore.Index].Minimum;
                    }
                case (eAllocationSummaryNode.DetailType):
                    {
                        return _subtotalDetailType[aStore.Index].Minimum;
                    }
                case (eAllocationSummaryNode.Bulk):
                case (eAllocationSummaryNode.BulkColorTotal):
                    {
                        return _subtotalBulk[aStore.Index].Minimum;
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
                    }
            }
        }

        /// <summary>
        /// Gets Store Minimum for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Subtotal Pack name.</param>
        /// <param name="aStoreRID">RID for store</param>
        /// <returns>Minimum to the store for the specified node.</returns>
        public int GetStoreMinimum(string aSubtotalPackName, int aStoreRID, bool aAdjust) 
        {
            return GetStoreMinimum(aSubtotalPackName, StoreIndex(aStoreRID), aAdjust);  
        }

        /// <summary>
        /// Gets Store Minimum for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPackName">Subtotal Pack name.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Minimum to the store for the specified node.</returns>
        internal int GetStoreMinimum(string aSubtotalPackName, Index_RID aStore, bool aAdjust) 
        {
            return GetStoreMinimum(GetSubtotalPackHdr(aSubtotalPackName), aStore, aAdjust);  
        }

        /// <summary>
        /// Gets Store Minimum for specified store on specified pack node.
        /// </summary>
        /// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
        /// <param name="aStore">Index_RID for store</param>
        /// <returns>Minimum to the store for the specified node.</returns>
        internal int GetStoreMinimum(PackHdr aSubtotalPack, Index_RID aStore, bool aAdjust) 
        {
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); 
            }
            if (_buildMinMax)
            {
                BuildMinMax();
            }
            if (aAdjust
                && AssortmentProfile != null)
            {
                return Math.Max(0,
                            aSubtotalPack.GetStorePackMinimum(aStore.Index)
                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                            + aSubtotalPack.GetStorePacksAllocated(aStore.Index)
                              * aSubtotalPack.PackMultiple);
            }
            return aSubtotalPack.GetStorePackMinimum(aStore.Index);
        }


        /// <summary>
        /// Gets Store Minimum for specified store on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Minimum to the store for the specified node.</returns>
        internal int GetStoreMinimum(HdrColorBin aColor, Index_RID aStore, bool aAdjust) 
        {
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); 
            }
            if (_buildMinMax)
            {
                BuildMinMax();
            }
            if (aAdjust
                && AssortmentProfile != null)
            {
                return Math.Max(0,
                            aColor.GetStoreMinimum(aStore.Index)
                            - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
                            + aColor.GetStoreUnitsAllocated(aStore.Index));
            }
            return aColor.GetStoreMinimum(aStore.Index);
        }


        /// <summary>
        /// Gets Store Minimum for specified store on specified color node.
        /// </summary>
        /// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        /// <param name="aStore">Index_RID for the store</param>
        /// <returns>Minimum to the store for the specified node.</returns>
        internal int GetStoreMinimum(HdrSizeBin aSize, Index_RID aStore, bool aAdjust) 
        {
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   
            }
            if (_buildMinMax)
            {
                BuildMinMax();
            }
            if (aAdjust
                && AssortmentProfile != null)
            {
                return Math.Max(0,
                            aSize.GetStoreSizeMinimum(aStore.Index)
                            - AssortmentProfile.GetStoreSizeInventoryBasisAllocation(InventoryBasisRIDs, aSize.SizeCodeRID, aStore)
                            + aSize.GetStoreSizeUnitsAllocated(aStore.Index));
            }
            return aSize.GetStoreSizeMinimum(aStore.Index);
        }
        #endregion GetStoreGradeMinimum

        #region OBSOLETE CODE (TT#1176)
        //#region GetStoreGradeMinimum
        ///// <summary>
        ///// Gets Store Minimum for specified store on specified component.
        ///// </summary>
        ///// <param name="aAllocationProfile">Allocation Profile</param>
        ///// <param name="aComponent">Description of the component</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>Minimum to the store for the specified component.</returns>
        //public int GetStoreMinimum(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        return GetStoreMinimum(aComponent, StoreIndex(aStoreRID), aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //    }
        //    return aAllocationProfile.GetStoreMinimum(aComponent, StoreIndex(aStoreRID), aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //}
        ///// <summary>
        ///// Gets Store Minimum for specified store on specified component.
        ///// </summary>
        ///// <param name="aComponent">Description of the component</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>Minimum to the store for the specified component.</returns>
        //public int GetStoreMinimum(GeneralComponent aComponent, int aStoreRID, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    return GetStoreMinimum(aComponent, StoreIndex(aStoreRID), aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified component.
        ///// </summary>
        ///// <param name="aComponent">Description of the component</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>Minimum to the store for the specified component.</returns>
        //internal int GetStoreMinimum(GeneralComponent aComponent, Index_RID aStore, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    AllocationPackComponent packComponent;
        //    AllocationColorOrSizeComponent colorComponent;
        //    SizeCodeList sizeCodeList;
        //    switch (aComponent.ComponentType)
        //    {
        //        case (eComponentType.AllColors):
        //        {
        //            return GetStoreMinimum(eAllocationSummaryNode.BulkColorTotal, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //        }
        //        case (eComponentType.AllGenericPacks):
        //        {
        //            return GetStoreMinimum(eAllocationSummaryNode.GenericType, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //        }
        //        case (eComponentType.AllNonGenericPacks):
        //        {
        //            return GetStoreMinimum(eAllocationSummaryNode.DetailType, aStore, aAdjust);   // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //        }
        //        case (eComponentType.AllPacks):
        //        {
        //            return GetStoreMinimum(eAllocationSummaryNode.Total, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //        }
        //        case (eComponentType.AllSizes):
        //        {
        //            //throw new MIDException (eErrorLevel.warning,  // MID track 5374 Workflow Errors do not stop Process
        //            throw new MIDException (eErrorLevel.severe,     // MID Track 5374 Workflow Errors do not stop process
        //                (int)eMIDTextCode.msg_al_MinimumNotTrackedForAllSizes,
        //                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_MinimumNotTrackedForAllSizes));
        //        }
        //        case (eComponentType.Bulk):
        //        {
        //            return GetStoreMinimum(eAllocationSummaryNode.Bulk, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //        }
        //        case (eComponentType.ColorAndSize):
        //        {
        //            AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
        //            GeneralComponent color = acs.ColorComponent;
        //            int minimum = int.MaxValue;
        //            switch (color.ComponentType)
        //            {
        //                case (eComponentType.AllColors):
        //                {
        //                    switch (acs.SizeComponent.ComponentType)
        //                    {
        //                        case (eComponentType.AllSizes):
        //                        {
        //                            foreach (AllocationProfile ap in this.SubtotalMembers)
        //                            {
        //                                foreach (HdrColorBin hcb in ap.BulkColors.Values)
        //                                {
        //                                    foreach (HdrSizeBin hsb in hcb.ColorSizes)
        //                                    {
        //                                        minimum = Math.Min(minimum, ap.GetStoreMinimum(hsb, aStore, aAdjust));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //                                    }
        //                                }
        //                            }
        //                            break;
        //                        }
        //                        case (eComponentType.SpecificSize):
        //                        {
        //                            int sizeRID;
        //                            foreach (AllocationProfile ap in this.SubtotalMembers)
        //                            {
        //                                foreach (HdrColorBin hcb in ap.BulkColors.Values)
        //                                {
        //                                    sizeRID = ((AllocationColorOrSizeComponent)acs.SizeComponent).SizeRID;
        //                                    if (hcb.SizeIsInColor(sizeRID))
        //                                    {
        //                                        minimum = Math.Min(minimum, ap.GetStoreMinimum(hcb, sizeRID, aStore, aAdjust));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //                                    }
        //                                }
        //                            }
        //                            break;
        //                        }
        //                        case (eComponentType.SpecificSizePrimaryDim):
        //                        {
        //                            sizeCodeList = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)acs.SizeComponent).PrimarySizeDimRID);
        //                            foreach (AllocationProfile ap in this.SubtotalMembers)
        //                            {
        //                                foreach (HdrColorBin hcb in ap.BulkColors.Values)
        //                                {
        //                                    foreach (SizeCodeProfile scp in sizeCodeList)
        //                                    {
        //                                        if (hcb.SizeIsInColor(scp.Key))
        //                                        {
        //                                            minimum = Math.Min(minimum, ap.GetStoreMinimum(hcb, scp.Key, aStore, aAdjust));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //                                        }
        //                                    }
        //                                }
        //                            }
        //                            break;
        //                        }
        //                        case (eComponentType.SpecificSizeSecondaryDim):
        //                        {
        //                            sizeCodeList = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)acs.SizeComponent).SecondarySizeDimRID);
        //                            foreach (AllocationProfile ap in this.SubtotalMembers)
        //                            {
        //                                foreach (HdrColorBin hcb in ap.BulkColors.Values)
        //                                {
        //                                    foreach (SizeCodeProfile scp in sizeCodeList)
        //                                    {
        //                                        if (hcb.SizeIsInColor(scp.Key))
        //                                        {
        //                                            minimum = Math.Min(minimum, ap.GetStoreMinimum(hcb, scp.Key, aStore, aAdjust));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //                                        }
        //                                    }
        //                                }
        //                            }
        //                            break;
        //                        }
        //                        default:
        //                        {
        //                            throw new MIDException(eErrorLevel.severe,
        //                                (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                        }
        //                    }
        //                    return GetStoreMinimum(eAllocationSummaryNode.Bulk, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //                }
        //                case (eComponentType.SpecificColor):
        //                {
        //                    colorComponent = (AllocationColorOrSizeComponent)color;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
        //                    return GetStoreMinimum(colorComponent.ColorRID, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //                }
        //                default:
        //                {
        //                    throw new MIDException(eErrorLevel.severe,
        //                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //                }
        //            }
        //        }
        //        case (eComponentType.DetailType):
        //        {
        //            return GetStoreMinimum(eAllocationSummaryNode.DetailType, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //        }
        //        case (eComponentType.GenericType):
        //        {
        //            return GetStoreMinimum(eAllocationSummaryNode.Total, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //        }
        //        case (eComponentType.SpecificColor):
        //        {
        //            colorComponent = (AllocationColorOrSizeComponent)aComponent;
        //            return GetStoreMinimum(colorComponent.ColorRID, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //        }
        //        case (eComponentType.SpecificSize):
        //        {
        //            //throw new MIDException (eErrorLevel.warning,  // MID track 5374 Workflow Errors do not stop Process
        //            throw new MIDException (eErrorLevel.severe,     // MID Track 5374 Workflow Errors do not stop process
        //                (int)eMIDTextCode.msg_al_MinimumNotTrackedForSizeAcrossColor,
        //                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_MinimumNotTrackedForSizeAcrossColor));
        //        }
        //        case (eComponentType.SpecificPack):
        //        {
        //            packComponent = (AllocationPackComponent)aComponent;
        //            return GetStoreMinimum(packComponent.PackName, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //        }
        //        case (eComponentType.Total):
        //        {
        //            return GetStoreMinimum(eAllocationSummaryNode.Total, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //        }
        //        default:
        //        {
        //            throw new MIDException(eErrorLevel.severe,
        //                (int)(eMIDTextCode.msg_al_UnknownComponentType),
        //                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
        //        }
        //    }
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //public int GetStoreMinimum(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    return GetStoreMinimum(aAllocationSummaryNode, StoreIndex(aStoreRID), aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified node.
        ///// </summary>
        ///// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //internal int GetStoreMinimum(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    // BEGIN MID Change j.ellis Delay subtotal build until request for info.
        //    if (_buildSubtotal)
        //    {
        //        this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
        //    }
        //    // END MID Change j.ellis Delay subtotal build until request for info.
        //    // BEGIN MID Change j.ellis Delay Grades till needed			
        //    if (_buildMinMax)
        //    {
        //        BuildMinMax();
        //    }
        //    // END MID Change j.ellis Delay Grades till needed
        //    // begin TT#1074 - MD - Jellis - Group ALlocation Inventory min max broken
        //    if (aAdjust
        //        && AssortmentProfile != null)
        //    {
        //        switch (aAllocationSummaryNode)
        //        {
        //            case (eAllocationSummaryNode.Total):
        //                {
        //                    return Math.Max(0,
        //                                    _subtotalTotal[aStore.Index].Minimum
        //                                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                                    + GetStoreQtyAllocated(eAllocationSummaryNode.Total, aStore));
        //                }
        //            case (eAllocationSummaryNode.GenericType):
        //                {
        //                    return Math.Max(0,
        //                                    _subtotalGenericType[aStore.Index].Minimum
        //                                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                                    + GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore));
        //                }
        //            case (eAllocationSummaryNode.DetailType):
        //                {
        //                    return Math.Max(0,
        //                                    _subtotalDetailType[aStore.Index].Minimum
        //                                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                                    + GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, aStore));
        //                }
        //            case (eAllocationSummaryNode.Bulk):
        //            case (eAllocationSummaryNode.BulkColorTotal): // MID Track 3326 cannot manually key size qty when no secondary dimension
        //                {
        //                    return Math.Max(0,
        //                                    _subtotalBulk[aStore.Index].Minimum
        //                                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                                    + GetStoreQtyAllocated(eAllocationSummaryNode.Bulk, aStore));
        //                }
        //            default:
        //                {
        //                    throw new MIDException(eErrorLevel.severe,
        //                        (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
        //                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
        //                }
        //        }
        //    }
        //    // end TT#1074- MD - Jellis - Group Allocation Inventory Min Max broken
        //    switch (aAllocationSummaryNode)
        //    {
        //        case (eAllocationSummaryNode.Total):
        //        {
        //            return _subtotalTotal[aStore.Index].Minimum;
        //        }
        //        case(eAllocationSummaryNode.GenericType):
        //        {
        //            return _subtotalGenericType[aStore.Index].Minimum;
        //        }
        //        case(eAllocationSummaryNode.DetailType):
        //        {
        //            return _subtotalDetailType[aStore.Index].Minimum;
        //        }
        //        case(eAllocationSummaryNode.Bulk):
        //        case (eAllocationSummaryNode.BulkColorTotal): // MID Track 3326 cannot manually key size qty when no secondary dimension
        //        {
        //            return _subtotalBulk[aStore.Index].Minimum;
        //        }
        //        default:
        //        {
        //            throw new MIDException(eErrorLevel.severe,
        //                (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
        //                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
        //        }
        //    }
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPackName">Subtotal Pack name.</param>
        ///// <param name="aStoreRID">RID for store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //public int GetStoreMinimum(string aSubtotalPackName, int aStoreRID, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    return GetStoreMinimum(aSubtotalPackName, StoreIndex(aStoreRID), aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPackName">Subtotal Pack name.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //internal int GetStoreMinimum(string aSubtotalPackName, Index_RID aStore, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    return GetStoreMinimum(GetSubtotalPackHdr(aSubtotalPackName), aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified pack node.
        ///// </summary>
        ///// <param name="aSubtotalPack">Subtotal Pack header object where store resides.</param>
        ///// <param name="aStore">Index_RID for store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //internal int GetStoreMinimum(PackHdr aSubtotalPack, Index_RID aStore, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    // BEGIN MID Change j.ellis Delay subtotal build until request for info.
        //    if (_buildSubtotal)
        //    {
        //        this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
        //    }
        //    // END MID Change j.ellis Delay subtotal build until request for info.
        //    // BEGIN MID Change j.ellis Delay Grades till needed			
        //    if (_buildMinMax)
        //    {
        //        BuildMinMax();
        //    }
        //    // END MID Change j.ellis Delay Grades till needed
        //    // begin TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //    if (aAdjust
        //        && AssortmentProfile != null)
        //    {
        //        return Math.Max(0,
        //                    aSubtotalPack.GetStorePackMinimum(aStore.Index)
        //                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                    + aSubtotalPack.GetStorePacksAllocated(aStore.Index)
        //                      * aSubtotalPack.PackMultiple);
        //    }
        //    // end TT#1074 - MD - Jellis  - Group Allocation Inventory Min Max Broken
        //    return aSubtotalPack.GetStorePackMinimum(aStore.Index);
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color.</param>
        ///// <param name="aStoreRID">RID for the store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //public int GetStoreMinimum(int aColorCodeRID, int aStoreRID, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    return GetStoreMinimum(aColorCodeRID, StoreIndex(aStoreRID), aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //internal int GetStoreMinimum(int aColorCodeRID, Index_RID aStore, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    return GetStoreMinimum(GetSubtotalHdrColorBin(aColorCodeRID), aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //internal int GetStoreMinimum(HdrColorBin aColor, Index_RID aStore, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    // BEGIN MID Change j.ellis Delay subtotal build until request for info.
        //    if (_buildSubtotal)
        //    {
        //        this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
        //    }
        //    // END MID Change j.ellis Delay subtotal build until request for info.
        //    // BEGIN MID Change j.ellis Delay Grades till needed			
        //    if (_buildMinMax)
        //    {
        //        BuildMinMax();
        //    }
        //    // END MID Change j.ellis Delay Grades till needed
        //    // begin TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //    if (aAdjust
        //        && AssortmentProfile != null)
        //    {
        //        return Math.Max(0,
        //                    aColor.GetStoreMinimum(aStore.Index)
        //                    - AssortmentProfile.GetStoreInventoryBasisAllocation(InventoryBasisRIDs, aStore)
        //                    + aColor.GetStoreUnitsAllocated(aStore.Index));
        //    }
        //    // end TT#1074 - MD - Jellis  - Group Allocation Inventory Min Max Broken
        //    return aColor.GetStoreMinimum(aStore.Index);
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStoreRID">RID for the store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //public int GetStoreMinimum(int aColorCodeRID, int aSizeRID, int aStoreRID, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    return GetStoreMinimum(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColorCodeRID">RID for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //internal int GetStoreMinimum(int aColorCodeRID, int aSizeRID, Index_RID aStore, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    return GetStoreMinimum(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        ///// <param name="aSizeRID">RID for the size.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //internal int GetStoreMinimum(HdrColorBin aColor, int aSizeRID, Index_RID aStore, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    return GetStoreMinimum(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore, aAdjust);  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //}

        ///// <summary>
        ///// Gets Store Minimum for specified store on specified color node.
        ///// </summary>
        ///// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
        ///// <param name="aStore">Index_RID for the store</param>
        ///// <returns>Minimum to the store for the specified node.</returns>
        //internal int GetStoreMinimum(HdrSizeBin aSize, Index_RID aStore, bool aAdjust)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
        //{
        //    // BEGIN MID Change j.ellis Delay subtotal build until request for info.
        //    if (_buildSubtotal)
        //    {
        //        this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
        //    }
        //    // END MID Change j.ellis Delay subtotal build until request for info.
        //    // BEGIN MID Change j.ellis Delay Grades till needed			
        //    if (_buildMinMax)
        //    {
        //        BuildMinMax();
        //    }
        //    // END MID Change j.ellis Delay Grades till needed	
        //    // begin TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
        //    if (aAdjust
        //        && AssortmentProfile != null)
        //    {
        //        return Math.Max(0,
        //                    aSize.GetStoreSizeMinimum(aStore.Index)
        //                    - AssortmentProfile.GetStoreSizeInventoryBasisAllocation(InventoryBasisRIDs, aSize.SizeCodeRID, aStore)
        //                    + aSize.GetStoreSizeUnitsAllocated(aStore.Index));
        //    }
        //    // end TT#1074 - MD - Jellis  - Group Allocation Inventory Min Max Broken
        //    return aSize.GetStoreSizeMinimum(aStore.Index);
        //}
        //#endregion GetStoreGradeMinimum
        #endregion OBSOLETE CODE (TT#1176)
        // end TT#1176 - MD - Jellis - Group Allocation Size Need not observing inv min max

        #region SetStoreGradeMinimum
        /// <summary>
		/// Sets Store Minimum for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aMinimum">Minimum</param>
		public void SetStoreMinimum(eAllocationSummaryNode aAllocationSummaryNode, int aStoreRID, int aMinimum)
		{
			SetStoreMinimum(aAllocationSummaryNode, StoreIndex(aStoreRID), aMinimum);
		}

		/// <summary>
		/// Sets Store Minimum for specified store on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aMinimum">Minimum</param>
		internal void SetStoreMinimum(eAllocationSummaryNode aAllocationSummaryNode, Index_RID aStore, int aMinimum)
		{
			switch (aAllocationSummaryNode)
			{
				case (eAllocationSummaryNode.Total):
				{
					_subtotalTotal[aStore.Index].Minimum = aMinimum;
					break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					_subtotalGenericType[aStore.Index].Minimum = aMinimum;
					break;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					_subtotalDetailType[aStore.Index].Minimum = aMinimum;
					break;
				}
				case(eAllocationSummaryNode.Bulk):
				{
					_subtotalBulk[aStore.Index].Minimum = aMinimum;
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
		}

		/// <summary>
		/// Sets Store Minimum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStoreRID">RID for store</param>
		/// <param name="aMinimum">Minimum.</param>
		public void SetStoreMinimum(string aSubtotalPackName, int aStoreRID, int aMinimum)
		{
			SetStoreMinimum(aSubtotalPackName, StoreIndex(aStoreRID), aMinimum);
		}

		/// <summary>
		/// Sets Store Minimum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPackName">Pack name.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aMinimum">Minimum</param>
		internal void SetStoreMinimum(string aSubtotalPackName, Index_RID aStore, int aMinimum)
		{
			SetStoreMinimum(GetSubtotalPackHdr(aSubtotalPackName), aStore, aMinimum);
		}

		/// <summary>
		/// Sets Store Minimum for specified store on specified pack node.
		/// </summary>
		/// <param name="aSubtotalPack">Pack header object where store resides.</param>
		/// <param name="aStore">Index_RID for store</param>
		/// <param name="aMinimum">Minimum.</param>
		internal void SetStoreMinimum(PackHdr aSubtotalPack, Index_RID aStore, int aMinimum)
		{
			aSubtotalPack.SetStorePackMinimum(aStore.Index, aMinimum);
		}

		/// <summary>
		/// Sets Store Minimum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aMinimum">Minimum</param>
		public void SetStoreMinimum(int aColorCodeRID, int aStoreRID, int aMinimum)
		{
			SetStoreMinimum(aColorCodeRID, StoreIndex(aStoreRID), aMinimum);
		}

		/// <summary>
		/// Sets Store Minimum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aMinimum">Minimum</param>
		internal void SetStoreMinimum(int aColorCodeRID, Index_RID aStore, int aMinimum)
		{
			SetStoreMinimum(GetSubtotalHdrColorBin(aColorCodeRID), aStore, aMinimum);
		}

		/// <summary>
		/// Sets Store Minimum for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aMinimum">Minimum</param>
		internal void SetStoreMinimum(HdrColorBin aColor, Index_RID aStore, int aMinimum)
		{
			aColor.SetStoreMinimum(aStore.Index, aMinimum);
		}

		/// <summary>
		/// Sets Store Minimum for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreRID">RID for the store</param>
		/// <param name="aMinimum">Minimum.</param>
		public void SetStoreMinimum(int aColorCodeRID, int aSizeRID, int aStoreRID, int aMinimum)
		{
			SetStoreMinimum(aColorCodeRID, aSizeRID, StoreIndex(aStoreRID), aMinimum);
		}

		/// <summary>
		/// Sets Store Minimum audit flag for specified store on specified color node.
		/// </summary>
		/// <param name="aColorCodeRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aMinimum">Minimum</param>
		internal void SetStoreMinimum(int aColorCodeRID, int aSizeRID, Index_RID aStore, int aMinimum)
		{
			SetStoreMinimum(GetSubtotalHdrColorBin(aColorCodeRID), aSizeRID, aStore, aMinimum);
		}

		/// <summary>
		/// Sets Store Minimum for specified store on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aMinimum">Minimum.</param>
		internal void SetStoreMinimum(HdrColorBin aColor, int aSizeRID, Index_RID aStore, int aMinimum)
		{
			SetStoreMinimum(GetSubtotalHdrSizeBin(aColor, aSizeRID), aStore, aMinimum);
		}

		/// <summary>
		/// Sets Store Minimum for specified store on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <param name="aStore">Index_RID for the store</param>
		/// <param name="aMinimum">Minimum</param>
		internal void SetStoreMinimum(HdrSizeBin aSize, Index_RID aStore, int aMinimum)
		{
			aSize.SetStoreSizeMinimum(aStore.Index, aMinimum);
		}
        #endregion SetStoreGradeMinimum
        #endregion StoreGradeMinimum

        #region StoreMayExceedMaximum
        //==========================//
		// Store May Exceed Maximum //
		//==========================//
		/// <summary>
		/// Gets Store May Exceed Max audit flag
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aStoreRID">RID identifier for the store.</param>
		/// <returns>True when store's allocation is permitted to exceed the maximum allocation.</returns>
		public bool GetStoreMayExceedMax(AllocationProfile aAllocationProfile, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreMayExceedMax (StoreIndex(aStoreRID));
			}
			return aAllocationProfile.GetStoreMayExceedMax(StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store May Exceed Max audit flag
		/// </summary>
		/// <param name="aStoreRID">RID identifier for the store.</param>
		/// <returns>True when store's allocation is permitted to exceed the maximum allocation.</returns>
		public bool GetStoreMayExceedMax(int aStoreRID)
		{
			return GetStoreMayExceedMax (StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store May Exceed Max audit flag
		/// </summary>
		/// <param name="aStore">Index_RID identifier for the store.</param>
		/// <returns>True when store's allocation is permitted to exceed the maximum allocation.</returns>
		internal bool GetStoreMayExceedMax (Index_RID aStore)
		{
			foreach (AllocationProfile ap in SubtotalMembers)
			{
				if (ap.GetStoreMayExceedMax(aStore))
				{
					return true;
				}
			}
			return false;
		}

		/// <summary>
		/// Sets store may exceed maximum allocation audit flag.
		/// </summary>
		/// <param name="aStoreRID">RID identifier for the store</param>
		/// <param name="aFlagValue">True indicates store may exceed its maximum allocation.</param>
		public void SetStoreMayExceedMax (int aStoreRID, bool aFlagValue)
		{
			SetStoreMayExceedMax (StoreIndex(aStoreRID), aFlagValue);
		}

		/// <summary>
		/// Sets store may exceed maximum allocation audit flag.
		/// </summary>
		/// <param name="aStore">Index_RID identifier for the store</param>
		/// <param name="aFlagValue">True indicates store may exceed its maximum allocation.</param>
		internal void SetStoreMayExceedMax (Index_RID aStore, bool aFlagValue)
		{
			foreach (AllocationProfile ap in SubtotalMembers)
			{
				ap.SetStoreMayExceedMax(aStore, aFlagValue);
			}
		}
		#endregion StoreMayExceedMaximum

		#region StoreMayExceedPrimaryMaximum 
		//==================================//
		// Store May Exceed Primary Maximum //
		//==================================//
		/// <summary>
		/// Gets Store May Exceed Primary Maximum audit flag
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aStoreRID">RID identifier for the store.</param>
		/// <returns>True when store's allocation is permitted to exceed the store's capacity</returns>
		public bool GetStoreMayExceedPrimaryMaximum(AllocationProfile aAllocationProfile, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreMayExceedPrimaryMaximum (StoreIndex(aStoreRID));
			}
			return aAllocationProfile.GetStoreMayExceedPrimaryMaximum (StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store May Exceed Primary Maximum audit flag
		/// </summary>
		/// <param name="aStoreRID">RID identifier for the store.</param>
		/// <returns>True when store's allocation is permitted to exceed the store's capacity</returns>
		public bool GetStoreMayExceedPrimaryMaximum(int aStoreRID)
		{
			return GetStoreMayExceedPrimaryMaximum (StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store May Exceed Primary Maximum audit flag
		/// </summary>
		/// <param name="aStore">Index_RID identifier for the store.</param>
		/// <returns>True when store's allocation is permitted to exceed the store's primary maximum</returns>
		internal bool GetStoreMayExceedPrimaryMaximum(Index_RID aStore)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.GetStoreMayExceedPrimaryMaximum(aStore))
				{
					return true;
				}
			}
			return false;
		}
		/// <summary>
		/// Sets store may exceed Primary Maximum audit flag.
		/// </summary>
		/// <param name="aStoreRID">RID identifier for the store</param>
		/// <param name="aFlagValue">True indicates store may exceed its primary maximum.</param>
		public void SetStoreMayExceedPrimaryMaximum (int aStoreRID, bool aFlagValue)
		{
			SetStoreMayExceedPrimaryMaximum (StoreIndex(aStoreRID), aFlagValue);
		}

		/// <summary>
		/// Sets store may exceed Primary Maximum audit flag.
		/// </summary>
		/// <param name="aStore">Index_RID identifier for the store</param>
		/// <param name="aFlagValue">True indicates store may exceed its primary maximum.</param>
		internal void SetStoreMayExceedPrimaryMaximum (Index_RID aStore, bool aFlagValue)
		{
			foreach (AllocationProfile ap in SubtotalMembers)
			{
				ap.SetStoreMayExceedPrimaryMaximum(aStore, aFlagValue);
			}
		}
		#endregion StoreMayExceedPrimaryMaximum

		#region StoreMayExceedCapacity 
		//===========================//
		// Store May Exceed Capacity //
		//===========================//
		/// <summary>
		/// Gets Store May Exceed Capacity audit flag
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aStoreRID">RID identifier for the store.</param>
		/// <returns>True when store's allocation is permitted to exceed the store's capacity</returns>
		public bool GetStoreMayExceedCapacity(AllocationProfile aAllocationProfile, int aStoreRID)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreMayExceedCapacity (StoreIndex(aStoreRID));
			}
			return aAllocationProfile.GetStoreMayExceedCapacity (StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store May Exceed Capacity audit flag
		/// </summary>
		/// <param name="aStoreRID">RID identifier for the store.</param>
		/// <returns>True when store's allocation is permitted to exceed the store's capacity</returns>
		public bool GetStoreMayExceedCapacity(int aStoreRID)
		{
			return GetStoreMayExceedCapacity (StoreIndex(aStoreRID));
		}

		/// <summary>
		/// Gets Store May Exceed Capacity audit flag
		/// </summary>
		/// <param name="aStore">Index_RID identifier for the store.</param>
		/// <returns>True when store's allocation is permitted to exceed the store's Capacity</returns>
		internal bool GetStoreMayExceedCapacity(Index_RID aStore)
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.GetStoreMayExceedCapacity(aStore))
				{
					return true;
				}
			}
			return false;
		}
		/// <summary>
		/// Sets store may exceed Capacity audit flag.
		/// </summary>
		/// <param name="aStoreRID">RID identifier for the store</param>
		/// <param name="aFlagValue">True indicates store may exceed its capacity.</param>
		public void SetStoreMayExceedCapacity (int aStoreRID, bool aFlagValue)
		{
			SetStoreMayExceedCapacity (StoreIndex(aStoreRID), aFlagValue);
		}

		/// <summary>
		/// Sets store may exceed Capacity audit flag.
		/// </summary>
		/// <param name="aStore">Index_RID identifier for the store</param>
		/// <param name="aFlagValue">True indicates store may exceed its Capacity.</param>
		internal void SetStoreMayExceedCapacity (Index_RID aStore, bool aFlagValue)
		{
			foreach (AllocationProfile ap in SubtotalMembers)
			{
				ap.SetStoreMayExceedCapacity(aStore, aFlagValue);
			}
		}
		#endregion StoreMayExceedPrimaryMaximum

		#region GetStoreExceedsCapacity
		/// <summary>
		/// Gets Store Exceeds Capacity Flag
		/// </summary>
		/// <param name="aStoreRID">RID of the store</param>
		/// <returns>True: when store has exceeded or equals capacity; False otherwise</returns>
		public bool GetStoreExceedsCapacity(int aStoreRID)
		{
			if (this.Transaction.AllocationStyleViewIncludesNeedAnalysis)
			{
				// only test for capacity when Need Analysis is showing!
				Index_RID storeIdxRID = StoreIndex(aStoreRID);
				Hashtable shipDayCapacity;
				int[] capacity_allocated;
				DateTime shipToDay;
				foreach (ArrayList al in this.CapacityNodes.Values)
				{
					shipDayCapacity = new Hashtable();
					foreach (AllocationProfile ap in al)
					{

						shipToDay = ap.GetStoreShipDay(storeIdxRID);
						if (shipDayCapacity.Contains(shipToDay))
						{
							capacity_allocated = (int[])shipDayCapacity[shipToDay];
						}
						else
						{
							capacity_allocated = new int[2];
							capacity_allocated.Initialize();
							//							capacity_allocated[0] = ap.GetStoreCapacityMaximum(storeIdxRID); //use first capacity value we see
							capacity_allocated[0] = ap.GetStoreAvailableCapacity(storeIdxRID); //use first capacity value we see
							shipDayCapacity.Add(shipToDay, capacity_allocated);
						}
						if (!ap.StyleIntransitUpdated)
						{
							capacity_allocated[1] += ap.GetStoreQtyAllocated(eAllocationSummaryNode.Total, storeIdxRID);
						}
						if (capacity_allocated[1] >= capacity_allocated[0])
						{
							return true;
						}
					}
				}
			}
			return false;
		}
		#endregion GetStoreExceedsCapacity

		#region StoresInVolumeGrade
		/// <summary>
		/// Identifies the stores that have the specified volume grade within the given store group level
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Profile List of stores having the specified volume grade within the given store group level.</returns>
		public ProfileList GetStoresInVolumeGrade(int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoresInVolumeGrade(Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), aVolumeGrade);  //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Identifies the stores that have the specified volume grade within the given list of stores
		/// </summary>
		/// <param name="aStoreList">Profile list of stores</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Profile List of stores having the specified volume grade within the given list of stores</returns>
		public ProfileList GetStoresInVolumeGrade(ProfileList aStoreList, string aVolumeGrade)
		{
			if (aVolumeGrade == null)
			{
				return aStoreList;
			}
			ProfileList storeList = new ProfileList(eProfileType.Store);
			foreach (StoreProfile sp in aStoreList)
			{
				if (this.GetStoreGrade(sp.Key) == aVolumeGrade)
				{
					storeList.Add(sp);
				}
			}
			return storeList;
		}
		#endregion StoresInVolumeGrade

		#region StoresInVelocityGrade
		/// <summary>
		/// Identifies the stores that have the specified Velocity grade within the given store group level
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aVelocityGrade">Velocity Grade</param>
		/// <returns>Profile List of stores having the specified Velocity grade within the given store group level.</returns>
		public ProfileList GetStoresInVelocityGrade(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
		{
			int storeGrpLvlRID = aStoreGrpLvlRID;
			if (storeGrpLvlRID == Include.TotalMatrixLevelRID)
			{
				storeGrpLvlRID = Include.AllStoreTotal;
			}
			return GetStoresInVelocityGrade(Transaction.GetActiveStoresInGroup(aStoreGrpRID, storeGrpLvlRID), aVelocityGrade); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Identifies the stores that have the specified Velocity grade within the given list of stores
		/// </summary>
		/// <param name="aStoreList">Profile list of stores</param>
		/// <param name="aVelocityGrade">Velocity Grade</param>
		/// <returns>Profile List of stores having the specified Velocity grade within the given list of stores</returns>
		public ProfileList GetStoresInVelocityGrade(ProfileList aStoreList, string aVelocityGrade)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			if (aVelocityGrade == null)
			{
				return aStoreList;
			}
			ProfileList storeList = new ProfileList(eProfileType.Store);
			foreach (StoreProfile sp in aStoreList)
			{
				if (this.GetStoreVelocityGrade(sp.Key) == aVelocityGrade)
				{
					storeList.Add(sp);
				}
			}
			return storeList;
		}
		#endregion StoresInVelocityGrade

		#region GetStoreAvgWeeklySales
		public double GetStoreAvgWeeklySales (int aStoreRID)
		{
			int[] storeRIDList = {aStoreRID};
			return GetStoreAvgWeeklySales(storeRIDList)[0];
		}
		public double[] GetStoreAvgWeeklySales (int[] aStoreRIDList)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
            // Begin TT#672 - RMatelic - Style View - Object Referrence error when selecting Basis columns when no basis exists
            //if (this._velocityStoreAvgWklySales == null)
            if (this._velocityStoreAvgWklySales == null && this.Transaction.GetAllocationBasisCubeGroup().OpenParms != null)
            // End TT#672
			{
				// BEGIN MID Track #2621  Period Basis Not Processed Correctly
//				if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(this.Transaction.GetAllocationGrandTotalProfile().PlanHnRID).OTSPlanLevelType)
//				{
//					_velocityStoreAvgWklySales = this.Transaction.GetStoreBasisElementValue(this.Transaction.AllStoreRIDList(), this.Transaction.Variables.SalesRegPromoUnits, this.Transaction.TimeTotalVariables.SalesRegPromoUnitsT2);
//				}
//				else
//				{
//					_velocityStoreAvgWklySales = this.Transaction.GetStoreBasisElementValue(this.Transaction.AllStoreRIDList(), this.Transaction.Variables.SalesTotalUnits, this.Transaction.TimeTotalVariables.SalesTotalUnitsT2);
//				}
				ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
//				foreach (BasisProfile bp in bpl)
				BasisProfile bp = (BasisProfile)bpl[0];
//				{
//					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
//					{
				        BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
						if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
						{
							_velocityStoreAvgWklySales = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.SalesRegPromoUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.AverageSalesRegPromoUnitsVariable);
						}
						else
						{
							_velocityStoreAvgWklySales = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.SalesTotalUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.AverageSalesTotalUnitsVariable);
						}
//					}
//				}
				// END MID Track #2621  Period Basis Not Processed Correctly                
			}
			double[] storeAvgWklySales = new double[aStoreRIDList.Length];
            // Begin TT#672 - RMatelic - Style View - Object Referrence error when selecting Basis columns when no basis exists
            //for (int i=0; i < aStoreRIDList.Length; i++)
            //{
            //    storeAvgWklySales[i] = _velocityStoreAvgWklySales[StoreIndex(aStoreRIDList[i]).Index];
            //}
            if (this._velocityStoreAvgWklySales != null)
            {
                for (int i = 0; i < aStoreRIDList.Length; i++)
                {
                    storeAvgWklySales[i] = _velocityStoreAvgWklySales[StoreIndex(aStoreRIDList[i]).Index];
                }
            }
            // End TT#672
			return storeAvgWklySales;
		}
		public double GetStoreGrpAvgWeeklySales (int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			// BEGIN MID Track #2621  Period Basis Not Processed Correctly
			//			if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(this.Transaction.GetAllocationGrandTotalProfile().PlanHnRID).OTSPlanLevelType)
			//			{
			//				return this.Transaction.GetStoreGrpBasisElementValue(aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.Variables.SalesRegPromoUnits, this.Transaction.TimeTotalVariables.SalesRegPromoUnitsT2);
			//			}
			//			else
			//			{
			//				return this.Transaction.GetStoreGrpBasisElementValue(aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.Variables.SalesTotalUnits, this.Transaction.TimeTotalVariables.SalesTotalUnitsT2);
			//			}
			ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
			//				foreach (BasisProfile bp in bpl)
			BasisProfile bp = (BasisProfile)bpl[0];
			//				{
			//					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
			//					{
			BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
			if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
			{
				return this.Transaction.GetStoreGrpBasisElementValue(this.PlanHnRID, aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.PlanComputations.PlanVariables.SalesRegPromoUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.AverageSalesRegPromoUnitsVariable);
			}
			else
			{
				return this.Transaction.GetStoreGrpBasisElementValue(this.PlanHnRID, aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.PlanComputations.PlanVariables.SalesTotalUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.AverageSalesTotalUnitsVariable);
			}
			// END MID Track #2621  Period Basis Not Processed Correctly
		}
		#endregion GetStoreAvgWeeklySales

		#region GetStoreAvgWeeklyStock
		public double GetStoreAvgWeeklyStock (int aStoreRID)
		{
			int[] storeRIDList = {aStoreRID};
			return GetStoreAvgWeeklyStock (storeRIDList)[0];
		}
		public double[] GetStoreAvgWeeklyStock (int[] aStoreRIDList)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
            // Begin TT#672 - RMatelic - Style View - Object Referrence error when selecting Basis columns when no basis exists
            //if (_velocityStoreAvgWklyStock == null)
            if (_velocityStoreAvgWklyStock == null && this.Transaction.GetAllocationBasisCubeGroup().OpenParms != null)
            // End TT#672
			{
				// BEGIN MID Track #2621  Period Basis Not Processed Correctly
//				if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(this.Transaction.GetAllocationGrandTotalProfile().PlanHnRID).OTSPlanLevelType)
//				{
//					_velocityStoreAvgWklyStock = this.Transaction.GetStoreBasisElementValue(
//						this.Transaction.AllStoreRIDList(), 
//						this.Transaction.Variables.InventoryRegularUnits, 
//						this.Transaction.TimeTotalVariables.InventoryRegularUnitsT2);
//				}
//				else
//				{
//					_velocityStoreAvgWklyStock = this.Transaction.GetStoreBasisElementValue(
//						this.Transaction.AllStoreRIDList(), 
//						this.Transaction.Variables.InventoryTotalUnits, 
//						this.Transaction.TimeTotalVariables.InventoryTotalUnitsT2);
//				}
				ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
				//				foreach (BasisProfile bp in bpl)
				BasisProfile bp = (BasisProfile)bpl[0];
				//				{
				//					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
				//					{
				BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
				if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
				{
					_velocityStoreAvgWklyStock = this.Transaction.GetStoreBasisElementValue(
						this.PlanHnRID, 
						this.Transaction.AllStoreRIDList(),
						this.Transaction.PlanComputations.PlanVariables.InventoryRegularUnitsVariable,
						this.Transaction.PlanComputations.PlanTimeTotalVariables.AverageInventoryRegularUnitsVariable);
				}
				else
				{
					_velocityStoreAvgWklyStock = this.Transaction.GetStoreBasisElementValue(
						this.PlanHnRID, 
						this.Transaction.AllStoreRIDList(),
						this.Transaction.PlanComputations.PlanVariables.InventoryTotalUnitsVariable,
						this.Transaction.PlanComputations.PlanTimeTotalVariables.AverageInventoryTotalUnitsVariable);
				}
				// END MID Track #2621  Period Basis Not Processed Correctly
			}
			double[] storeAvgWklyStock = new double[aStoreRIDList.Length];
            // Begin TT#672 - RMatelic - Style View - Object Referrence error when selecting Basis columns when no basis exists
            //for (int i=0; i < aStoreRIDList.Length; i++)
            //{
            //    storeAvgWklyStock[i] = _velocityStoreAvgWklyStock[StoreIndex(aStoreRIDList[i]).Index];
            //}
            if (_velocityStoreAvgWklyStock != null)
            {
                for (int i = 0; i < aStoreRIDList.Length; i++)
                {
                    storeAvgWklyStock[i] = _velocityStoreAvgWklyStock[StoreIndex(aStoreRIDList[i]).Index];
                }
            }
            // End TT#672
			return storeAvgWklyStock;
		}
		public double GetStoreGrpAvgWeeklyStock (int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			// BEGIN MID Track #2621  Period Basis Not Processed Correctly
//			if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(this.Transaction.GetAllocationGrandTotalProfile().PlanHnRID).OTSPlanLevelType)
//			{
//				return this.Transaction.GetStoreGrpBasisElementValue(aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.Variables.InventoryRegularUnits, this.Transaction.TimeTotalVariables.InventoryRegularUnitsT2);
//			}
//			else
//			{
//				return this.Transaction.GetStoreGrpBasisElementValue(aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.Variables.InventoryTotalUnits, this.Transaction.TimeTotalVariables.InventoryTotalUnitsT2);
//			}
			ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
			//				foreach (BasisProfile bp in bpl)
			BasisProfile bp = (BasisProfile)bpl[0];
			//				{
			//					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
			//					{
			BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
			if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
			{
				return this.Transaction.GetStoreGrpBasisElementValue(this.PlanHnRID, aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.PlanComputations.PlanVariables.InventoryRegularUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.AverageInventoryRegularUnitsVariable);
			}
			else
			{
				return this.Transaction.GetStoreGrpBasisElementValue(this.PlanHnRID, aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.PlanComputations.PlanVariables.InventoryTotalUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.AverageInventoryTotalUnitsVariable);
			}
			// END MID Track #2621  Period Basis Not Processed Correctly
		}
		#endregion GetStoreAvgWeeklyStock

		#region GetStoreBasisStock
		public int GetStoreBasisStock (int aStoreRID)
		{
			int[] storeRIDList = {aStoreRID};
			return GetStoreBasisStock(storeRIDList)[0];
		}
		public int[] GetStoreBasisStock (int[] aStoreRIDList)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			if (_velocityStoreBasisStock == null)
			{
				// BEGIN MID Track #2621  Period Basis Not Processed Correctly
//				if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(this.Transaction.GetAllocationGrandTotalProfile().PlanHnRID).OTSPlanLevelType)
//				{
//
//					_velocityStoreBasisStock = this.Transaction.GetStoreBasisElementValue(this.Transaction.AllStoreRIDList(), this.Transaction.Variables.InventoryRegularUnits, this.Transaction.TimeTotalVariables.InventoryRegularUnitsT1);
//				}
//				else
//				{
//					_velocityStoreBasisStock = this.Transaction.GetStoreBasisElementValue(this.Transaction.AllStoreRIDList(), this.Transaction.Variables.InventoryTotalUnits, this.Transaction.TimeTotalVariables.InventoryTotalUnitsT1);
//				}
				ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
				//				foreach (BasisProfile bp in bpl)
				BasisProfile bp = (BasisProfile)bpl[0];
				//				{
				//					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
				//					{
				BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
				if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
				{
					_velocityStoreBasisStock = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.InventoryRegularUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.BeginningInventoryRegularUnitsVariable);
				}
				else
				{
					_velocityStoreBasisStock = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.InventoryTotalUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.BeginningInventoryTotalUnitsVariable);
				}
				// END MID Track #2621  Period Basis Not Processed Correctly
			}
			int[] storeBasisStock = new int[aStoreRIDList.Length];
			for (int i=0; i < aStoreRIDList.Length; i++)
			{
				storeBasisStock[i] = (int)_velocityStoreBasisStock[StoreIndex(aStoreRIDList[i]).Index];
			}
			return storeBasisStock;
			
		}
		public int GetStoreGrpBasisStock (int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			// BEGIN MID Track #2621  Period Basis Not Processed Correctly
//			if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(this.Transaction.GetAllocationGrandTotalProfile().PlanHnRID).OTSPlanLevelType)
//			{
//
//				return (int)this.Transaction.GetStoreGrpBasisElementValue(aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.Variables.InventoryRegularUnits, this.Transaction.TimeTotalVariables.InventoryRegularUnitsT1);
//			}
//			else
//			{
//				return (int)this.Transaction.GetStoreGrpBasisElementValue(aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.Variables.InventoryTotalUnits, this.Transaction.TimeTotalVariables.InventoryTotalUnitsT1);
//			}
			ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
			//				foreach (BasisProfile bp in bpl)
			BasisProfile bp = (BasisProfile)bpl[0];
			//				{
			//					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
			//					{
			BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
			if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
			{
				return (int)this.Transaction.GetStoreGrpBasisElementValue(this.PlanHnRID, aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.PlanComputations.PlanVariables.InventoryRegularUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.BeginningInventoryRegularUnitsVariable);
			}
			else
			{
				return (int)this.Transaction.GetStoreGrpBasisElementValue(this.PlanHnRID, aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.PlanComputations.PlanVariables.InventoryTotalUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.BeginningInventoryTotalUnitsVariable);
			}
			// END MID Track #2621  Period Basis Not Processed Correctly
		}
		#endregion GetStoreBasisStock

        // Begin TT#638 - RMatelic - Style Review - Add Basis Variables
        #region GetStoreBasisGrade
        public string GetStoreBasisGrade(int aStoreRID)
        {
            int[] storeRIDList = { aStoreRID };
            return GetStoreBasisGradeFromValues(storeRIDList)[0];
        }

        public string[] GetStoreBasisGradeFromValues(int[] aStoreRIDList)
        {
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
            if (_basisStoreGradeList == null)
            {
                ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
                //				foreach (BasisProfile bp in bpl)
                BasisProfile bp = (BasisProfile)bpl[0];
                //				{
                //					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
                //					{
                BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
                if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
                {
                    _basisStoreGradeList = this.Transaction.GetStoreBasisElementValueString(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.GradeRegPromoVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalGradeRegPromoVariable);
                }
                else
                {
                    _basisStoreGradeList = this.Transaction.GetStoreBasisElementValueString(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.GradeTotalVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalGradeTotalVariable);
                }
            }
            string[] storeBasisGrade = new string[aStoreRIDList.Length];
          
            for (int i = 0; i < aStoreRIDList.Length; i++)
            {
                storeBasisGrade[i] = _basisStoreGradeList[StoreIndex(aStoreRIDList[i]).Index];
            }
            
            return storeBasisGrade;
        }
        #endregion GetStoreBasisGrade
        // End TT#638  
		
        #region GetStoreBasisSales
		public int GetStoreBasisSales (int aStoreRID)
		{
			int[] storeRIDList = {aStoreRID};
			return GetStoreBasisSales(storeRIDList)[0];
		}
		public int[] GetStoreBasisSales(int[] aStoreRIDList)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
            // Begin TT#672 - RMatelic - Style View - Object Referrence error when selecting Basis columns when no basis exists
            //if (_velocityStoreBasisSales == null)
            if (_velocityStoreBasisSales == null && this.Transaction.GetAllocationBasisCubeGroup().OpenParms != null)
            // End TT#672
			{
				// BEGIN MID Track #2621  Period Basis Not Processed Correctly
//				if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(this.Transaction.GetAllocationGrandTotalProfile().PlanHnRID).OTSPlanLevelType)
//				{
//					_velocityStoreBasisSales = this.Transaction.GetStoreBasisElementValue(this.Transaction.AllStoreRIDList(), this.Transaction.Variables.SalesRegPromoUnits, this.Transaction.TimeTotalVariables.SalesRegPromoUnitsT1);
//				}
//				else
//				{
//					_velocityStoreBasisSales = this.Transaction.GetStoreBasisElementValue(this.Transaction.AllStoreRIDList(), this.Transaction.Variables.SalesTotalUnits, this.Transaction.TimeTotalVariables.SalesTotalUnitsT1);
//				}

				ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
				//				foreach (BasisProfile bp in bpl)
				BasisProfile bp = (BasisProfile)bpl[0];
				//				{
				//					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
				//					{
				BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
				if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
				{
					_velocityStoreBasisSales = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.SalesRegPromoUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalSalesRegPromoUnitsVariable);
				}
				else
				{
					_velocityStoreBasisSales = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.SalesTotalUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalSalesTotalUnitsVariable);
				}
				// END MID Track #2621  Period Basis Not Processed Correctly
			}
			int[] storeBasisSales= new int[aStoreRIDList.Length];
            // Begin TT#672 - RMatelic - Style View - Object Referrence error when selecting Basis columns when no basis exists
            //for (int i = 0; i < aStoreRIDList.Length; i++)
            //{
            //    storeBasisSales[i] = (int)_velocityStoreBasisSales[StoreIndex(aStoreRIDList[i]).Index];
            //}
            if (_velocityStoreBasisSales != null)
            {
                for (int i = 0; i < aStoreRIDList.Length; i++)
                {
                    storeBasisSales[i] = (int)_velocityStoreBasisSales[StoreIndex(aStoreRIDList[i]).Index];
                }
            }
            // End TT#672
			return storeBasisSales;
		}
		public int GetStoreGrpBasisSales (int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			// BEGIN MID Track #2621  Period Basis Not Processed Correctly
//			if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(this.Transaction.GetAllocationGrandTotalProfile().PlanHnRID).OTSPlanLevelType)
//			{
//				return (int)this.Transaction.GetStoreGrpBasisElementValue(aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.Variables.SalesRegPromoUnits, this.Transaction.TimeTotalVariables.SalesRegPromoUnitsT1);
//			}
//			else
//			{
//				return (int)this.Transaction.GetStoreGrpBasisElementValue(aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.Variables.SalesTotalUnits, this.Transaction.TimeTotalVariables.SalesTotalUnitsT1);
//			}
			ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
			//				foreach (BasisProfile bp in bpl)
			BasisProfile bp = (BasisProfile)bpl[0];
			//				{
			//					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
			//					{
			BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
   			if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
			{
				return (int)this.Transaction.GetStoreGrpBasisElementValue(this.PlanHnRID, aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.PlanComputations.PlanVariables.SalesRegPromoUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalSalesRegPromoUnitsVariable);
			}
			else
			{
				return (int)this.Transaction.GetStoreGrpBasisElementValue(this.PlanHnRID, aStoreGrpRID, aStoreGrpLvlRID, this.Transaction.PlanComputations.PlanVariables.SalesTotalUnitsVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalSalesTotalUnitsVariable);
			}
			// END MID Track #2621  Period Basis Not Processed Correctly
		}
		#endregion GetStoreBasisSales

		#region GetStoreVelocityGrade
		public double GetStoreVelocityGradeIDX(int aStoreRID)
		{
			int[] storeRIDList = {aStoreRID};
			return GetStoreVelocityGradeIDX(storeRIDList)[0];
		}
		public double[] GetStoreVelocityGradeIDX(int[] aStoreRIDList)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
            if (this.Transaction.VelocityCalculateAverageUsingChain) //TT#855-MD -jsobek -Velocity Enhancements
            {
                if (_velocityStoreGradeIDX_Chain == null)
                {
                    // BEGIN MID Track #2621  Period Basis Not Processed Correctly
                    //				if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(this.Transaction.GetAllocationGrandTotalProfile().PlanHnRID).OTSPlanLevelType)
                    //				{
                    //					_velocityStoreGradeIDX_Chain = this.Transaction.GetStoreBasisElementValue(this.Transaction.AllStoreRIDList(), this.Transaction.Variables.SalesRegPromoAllStoreIndex, this.Transaction.TimeTotalVariables.SalesRegPromoAllStoreIndexT1);
                    //				}
                    //				else
                    //				{
                    //					_velocityStoreGradeIDX_Chain = this.Transaction.GetStoreBasisElementValue(this.Transaction.AllStoreRIDList(), this.Transaction.Variables.SalesTotalAllStoreIndex, this.Transaction.TimeTotalVariables.SalesTotalAllStoreIndexT1);
                    //				}
                    ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
                    //				foreach (BasisProfile bp in bpl)
                    BasisProfile bp = (BasisProfile)bpl[0];
                    //				{
                    //					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
                    //					{
                    BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
                    if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
                    {
                        //Begin TT#855-MD -jsobek -Velocity Enhancements
                        if (this.Transaction.VelocityCalculateGradeVariableType == eVelocityMethodGradeVariableType.Sales) 
                        {
                            _velocityStoreGradeIDX_Chain = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.SalesRegPromoAllStoreIndexVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalSalesRegPromoAllStoreIndexVariable);
                        }
                        else if (this.Transaction.VelocityCalculateGradeVariableType == eVelocityMethodGradeVariableType.Stock)
                        {
                            _velocityStoreGradeIDX_Chain = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.InventoryRegularAllStoreIndexVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalInventoryRegularAllStoreIndexVariable);
                        }
                        //End TT#855-MD -jsobek -Velocity Enhancements

                    }
                    else
                    {
                        //Begin TT#855-MD -jsobek -Velocity Enhancements
                        if (this.Transaction.VelocityCalculateGradeVariableType == eVelocityMethodGradeVariableType.Sales)
                        {
                            _velocityStoreGradeIDX_Chain = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.SalesTotalAllStoreIndexVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalSalesTotalAllStoreIndexVariable);
                        }
                        else if (this.Transaction.VelocityCalculateGradeVariableType == eVelocityMethodGradeVariableType.Stock)
                        {
                            _velocityStoreGradeIDX_Chain = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.InventoryTotalAllStoreIndexVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalInventoryTotalAllStoreIndexVariable);
                        }
                        //End TT#855-MD -jsobek -Velocity Enhancements
                    }
                    // END MID Track #2621  Period Basis Not Processed Correctly
                }
            }
            else
            {
                if (_velocityStoreGradeIDX_Set == null)
                {
                    // BEGIN MID Track #2621  Period Basis Not Processed Correctly
                    //				if (eOTSPlanLevelType.Regular == this.Transaction.GetNodeData(this.Transaction.GetAllocationGrandTotalProfile().PlanHnRID).OTSPlanLevelType)
                    //				{
                    //					_velocityStoreGradeIDX_Set = this.Transaction.GetStoreBasisElementValue(this.Transaction.AllStoreRIDList(), this.Transaction.Variables.SalesRegPromoSetIndex, this.Transaction.TimeTotalVariables.SalesRegPromoSetIndexT1);
                    //				}
                    //				else
                    //				{
                    //					_velocityStoreGradeIDX_Set = this.Transaction.GetStoreBasisElementValue(this.Transaction.AllStoreRIDList(), this.Transaction.Variables.SalesTotalSetIndex,this.Transaction.TimeTotalVariables.SalesTotalSetIndexT1);
                    //				}
                    ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
                    //				foreach (BasisProfile bp in bpl)
                    BasisProfile bp = (BasisProfile)bpl[0];
                    //				{
                    //					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
                    //					{
                    BasisDetailProfile bdp = (BasisDetailProfile)bp.BasisDetailProfileList[0];
                    if (eOTSPlanLevelType.Regular == bdp.HierarchyNodeProfile.OTSPlanLevelType)
                    {
                        //Begin TT#855-MD -jsobek -Velocity Enhancements
                        if (this.Transaction.VelocityCalculateGradeVariableType == eVelocityMethodGradeVariableType.Sales)
                        {
                            _velocityStoreGradeIDX_Set = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.SalesRegPromoSetIndexVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalSalesRegPromoSetIndexVariable);
                        }
                        else if (this.Transaction.VelocityCalculateGradeVariableType == eVelocityMethodGradeVariableType.Stock)
                        {
                            _velocityStoreGradeIDX_Set = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.InventoryRegularSetIndexVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalInventoryRegularSetIndexVariable);
              
                        }
                        //End TT#855-MD -jsobek -Velocity Enhancements
                    }
                    else
                    {
                        //Begin TT#855-MD -jsobek -Velocity Enhancements
                        if (this.Transaction.VelocityCalculateGradeVariableType == eVelocityMethodGradeVariableType.Sales)
                        {
                            _velocityStoreGradeIDX_Set = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.SalesTotalSetIndexVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalSalesTotalSetIndexVariable);
                        }
                        else if (this.Transaction.VelocityCalculateGradeVariableType == eVelocityMethodGradeVariableType.Stock)
                        {
                            _velocityStoreGradeIDX_Set = this.Transaction.GetStoreBasisElementValue(this.PlanHnRID, this.Transaction.AllStoreRIDList(), this.Transaction.PlanComputations.PlanVariables.InventoryTotalSetIndexVariable, this.Transaction.PlanComputations.PlanTimeTotalVariables.TotalInventoryTotalSetIndexVariable);
                        }
                        //End TT#855-MD -jsobek -Velocity Enhancements
                    }
                    // END MID Track #2621  Period Basis Not Processed Correctly

                }
            }
			double[] storeVelocityGradeIDX = new double[aStoreRIDList.Length];
			if (this.Transaction.VelocityCalculateAverageUsingChain)
			{
				for (int i=0; i < aStoreRIDList.Length; i++)
				{
					storeVelocityGradeIDX[i] = _velocityStoreGradeIDX_Chain[StoreIndex(aStoreRIDList[i]).Index];
				}
			}
			else
			{
				for (int i=0; i < aStoreRIDList.Length; i++)
				{
					storeVelocityGradeIDX[i] = _velocityStoreGradeIDX_Set[StoreIndex(aStoreRIDList[i]).Index];
				}
			}
			return storeVelocityGradeIDX;
		}
    
		public string GetStoreVelocityGrade (int aStoreRID)
		{
			int[] storeRIDList = {aStoreRID};
			return GetStoreVelocityGrade(storeRIDList)[0];
		}
		public string[] GetStoreVelocityGrade(int[] aStoreRIDList)
		{
			double[] velocityGradeIDX = GetStoreVelocityGradeIDX(aStoreRIDList);
			string[] velocityGrades = new string[aStoreRIDList.Length];
			for (int i=0; i< velocityGradeIDX.Length; i++)
			{
				velocityGrades[i] = this.Transaction.Velocity.VelocityGrade(velocityGradeIDX[i]);
			}
			return velocityGrades;
		}
		#endregion GetStoreVelocityGrade

        // Begin TT#2066-MD - JSmith - Ship to Date validation.  Is this how it should be working
        #region GetStoreAssortmentGrade
        public string GetStoreAssortmentGrade(int aStoreRID)
        {
            if (Transaction.AssortmentProfile == null)
            {
                return " ";
            }
            return Transaction.AssortmentProfile.GetAssortmentGrade(aStoreRID);
        }
        #endregion GetStoreAssortmentGrade
        // End TT#2066-MD - JSmith - Ship to Date validation.  Is this how it should be working

		#region Velocity
// (CSMITH) - BEG MID Track #2410: Allow interactive processing with multiple headers
//		public int GetStoreGrpVelocityRuleResult (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		public int GetStoreGrpVelocityRuleResult (int aHeaderRID, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
// (CSMITH) - END MID Track #2410
		{
// (CSMITH) - BEG MID Track #2410: Allow interactive processing with multiple headers
//			return GetStoreGrpVelocityRuleResult (aComponent, aStoreGrpRID, aStoreGrpLvlRID, false);
			return GetStoreGrpVelocityRuleResult (aHeaderRID, aComponent, aStoreGrpRID, aStoreGrpLvlRID, false);
// (CSMITH) - END MID Track #2410
		}
// (CSMITH) - BEG MID Track #2410: Allow interactive processing with multiple headers
//		private int GetStoreGrpVelocityRuleResult (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, bool aIncludeAllStores)
		private int GetStoreGrpVelocityRuleResult (int aHeaderRID, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, bool aIncludeAllStores)
// (CSMITH) - END MID Track #2410
		{
			ProfileList storeList = this.Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID); //MID Track 5820 - Unhandled Exception After Store Activation
			int count = storeList.Count;
			int ruleResult = 0;
			ArrayList storeArray = storeList.ArrayList;
			int storeRID;
			for(int i=0; i<count; i++)
			{
				storeRID = ((StoreProfile)storeArray[i]).Key;
				if (this.StoreIsVisible(storeRID) || aIncludeAllStores)
				{
// (CSMITH) - BEG MID Track #2410: Allow interactive processing with multiple headers
//					ruleResult += (int)this.Transaction.Velocity.GetStoreVelocityRuleResult(storeRID);
					ruleResult += (int)this.Transaction.Velocity.GetStoreVelocityRuleResult(aHeaderRID, storeRID);
// (CSMITH) - END MID Track #2410
				}
			}
			return ruleResult;
		}
		public int GetVelocityRuleBalance (AllocationProfile aAllocationProfile)
		{
			int balance = 0;
			if (aAllocationProfile == null)
			{
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					balance += GetVelocityBalance (ap);
				}
			}
			else
			{
				balance = GetVelocityBalance (aAllocationProfile);
			}
			return balance;
		}
		private int GetVelocityBalance(AllocationProfile aAllocationProfile)
		{
// (CSMITH) - BEG MID Track #2410: Allow interactive processing with multiple headers
//			return 
//				aAllocationProfile.GetQtyToAllocate(this.Transaction.Velocity.Component)
//				- GetStoreGrpVelocityRuleResult (this.Transaction.Velocity.Component, Include.AllStoreFilterRID, Include.AllStoreTotal, true);
			return 
				aAllocationProfile.GetQtyToAllocate(this.Transaction.Velocity.Component)
				- GetStoreGrpVelocityRuleResult (aAllocationProfile.HeaderRID, this.Transaction.Velocity.Component, Include.AllStoreFilterRID, Include.AllStoreTotal, true);
// (CSMITH) - END MID Track #2410
		}
		#endregion Velocity

		#region GetStoreStyleInTransit
		public int GetStoreStyleInTransit (IntransitKeyType aIKT, int aStoreRID)
		{
			int[] aStoreRIDList = {aStoreRID};
			return GetStoreStyleInTransit (aIKT, aStoreRIDList)[0];
		}
		public int[] GetStoreStyleInTransit(IntransitKeyType aIKT, int[] aStoreRIDList)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			int count = aStoreRIDList.Length;
			int[] inTransit = new int[count];
			if (_loadVelocityStyleInTransit)
			{
				DayProfile startDay;
				if (this.BeginDay == Include.UndefinedDate)
				{
					startDay = ((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.CurrentDate;
				}
				else
				{
					startDay = 	((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.GetDay(this.BeginDay);
				}
				int[] storeFromDay = new int[this._allStoreList.Count];
				int[] storeToDay = new int[this._allStoreList.Count];
				int storeRID;
				for (int i=0; i<this._allStoreList.Count; i++)
				{
					storeRID = ((StoreProfile)this._allStoreList.ArrayList[i]).Key;
					storeFromDay[i] = startDay.YearDay;
					storeToDay[i] = ((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.GetDay(this.GetStoreNeedDay(storeRID)).YearDay;
				}
                // begin TT#4345 - MD - Jellis - GA VSW calculated incorrectly
                Horizon_ID horizonID = new Horizon_ID(startDay.Date, EndDay);
                // Begin TT#1674-MD - JSmith - Velocity is not displaying or considering intransit for results during a Group or Non-Group Allocation
                //_velocityStoreSalesITHorizon = new StoreSalesITHorizon(Transaction, horizonID, storeToDay, storeToDay);
                _velocityStoreSalesITHorizon = new StoreSalesITHorizon(Transaction, horizonID, storeFromDay, storeToDay);
                // End TT#1674-MD - JSmith - Velocity is not displaying or considering intransit for results during a Group or Non-Group Allocation
                //((ApplicationSessionTransaction)Transaction).GetIntransitReader().SetStoreIT_DayRange(_allStoreList, this.VelocityStyleHnRID, storeFromDay, storeToDay);
                // end TT#4345 - MD - Jellis - GA VSW calculated incorrectly 
				_loadVelocityStyleInTransit = false;
			}
			for(int i=0; i<count; i++)
			{
				inTransit[i] = this.GetStoreInTransit(aIKT, aStoreRIDList[i], this.VelocityStyleHnRID, _velocityStoreSalesITHorizon);  // TT#4345 - MD - Jellis - GA VSW calculated incorrectly
			}
			return inTransit;
		}

		public int GetStoreGrpStyleInTransit (IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			ProfileList storeList = this.Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID); //MID Track 5820 - Unhandled Exception After Store Activation
			int count = storeList.Count;
			int[] storeRIDList = new int[count];
			for (int i=0; i<count; i++)
			{
				storeRIDList[i] = ((StoreProfile)storeList.ArrayList[i]).Key;
			}
			int[] storeInTransit = GetStoreStyleInTransit(
				new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize), 
				storeRIDList);
			int inTransit = 0;
			for(int i=0; i<count; i++)
			{
				if (this.StoreIsVisible(storeRIDList[i]))
				{
					inTransit +=storeInTransit[i];
				}
			}
			return inTransit;
		}
		#endregion GetStoreStyleInTransit

		#region GetStoreBasisInTransit
		public int GetStoreBasisInTransit (int aStoreRID)
		{
			IntransitKeyType ikt = new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize);
			return GetStoreBasisInTransit(ikt, aStoreRID);
		}
		public int GetStoreBasisInTransit (IntransitKeyType aIKT, int aStoreRID)
		{
			int[] aStoreRIDList = {aStoreRID};
			return GetStoreBasisInTransit (aIKT, aStoreRIDList)[0];
		}
		public int[] GetStoreBasisInTransit(IntransitKeyType aIKT, int[] aStoreRIDList)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			int count = aStoreRIDList.Length;
			int[] inTransit = new int[count];
			IntransitKeyType[] iktArray = {aIKT};
			if (_loadVelocityBasisInTransit)
			{
				_loadVelocityBasisInTransit = false;
				int storeCount = this._allStoreList.Count;
				this._velocityBasisInTransit = new int[storeCount];
				this._velocityBasisInTransit.Initialize();
				ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
				DayProfile startDay;
				if (this.BeginDay == Include.UndefinedDate)
				{
					startDay = ((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.CurrentDate;
				}
				else
				{
					startDay = 	((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.GetDay(this.BeginDay);
				}
				int[] storeFromDay = new int[storeCount];
				int[] storeToDay = new int[storeCount];
				int storeRID;
				for (int i=0; i<storeCount; i++)
				{
					storeRID = ((StoreProfile)this._allStoreList.ArrayList[i]).Key;
					storeFromDay[i] = startDay.YearDay;
					storeToDay[i] = ((ApplicationSessionTransaction)Transaction).SAB.ApplicationServerSession.Calendar.GetDay(this.GetStoreNeedDay(storeRID)).YearDay;
				}
			    // begin TT#4345 - MD - Jellis - GA VSW calculated incorrectly
                Horizon_ID horizonID = new Horizon_ID(startDay.Date, EndDay);
                _velocityBasisStoreSalesITHorizon = new StoreSalesITHorizon(Transaction, horizonID, storeFromDay, storeToDay);
                // end TT#4345 - MD - Jellis - GA VSW calculated incorrectly
				Hashtable basisNode = new Hashtable();  // MID Track 2927 Basis Intransit double in velocity when multiple dates selected
				foreach (BasisProfile bp in bpl)
				{
					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
					{
						// BEGIN MID Track 2927 Basis Intransit double in velocity when multiple dates selected
						if (basisNode.Contains(bdp.HierarchyNodeProfile.Key))
						{
							//  Skip node because it is already reflected in the intransit
						}
						else
						{
							basisNode.Add(bdp.HierarchyNodeProfile.Key,bdp.HierarchyNodeProfile.Key);
							// END MID Track 2927 Basis Intransit double in velocity when multiple dates selected
                            // begin TT#4345 - MD - Jellis - GA VSW calculated incorrectly
                            //((ApplicationSessionTransaction)Transaction).GetIntransitReader().SetStoreIT_DayRange(_allStoreList, bdp.HierarchyNodeProfile.Key, storeFromDay, storeToDay);
                            // end TT#4345 - MD - JEllis - GA VSW calculaated incorrectly
							double intermediateValue;
							for (int i=0; i<storeCount; i++)
							{
								intermediateValue = 
									(double)this.Transaction.GetStoreInTransit(bdp.HierarchyNodeProfile.Key, _velocityBasisStoreSalesITHorizon, iktArray, ((StoreProfile)_allStoreList.ArrayList[i]).Key) // TT#4345 - MD - Jellis - GA VSW calculated incorrectly
									* bdp.Weight;
								if (intermediateValue <0)
								{
									_velocityBasisInTransit[i] += (int)(intermediateValue - .5d);
								}
								else
								{
									_velocityBasisInTransit[i] += (int)(intermediateValue + .5d);
								}
							}
						} // MID Track 2927 Basis Intransit double in velocity when multiple dates selected
					}
				}
			}
			Index_RID storeIdxRID;
			for (int i=0; i<count; i++)
			{
				storeIdxRID = StoreIndex(aStoreRIDList[i]);
				inTransit[i] = _velocityBasisInTransit[storeIdxRID.Index];
			}
			return inTransit;
		}
		//		{
		//			int count = aStoreRIDList.Length;
		//			int[] inTransit = new int[count];
		//			double[] inTransitD = new double[count];
		//			inTransitD = this.Transaction.GetStoreBasisElementValue(aStoreRIDList, this.Transaction.Variables.Intransit, this.Transaction.TimeTotalVariables.IntransitT1);
		//
		//			for(int i=0; i<count; i++)
		//			{
		//				inTransit[i] = (int)inTransitD[i];
		//			}
		//			return inTransit;
		//		}

		public int GetStoreGrpBasisInTransit (IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			int inTransit = 0;
			ProfileList storeList = this.Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID); //MID Track 5820 - Unhandled Exception After Store Activation
			int count = storeList.Count;
			int[] storeRIDList = new int[count];
			for (int i=0; i < count; i++)
			{
				storeRIDList[i] = ((StoreProfile)storeList.ArrayList[i]).Key;
			}
			int[] storeInTransit = this.GetStoreBasisInTransit(
				new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize),
				storeRIDList);
			for (int i=0; i<count; i++)
			{
				if (this.StoreIsVisible(storeRIDList[i]))
				{
					inTransit += storeInTransit[i];
				}
			}
			return inTransit;
		}
		#endregion GetStoreBasisInTransit

		#region GetStoreStyleOnHand
		/// <summary>
		/// Gets the "actual" OnHand for the the style of the first receiver.
		/// </summary>
		/// <param name="aIKT">Intransit Key Type identifies level of onhand to read</param>
		/// <param name="aStoreRID">RID of the store</param>
		/// <returns>OnHand for the store in the style of the 1st selected header.</returns>
		public int GetStoreStyleOnHand (IntransitKeyType aIKT, int aStoreRID)
		{
			int[] aStoreRIDList = {aStoreRID};
			return GetStoreStyleOnHand (aIKT, aStoreRIDList)[0];
		}

		/// <summary>
		/// Gets the "actual" OnHand for the the style of the first receiver.
		/// </summary>
		/// <param name="aIKT">Intransit Key Type identifies level of onhand to read</param>
		/// <param name="aStoreRIDList">List of store RIDs</param>
		/// <returns>OnHand for the stores in the style of the 1st selected header.</returns>
		public int[] GetStoreStyleOnHand(IntransitKeyType aIKT, int[] aStoreRIDList)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal();   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			int count = aStoreRIDList.Length;
			int[] onHand = new int[count];
			for(int i=0; i<count; i++)
			{
				onHand[i] = this.GetStoreOnHand(aIKT, aStoreRIDList[i], this.VelocityStyleHnRID); 
			}
			return onHand;
		}
		public int GetStoreGrpStyleOnHand (IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			ProfileList storeList = this.Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID); //MID Track 5820 - Unhandled Exception After Store Activation
			int count = storeList.Count;
			int[] storeRIDList = new int[count];
			for (int i=0; i<count; i++)
			{
				storeRIDList[i] = ((StoreProfile)storeList.ArrayList[i]).Key;
			}
			int[] storeOnHand = GetStoreStyleOnHand(
				new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize), 
				storeRIDList);
			int onHand = 0;
			for(int i=0; i<count; i++)
			{
				if (this.StoreIsVisible(storeRIDList[i]))
				{
					onHand +=storeOnHand[i];
				}
			}
			return onHand;
		}
		#endregion GetStoreStyleOnhand

		#region GetStoreBasisOnHand
		public int GetStoreBasisOnHand (int aStoreRID)
		{
			IntransitKeyType ikt = new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize);
			return GetStoreBasisOnHand(ikt, aStoreRID);
		}
		public int GetStoreBasisOnHand (IntransitKeyType aIKT, int aStoreRID)
		{
			int[] aStoreRIDList = {aStoreRID};
			return GetStoreBasisOnHand (aIKT, aStoreRIDList)[0];
		}
		public int[] GetStoreBasisOnHand(IntransitKeyType aIKT, int[] aStoreRIDList)
		{
			// BEGIN MID Change j.ellis Delay subtotal build until request for info.
            if (_buildSubtotal)
            {
                this.BuildSubtotal(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H 
            }
			// END MID Change j.ellis Delay subtotal build until request for info.
			int count = aStoreRIDList.Length;
			int[] onHand = new int[count];
			if (_loadVelocityBasisOnHand)
			{
				_loadVelocityBasisOnHand = false;
				int storeCount = this._allStoreList.Count;
				this._velocityBasisOnHand = new int[storeCount];
				this._velocityBasisOnHand.Initialize();
				ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
				double intermediateValue;
				Hashtable basisNode = new Hashtable(); // MID Track 2927 Basis Onhand and Intransit double in velocity when multiple dates selected
				foreach (BasisProfile bp in bpl)
				{
					foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
					{
						// BEGIN MID Track 2927 Basis Onhand and Intransit double in velocity when multiple dates selected
						if (basisNode.Contains(bdp.HierarchyNodeProfile.Key))
						{
							// Hierarchy node already reflected in onhand
						}
						else
						{
							basisNode.Add(bdp.HierarchyNodeProfile.Key, bdp.HierarchyNodeProfile.Key);
							// END MID Track 2927 Basis Onhand and Intransit double in velocity when multiple dates selected
							for (int i=0; i<storeCount; i++)
							{
								intermediateValue = 
									(double)this.Transaction.GetStoreOnHand(bdp.HierarchyNodeProfile.Key, BeginDay, aIKT, ((StoreProfile)_allStoreList.ArrayList[i]).Key) 
									* bdp.Weight;
								if (intermediateValue < 0)
								{
									_velocityBasisOnHand[i] += (int)(intermediateValue - .5d);
								}
								else
								{
									_velocityBasisOnHand[i] += (int)(intermediateValue + .5d);
								}
							}
						} // MID Track 2927 Basis Onhand and Intransit double in velocity when multiple dates selected
					}
				}
			}
			Index_RID storeIdxRID;
			for (int i=0; i<count; i++)
			{
				storeIdxRID = StoreIndex(aStoreRIDList[i]);
				onHand[i] = _velocityBasisOnHand[storeIdxRID.Index];
			}
			return onHand;
		}
		public int GetStoreListBasisOnHand (int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			int onHand = 0;
			ProfileList storeList = this.Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID); //MID Track 5820 - Unhandled Exception After Store Activation
			int count = storeList.Count;
			int[] storeRIDList = new int[count];
			for (int i=0; i < count; i++)
			{
				storeRIDList[i] = ((StoreProfile)storeList.ArrayList[i]).Key;
			}
			int[] storeOnHand = this.GetStoreBasisOnHand(
				new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize),
				storeRIDList);
			for (int i=0; i<count; i++)
			{
				if (this.StoreIsVisible(storeRIDList[i]))
				{
					onHand += storeOnHand[i];
				}
			}
			return onHand;
		}

        public int GetStoreListBasisOnHand(ProfileList storeList)
        {
            int onHand = 0;
            int count = storeList.Count;
            int[] storeRIDList = new int[count];
            for (int i = 0; i < count; i++)
            {
                storeRIDList[i] = ((StoreProfile)storeList.ArrayList[i]).Key;
            }
            int[] storeOnHand = this.GetStoreBasisOnHand(
                new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize),
                storeRIDList);
            for (int i = 0; i < count; i++)
            {
                if (this.StoreIsVisible(storeRIDList[i]))
                {
                    onHand += storeOnHand[i];
                }
            }
            return onHand;
        }

		#endregion GetStoreBasisOnHand

        // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 34
        #region Get Store Basis IMO History
        public int GetStoreBasisImoHistory(int aStoreRID)
        {
            IntransitKeyType ikt = new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize);
            return GetStoreBasisImoHistory(ikt, aStoreRID);
        }
        public int GetStoreBasisImoHistory(IntransitKeyType aIKT, int aStoreRID)
        {
            int[] aStoreRIDList = { aStoreRID };
            return GetStoreBasisImoHistory(aIKT, aStoreRIDList)[0];
        }
        public int[] GetStoreBasisImoHistory(IntransitKeyType aIKT, int[] aStoreRIDList)
        {
            if (_buildSubtotal)
            {
                this.BuildSubtotal();
            }
            int count = aStoreRIDList.Length;
            int[] onHand = new int[count];
            if (_loadVelocityBasisImoHistory)
            {
                _loadVelocityBasisImoHistory = false;
                int storeCount = this._allStoreList.Count;
                this._velocityBasisImoHistory = new int[storeCount];
                this._velocityBasisImoHistory.Initialize();
                ProfileList bpl = (ProfileList)this.Transaction.GetAllocationBasisCubeGroup().OpenParms.BasisProfileList;
                double intermediateValue;
                Hashtable basisNode = new Hashtable(); 
                foreach (BasisProfile bp in bpl)
                {
                    foreach (BasisDetailProfile bdp in bp.BasisDetailProfileList)
                    {
                        if (basisNode.Contains(bdp.HierarchyNodeProfile.Key))
                        {
                            // Hierarchy node already reflected in onhand
                        }
                        else
                        {
                            basisNode.Add(bdp.HierarchyNodeProfile.Key, bdp.HierarchyNodeProfile.Key);
                            for (int i = 0; i < storeCount; i++)
                            {
                                intermediateValue =
                                    (double)this.Transaction.GetStoreImoHistory(bdp.HierarchyNodeProfile.Key, BeginDay, aIKT, ((StoreProfile)_allStoreList.ArrayList[i]).Key)
                                    * bdp.Weight;
                                if (intermediateValue < 0)
                                {
                                    //BEGIN TT#4262-VStuart-Velocity-VSW On Hand at the plan level is used when calculating ship up to, wos and fwos-MID
                                    //_velocityBasisOnHand[i] += (int)(intermediateValue - .5d);
                                    _velocityBasisImoHistory[i] += (int)(intermediateValue - .5d);
                                }
                                else
                                {
                                    //_velocityBasisOnHand[i] += (int)(intermediateValue + .5d);
                                    _velocityBasisImoHistory[i] += (int)(intermediateValue + .5d);
                                    //END TT#4262-VStuart-Velocity-VSW On Hand at the plan level is used when calculating ship up to, wos and fwos-MID
                                }
                            }
                        } 
                    }
                }
            }
            Index_RID storeIdxRID;
            for (int i = 0; i < count; i++)
            {
                storeIdxRID = StoreIndex(aStoreRIDList[i]);
                onHand[i] = _velocityBasisImoHistory[storeIdxRID.Index];
            }
            return onHand;
        }
        public int GetStoreListBasisImoHistory(int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            int imoHistory = 0;
            ProfileList storeList = this.Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID); //MID Track 5820 - Unhandled Exception After Store Activation
            int count = storeList.Count;
            int[] storeRIDList = new int[count];
            for (int i = 0; i < count; i++)
            {
                storeRIDList[i] = ((StoreProfile)storeList.ArrayList[i]).Key;
            }
            int[] storeImoHistory = this.GetStoreBasisImoHistory(
                new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize),
                storeRIDList);
            for (int i = 0; i < count; i++)
            {
                if (this.StoreIsVisible(storeRIDList[i]))
                {
                    imoHistory += storeImoHistory[i];
                }
            }
            return imoHistory;
        }

        public int GetStoreListBasisImoHistory(ProfileList storeList)
        {
            int onHand = 0;
            int count = storeList.Count;
            int[] storeRIDList = new int[count];
            for (int i = 0; i < count; i++)
            {
                storeRIDList[i] = ((StoreProfile)storeList.ArrayList[i]).Key;
            }
            int[] storeOnHand = this.GetStoreBasisOnHand(
                new IntransitKeyType(Include.IntransitKeyTypeNoColor, Include.IntransitKeyTypeNoSize),
                storeRIDList);
            for (int i = 0; i < count; i++)
            {
                if (this.StoreIsVisible(storeRIDList[i]))
                {
                    onHand += storeOnHand[i];
                }
            }
            return onHand;
        }

        #endregion Get Store Basis IMO History
        // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 34

		// BEGIN MID Track # 1511 Highlight Stores that are out of balance
		#region StoreAllocationOutOfBalance
		/// <summary>
		/// Gets a bool value to indicate whether a store's allocation is out of balance with its components
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile whose balance condition is to be tested.  NOTE: when null, all allocation profiles in the subtotal are tested</param>
		/// <param name="aComponent">Component where the out of balance condition is to be tested</param>
		/// <param name="aStoreRID">The RID of the store whose balance condition is to be tested</param>
		/// <returns>TRUE:  store's allocation is "in balance"; FALSE: store's allocation is "out of balance"</returns>
		public bool IsStoreAllocationOutOfBalance (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreRID)
		{
			Index_RID storeIdxRID = this.StoreIndex(aStoreRID);
			if (aAllocationProfile != null)
			{
				return aAllocationProfile.IsStoreAllocationOutOfBalance (aComponent, storeIdxRID);
			}
			bool isStoreAllocationOutOfBalance = false;
            // BEGIN MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			switch (aComponent.ComponentType)
			{
				case(eComponentType.Total):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.IsStoreAllocationOutOfBalance(aComponent, storeIdxRID))
						{
							isStoreAllocationOutOfBalance = true;
							break;
						}
					}
					break;
				}
				case(eComponentType.DetailType):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.NonGenericPackCount > 0
							|| (ap.BulkIsDetail && ap.BulkColors.Count > 0))
						{
							if (ap.IsStoreAllocationOutOfBalance(aComponent, storeIdxRID))
							{
								isStoreAllocationOutOfBalance = true;
								break;
							}
						}
					}
					break;
				}
				case(eComponentType.Bulk):
				{
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.BulkColors.Count > 0)
						{
							if (ap.IsStoreAllocationOutOfBalance(aComponent, storeIdxRID))
							{
								isStoreAllocationOutOfBalance = true;
								break;
							}
						}
					}
					break;
				}
				case(eComponentType.SpecificColor):
				{
					int colorRID = ((AllocationColorOrSizeComponent)aComponent).ColorRID;
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.BulkColorIsOnHeader(colorRID))
						{
							if (ap.IsStoreAllocationOutOfBalance(aComponent, storeIdxRID))
							{
								isStoreAllocationOutOfBalance = true;
								break;
							}
						}
					}
					break;
 				}
                // END MID Track #2412
    		}

			return isStoreAllocationOutOfBalance;
		}
		#endregion StoreAllocationOutOfBalance
		// END MID Track # 1511

		// BEGIN MID Track # 2937 Size OnHand Incorrect
		#region StoreSizeCurvePct
		public double GetStoreSizeCurvePct(AllocationProfile aAllocationProfile, int aStoreRID, GeneralComponent aComponent)
		{
			if (aAllocationProfile == null)
			{
				return 0.0d;
			}
			return aAllocationProfile.GetStoreSizeCurvePct(aStoreRID, aComponent);
		}
		public double GetStoreSizeCurvePct(AllocationProfile aAllocationProfile, Index_RID aStore, HdrColorBin aColor, int aSizeRID)
		{
			return GetStoreSizeCurvePct(aAllocationProfile, aStore.RID, aColor.ColorCodeRID, aSizeRID);
		}
		public double GetStoreSizeCurvePct(AllocationProfile aAllocationProfile, Index_RID aStore, int aColorRID, int aSizeRID)
		{
			return GetStoreSizeCurvePct(aAllocationProfile, aStore.RID, aColorRID, aSizeRID);
		}
		public double GetStoreSizeCurvePct(AllocationProfile aAllocationProfile, int aStoreRID, int aColorRID, int aSizeRID)
		{
			if (aAllocationProfile == null)
			{
				return 0.0d;
			}
			return aAllocationProfile.GetStoreSizeCurvePct(aStoreRID, aColorRID, aSizeRID);
		}
		#endregion StoreSizeCurvePct

		#region StoreSizeOnHand
		public int GetStoreSizeOnHand(AllocationProfile aAllocationProfile, int aStoreRID, GeneralComponent aComponent, bool curveAdjusted) // MID Track 3209 Show actual OH and IT on Size Review
		{
			if (aAllocationProfile == null)
			{
				int sizeOnHand = 0;
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					sizeOnHand += ap.GetStoreSizeOnHand(aStoreRID, aComponent, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
				}
				return sizeOnHand;
			}

			return aAllocationProfile.GetStoreSizeOnHand(aStoreRID, aComponent, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
		}
        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
        //public double GetStoreSizeOnHand(AllocationProfile aAllocationProfile, Index_RID aStore, HdrColorBin aColor, int aSizeRID, bool curveAdjusted) // MID Track 3209 Show actual OH and IT on Size Review
        //{
        //    return GetStoreSizeOnHand(aAllocationProfile, aStore.RID, aColor.ColorCodeRID, aSizeRID, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
        //}
        
        //public double GetStoreSizeOnHand(AllocationProfile aAllocationProfile, Index_RID aStore, int aColorRID, int aSizeRID, bool curveAdjusted) // MID Track 3209 Show actual OH and IT on Size Review
        //{
        //    return GetStoreSizeOnHand(aAllocationProfile, aStore.RID, aColorRID, aSizeRID, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		public double GetStoreSizeOnHand(AllocationProfile aAllocationProfile, int aStoreRID, int aColorRID, int aSizeRID, bool curveAdjusted)  // MID Track 3209 Show actual OH and IT on Size Review
		{
			if (aAllocationProfile == null)
			{
				AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
				AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
				return GetStoreSizeOnHand(aAllocationProfile, aStoreRID, new AllocationColorSizeComponent(colorComponent, sizeComponent), curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
			}
			return aAllocationProfile.GetStoreSizeOnHand(aStoreRID, aColorRID, aSizeRID, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
		}
		#endregion StoreSizeOnHand

		#region StoreSizeInTransit
		public int GetStoreSizeInTransit(AllocationProfile aAllocationProfile, int aStoreRID, GeneralComponent aComponent, bool curveAdjusted)
		{
			if (aAllocationProfile == null)
			{
				int sizeIntransit = 0;
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					sizeIntransit += ap.GetStoreSizeInTransit(aStoreRID, aComponent, curveAdjusted);  // MID Track 3209 Show actual OH and IT in Size Review
				}
				return sizeIntransit;
			}
			return aAllocationProfile.GetStoreSizeInTransit(aStoreRID, aComponent, curveAdjusted);  // MID Track 3209 Show actual OH and IT in Size Review
		}
        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
        //public double GetStoreSizeInTransit(AllocationProfile aAllocationProfile, Index_RID aStore, HdrColorBin aColor, int aSizeRID, bool curveAdjusted) // MID Track 3209 Show actual OH and IT in Size Review  
        //{
        //    return GetStoreSizeInTransit(aAllocationProfile, aStore.RID, aColor.ColorCodeRID, aSizeRID, curveAdjusted); // MID Track 3209 Show actual OH and IT in Size Review 
        //}
        
        //public double GetStoreSizeInTransit(AllocationProfile aAllocationProfile, Index_RID aStore, int aColorRID, int aSizeRID, bool curveAdjusted) // MID Track 3209 Show actual OH and IT in Size Review
        //{
        //    return GetStoreSizeInTransit(aAllocationProfile, aStore.RID, aColorRID, aSizeRID, curveAdjusted);  // MID Track 3209 Show actual OH and IT in Size Review
        //}
        
        //public double GetStoreSizeInTransit(AllocationProfile aAllocationProfile, int aStoreRID, int aColorRID, int aSizeRID, bool curveAdjusted)  // MID Track 3209 Show actual OH and IT in Size Review 
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
        //        AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
        //        return GetStoreSizeInTransit(aAllocationProfile, aStoreRID, new AllocationColorSizeComponent(colorComponent, sizeComponent), curveAdjusted); // MID Track 3209 Show actual OH and IT in Size Review
        //    }
        //    return aAllocationProfile.GetStoreSizeInTransit(aStoreRID, aColorRID, aSizeRID, curveAdjusted);  // MID Track 3209 Show actual OH and IT in Size Review
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreSizeInTransit

		#region StoreSizePlan
        /// <summary>
        /// Gets the store's size plan
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Header; when null gets plan across all headers</param>
        /// <param name="aStoreRID">RID of the store</param>
        /// <param name="aComponent">Color Size Component</param>
        /// <param name="aReturnFillPlan">True: Gets plans used in Fill Size Holes; False: Gets plans used in Size Need</param>
		/// <param name="aUseBasisPlan">True: Fill Size Plan Based on Basis Plan; False: Fill Size Plan Based on Ownership</param>		
		/// <returns>Store Size Plan</returns>
		public int GetStoreSizePlan(AllocationProfile aAllocationProfile, int aStoreRID, GeneralComponent aComponent, bool aReturnFillPlan, bool aUseBasisPlan) // MID Track 4291 Add Fill Variables to Size Review // MID track 4921 AnF#666 Fill to Size Plan Enhancement
		{
			if (aAllocationProfile == null)
			{
				int sizePlan = 0;
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					sizePlan += ap.GetStoreSizePlan(aStoreRID, aComponent, aReturnFillPlan, aUseBasisPlan);  // MID Track 4291 Add Fill Variables to Size Review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement 
				}
				return sizePlan;
			}
			return aAllocationProfile.GetStoreSizePlan(aStoreRID, aComponent, aReturnFillPlan, aUseBasisPlan); // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function - and infinite loop
		/// <summary>
		/// Gets the store's size plan
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Header; when null gets plan across all headers</param>
		/// <param name="aStore">Index_RID of the store</param>
		/// <param name="aColor">HdrColorBin describing the color</param>
		/// <param name="aSizeRID">RID of teh size</param>
		/// <param name="aReturnFillPlan">True: Gets plans used in Fill Size Holes; False: Gets plans used in Size Need</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store's size plan</returns>
        //public double GetStoreSizePlan(AllocationProfile aAllocationProfile, Index_RID aStore, HdrColorBin aColor, int aSizeRID, bool aReturnFillPlan, bool aUseBasisPlan) // MID Track 4291 Add Fill Variables to Size Review // MID Track 4921 Fill to Size Plan Enhancement
        //{
        //    return GetStoreSizePlan(aAllocationProfile, aStore.RID, aColor.ColorCodeRID, aSizeRID, aReturnFillPlan, aUseBasisPlan); // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function - and infinite loop

        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Gets the store's size plan
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Header; when null gets plan across all headers</param>
		/// <param name="aStore">Index_RID of the store</param>
		/// <param name="aColorRID">RID of the color</param>
		/// <param name="aSizeRID">RID of the size</param>
		/// <param name="aReturnFillPlan">True: Gets plans used in Fill Size Holes; False: Gets plans used in Size Need</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store's size plan</returns>
        //public double GetStoreSizePlan(AllocationProfile aAllocationProfile, Index_RID aStore, int aColorRID, int aSizeRID, bool aReturnFillPlan, bool aUseBasisPlan) // MID track 4291 Add Fill Variables to Size Review  // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    return GetStoreSizePlan(aAllocationProfile, aStore.RID, aColorRID, aSizeRID, aReturnFillPlan, aUseBasisPlan); // MID track 4291 Add Fill Variables to Size Review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Gets the store's size plan
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Header; when null gets plan across all headers</param>
		/// <param name="aStoreRID">ndex_RID of the store</param>
		/// <param name="aColorRID">RID of the color</param>
		/// <param name="aSizeRID">RID of the size</param>
		/// <param name="aReturnFillPlan">True: Gets plans used in Fill Size Holes; False: Gets plans used in Size Need</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store's size plan</returns>
        //public double GetStoreSizePlan(AllocationProfile aAllocationProfile, int aStoreRID, int aColorRID, int aSizeRID, bool aReturnFillPlan, bool aUseBasisPlan) // MID Track 4291 Add Fill Variables to Size Review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
        //        AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
        //        return GetStoreSizePlan(aAllocationProfile, aStoreRID, new AllocationColorSizeComponent(colorComponent, sizeComponent), aReturnFillPlan, aUseBasisPlan); // MID Track 4291 Add Fill Variables to Size Review  // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //    }
        //    return aAllocationProfile.GetStoreSizePlan(aStoreRID, aColorRID, aSizeRID, aReturnFillPlan, aUseBasisPlan); // MID Track 4291 Add Fill Variables to Size Review  // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreSizePlan

		#region StoreSizeNeed
		/// <summary>
		/// Get Store Size Need
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", return store total size need across all headers in subtotal</param>
		/// <param name="aStoreRID">RID that identifies the store</param>
		/// <param name="aComponent">Component that identifies the color and size</param>
		/// <param name="aReturnFillSizeNeed">True: Return the size need used by fill size holes (plan calculation does not include units allocated); False: Return the size need used in "size need allocation" (plan calculation does include the units allocated)</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store Size Need</returns>
		public int GetStoreSizeNeed(AllocationProfile aAllocationProfile, int aStoreRID, GeneralComponent aComponent, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID track 4291 add fill variables to size review // MID Track 4921 Fill to Size Plan Enhancement
		{
			if (aAllocationProfile == null)
			{
				return (int)Need.UnitNeed(
					this.GetStoreSizePlan(aAllocationProfile, aStoreRID, aComponent, aReturnFillSizeNeed, aUseBasisPlan),  // MID Track 4291 add fill variables to size review  // MID track 4921 AnF#666 Fill to Size Plan Enhancement
					this.GetStoreSizeOnHand(aAllocationProfile, aStoreRID, aComponent, true)  // TT#1055 - MD - JEllis - Size Need on Size Review does not Include effect of VSW Onhand
                    + this.GetStoreImoHistory(aAllocationProfile, aComponent, aStoreRID),     // TT#1055 - MD - JEllis - Size Need on Size Review does not Include effect of VSW Onhand
					this.GetStoreSizeInTransit(aAllocationProfile, aStoreRID, aComponent, true),
					this.GetStoreQtyAllocated(aAllocationProfile, aComponent, aStoreRID));
			}
			return aAllocationProfile.GetStoreSizeNeed(aStoreRID, aComponent, aReturnFillSizeNeed, aUseBasisPlan); // MID track 4291 add fill variables to size review // MID Track 4921 Fill to Size Plan Enhancement
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get Store Size Need
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", return store total size need across all headers in subtotal</param>
		/// <param name="aStore">Index_RID that identifies the store</param>
		/// <param name="aColor">HdrColorBin that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizeNeed">True: Return the size need used by fill size holes (plan calculation does not include units allocated); False: Return the size need used in "size need allocation" (plan calculation does include the units allocated)</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store Size Need</returns>
        //public int GetStoreSizeNeed(AllocationProfile aAllocationProfile, Index_RID aStore, HdrColorBin aColor, int aSizeRID, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    return GetStoreSizeNeed(aAllocationProfile, aStore.RID, aColor.ColorCodeRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan); // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get Store Size Need
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", return store total size need across all headers in subtotal</param>
		/// <param name="aStore">Index_RID that identifies the store</param>
		/// <param name="aColorRID">Color Code RID that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizeNeed">True: Return the size need used by fill size holes (plan calculation does not include units allocated); False: Return the size need used in "size need allocation" (plan calculation does include the units allocated)</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store Size Need</returns>
        //public int GetStoreSizeNeed(AllocationProfile aAllocationProfile, Index_RID aStore, int aColorRID, int aSizeRID, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    return GetStoreSizeNeed(aAllocationProfile, aStore.RID, aColorRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan); // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get Store Size Need
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", return store total size need across all headers in subtotal</param>
		/// <param name="aStoreRID">RID that identifies the store</param>
		/// <param name="aColorRID">Color Code RID that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizeNeed">True: Return the size need used by fill size holes (plan calculation does not include units allocated); False: Return the size need used in "size need allocation" (plan calculation does include the units allocated)</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store Size Need</returns>
        //public int GetStoreSizeNeed(AllocationProfile aAllocationProfile, int aStoreRID, int aColorRID, int aSizeRID, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID track 4291 add fill variables to size review // MID track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
        //        AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
        //        return GetStoreSizeNeed(aAllocationProfile, aStoreRID, new AllocationColorSizeComponent(colorComponent, sizeComponent), aReturnFillSizeNeed, aUseBasisPlan); // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //    }
        //    return aAllocationProfile.GetStoreSizeNeed(aStoreRID, aColorRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan); // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreSizeNeed

		#region StoreSizePctNeed
		/// <summary>
		/// Get Store Size Percent Need
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", the store size percent need returned is the total store size percent need across all headers in subtotal.</param>
		/// <param name="aStoreRID">RID that identifies the store</param>
		/// <param name="aComponent">Component that identifies the color and size</param>
		/// <param name="aReturnFillSizeNeed">True: Return Size Percent Need used in Fill Size Holes (Plan calculations does not include units allocated); False: Return Size Percent Need used in "size need allocatin" (Plan Calculation includes the units allocated)</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store Size Percent Need</returns>
		public double GetStoreSizePctNeed(AllocationProfile aAllocationProfile, int aStoreRID, GeneralComponent aComponent, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
		{
			if (aAllocationProfile == null)
			{
				return (double)(((long)(Need.PctUnitNeed(this.GetStoreSizeNeed(null, aStoreRID, aComponent, aReturnFillSizeNeed, aUseBasisPlan), this.GetStoreSizePlan(null, aStoreRID, aComponent, aReturnFillSizeNeed, aUseBasisPlan)) // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
					* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision + .5d))
					/ (double)this.Transaction.StoreSizePctToTotalDecimalPrecision);
			}
			return aAllocationProfile.GetStoreSizePctNeed(aStoreRID, aComponent, aReturnFillSizeNeed, aUseBasisPlan); // MID Track 4291 add fill variables to size review // MID track 4921 AnF#666 Fill to Size Plan ENhancment
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get Store Size Percent Need
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", the store size percent need returned is the total store size percent need across all headers in subtotal.</param>
		/// <param name="aStore">Index_RID that identifies the store</param>
		/// <param name="aColor">HdrColorBin that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizeNeed">True: Return Size Percent Need used in Fill Size Holes (Plan calculations does not include units allocated); False: Return Size Percent Need used in "size need allocatin" (Plan Calculation includes the units allocated)</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store Size Percent Need</returns>
        //public double GetStoreSizePctNeed(AllocationProfile aAllocationProfile, Index_RID aStore, HdrColorBin aColor, int aSizeRID, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 FIll to Size Plan Enhancement
        //{
        //    return GetStoreSizePctNeed(aAllocationProfile, aStore.RID, aColor.ColorCodeRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan); // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 FIll to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get Store Size Percent Need
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", the store size percent need returned is the total store size percent need across all headers in subtotal.</param>
		/// <param name="aStore">Index_RID that identifies the store</param>
		/// <param name="aColorRID">Color Code RID that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizeNeed">True: Return Size Percent Need used in Fill Size Holes (Plan calculations does not include units allocated); False: Return Size Percent Need used in "size need allocatin" (Plan Calculation includes the units allocated)</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store Size Percent Need</returns>
        //public double GetStoreSizePctNeed(AllocationProfile aAllocationProfile, Index_RID aStore, int aColorRID, int aSizeRID, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID track 4291 add fill variables to size review // MID Track 4921 Fill to Size Plan Enhancement
        //{
        //    return GetStoreSizePctNeed(aAllocationProfile, aStore.RID, aColorRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan); // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get Store Size Percent Need
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", the store size percent need returned is the total store size percent need across all headers in subtotal.</param>
		/// <param name="aStoreRID">RID that identifies the store</param>
		/// <param name="aColorRID">Color Code RID that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizeNeed">True: Return Size Percent Need used in Fill Size Holes (Plan calculations does not include units allocated); False: Return Size Percent Need used in "size need allocatin" (Plan Calculation includes the units allocated)</param>
		/// <param name="aUseBasisPlan">True: Returns Size Plan Using the basis plan; False: Returns Size Plan Using the basis ownership</param>
		/// <returns>Store Size Percent Need</returns>
        //public double GetStoreSizePctNeed(AllocationProfile aAllocationProfile, int aStoreRID, int aColorRID, int aSizeRID, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        return (double)(((long)(Need.PctUnitNeed(this.GetStoreSizeNeed(null, aStoreRID, aColorRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan), this.GetStoreSizePlan(null, aStoreRID, aColorRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan)) // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //            * (double)this.Transaction.StoreSizePctToTotalDecimalPrecision + .5d))
        //            / (double)this.Transaction.StoreSizePctToTotalDecimalPrecision);
        //    }
        //    return aAllocationProfile.GetStoreSizePctNeed(aStoreRID, aColorRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan); // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreSizePctNeed

		#region StoreSizePosNeed
		public int GetStoreSizePosNeed(AllocationProfile aAllocationProfile, int aStoreRID, GeneralComponent aComponent)
		{
			if (aAllocationProfile == null)
			{
				return Math.Max(0, GetStoreSizeNeed(aAllocationProfile, aStoreRID, aComponent, false, false)); // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
			}
			return aAllocationProfile.GetStoreSizePosNeed(aStoreRID, aComponent);
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
        //public int GetStoreSizePosNeed(AllocationProfile aAllocationProfile, Index_RID aStore, HdrColorBin aColor, int aSizeRID)
        //{
        //    return GetStoreSizePosNeed(aAllocationProfile, aStore.RID, aColor.ColorCodeRID, aSizeRID);
        //}
        
        //public int GetStoreSizePosNeed(AllocationProfile aAllocationProfile, Index_RID aStore, int aColorRID, int aSizeRID)
        //{
        //    return GetStoreSizePosNeed(aAllocationProfile, aStore.RID, aColorRID, aSizeRID);
        //}
        
        //public int GetStoreSizePosNeed(AllocationProfile aAllocationProfile, int aStoreRID, int aColorRID, int aSizeRID)
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
        //        AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
        //        return GetStoreSizePosNeed(aAllocationProfile, aStoreRID, new AllocationColorSizeComponent(colorComponent, sizeComponent));
        //    }			return aAllocationProfile.GetStoreSizePosNeed(aStoreRID, aColorRID, aSizeRID);
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreSizePosNeed

		#region StoreSizePosPctNeed
		public double GetStoreSizePosPctNeed(AllocationProfile aAllocationProfile, int aStoreRID, GeneralComponent aComponent)
		{
			if (aAllocationProfile == null)
			{
				return Math.Max(
					0,
					(double)(((long)(Need.PctUnitNeed(this.GetStoreSizeNeed(null, aStoreRID, aComponent, false, false), this.GetStoreSizePlan(null, aStoreRID, aComponent, false, false)) // MID Track 4291 add fill variables to size review // MID Track 4921 Fill to Size Plan Enhancement
					* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision + .5d))
					/ (double)this.Transaction.StoreSizePctToTotalDecimalPrecision)
					);
			}
			return aAllocationProfile.GetStoreSizePosPctNeed(aStoreRID, aComponent);
		}
        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
        //public double GetStoreSizePosPctNeed(AllocationProfile aAllocationProfile, Index_RID aStore, HdrColorBin aColor, int aSizeRID)
        //{
        //    return GetStoreSizePosPctNeed(aAllocationProfile, aStore.RID, aColor.ColorCodeRID, aSizeRID);
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
        //public double GetStoreSizePosPctNeed(AllocationProfile aAllocationProfile, Index_RID aStore, int aColorRID, int aSizeRID)
        //{
        //    return GetStoreSizePosPctNeed(aAllocationProfile, aStore.RID, aColorRID, aSizeRID);
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
        //public double GetStoreSizePosPctNeed(AllocationProfile aAllocationProfile, int aStoreRID, int aColorRID, int aSizeRID)
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        return Math.Max(
        //            0, 
        //            (double)(((long)(Need.PctUnitNeed(this.GetStoreSizeNeed(null, aStoreRID, aColorRID, aSizeRID, false, false), this.GetStoreSizePlan(null, aStoreRID, aColorRID, aSizeRID, false, false)) // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //            * (double)this.Transaction.StoreSizePctToTotalDecimalPrecision + .5d))
        //            / (double)this.Transaction.StoreSizePctToTotalDecimalPrecision)
        //            );
        //    }
        //    return aAllocationProfile.GetStoreSizePosPctNeed(aStoreRID, aColorRID, aSizeRID);
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreSizePosPctNeed
		// END MID Track # 2937 Size OnHand Incorrect
		#endregion Stores

		#region StoreGrpLvls
		#region StoreListTotalOnHand
		// BEGIN MID Track #2937 size onhand incorrect
		/// <summary>
		/// Gets Store List Total OnHand
		/// </summary>
		/// <param name="aIKT">Array list of Key types for the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
		/// <returns>OnHand for the requested store List.</returns>
		public int GetStoreListTotalOnHand(ArrayList aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalOnHand(null, aIKT, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
		}
		// END MID Track #2937 size onhand incorrect

		/// <summary>
		/// Gets Store List Total OnHand
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile used to calculate future size onhan when required</param>
		/// <param name="aIKT">Array list of Key types for the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
		/// <param name="aVolumeGrade">VolumeGrade</param>
		/// <returns>OnHand for the requested store List.</returns>
		public int GetStoreListTotalOnHand(AllocationProfile aAllocationProfile, ArrayList aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade) // MID Track #2937 Size ONhand incorrect
		{
			int onHand = 0;
			ProfileList storeList = GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
			foreach (IntransitKeyType ikt in aIKT)
			{
				onHand += GetStoreListTotalOnHand(aAllocationProfile, ikt, storeList);
			}
			return onHand;
		}

		/// <summary>
		/// Gets Store List Total OnHand
		/// </summary>
		/// <param name="aIKT">Key type of the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>OnHand for the requested store List.</returns>
		public int GetStoreListTotalOnHand(IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalOnHand(null, aIKT, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade); // MID Track #2937 Size Onhand incorrect
		}

		// BEGIN MID Track #2937 size onhand incorrect
		/// <summary>
		/// Gets Store List Total OnHand
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile to use in calculation of future size onhand when required</param>
		/// <param name="aIKT">Key type of the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>OnHand for the requested store List.</returns>
		public int GetStoreListTotalOnHand(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalOnHand(aAllocationProfile, aIKT, GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}
		// END MID Track #2937 size onhand incorrect

		/// <summary>
		/// Gets Store List Total OnHand
		/// </summary>
		/// <param name="aIKT">Key type of the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
		/// <returns>OnHand for the requested store List.</returns>
		public int GetStoreListTotalOnHand(IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOnHand(null, aIKT, aStoreGrpRID, aStoreGrpLvlRID); // MID Track #2937 Size OnHand Incorrect
		}

		// BEGIN MID Track #2937 Size Onhand incorrect
		/// <summary>
		/// Gets Store List Total OnHand
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile to use when future size onhand is requested.</param>
		/// <param name="aIKT">Key type of the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
		/// <returns>OnHand for the requested store List.</returns>
		public int GetStoreListTotalOnHand(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOnHand(aAllocationProfile, aIKT, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}
		// END MID Track #2937 Size Onhand incorrect

		/// <summary>
		/// Gets Store List Total OnHand
		/// </summary>
		/// <param name="aIKT">Key type of the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreList">Store profile list identifying the stores whose onhand is to be retrieved.</param>
		/// <returns>OnHand for the requested store list.</returns>
		public int GetStoreListTotalOnHand(IntransitKeyType aIKT, ProfileList aStoreList)
		{
			return GetStoreListTotalOnHand(null, aIKT, aStoreList);
		}
		// END MID Track #2937 Size Onhand incorrect

		/// <summary>
		/// Gets Store List Total OnHand
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile to use when future size onhand is requested</param>
		/// <param name="aIKT">Key type of the onhand to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreList">Store profile list identifying the stores whose onhand is to be retrieved.</param>
		/// <returns>OnHand for the requested store list.</returns>
		public int GetStoreListTotalOnHand(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, ProfileList aStoreList) // MID Track #2937 Size Onhand Incorrect
		{
			int onHand = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					onHand += GetStoreOnHand(aAllocationProfile, aIKT, storeIdxRID);
				}
			}
			return onHand;
		}
		#endregion StoreListTotalOnHand

		#region StoreListTotalInTransit
		/// <summary>
		/// Gets Store List Total InTransit
		/// </summary>
		/// <param name="aIKT">Array of Key types for the intransit to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies the store attribute </param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the stores within the attribute whose intransit is to be retrieved</param>
		/// <param name="aVolumeGrade">The volume grade of the stores whose intransit is to be retrieved</param>
		/// <returns>InTransit Total for the requested stores</returns>
		public int GetStoreListTotalInTransit(ArrayList aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			int intransit = 0;
			ProfileList storeList = this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
			foreach (IntransitKeyType ikt in aIKT)
			{
				intransit += GetStoreListTotalInTransit(ikt, storeList);
			}
			return intransit;
		}
		/// <summary>
		/// Gets Store List Total InTransit
		/// </summary>
		/// <param name="aIKT">Key type for the intransit to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies the store attribute </param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the stores within the attribute whose intransit is to be retrieved</param>
		/// <param name="aVolumeGrade">The volume grade of the stores whose intransit is to be retrieved</param>
		/// <returns>InTransit Total for the requested stores</returns>
		public int GetStoreListTotalInTransit(IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalInTransit(aIKT, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}
		/// <summary>
		/// Gets Store List Total InTransit
		/// </summary>
		/// <param name="aIKT">Key type of the intransit to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">RID describing the Store Group (Attribute).</param>
		/// <param name="aStoreGrpLvlRID">RID describing the Store Group Level (Set)</param>
		/// <returns>InTransit Total for the requested store List.</returns>
		public int GetStoreListTotalInTransit(IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalInTransit(aIKT, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets Store List Total InTransit
		/// </summary>
		/// <param name="aIKT">Key type of the InTransit to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreList">Profile List of stores.</param>
		/// <returns>InTransit total for the requested store list.</returns>
		public int GetStoreListTotalInTransit(IntransitKeyType aIKT, ProfileList aStoreList)
		{
			int inTransit = 0;
			foreach (StoreProfile sp in aStoreList)
			{
				if (this.StoreIsVisible(sp.Key)) // MID Track 4303 Size Review Set Total Wrong
				{                                // MID Track 4303 Size Review Set Total Wrong
					inTransit += GetStoreInTransit(aIKT, sp.Key);
				}                                // MID track 4303 Size Review Set Total Wrong
			}
			return inTransit;
		}
		#endregion StoreListTotalInTransit

        // begin TT#1401 - JEllis - Urban Reservation Stores pt 7
        #region StoreListTotalImoHistory
         /// <summary>
        /// Gets Store List Total IMO History
        /// </summary>
        /// <param name="aIKT">Array list of Key types for the IMO History to retrieve: Total, Color or Color-Size</param>
        /// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
        /// <returns>OnHand for the requested store List.</returns>
        public int GetStoreListTotalImoHistory(ArrayList aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
        {
            return GetStoreListTotalImoHistory(null, aIKT, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
        }

        /// <summary>
        /// Gets Store List Total IMO History
        /// </summary>
        /// <param name="aAllocationProfile">AllocationProfile used to identify HnRID and Begin Date</param>
        /// <param name="aIKT">Array list of Key types for the IMO History to retrieve: Total, Color or Color-Size</param>
        /// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
        /// <param name="aVolumeGrade">VolumeGrade</param>
        /// <returns>OnHand for the requested store List.</returns>
        public int GetStoreListTotalImoHistory(AllocationProfile aAllocationProfile, ArrayList aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade) 
        {
            int imoHistory = 0;
            ProfileList storeList = GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
            foreach (IntransitKeyType ikt in aIKT)
            {
                imoHistory += GetStoreListTotalImoHistory(aAllocationProfile, ikt, storeList);
            }
            return imoHistory;
        }

        //BEGIN TT#4409-VSuart--Velocity - Detail Section - VSW On Hand- All Store and Set-MID
        ///// <summary>
        ///// Gets Store List Total IMO History
        ///// </summary>
        ///// <param name="aIKT">Key type of the IMO History to retrieve: Total, Color or Color-Size</param>
        ///// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
        ///// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
        ///// <param name="aVolumeGrade">Volume Grade</param>
        ///// <returns>OnHand for the requested store List.</returns>
        //public int GetStoreListTotalImoHistory(IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
        //{
        //    return GetStoreListTotalImoHistory(null, aIKT, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
        //}
        
        /// <summary>
        /// Gets Store List Total IMO History
        /// </summary>
        /// <param name="aIKT">Key type of the IMO History to retrieve: Total, Color or Color-Size</param>
        /// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
        /// <param name="aVolumeGrade">Volume Grade</param>
        /// <returns>OnHand for the requested store List.</returns>
        public int GetStoreListTotalImoHistory(IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aHN_Rid = Include.NoRID)
        {
            return GetStoreListTotalImoHistory(null, aIKT, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aHN_Rid);
        }

        /// <summary>
        /// Gets Store List Total IMO History
        /// </summary>
        /// <param name="aAllocationProfile">AllocationProfile to use to identify StyleHnRID and Begin Date</param>
        /// <param name="aIKT">Key type of the IMO History to retrieve: Total, Color or Color-Size</param>
        /// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
        /// <param name="aVolumeGrade">Volume Grade</param>
        /// <returns>IMO History for the requested store List.</returns>
        public int GetStoreListTotalImoHistory(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aHN_Rid = Include.NoRID)
        {
            return GetStoreListTotalImoHistory(aAllocationProfile, aIKT, GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aHN_Rid);
        }
        //END TT#4409-VSuart--Velocity - Detail Section - VSW On Hand- All Store and Set-MID

        /// <summary>
        /// Gets Store List Total IMO History
        /// </summary>
        /// <param name="aIKT">Key type of the IMO History to retrieve: Total, Color or Color-Size</param>
        /// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
        /// <returns>OnHand for the requested store List.</returns>
        public int GetStoreListTotalImoHistory(IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalImoHistory(null, aIKT, aStoreGrpRID, aStoreGrpLvlRID); 
        }

        /// <summary>
        /// Gets Store List Total IMO History
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile to use to identify Style HnRID and Begin Date.</param>
        /// <param name="aIKT">Key type of the IMO History to retrieve: Total, Color or Color-Size</param>
        /// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
        /// <returns>OnHand for the requested store List.</returns>
        public int GetStoreListTotalImoHistory(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalImoHistory(aAllocationProfile, aIKT, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); 
        }

        /// <summary>
        /// Gets Store List Total IMO History
        /// </summary>
        /// <param name="aIKT">Key type of the IMO History to retrieve: Total, Color or Color-Size</param>
        /// <param name="aStoreList">Store profile list identifying the stores whose IMO History is to be retrieved.</param>
        /// <returns>IMO History for the requested store list.</returns>
        public int GetStoreListTotalImoHistory(IntransitKeyType aIKT, ProfileList aStoreList)
        {
            return GetStoreListTotalImoHistory(null, aIKT, aStoreList);
        }

        //BEGIN TT#4409-VSuart--Velocity - Detail Section - VSW On Hand- All Store and Set-MID
        ///// <summary>
        ///// Gets Store List Total IMO History
        ///// </summary>
        ///// <param name="aAllocationProfile">Allocation Profile to use to Identify Style HnRID and Begin Date</param>
        ///// <param name="aIKT">Key type of the IMO history to retrieve: Total, Color or Color-Size</param>
        ///// <param name="aStoreList">Store profile list identifying the stores whose onhand is to be retrieved.</param>
        ///// <returns>IMO History for the requested store list.</returns>
        //public int GetStoreListTotalImoHistory(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, ProfileList aStoreList)
        //{
        //    int imoHistory = 0;
        //    Index_RID storeIdxRID;
        //    foreach (StoreProfile sp in aStoreList)
        //    {
        //        storeIdxRID = StoreIndex(sp.Key);
        //        if (this.StoreIsVisible(storeIdxRID))
        //        {
        //            imoHistory += GetStoreImoHistory(aAllocationProfile, aIKT, storeIdxRID.RID);
        //        }
        //    }
        //    return imoHistory;
        //}

        /// <summary>
        /// Gets Store List Total IMO History
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile to use to Identify Style HnRID and Begin Date</param>
        /// <param name="aIKT">Key type of the IMO history to retrieve: Total, Color or Color-Size</param>
        /// <param name="aStoreList">Store profile list identifying the stores whose onhand is to be retrieved.</param>
        /// <returns>IMO History for the requested store list.</returns>
        public int GetStoreListTotalImoHistory(AllocationProfile aAllocationProfile, IntransitKeyType aIKT, ProfileList aStoreList, int aHN_Rid = Include.NoRID)
        {
            int imoHistory = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    imoHistory += GetStoreImoHistory(aAllocationProfile, aIKT, storeIdxRID.RID, aHN_Rid);
                }
            }
            return imoHistory;
        }
        //END TT#4409-VSuart--Velocity - Detail Section - VSW On Hand- All Store and Set-MID

        //  replaced by StoreListTotalImoHistory
		// BEGIN TT#1401 - stodd - add resevation stores (IMO)
        //#region StoreListTotalIMO
        ///// <summary>
        ///// Gets Store List Total IMO 
        ///// </summary>
        ///// <param name="aIKT">Array of Key types for the IMO to retrieve: Total, Color or Color-Size</param>
        ///// <param name="aStoreGrpRID">Store Group RID that identifies the store attribute </param>
        ///// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the stores within the attribute whose IMO is to be retrieved</param>
        ///// <param name="aVolumeGrade">The volume grade of the stores whose IMO is to be retrieved</param>
        ///// <returns>IMO Total for the requested stores</returns>
        //public int GetStoreListTotalIMO(ArrayList aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
        //{
        //    int IMO = 0;
        //    ProfileList storeList = this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
        //    foreach (IntransitKeyType ikt in aIKT)
        //    {
        //        IMO += GetStoreListTotalIMO(ikt, storeList);
        //    }
        //    return IMO;
        //}
        ///// <summary>
        ///// Gets Store List Total IMO 
        ///// </summary>
        ///// <param name="aIKT">Key type for the IMO to retrieve: Total, Color or Color-Size</param>
        ///// <param name="aStoreGrpRID">Store Group RID that identifies the store attribute </param>
        ///// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the stores within the attribute whose IMO is to be retrieved</param>
        ///// <param name="aVolumeGrade">The volume grade of the stores whose IMO is to be retrieved</param>
        ///// <returns>IMO Total for the requested stores</returns>
        //public int GetStoreListTotalIMO(IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
        //{
        //    return GetStoreListTotalIMO(aIKT, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
        //}
        ///// <summary>
        ///// Gets Store List Total IMO 
        ///// </summary>
        ///// <param name="aIKT">Key type of the IMO to retrieve: Total, Color or Color-Size</param>
        ///// <param name="aStoreGrpRID">RID describing the Store Group (Attribute).</param>
        ///// <param name="aStoreGrpLvlRID">RID describing the Store Group Level (Set)</param>
        ///// <returns>IMO Total for the requested store List.</returns>
        //public int GetStoreListTotalIMO(IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID)
        //{
        //    return GetStoreListTotalIMO(aIKT, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); 
        //}

        ///// <summary>
        ///// Gets Store List Total IMO 
        ///// </summary>
        ///// <param name="aIKT">Key type of the IMO to retrieve: Total, Color or Color-Size</param>
        ///// <param name="aStoreList">Profile List of stores.</param>
        ///// <returns>IMO total for the requested store list.</returns>
        //public int GetStoreListTotalIMO(IntransitKeyType aIKT, ProfileList aStoreList)
        //{
        //    int IMO = 0;
        //    foreach (StoreProfile sp in aStoreList)
        //    {
        //        if (this.StoreIsVisible(sp.Key)) 
        //        {
        //            IMO += GetStoreListTotalIMO(aIKT, sp.Key);
        //        }                                
        //    }
        //    return IMO;
        //}
        //#endregion StoreListTotalIMO
        //// END TT#1401 - stodd - add resevation stores (IMO)
        #endregion StoreListTotalImoHistory
        // end TT#1401 - JEllis - Urban Reservation Store pt 7

        #region StoreListTotalSalesPlan
        /// <summary>
		/// Gets Store List Total Sales Plan
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
		/// <param name="aVolumeGrade">Filters the store list by volume grade.</param>
		/// <returns>Sales Plan Total for the requested store List.</returns>
		public int GetStoreListTotalSalesPlan(int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalSalesPlan(GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		/// <summary>
		/// Gets Store List Total Sales Plan
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
		/// <returns>Sales Plan Total for the requested store List.</returns>
		public int GetStoreListTotalSalesPlan(int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalSalesPlan(Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets Store List Sales Plan
		/// </summary>
		/// <param name="aStoreList">List of stores whose sales plan is to be retrieved.</param>
		/// <returns>Sales Plan total for the requested store list.</returns>
		public int GetStoreListTotalSalesPlan(ProfileList aStoreList)
		{
			int plan = 0;
			//			Index_RID storeIdxRID;
			//			foreach (StoreProfile sp in aStoreList)
			//			{
			//				storeIdxRID = StoreIndex(sp.Key);
			//				foreach (Index_RID storeIdxRID in this.Transaction.StoreIndexRIDArray)
			//				{
			//					if (this.StoreIsVisible (storeIdxRID))
			//					{
			//						plan += GetStoreSalesPlan(storeIdxRID.RID);
			//					}
			//				}
			//				return plan;
			//			}
			foreach (Index_RID storeIdxRID in this.Transaction.StoreIndexRIDArray())
			{
				if (aStoreList.Contains(storeIdxRID.RID)
					&& this.StoreIsVisible (storeIdxRID))
				{
					plan += GetStoreSalesPlan(storeIdxRID.RID);
				}
			}
			return plan;
		}
		#endregion StoreListTotalSalesPlan

		#region StoreListTotalStockPlan
		/// <summary>
		/// Gets Store List Total Stock Plan
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
		/// <param name="aVolumeGrade">Volume Grade of the stores whose stock plan is retrieved.</param>
		/// <returns>Stock Plan Total for the requested store List.</returns>
		public int GetStoreListTotalStockPlan(int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalStockPlan(this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		/// <summary>
		/// Gets Store List Total Stock Plan
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
		/// <returns>Stock Plan Total for the requested store List.</returns>
		public int GetStoreListTotalStockPlan(int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalStockPlan(Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets Store List Stock Plan
		/// </summary>
		/// <param name="aStoreList">List of stores whose stock plan is to be retrieved</param>
		/// <returns>Stock Plan total for the requested store list.</returns>
		public int GetStoreListTotalStockPlan(ProfileList aStoreList)
		{
			int plan = 0;
//			Index_RID storeIdxRID;
//			foreach (StoreProfile sp in aStoreList)
//			{
//				storeIdxRID = StoreIndex(sp.Key);
//				if (this.StoreIsVisible (storeIdxRID))
//				{
//					plan += GetStoreStockPlan(storeIdxRID.RID);
//				}
//			}
//			return plan;
			foreach (Index_RID storeIdxRID in this.Transaction.StoreIndexRIDArray())
			{
				if (aStoreList.Contains(storeIdxRID.RID)
					&& this.StoreIsVisible (storeIdxRID))
				{
					plan += GetStoreStockPlan(storeIdxRID.RID);
				}
			}
			return plan;
		}
		#endregion StoreListTotalStockPlan

		#region StoreListTotalFillSizePlan
		/// <summary>
		/// Gets the Fill Size Plan for a given group of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aColorComponent">Color Component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
		/// <param name="aVolumeGrade">Filters the store list by volume grade.</param>
		/// <param name="aReturnSales">True: Store sales basis plan returned; False: Store Stock basis plan returned</param>
		/// <returns></returns>
		public int GetStoreListTotalFillSizeBasisPlan(
			AllocationProfile aAllocationProfile, 
			GeneralComponent aColorComponent, 
			int aStoreGrpRID, 
			int aStoreGrpLvlRID, 
			string aVolumeGrade, 
			bool aReturnSales)
		{
			return GetStoreListTotalFillSizeBasisPlan(
				aAllocationProfile,
				aColorComponent,
				GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade),
				aReturnSales);
		}
		/// <summary>
		/// Gets the Fill Size Plan for a given group of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aColorComponent">Color Component</param>
		/// <param name="aStoreList">List of stores whose sales plan is to be retrieved.</param>
		/// <param name="aReturnSales">True: Store sales basis plan returned; False: Store Stock basis plan returned</param>
		/// <returns></returns>
		public int GetStoreListTotalFillSizeBasisPlan(
			AllocationProfile aAllocationProfile, 
			GeneralComponent aColorComponent, 
			ProfileList aStoreList,
			bool aReturnSales)
		{
			int fillSizePlan = 0;
			if (aAllocationProfile == null)
			{
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					fillSizePlan += ap.GetStoreListTotalFillSizeBasisPlan(aColorComponent, aStoreList, aReturnSales);
				}
			}
			else
			{
				fillSizePlan = aAllocationProfile.GetStoreListTotalFillSizeBasisPlan (aColorComponent, aStoreList, aReturnSales);
			}
			return fillSizePlan;
		}
		#endregion StoreListTotalFillSizePlan
		
		#region StoreListTotalNeed
		//===========//
		// Unit Need //
		//===========//
		/// <summary>
		/// Gets Store List Total Unit Need
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
        /// <param name="aVolumeGrade">Volume Grade of the stores whose accumulated unit need is returned.</param>
		/// <returns>Total Unit Need for the requested store List.</returns>
		public double GetStoreListTotalUnitNeed(int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aVolumeGrade == null)
			{
				return GetStoreListTotalUnitNeed(aStoreGrpRID, aStoreGrpLvlRID);
			}
			return GetStoreListTotalUnitNeed(this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}  

		/// <summary>
		/// Gets Store List Total Unit Need
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <returns>Total Unit Need for the requested store List.</returns>
		public double GetStoreListTotalUnitNeed(int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalUnitNeed(Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets Store List Total Unit Need
		/// </summary>
		/// <param name="aStoreList">Profile List of stores.</param>
		/// <returns>Total unit need for the requested store list.</returns>
		public double GetStoreListTotalUnitNeed(ProfileList aStoreList)
		{
			double need = 0;
//			Index_RID storeIdxRID;
//			foreach (StoreProfile sp in aStoreList)
//			{
//				storeIdxRID = StoreIndex(sp.Key);
//				if (this.StoreIsVisible(storeIdxRID))
//				{
//					need += GetStoreUnitNeed(storeIdxRID.RID);
//				}
//			}
//			return need;
			foreach (Index_RID storeIdxRID in this.Transaction.StoreIndexRIDArray())
			{
				if (aStoreList.Contains(storeIdxRID.RID)
					&& this.StoreIsVisible (storeIdxRID))
				{
					need += GetStoreUnitNeed(storeIdxRID.RID);
				}
			}
			return need;
		}

		//==============//
		// Percent Need //
		//==============//
		/// <summary>
		/// Gets Store List Total Percent Need
		/// </summary>
		/// <param name="aStoreGrpRID">RID describing a Store Attribute Group.</param>
		/// <param name="aStoreGrpLvlRID">RID describing the store group level</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Total Unit Need for the requested store List.</returns>
		public double GetStoreListTotalPercentNeed(int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalPercentNeed(this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}
	
		/// <summary>
		/// Gets Store List Total Percent Need
		/// </summary>
		/// <param name="aStoreGrpRID">RID describing the store group (attribute).</param>
		/// <param name="aStoreGrpLvlRID">RID describing the store group level (set).</param>
		/// <returns>Total Unit Need for the requested store List.</returns>
		public double GetStoreListTotalPercentNeed(int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalPercentNeed(Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets Store List Total Percent Need
		/// </summary>
		/// <param name="aStoreList">Profile List of stores.</param>
		/// <returns>Total unit need for the requested store list.</returns>
		public double GetStoreListTotalPercentNeed(ProfileList aStoreList)
		{
			return Need.PctUnitNeed(
				GetStoreListTotalUnitNeed(aStoreList),
				GetStoreListTotalSalesPlan(aStoreList) + GetStoreListTotalStockPlan(aStoreList));
		}
		#endregion StoreListTotalNeed

		#region StoreListTotalLocked
		//==============//
		// Total Locked //
		//==============//
		#region GetStoreListTotalLocked
		/// <summary>
		/// Gets StoreListTotal Locked for stores in specified Grade in specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
		public bool GetStoreListTotalLocked (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreListTotalLocked (aComponent, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
			}
			return aAllocationProfile.GetStoreListTotalLocked (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}


		/// <summary>
		/// Gets StoreListTotal Locked for stores in specified Grade in specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
		public bool GetStoreListTotalLocked (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return (GetStoreListTotalLocked (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade)));
		}

		/// <summary>
		/// Gets StoreListTotal Locked for specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
		public bool GetStoreListTotalLocked(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalLocked(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Locked for specified Store List on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">List of Stores for which a total is desired.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
        public bool GetStoreListTotalLocked(GeneralComponent aComponent, ProfileList aStoreList) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			bool Locked = true;
			Index_RID storeIdxRID; // MID Track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID Track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreLocked(aComponent, StoreIndex(sp.Key)))
					if (!GetStoreLocked(aComponent, storeIdxRID))
						// end MID Track 4303 Size Review Set Total wrong
					{
						Locked = false;
						break; // MID Track 4303 Size Review Set Total wrong
					}
				}   // MID Track 4303 Size Review Set Total Wrong
			}
			return Locked;
		}

		/// <summary>
		/// Gets StoreListTotal Locked for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
		public bool GetStoreListTotalLocked(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalLocked(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Locked for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreList">StoreList for which a total is desired</param>
		/// <returns>Total Locked to the StoreList for the specified node.</returns>
        public bool GetStoreListTotalLocked(eAllocationSummaryNode aAllocationSummaryNode, ProfileList aStoreList) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			bool Locked = true;
			Index_RID storeIdxRID; // MID Track 4303 SizeReview Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID Track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreLocked(aAllocationSummaryNode, StoreIndex(sp.Key)))
					if (!GetStoreLocked(aAllocationSummaryNode, storeIdxRID))
						// end MID track 4303 Size Review Set Total Wrong
					{
						Locked = false;
						break; // MID Track 4303 Size Review Set Total Wrong
					}
				}   // MID track 4303 Size Review Set Total Wrong
			}
			return Locked;
		}

		/// <summary>
		/// Gets StoreListTotal Locked for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl.</param>
		/// <returns>Total Locked to the StoreList for the specified node.</returns>
		public bool GetStoreListTotalLocked(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalLocked(aPackName, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Locked for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreList">Profile List of stores for which a total allocation is desired</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
        public bool GetStoreListTotalLocked(string aPackName, ProfileList aStoreList) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			return GetStoreListTotalLocked(GetSubtotalPackHdr(aPackName), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Locked for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where StoreList resides.</param>
		/// <param name="aStoreList">Profile list of stores for which a total allocation is desired</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
        public bool GetStoreListTotalLocked(PackHdr aPack, ProfileList aStoreList) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			bool Locked = true;
			Index_RID storeIdxRID; // MID track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID Track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreLocked(aPack, StoreIndex(sp.Key)))
					if (!GetStoreLocked(aPack, storeIdxRID))
						// end MID Track 4303 Size Review Set Total Wrong
					{
						Locked = false;
						break; // MID track 4303 Size Review Set Total Wrong
					}
				}   // MID track 4303 Size Review set total wrong
			}
			return Locked;
		}

		/// <summary>
		/// Gets StoreListTotal Locked for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
		public bool GetStoreListTotalLocked(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalLocked(aColorRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Locked for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreList">Profile list for the Stores for which a total is desired.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
        public bool GetStoreListTotalLocked(int aColorRID, ProfileList aStoreList) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			return GetStoreListTotalLocked(GetSubtotalHdrColorBin(aColorRID), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Locked for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
        public bool GetStoreListTotalLocked(HdrColorBin aColor, ProfileList aStoreList) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			bool Locked = true;
			Index_RID storeIdxRID; // MID track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreLocked(aColor, StoreIndex(sp.Key)))
					if (!GetStoreLocked(aColor, storeIdxRID))
						// end MID track 4303 Size Review Set Total Wrong
					{
						Locked = false;
						break; // MID Track 4303 Size Review Set Total Wrong
					}
				}   // MID track 4303 Size Review Set Total Wrong
			}
			return Locked;
		}
		#endregion GetStoreListTotalLocked

		#region SetStoreListTotalLocked
		/// <summary>
		/// Sets StoreListTotal Locked for stores in specified Grade in specified StoreGrpLvl on specified component of the specified AllocationProfile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aLocked">True: if all selected stores are locked; False: otherwise.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
		public void SetStoreListTotalLocked (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, bool aLocked)
		{
			if (aAllocationProfile == null)
			{
				SetStoreListTotalLocked (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aLocked);
			}
			else
			{
				aAllocationProfile.SetStoreListTotalLocked(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aLocked);
			}
		}
		
		/// <summary>
		/// Sets StoreListTotal Locked for stores in specified Grade in specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aLocked">True: if all selected stores are locked; False: otherwise.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Locked; False otherwise.</returns>
		public void SetStoreListTotalLocked (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, bool aLocked)
		{
			SetStoreListTotalLocked (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aLocked);
		}

		/// <summary>
		/// Sets StoreListTotal Locked for specified StoreList on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aLocked">True: if all selected stores are Locked; False: otherwise.</param>
		public void SetStoreListTotalLocked(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, bool aLocked)
		{
			SetStoreListTotalLocked(
				aComponent, 
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID),  //MID Track 5820 - Unhandled Exception After Store Activation
				aLocked);
		}

		/// <summary>
		/// Sets StoreListTotal Locked for specified StoreList on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">ProfileList of stores for which a total is to be set.</param>
		/// <param name="aLocked">True: if all selected stores are Locked; False: otherwise.</param>
        public void SetStoreListTotalLocked(   // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
			GeneralComponent aComponent, 
			ProfileList aStoreList, 
			bool aLocked) 
		{
			Index_RID storeIdxRID; // MID Track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID Track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//SetStoreLocked(aComponent, StoreIndex(sp.Key), aLocked);
					SetStoreLocked(aComponent, storeIdxRID, aLocked);
				}
				// end MID Track 4303 Size Review Set Total Wrong
			}
		}

		/// <summary>
		/// Sets StoreListTotal Locked for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aLocked">True: if all selected stores are Locked; False: otherwise.</param>
		public void SetStoreListTotalLocked(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID, bool aLocked)
		{
			SetStoreListTotalLocked(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), aLocked); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Sets StoreListTotal Locked for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreList">Profile List of stores for which a total is to be set.</param>
		/// <param name="aLocked">True: if all selected stores are Locked; False: otherwise.</param>
        public void SetStoreListTotalLocked(eAllocationSummaryNode aAllocationSummaryNode,  // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
			ProfileList aStoreList, bool aLocked)
		{
			GeneralComponent gc;
			switch(aAllocationSummaryNode)
			{
				case(eAllocationSummaryNode.Bulk):
				{
					gc = new GeneralComponent(eComponentType.Bulk);
					break;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					gc = new GeneralComponent(eComponentType.DetailType);
					break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					gc = new GeneralComponent(eComponentType.GenericType);
					break;
				}
				case(eAllocationSummaryNode.Total):
				{
					gc = new GeneralComponent(eComponentType.Total);
					break;
				}
				case(eAllocationSummaryNode.Type):
				{
					gc = new GeneralComponent(eComponentType.Total);
					break;
				}
				case(eAllocationSummaryNode.DetailSubType):
				{
					gc = new GeneralComponent(eComponentType.DetailType);
					break;
				}
				case(eAllocationSummaryNode.BulkColorTotal):
				{
					gc= new GeneralComponent(eComponentType.Bulk);
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
			this.SetStoreListTotalLocked(gc, aStoreList, aLocked);
		}

		/// <summary>
		/// Sets StoreListTotal Locked for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreGrpRID">RID for Store Group</param>
		/// <param name="aStoreGrpLvlRID">RID for Store Group Level</param>
		/// <param name="aLocked">True: if all selected stores are Locked; False: otherwise.</param>
		public void SetStoreListTotalLocked(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID, bool aLocked)
		{
			SetStoreListTotalLocked
				(aPackName,
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
				aLocked);
		}

		/// <summary>
		/// Sets StoreListTotal Locked for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreList">Profile List of storess</param>
		/// <param name="aLocked">True: if all selected stores are Locked; False: otherwise.</param>
        public void SetStoreListTotalLocked(string aPackName, ProfileList aStoreList, bool aLocked) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			SetStoreListTotalLocked(this.GetSubtotalPackHdr(aPackName), aStoreList, aLocked);
		}

		/// <summary>
		/// Sets StoreListTotal Locked for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where StoreListTotal resides.</param>
		/// <param name="aStoreList">Profile lists of stores</param>
		/// <param name="aLocked">True: if all selected stores are Locked; False: otherwise.</param>
        public void SetStoreListTotalLocked(PackHdr aPack, ProfileList aStoreList, bool aLocked) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			AllocationPackComponent packComponent = new AllocationPackComponent(aPack.PackName);
			SetStoreListTotalLocked(packComponent, aStoreList, aLocked);
		}

		/// <summary>
		/// Sets StoreListTotal Locked for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGroup</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGroup Level.</param>
		/// <param name="aLocked">True: if all selected stores are Locked; False: otherwise.</param>
		public void SetStoreListTotalLocked(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID, bool aLocked)
		{
			SetStoreListTotalLocked
				(aColorRID,
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
				aLocked);
		}
	
		/// <summary>
		/// Sets StoreListTotal Locked for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <param name="aLocked">True: if all selected stores are Locked; False: otherwise.</param>
        public void SetStoreListTotalLocked(int aColorRID, ProfileList aStoreList, bool aLocked) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			SetStoreListTotalLocked
				(this.GetSubtotalHdrColorBin(aColorRID),
				aStoreList,
				aLocked);
		}

		/// <summary>
		/// Sets StoreListTotal Locked for specified StoreListTotal on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <param name="aLocked">True: if all selected stores are Locked; False: otherwise.</param>
        public void SetStoreListTotalLocked(HdrColorBin aColor, ProfileList aStoreList, bool aLocked) // TT#1189 - MD - Jellis - Group Allocation - Implement Lock Not Persist to Database pt 1
		{
			AllocationColorOrSizeComponent colorComponent = 
				new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColor.ColorCodeRID);
			SetStoreListTotalLocked(colorComponent, aStoreList, aLocked);
		}
		#endregion SetStoreListTotalLocked
		#endregion StoreListTotalLocked

		#region StoreListTotalTempLock
		//================//
		// Total TempLock //
		//================//
		#region GetStoreListTotalTempLock
		/// <summary>
		/// Gets StoreListTotal TempLock for specified Volume Grade in specified StoreGrpLvl on specified component of the specified AllocationProfile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are TempLock; False otherwise.</returns>
		public bool GetStoreListTotalTempLock(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreListTotalTempLock(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
			}
			return aAllocationProfile.GetStoreListTotalTempLock(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified Volume Grade in specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are TempLock; False otherwise.</returns>
		public bool GetStoreListTotalTempLock(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalTempLock(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are TempLock; False otherwise.</returns>
		public bool GetStoreListTotalTempLock(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalTempLock(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified Store List on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">List of Stores for which a total is desired.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are TempLock; False otherwise.</returns>
		internal bool GetStoreListTotalTempLock(GeneralComponent aComponent, ProfileList aStoreList)
		{
			bool TempLock = true;
			Index_RID storeIdxRID; // MID track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreTempLock(aComponent, StoreIndex(sp.Key)))
					if (!GetStoreTempLock(aComponent, storeIdxRID))
						// end MID track 4303 Size Review Set Total Wrong
					{
						TempLock = false;
						break; // MID track 4303 Size Review Set Total wrong
					}
				}    // MID track 4303 Size Review Set Total Wrong
			}
			return TempLock;
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are TempLock; False otherwise.</returns>
		public bool GetStoreListTotalTempLock(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalTempLock(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreList">StoreList for which a total is desired</param>
		/// <returns>Total TempLock to the StoreList for the specified node.</returns>
		internal bool GetStoreListTotalTempLock(eAllocationSummaryNode aAllocationSummaryNode, ProfileList aStoreList)
		{
			bool TempLock = true;
			Index_RID storeIdxRID; // MID track 4303 Size Review Set total wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID track 4303 Size Review Set Total wrong
				storeIdxRID = StoreIndex(sp.Key); 
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreTempLock(aAllocationSummaryNode, StoreIndex(sp.Key)))
					if (!GetStoreTempLock(aAllocationSummaryNode, storeIdxRID))
						// end MID Track 4303 Size Review Set Total wrong
					{
						TempLock = false;
						break; // MID track 4303 Size Review Set Total Wrong
					}
				}   // MID track 4303 Size Review Set Total Wrong
			}
			return TempLock;
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl.</param>
		/// <returns>Total TempLock to the StoreList for the specified node.</returns>
		public bool GetStoreListTotalTempLock(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalTempLock(aPackName, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreList">Profile List of stores for which a total allocation is desired</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are TempLock; False otherwise.</returns>
		internal bool GetStoreListTotalTempLock(string aPackName, ProfileList aStoreList)
		{
			return GetStoreListTotalTempLock(GetSubtotalPackHdr(aPackName), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where StoreList resides.</param>
		/// <param name="aStoreList">Profile list of stores for which a total allocation is desired</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are TempLock; False otherwise.</returns>
		internal bool GetStoreListTotalTempLock(PackHdr aPack, ProfileList aStoreList)
		{
			bool TempLock = true;
			Index_RID storeIdxRID; // MID track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreTempLock(aPack,	StoreIndex(sp.Key)))
					if (!GetStoreTempLock(aPack, storeIdxRID))
						// end MID track 4303 Size Review Set Total Wrong
					{
						TempLock = false;
						break; // MID track 4303 Size Review Set Total Wrong
					}
				}   // MID track 4303 Size Review Set Total Wrong
			}
			return TempLock;
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are TempLock; False otherwise.</returns>
		public bool GetStoreListTotalTempLock(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalTempLock(aColorRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreList">Profile list for the Stores for which a total is desired.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are TempLock; False otherwise.</returns>
		internal bool GetStoreListTotalTempLock(int aColorRID, ProfileList aStoreList)
		{
			return GetStoreListTotalTempLock(GetSubtotalHdrColorBin(aColorRID), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal TempLock for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are TempLock; False otherwise.</returns>
		internal bool GetStoreListTotalTempLock(HdrColorBin aColor, ProfileList aStoreList)
		{
			bool TempLock = true;
			Index_RID storeIdxRID; // MID track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID track 4303 Size Review set total wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreTempLock(aColor, StoreIndex(sp.Key)))
					if (!GetStoreTempLock(aColor, storeIdxRID))
						// end MID track 4303 Size Review set total wrong
					{
						TempLock = false;
						break; // MID track 4303 Size Review set total wrong
					}
				} // MID track 4303 Size Review Set Total Wrong
			}
			return TempLock;
		}
		#endregion GetStoreListTotalTempLock

		#region SetStoreListTotalTempLock
		/// <summary>
		/// Sets StoreListTotal Temp Lock for stores in specified Grade in specified StoreGrpLvl on specified component of the specified AllocationProfile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aTempLock">True: if all selected stores are locked; False: otherwise.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Temp Locked; False otherwise.</returns>
		public void SetStoreListTotalTempLock (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, bool aTempLock)
		{
			if (aAllocationProfile == null)
			{
				SetStoreListTotalTempLock (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aTempLock);
			}
			else
			{
				aAllocationProfile.SetStoreListTotalTempLock(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aTempLock);
			}
		}

		/// <summary>
		/// Sets StoreListTotal Temp Lock for stores in specified Grade in specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aTempLock">True: if all selected stores are locked; False: otherwise.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Temp Locked; False otherwise.</returns>
		public void SetStoreListTotalTempLock (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, bool aTempLock)
		{
			SetStoreListTotalTempLock (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aTempLock);
		}

		/// <summary>
		/// Sets StoreListTotal TempLock for specified StoreList on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aTempLock">True: if all selected stores are TempLock; False: otherwise.</param>
		public void SetStoreListTotalTempLock(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, bool aTempLock)
		{
			SetStoreListTotalTempLock(
				aComponent, 
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID),  //MID Track 5820 - Unhandled Exception After Store Activation
				aTempLock);
		}

		/// <summary>
		/// Sets StoreListTotal TempLock for specified StoreList on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">ProfileList of stores for which a total is to be set.</param>
		/// <param name="aTempLock">True: if all selected stores are TempLock; False: otherwise.</param>
		internal void SetStoreListTotalTempLock(
			GeneralComponent aComponent, 
			ProfileList aStoreList, 
			bool aTempLock) 
		{
			Index_RID storeIdxRID; // MID track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//SetStoreTempLock(aComponent, StoreIndex(sp.Key), aTempLock);
					SetStoreTempLock(aComponent, storeIdxRID, aTempLock);
				}
				// end MID track 4303 Size Review Set Total Wrong
			}
		}

		/// <summary>
		/// Sets StoreListTotal TempLock for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aTempLock">True: if all selected stores are TempLock; False: otherwise.</param>
		public void SetStoreListTotalTempLock(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID, bool aTempLock)
		{
			SetStoreListTotalTempLock(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), aTempLock); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Sets StoreListTotal TempLock for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreList">Profile List of stores for which a total is to be set.</param>
		/// <param name="aTempLock">True: if all selected stores are TempLock; False: otherwise.</param>
		internal void SetStoreListTotalTempLock(eAllocationSummaryNode aAllocationSummaryNode, 
			ProfileList aStoreList, bool aTempLock)
		{
			GeneralComponent gc;
			switch(aAllocationSummaryNode)
			{
				case(eAllocationSummaryNode.Bulk):
				{
					gc = new GeneralComponent(eComponentType.Bulk);
					break;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					gc = new GeneralComponent(eComponentType.DetailType);
					break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					gc = new GeneralComponent(eComponentType.GenericType);
					break;
				}
				case(eAllocationSummaryNode.Total):
				{
					gc = new GeneralComponent(eComponentType.Total);
					break;
				}
				case(eAllocationSummaryNode.Type):
				{
					gc = new GeneralComponent(eComponentType.Total);
					break;
				}
				case(eAllocationSummaryNode.DetailSubType):
				{
					gc = new GeneralComponent(eComponentType.DetailType);
					break;
				}
				case(eAllocationSummaryNode.BulkColorTotal):
				{
					gc= new GeneralComponent(eComponentType.Bulk);
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
			this.SetStoreListTotalTempLock(gc, aStoreList, aTempLock);
		}

		/// <summary>
		/// Sets StoreListTotal TempLock for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreGrpRID">RID for Store Group</param>
		/// <param name="aStoreGrpLvlRID">RID for Store Group Level</param>
		/// <param name="aTempLock">True: if all selected stores are TempLock; False: otherwise.</param>
		public void SetStoreListTotalTempLock(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID, bool aTempLock)
		{
			SetStoreListTotalTempLock
				(aPackName,
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
				aTempLock);
		}

		/// <summary>
		/// Sets StoreListTotal TempLock for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreList">Profile List of storess</param>
		/// <param name="aTempLock">True: if all selected stores are TempLock; False: otherwise.</param>
		internal void SetStoreListTotalTempLock(string aPackName, ProfileList aStoreList, bool aTempLock)
		{
			SetStoreListTotalTempLock(GetSubtotalPackHdr(aPackName), aStoreList, aTempLock);
		}

		/// <summary>
		/// Sets StoreListTotal TempLock for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where StoreListTotal resides.</param>
		/// <param name="aStoreList">Profile lists of stores</param>
		/// <param name="aTempLock">True: if all selected stores are TempLock; False: otherwise.</param>
		internal void SetStoreListTotalTempLock(PackHdr aPack, ProfileList aStoreList, bool aTempLock)
		{
			AllocationPackComponent packComponent = new AllocationPackComponent(aPack.PackName);
			SetStoreListTotalTempLock(packComponent, aStoreList, aTempLock);
		}

		/// <summary>
		/// Sets StoreListTotal TempLock for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGroup</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGroup Level.</param>
		/// <param name="aTempLock">True: if all selected stores are TempLock; False: otherwise.</param>
		public void SetStoreListTotalTempLock(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID, bool aTempLock)
		{
			SetStoreListTotalTempLock
				(aColorRID,
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
				aTempLock);
		}

		/// <summary>
		/// Sets StoreListTotal TempLock for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <param name="aTempLock">True: if all selected stores are TempLock; False: otherwise.</param>
		internal void SetStoreListTotalTempLock(int aColorRID, ProfileList aStoreList, bool aTempLock)
		{
			SetStoreListTotalTempLock
				(this.GetSubtotalHdrColorBin(aColorRID),
				aStoreList,
				aTempLock);
		}

		/// <summary>
		/// Sets StoreListTotal TempLock for specified StoreListTotal on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <param name="aTempLock">True: if all selected stores are TempLock; False: otherwise.</param>
		internal void SetStoreListTotalTempLock(HdrColorBin aColor, ProfileList aStoreList, bool aTempLock)
		{
			AllocationColorOrSizeComponent colorComponent = 
				new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColor.ColorCodeRID);
			SetStoreListTotalTempLock(colorComponent, aStoreList, aTempLock);
		}
		#endregion SetStoreListTotalTempLock
		#endregion StoreListTotalTempLock

		#region StoreListTotalOut
		//===========//
		// Total Out //
		//===========//
		#region GetStoreListTotalOut
		/// <summary>
		/// Gets StoreListTotal Out for specified Volume Grade in specified StoreGrpLvl on specified component of the specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are out; False otherwise.</returns>
		public bool GetStoreListTotalOut(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreListTotalOut(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
			}
			else
			{
				return aAllocationProfile.GetStoreListTotalOut(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));

			}
		}
		
		/// <summary>
		/// Gets StoreListTotal Out for specified Volume Grade in specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are out; False otherwise.</returns>
		public bool GetStoreListTotalOut(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalOut(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}
		
		/// <summary>
		/// Gets StoreListTotal Out for specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are out; False otherwise.</returns>
		public bool GetStoreListTotalOut(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOut(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Out for specified Store List on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">List of Stores for which a total is desired.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are out; False otherwise.</returns>
		internal bool GetStoreListTotalOut(GeneralComponent aComponent, ProfileList aStoreList)
		{
			bool Out = true;
			Index_RID storeIdxRID; // MID track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreOut(aComponent, StoreIndex(sp.Key)))
					if (!GetStoreOut(aComponent, storeIdxRID))
						// end MID track 4303 Size Review Set Total Wrong
					{
						Out = false;
						break; // MID Track 4303 Size Review Set Total Wrong
					}
				}   // MID track 4303 Size Review Set Total Wrong
			}
			return Out;
		}

		/// <summary>
		/// Gets StoreListTotal Out for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are out; False otherwise.</returns>
		public bool GetStoreListTotalOut(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOut(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Out for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreList">StoreList for which a total is desired</param>
		/// <returns>Total Out to the StoreList for the specified node.</returns>
		internal bool GetStoreListTotalOut(eAllocationSummaryNode aAllocationSummaryNode, ProfileList aStoreList)
		{
			bool Out = true;
			Index_RID storeIdxRID; // MID Track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID Track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreOut(aAllocationSummaryNode, StoreIndex(sp.Key)))
					if (!GetStoreOut(aAllocationSummaryNode, storeIdxRID))
						// end MID track 4303 Size Review Set Total Wrong
					{
						Out = false;
						break; // MID track 4303 Size Review Set Total Wrong
					}
				}   // MID track 4303 Size Review Set Total Wrong
			}
			return Out;
		}

		/// <summary>
		/// Gets StoreListTotal Out for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl.</param>
		/// <returns>Total Out to the StoreList for the specified node.</returns>
		public bool GetStoreListTotalOut(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOut(aPackName, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Out for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreList">Profile List of stores for which a total allocation is desired</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are out; False otherwise.</returns>
		internal bool GetStoreListTotalOut(string aPackName, ProfileList aStoreList)
		{
			return GetStoreListTotalOut(GetSubtotalPackHdr(aPackName), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Out for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where StoreList resides.</param>
		/// <param name="aStoreList">Profile list of stores for which a total allocation is desired</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are out; False otherwise.</returns>
		internal bool GetStoreListTotalOut(PackHdr aPack, ProfileList aStoreList)
		{
			bool Out = true;
			Index_RID storeIdxRID; // MID track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID track 4303 Size Review set total wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreOut(aPack,	StoreIndex(sp.Key)))
					if (!GetStoreOut(aPack, storeIdxRID))
						// end MID track 4303 Size Review Set Total wrong
					{
						Out = false;
						break; // MID track 4303 Size Review Set Total Wrong
					}
				}   // MID track 4303  Size Review Set Total wrong
			}
			return Out;
		}

		/// <summary>
		/// Gets StoreListTotal Out for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are out; False otherwise.</returns>
		public bool GetStoreListTotalOut(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOut(aColorRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Out for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreList">Profile list for the Stores for which a total is desired.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are out; False otherwise.</returns>
		internal bool GetStoreListTotalOut(int aColorRID, ProfileList aStoreList)
		{
			return GetStoreListTotalOut(GetSubtotalHdrColorBin(aColorRID), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Out for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are out; False otherwise.</returns>
		internal bool GetStoreListTotalOut(HdrColorBin aColor, ProfileList aStoreList)
		{
			bool Out = true;
			Index_RID storeIdxRID; // MID track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//if (!GetStoreOut(aColor, StoreIndex(sp.Key)))
					if (!GetStoreOut(aColor, storeIdxRID))
						// end MID track 4303 Size Review Set Total Wrong
					{
						Out = false;
						break; // MID Track 4303 Size Review Set Total Wrong
					}
				}   // MID Track 4303 Size Review Set Total Wrong
			}
			return Out;
		}
		#endregion GetStoreListTotalOut

		#region SetStoreListTotalOut
		/// <summary>
		/// Sets StoreListTotal Out for stores in specified Grade in specified StoreGrpLvl on specified component of the specified AllocationProfile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aOut">True: if all selected stores are Out; False: otherwise.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Out; False otherwise.</returns>
		public void SetStoreListTotalOut (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, bool aOut)
		{
			if (aAllocationProfile == null)
			{
				SetStoreListTotalOut (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aOut);
			}
			else
			{
				aAllocationProfile.SetStoreListTotalOut (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aOut);
			}
		}
		
		/// <summary>
		/// Sets StoreListTotal Out for stores in specified Grade in specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aOut">True: if all selected stores are Out; False: otherwise.</param>
		/// <returns>True: if all stores in StoreGrpLvl for component are Out; False otherwise.</returns>
		public void SetStoreListTotalOut (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, bool aOut)
		{
			SetStoreListTotalOut (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aOut);
		}

		/// <summary>
		/// Sets StoreListTotal Out for specified StoreList on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aOut">True: if all selected stores are OUT; False: otherwise.</param>
		public void SetStoreListTotalOut(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, bool aOut)
		{
			SetStoreListTotalOut(
				aComponent, 
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID),  //MID Track 5820 - Unhandled Exception After Store Activation
				aOut);
		}

		/// <summary>
		/// Sets StoreListTotal Out for specified StoreList on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">ProfileList of stores for which a total is to be set.</param>
		/// <param name="aOut">True: if all selected stores are OUT; False: otherwise.</param>
		internal void SetStoreListTotalOut(
			GeneralComponent aComponent, 
			ProfileList aStoreList, 
			bool aOut) 
		{
			Index_RID storeIdxRID;  // MID Track 4303 Size Review Set Total Wrong
			foreach (StoreProfile sp in aStoreList)
			{
				// begin MID Track 4303 Size Review Set Total Wrong
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					//SetStoreOut(aComponent, StoreIndex(sp.Key), aOut);
					SetStoreOut(aComponent, storeIdxRID, aOut);
				}
				// end MID track 4303 Size Review set total wrong
			}
		}

		/// <summary>
		/// Sets StoreListTotal Out for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aOut">True: if all selected stores are OUT; False: otherwise.</param>
		public void SetStoreListTotalOut(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID, bool aOut)
		{
			SetStoreListTotalOut(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), aOut); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Sets StoreListTotal Out for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreList">Profile List of stores for which a total is to be set.</param>
		/// <param name="aOut">True: if all selected stores are OUT; False: otherwise.</param>
		internal void SetStoreListTotalOut(eAllocationSummaryNode aAllocationSummaryNode, 
			ProfileList aStoreList, bool aOut)
		{
			GeneralComponent gc;
			switch(aAllocationSummaryNode)
			{
				case(eAllocationSummaryNode.Bulk):
				{
					gc = new GeneralComponent(eComponentType.Bulk);
					break;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					gc = new GeneralComponent(eComponentType.DetailType);
					break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					gc = new GeneralComponent(eComponentType.GenericType);
					break;
				}
				case(eAllocationSummaryNode.Total):
				{
					gc = new GeneralComponent(eComponentType.Total);
					break;
				}
				case(eAllocationSummaryNode.Type):
				{
					gc = new GeneralComponent(eComponentType.Total);
					break;
				}
				case(eAllocationSummaryNode.DetailSubType):
				{
					gc = new GeneralComponent(eComponentType.DetailType);
					break;
				}
				case(eAllocationSummaryNode.BulkColorTotal):
				{
					gc= new GeneralComponent(eComponentType.Bulk);
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
			this.SetStoreListTotalOut(gc, aStoreList, aOut);
		}

		/// <summary>
		/// Sets StoreListTotal Out for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreGrpRID">RID for Store Group</param>
		/// <param name="aStoreGrpLvlRID">RID for Store Group Level</param>
		/// <param name="aOut">True: if all selected stores are OUT; False: otherwise.</param>
		public void SetStoreListTotalOut(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID, bool aOut)
		{
			SetStoreListTotalOut
				(aPackName,
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
				aOut);
		}

		/// <summary>
		/// Sets StoreListTotal Out for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreList">Profile List of storess</param>
		/// <param name="aOut">True: if all selected stores are OUT; False: otherwise.</param>
		internal void SetStoreListTotalOut(string aPackName, ProfileList aStoreList, bool aOut)
		{
			SetStoreListTotalOut(GetSubtotalPackHdr(aPackName), aStoreList, aOut);
		}

		/// <summary>
		/// Sets StoreListTotal Out for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where StoreListTotal resides.</param>
		/// <param name="aStoreList">Profile lists of stores</param>
		/// <param name="aOut">True: if all selected stores are OUT; False: otherwise.</param>
		internal void SetStoreListTotalOut(PackHdr aPack, ProfileList aStoreList, bool aOut)
		{
			AllocationPackComponent packComponent = new AllocationPackComponent(aPack.PackName);
			SetStoreListTotalOut(packComponent, aStoreList, aOut);
		}

		/// <summary>
		/// Sets StoreListTotal Out for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGroup</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGroup Level.</param>
		/// <param name="aOut">True: if all selected stores are OUT; False: otherwise.</param>
		public void SetStoreListTotalOut(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID, bool aOut)
		{
			SetStoreListTotalOut
				(aColorRID,
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
				aOut);
		}
	
		/// <summary>
		/// Sets StoreListTotal Out for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <param name="aOut">True: if all selected stores are OUT; False: otherwise.</param>
		internal void SetStoreListTotalOut(int aColorRID, ProfileList aStoreList, bool aOut)
		{
			SetStoreListTotalOut
				(this.GetSubtotalHdrColorBin(aColorRID),
				aStoreList,
				aOut);
		}

		/// <summary>
		/// Sets StoreListTotal Out for specified StoreListTotal on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <param name="aOut">True: if all selected stores are OUT; False: otherwise.</param>
		internal void SetStoreListTotalOut(HdrColorBin aColor, ProfileList aStoreList, bool aOut)
		{
			AllocationColorOrSizeComponent colorComponent = 
				new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColor.ColorCodeRID);
			SetStoreListTotalOut(colorComponent, aStoreList, aOut);
		}
		#endregion SetStoreListTotalOut
		#endregion StoreListTotalOut

		#region StoreListTotalQuantityAllocated
		//==========================//
		// Total Quantity Allocated //
		//==========================//
		#region GetStoreListTotalQuantityAllocated
		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified Volume Grade in specified StoreGrpLvl on specified component of the specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
		public int GetStoreListTotalQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreListTotalQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
			}
			return aAllocationProfile.GetStoreListTotalQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified Volume Grade in specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
		public int GetStoreListTotalQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
		public int GetStoreListTotalQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalQtyAllocated(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified Store List on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">List of Stores for which a total is desired.</param>
		/// <returns>Total Quantity Allocated across all stores in the list for the specified component.</returns>
		internal int GetStoreListTotalQtyAllocated(GeneralComponent aComponent, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreQtyAllocated(aComponent, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		public int GetStoreListTotalQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalQtyAllocated(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreList">StoreList for which a total is desired</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, ProfileList aStoreList)
		{
			int allocated =0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreQtyAllocated(aAllocationSummaryNode, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl.</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		public int GetStoreListTotalQtyAllocated(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalQtyAllocated(aPackName, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreList">Profile List of stores for which a total allocation is desired</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocated(string aPackName, ProfileList aStoreList)
		{
			return GetStoreListTotalQtyAllocated(GetSubtotalPackHdr(aPackName), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where StoreList resides.</param>
		/// <param name="aStoreList">Profile list of stores for which a total allocation is desired</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocated(PackHdr aPack, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreQtyAllocated(aPack, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
		/// <returns>Quantity Allocated to the StoreList for the specified node.</returns>
		public int GetStoreListTotalQtyAllocated(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalQtyAllocated(aColorRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreList">Profile list for the Stores for which a total is desired.</param>
		/// <returns>Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocated(int aColorRID, ProfileList aStoreList)
		{
			return GetStoreListTotalQtyAllocated(GetSubtotalHdrColorBin(aColorRID), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocated(HdrColorBin aColor, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreQtyAllocated(aColor, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified color-size node.
		/// </summary>
		/// <param name="aColorRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
		/// <returns>Quantity Allocated to the StoreList for the specified node.</returns>
		public int GetStoreListTotalQtyAllocated(int aColorRID, int aSizeRID, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalQtyAllocated(aColorRID, aSizeRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified color-size node.
		/// </summary>
		/// <param name="aColorRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocated(int aColorRID, int aSizeRID, ProfileList aStoreList)
		{
			return GetStoreListTotalQtyAllocated(GetSubtotalHdrColorBin(aColorRID), aSizeRID, aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreList">ProfileList of stores for which a total is desired</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocated(HdrColorBin aColor, int aSizeRID, ProfileList aStoreList)
		{
			return GetStoreListTotalQtyAllocated(aColor.GetSizeBin(aSizeRID), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the StoreList resides.</param>
		/// <param name="aStoreList">ProfileList of stores for which a total is desired.</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocated(HdrSizeBin aSize, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreQtyAllocated(aSize, storeIdxRID);
				}
			}
			return allocated;
		}
		#endregion GetStoreListTotalQuantityAllocated

		#region SetStoreListTotalQuantityAllocated
		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for stores in specified Grade in specified StoreGrpLvl on specified component of the specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		public void SetStoreListTotalQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aQtyAllocated)
		{
			if (aAllocationProfile == null)
			{
				SetStoreListTotalQtyAllocated (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aQtyAllocated);
			}
			else
			{
				aAllocationProfile.SetStoreListTotalQtyAllocated (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aQtyAllocated);
			}
		}
		
		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for stores in specified Grade in specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		public void SetStoreListTotalQtyAllocated (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aQtyAllocated)
		{
			SetStoreListTotalQtyAllocated (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreList on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		public void SetStoreListTotalQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, int aQtyAllocated)
		{
			SetStoreListTotalQtyAllocated(
				aComponent, 
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID),  //MID Track 5820 - Unhandled Exception After Store Activation
				aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreList on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">ProfileList of stores for which a total is to be set.</param>
		/// <param name="aQtyAllocated">Total QuantityAllocated</param>
		internal void SetStoreListTotalQtyAllocated(
			GeneralComponent aComponent, 
			ProfileList aStoreList, 
			int aQtyAllocated) 
		{
			this.SpreadStoreListTotalQtyAllocated(aComponent, aStoreList, aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		/// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
		public void SetStoreListTotalQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID, int aQtyAllocated)
		{
			SetStoreListTotalQtyAllocated(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), aQtyAllocated); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreList">Profile List of stores for which a total is to be set.</param>
		/// <param name="aQtyAllocated">Total Quantity Allocated</param>
		internal void SetStoreListTotalQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, 
			ProfileList aStoreList, int aQtyAllocated)
		{
			GeneralComponent gc;
			switch(aAllocationSummaryNode)
			{
				case(eAllocationSummaryNode.Bulk):
				{
					gc = new GeneralComponent(eComponentType.Bulk);
					break;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					gc = new GeneralComponent(eComponentType.DetailType);
					break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					gc = new GeneralComponent(eComponentType.GenericType);
					break;
				}
				case(eAllocationSummaryNode.Total):
				{
					gc = new GeneralComponent(eComponentType.Total);
					break;
				}
				case(eAllocationSummaryNode.Type):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_TypeTtlReadOnly),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_TypeTtlReadOnly));
				}
				case(eAllocationSummaryNode.DetailSubType):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_DetailSubTypeTtlReadOnly),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_DetailSubTypeTtlReadOnly));
				}
				case(eAllocationSummaryNode.BulkColorTotal):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_AllColorsTtlReadOnly),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllColorsTtlReadOnly));
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
				}
			}
			this.SetStoreListTotalQtyAllocated(gc, aStoreList, aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreGrpRID">RID for Store Group</param>
		/// <param name="aStoreGrpLvlRID">RID for Store Group Level</param>
		/// <param name="aQtyAllocated">Quantity Allocated.</param>
		/// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
		public void SetStoreListTotalQtyAllocated(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID, int aQtyAllocated)
		{
			SetStoreListTotalQtyAllocated
				(aPackName,
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
				aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreList">Profile List of storess</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		internal void SetStoreListTotalQtyAllocated(string aPackName, ProfileList aStoreList, int aQtyAllocated)
		{
			SetStoreListTotalQtyAllocated(GetSubtotalPackHdr(aPackName), aStoreList, aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where StoreListTotal resides.</param>
		/// <param name="aStoreList">Profile lists of stores</param>
		/// <param name="aQtyAllocated">Quantity Allocated.</param>
		internal void SetStoreListTotalQtyAllocated(PackHdr aPack, ProfileList aStoreList, int aQtyAllocated)
		{
			AllocationPackComponent packComponent = new AllocationPackComponent(aPack.PackName);
			this.SpreadStoreListTotalQtyAllocated(packComponent, aStoreList, aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGroup</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGroup Level.</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		public void SetStoreListTotalQtyAllocated(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID, int aQtyAllocated)
		{
			SetStoreListTotalQtyAllocated
				(aColorRID,
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
				aQtyAllocated);
		}
	
		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		internal void SetStoreListTotalQtyAllocated(int aColorRID, ProfileList aStoreList, int aQtyAllocated)
		{
			SetStoreListTotalQtyAllocated
				(this.GetSubtotalHdrColorBin(aColorRID),
				aStoreList,
				aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreListTotal on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		internal void SetStoreListTotalQtyAllocated(HdrColorBin aColor, ProfileList aStoreList, int aQtyAllocated)
		{
			AllocationColorOrSizeComponent colorComponent = 
				new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColor.ColorCodeRID);
			this.SpreadStoreListTotalQtyAllocated(colorComponent, aStoreList, aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreListTotal on specified color-size node.
		/// </summary>
		/// <param name="aColorRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreGrpRID">RID for Store Group</param>
		/// <param name="aStoreGrpLvlRID">RID for Store Group Level</param>
		/// <param name="aQtyAllocated">Quantity Allocated.</param>
		public void SetStoreListTotalQtyAllocated(int aColorRID, int aSizeRID, int aStoreGrpRID, int aStoreGrpLvlRID, int aQtyAllocated)
		{
			SetStoreListTotalQtyAllocated
				(aColorRID, 
				aSizeRID, 
				Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
				aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated audit flag for specified StoreListTotal on specified color-size node.
		/// </summary>
		/// <param name="aColorRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		internal void SetStoreListTotalQtyAllocated(int aColorRID, int aSizeRID, ProfileList aStoreList, int aQtyAllocated)
		{
			SetStoreListTotalQtyAllocated
				(GetSubtotalHdrColorBin(aColorRID),
				aSizeRID, 
				aStoreList,	
				aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreListTotal on specified color-size node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreList">Profile List of stores.</param>
		/// <param name="aQtyAllocated">Quantity Allocated.</param>
		internal void SetStoreListTotalQtyAllocated(HdrColorBin aColor, int aSizeRID, ProfileList aStoreList, int aQtyAllocated)
		{
			SetStoreListTotalQtyAllocated
				(aColor.GetSizeBin(aSizeRID),
				aStoreList, 
				aQtyAllocated);
		}

		/// <summary>
		/// Sets StoreListTotal Quantity Allocated for specified StoreList on specified color-size node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the StoreList resides.</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <param name="aQtyAllocated">Quantity Allocated</param>
		internal void SetStoreListTotalQtyAllocated(HdrSizeBin aSize, ProfileList aStoreList, int aQtyAllocated)
		{
			AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aSize.Color.ColorCodeRID);
            AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSize.SizeCodeRID); // Assortment: color/size changes
			AllocationColorSizeComponent colorSizeComponent = new AllocationColorSizeComponent(colorComponent, sizeComponent);
			this.SpreadStoreListTotalQtyAllocated(colorSizeComponent, aStoreList, aQtyAllocated);
		}
		#endregion SetStoreListTotalQuantityAllocated
		#endregion StoreListTotalQuantityAllocated

        // begin TT#1401 - JEllis - Urban Reservation Store pt 7
        #region StoreListTotalItemQuantityAllocated
        #region GetStoreListTotalItemQuantityAllocated
        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified Volume Grade in specified StoreGrpLvl on specified component of the specified Allocation Profile.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <param name="aVolumeGrade">Volume Grade</param>
        /// <returns>Item Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
        public int GetStoreListTotalItemQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
        {
            if (aAllocationProfile == null)
            {
                return GetStoreListTotalItemQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
            }
            return aAllocationProfile.GetStoreListTotalItemQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified Volume Grade in specified StoreGrpLvl on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <param name="aVolumeGrade">Volume Grade</param>
        /// <returns>Item Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
        public int GetStoreListItemTotalQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
        {
            return GetStoreListTotalItemQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreGrpLvl on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <returns>Item Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
        public int GetStoreListTotalItemQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalItemQtyAllocated(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); 
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified Store List on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreList">List of Stores for which a total is desired.</param>
        /// <returns>Total Item Quantity Allocated across all stores in the list for the specified component.</returns>
        internal int GetStoreListTotalItemQtyAllocated(GeneralComponent aComponent, ProfileList aStoreList)
        {
            int allocated = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    allocated += GetStoreItemQtyAllocated(aComponent, storeIdxRID);
                }
            }
            return allocated;
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreGrpRID">RID for StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <returns>Total Item Quantity Allocated to the StoreList for the specified node.</returns>
        public int GetStoreListTotaItemlQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalItemQtyAllocated(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); 
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreList">StoreList for which a total is desired</param>
        /// <returns>Total Item Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalItemQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, ProfileList aStoreList)
        {
            int allocated = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    allocated += GetStoreItemQtyAllocated(aAllocationSummaryNode, storeIdxRID);
                }
            }
            return allocated;
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified pack node.
        /// </summary>
        /// <param name="aPackName">Pack name.</param>
        /// <param name="aStoreGrpRID">RID for StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl.</param>
        /// <returns>Total Item Quantity Allocated to the StoreList for the specified node.</returns>
        public int GetStoreListTotalItemQtyAllocated(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalItemQtyAllocated(aPackName, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified pack node.
        /// </summary>
        /// <param name="aPackName">Pack name.</param>
        /// <param name="aStoreList">Profile List of stores for which a total allocation is desired</param>
        /// <returns>Total Item Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalItemQtyAllocated(string aPackName, ProfileList aStoreList)
        {
            return GetStoreListTotalItemQtyAllocated(GetSubtotalPackHdr(aPackName), aStoreList);
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified pack node.
        /// </summary>
        /// <param name="aPack">Pack header object where StoreList resides.</param>
        /// <param name="aStoreList">Profile list of stores for which a total allocation is desired</param>
        /// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalItemQtyAllocated(PackHdr aPack, ProfileList aStoreList)
        {
            int allocated = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    allocated += GetStoreItemQtyAllocated(aPack, storeIdxRID);
                }
            }
            return allocated;
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aColorRID">RID for the color.</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
        /// <returns>Item Quantity Allocated to the StoreList for the specified node.</returns>
        public int GetStoreListTotalItemQtyAllocated(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalItemQtyAllocated(aColorRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aColorRID">RID for the color.</param>
        /// <param name="aStoreList">Profile list for the Stores for which a total is desired.</param>
        /// <returns>Item Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalItemQtyAllocated(int aColorRID, ProfileList aStoreList)
        {
            return GetStoreListTotalItemQtyAllocated(GetSubtotalHdrColorBin(aColorRID), aStoreList);
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color.</param>
        /// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
        /// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalItemQtyAllocated(HdrColorBin aColor, ProfileList aStoreList)
        {
            int allocated = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    allocated += GetStoreItemQtyAllocated(aColor, storeIdxRID);
                }
            }
            return allocated;
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified color-size node.
        /// </summary>
        /// <param name="aColorRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
        /// <returns>Item Quantity Allocated to the StoreList for the specified node.</returns>
        public int GetStoreListTotalItemQtyAllocated(int aColorRID, int aSizeRID, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalItemQtyAllocated(aColorRID, aSizeRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified color-size node.
        /// </summary>
        /// <param name="aColorRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
        /// <returns>Total Item Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalItemQtyAllocated(int aColorRID, int aSizeRID, ProfileList aStoreList)
        {
            return GetStoreListTotalItemQtyAllocated(GetSubtotalHdrColorBin(aColorRID), aSizeRID, aStoreList);
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreList">ProfileList of stores for which a total is desired</param>
        /// <returns>Total Item Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalItemQtyAllocated(HdrColorBin aColor, int aSizeRID, ProfileList aStoreList)
        {
            return GetStoreListTotalItemQtyAllocated(aColor.GetSizeBin(aSizeRID), aStoreList);
        }

        /// <summary>
        /// Gets StoreListTotal Item Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aSize">HdrSizeBin for the size where the StoreList resides.</param>
        /// <param name="aStoreList">ProfileList of stores for which a total is desired.</param>
        /// <returns>Total Item Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalItemQtyAllocated(HdrSizeBin aSize, ProfileList aStoreList)
        {
            int allocated = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    allocated += GetStoreItemQtyAllocated(aSize, storeIdxRID);
                }
            }
            return allocated;
        }
        #endregion GetStoreListTotalITemQuantityAllocated

        #region SetStoreListTotalItemQuantityAllocated
        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for stores in specified Grade in specified StoreGrpLvl on specified component of the specified Allocation Profile.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <param name="aVolumeGrade">Volume Grade</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated</param>
        public void SetStoreListTotalItemQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aQtyAllocated)
        {
            if (aAllocationProfile == null)
            {
                SetStoreListTotalItemQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aQtyAllocated);
            }
            else
            {
                aAllocationProfile.SetStoreListTotalItemQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aQtyAllocated);
            }
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for stores in specified Grade in specified StoreGrpLvl on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <param name="aVolumeGrade">Volume Grade</param>
        /// <param name="aQtyAllocated">Quantity Allocated</param>
        public void SetStoreListTotalItemQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aQtyAllocated)
        {
            SetStoreListTotalItemQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreList on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreGrpRID">RID for StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated</param>
        public void SetStoreListTotalItemQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, int aQtyAllocated)
        {
            SetStoreListTotalItemQtyAllocated(
                aComponent,
                Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID),  //MID Track 5820 - Unhandled Exception After Store Activation
                aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreList on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreList">ProfileList of stores for which a total is to be set.</param>
        /// <param name="aQtyAllocated">Total Item QuantityAllocated</param>
        internal void SetStoreListTotalItemQtyAllocated(
            GeneralComponent aComponent,
            ProfileList aStoreList,
            int aQtyAllocated)
        {
            this.SpreadStoreListTotalItemQtyAllocated(aComponent, aStoreList, aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreList on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreGrpRID">RID for StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated</param>
        /// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        public void SetStoreListTotalItemQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID, int aQtyAllocated)
        {
            SetStoreListTotalItemQtyAllocated(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), aQtyAllocated); //MID Track 5820 - Unhandled Exception After Store Activation
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreList on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreList">Profile List of stores for which a total is to be set.</param>
        /// <param name="aQtyAllocated">Total Item Quantity Allocated</param>
        internal void SetStoreListTotalItemQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode,
            ProfileList aStoreList, int aQtyAllocated)
        {
            GeneralComponent gc;
            switch (aAllocationSummaryNode)
            {
                case (eAllocationSummaryNode.Bulk):
                    {
                        gc = new GeneralComponent(eComponentType.Bulk);
                        break;
                    }
                case (eAllocationSummaryNode.DetailType):
                    {
                        gc = new GeneralComponent(eComponentType.DetailType);
                        break;
                    }
                case (eAllocationSummaryNode.GenericType):
                    {
                        gc = new GeneralComponent(eComponentType.GenericType);
                        break;
                    }
                case (eAllocationSummaryNode.Total):
                    {
                        gc = new GeneralComponent(eComponentType.Total);
                        break;
                    }
                case (eAllocationSummaryNode.Type):
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_TypeTtlReadOnly),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_TypeTtlReadOnly));
                    }
                case (eAllocationSummaryNode.DetailSubType):
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_DetailSubTypeTtlReadOnly),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_DetailSubTypeTtlReadOnly));
                    }
                case (eAllocationSummaryNode.BulkColorTotal):
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_AllColorsTtlReadOnly),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllColorsTtlReadOnly));
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownAllocationSummaryNode),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownAllocationSummaryNode));
                    }
            }
            this.SetStoreListTotalItemQtyAllocated(gc, aStoreList, aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreList on specified pack node.
        /// </summary>
        /// <param name="aPackName">Pack name.</param>
        /// <param name="aStoreGrpRID">RID for Store Group</param>
        /// <param name="aStoreGrpLvlRID">RID for Store Group Level</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated.</param>
        /// <remarks>Values interfaced via this method instance are assumed to be manually specified by the user.</remarks>
        public void SetStoreListTotalItemQtyAllocated(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID, int aQtyAllocated)
        {
            SetStoreListTotalItemQtyAllocated
                (aPackName,
                Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
                aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreList on specified pack node.
        /// </summary>
        /// <param name="aPackName">Pack name.</param>
        /// <param name="aStoreList">Profile List of storess</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated</param>
        internal void SetStoreListTotalItemQtyAllocated(string aPackName, ProfileList aStoreList, int aQtyAllocated)
        {
            SetStoreListTotalItemQtyAllocated(GetSubtotalPackHdr(aPackName), aStoreList, aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreList on specified pack node.
        /// </summary>
        /// <param name="aPack">Pack header object where StoreListTotal resides.</param>
        /// <param name="aStoreList">Profile lists of stores</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated.</param>
        internal void SetStoreListTotalItemQtyAllocated(PackHdr aPack, ProfileList aStoreList, int aQtyAllocated)
        {
            AllocationPackComponent packComponent = new AllocationPackComponent(aPack.PackName);
            this.SpreadStoreListTotalItemQtyAllocated(packComponent, aStoreList, aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aColorRID">RID for the color.</param>
        /// <param name="aStoreGrpRID">RID for the StoreGroup</param>
        /// <param name="aStoreGrpLvlRID">RID for the StoreGroup Level.</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated</param>
        public void SetStoreListTotalItemQtyAllocated(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID, int aQtyAllocated)
        {
            SetStoreListTotalItemQtyAllocated
                (aColorRID,
                Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
                aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aColorRID">RID for the color.</param>
        /// <param name="aStoreList">Profile List of stores</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated</param>
        internal void SetStoreListTotalItemQtyAllocated(int aColorRID, ProfileList aStoreList, int aQtyAllocated)
        {
            SetStoreListTotalItemQtyAllocated
                (this.GetSubtotalHdrColorBin(aColorRID),
                aStoreList,
                aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreListTotal on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color.</param>
        /// <param name="aStoreList">Profile List of stores</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated</param>
        internal void SetStoreListTotalItemQtyAllocated(HdrColorBin aColor, ProfileList aStoreList, int aQtyAllocated)
        {
            AllocationColorOrSizeComponent colorComponent =
                new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColor.ColorCodeRID);
            this.SpreadStoreListTotalItemQtyAllocated(colorComponent, aStoreList, aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreListTotal on specified color-size node.
        /// </summary>
        /// <param name="aColorRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreGrpRID">RID for Store Group</param>
        /// <param name="aStoreGrpLvlRID">RID for Store Group Level</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated.</param>
        public void SetStoreListTotalItemQtyAllocated(int aColorRID, int aSizeRID, int aStoreGrpRID, int aStoreGrpLvlRID, int aQtyAllocated)
        {
            SetStoreListTotalItemQtyAllocated
                (aColorRID,
                aSizeRID,
                Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), //MID Track 5820 - Unhandled Exception After Store Activation
                aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated audit flag for specified StoreListTotal on specified color-size node.
        /// </summary>
        /// <param name="aColorRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreList">Profile List of stores</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated</param>
        internal void SetStoreListTotalItemQtyAllocated(int aColorRID, int aSizeRID, ProfileList aStoreList, int aQtyAllocated)
        {
            SetStoreListTotalItemQtyAllocated
                (GetSubtotalHdrColorBin(aColorRID),
                aSizeRID,
                aStoreList,
                aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreListTotal on specified color-size node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreList">Profile List of stores.</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated.</param>
        internal void SetStoreListTotalItemQtyAllocated(HdrColorBin aColor, int aSizeRID, ProfileList aStoreList, int aQtyAllocated)
        {
            SetStoreListTotalItemQtyAllocated
                (aColor.GetSizeBin(aSizeRID),
                aStoreList,
                aQtyAllocated);
        }

        /// <summary>
        /// Sets StoreListTotal Item Quantity Allocated for specified StoreList on specified color-size node.
        /// </summary>
        /// <param name="aSize">HdrSizeBin for the size where the StoreList resides.</param>
        /// <param name="aStoreList">Profile List of stores</param>
        /// <param name="aQtyAllocated">Item Quantity Allocated</param>
        internal void SetStoreListTotalItemQtyAllocated(HdrSizeBin aSize, ProfileList aStoreList, int aQtyAllocated)
        {
            AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aSize.Color.ColorCodeRID);
            AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSize.SizeCodeRID); // Assortment: color/size changes
            AllocationColorSizeComponent colorSizeComponent = new AllocationColorSizeComponent(colorComponent, sizeComponent);
            this.SpreadStoreListTotalItemQtyAllocated(colorSizeComponent, aStoreList, aQtyAllocated);
        }
        #endregion SetStoreListTotalItemQuantityAllocated
        #endregion StoreListTotalItemQuantityAllocated

        #region StoreListTotalImoQuantityAllocated
        #region GetStoreListTotalImoQuantityAllocated
        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified Volume Grade in specified StoreGrpLvl on specified component of the specified Allocation Profile.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile</param>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <param name="aVolumeGrade">Volume Grade</param>
        /// <returns>Imo Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
        public int GetStoreListTotalImoQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
        {
            if (aAllocationProfile == null)
            {
                return GetStoreListTotalImoQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
            }
            return aAllocationProfile.GetStoreListTotalImoQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified Volume Grade in specified StoreGrpLvl on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <param name="aVolumeGrade">Volume Grade</param>
        /// <returns>Imo Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
        public int GetStoreListImoTotalQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
        {
            return GetStoreListTotalImoQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreGrpLvl on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <returns>Imo Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
        public int GetStoreListTotalImoQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalImoQtyAllocated(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID));
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified Store List on specified component.
        /// </summary>
        /// <param name="aComponent">Description of the component</param>
        /// <param name="aStoreList">List of Stores for which a total is desired.</param>
        /// <returns>Total Imo Quantity Allocated across all stores in the list for the specified component.</returns>
        internal int GetStoreListTotalImoQtyAllocated(GeneralComponent aComponent, ProfileList aStoreList)
        {
            int allocated = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    allocated += GetStoreImoQtyAllocated(aComponent, storeIdxRID);
                }
            }
            return allocated;
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreGrpRID">RID for StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
        /// <returns>Total Imo Quantity Allocated to the StoreList for the specified node.</returns>
        public int GetStoreListTotalImoQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalImoQtyAllocated(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID));
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified node.
        /// </summary>
        /// <param name="aAllocationSummaryNode">Allocation summary node.</param>
        /// <param name="aStoreList">StoreList for which a total is desired</param>
        /// <returns>Total Imo Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalImoQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, ProfileList aStoreList)
        {
            int allocated = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    allocated += GetStoreImoQtyAllocated(aAllocationSummaryNode, storeIdxRID);
                }
            }
            return allocated;
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified pack node.
        /// </summary>
        /// <param name="aPackName">Pack name.</param>
        /// <param name="aStoreGrpRID">RID for StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl.</param>
        /// <returns>Total Imo Quantity Allocated to the StoreList for the specified node.</returns>
        public int GetStoreListTotalImoQtyAllocated(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalImoQtyAllocated(aPackName, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified pack node.
        /// </summary>
        /// <param name="aPackName">Pack name.</param>
        /// <param name="aStoreList">Profile List of stores for which a total allocation is desired</param>
        /// <returns>Total Imo Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalImoQtyAllocated(string aPackName, ProfileList aStoreList)
        {
            return GetStoreListTotalImoQtyAllocated(GetSubtotalPackHdr(aPackName), aStoreList);
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified pack node.
        /// </summary>
        /// <param name="aPack">Pack header object where StoreList resides.</param>
        /// <param name="aStoreList">Profile list of stores for which a total allocation is desired</param>
        /// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalImoQtyAllocated(PackHdr aPack, ProfileList aStoreList)
        {
            int allocated = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    allocated += GetStoreImoQtyAllocated(aPack, storeIdxRID);
                }
            }
            return allocated;
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aColorRID">RID for the color.</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
        /// <returns>Imo Quantity Allocated to the StoreList for the specified node.</returns>
        public int GetStoreListTotalImoQtyAllocated(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalImoQtyAllocated(aColorRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aColorRID">RID for the color.</param>
        /// <param name="aStoreList">Profile list for the Stores for which a total is desired.</param>
        /// <returns>Imo Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalImoQtyAllocated(int aColorRID, ProfileList aStoreList)
        {
            return GetStoreListTotalImoQtyAllocated(GetSubtotalHdrColorBin(aColorRID), aStoreList);
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color.</param>
        /// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
        /// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalImoQtyAllocated(HdrColorBin aColor, ProfileList aStoreList)
        {
            int allocated = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    allocated += GetStoreImoQtyAllocated(aColor, storeIdxRID);
                }
            }
            return allocated;
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified color-size node.
        /// </summary>
        /// <param name="aColorRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreGrpRID">RID for the StoreGrp</param>
        /// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
        /// <returns>Imo Quantity Allocated to the StoreList for the specified node.</returns>
        public int GetStoreListTotalImoQtyAllocated(int aColorRID, int aSizeRID, int aStoreGrpRID, int aStoreGrpLvlRID)
        {
            return GetStoreListTotalImoQtyAllocated(aColorRID, aSizeRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified color-size node.
        /// </summary>
        /// <param name="aColorRID">RID for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
        /// <returns>Total Imo Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalImoQtyAllocated(int aColorRID, int aSizeRID, ProfileList aStoreList)
        {
            return GetStoreListTotalImoQtyAllocated(GetSubtotalHdrColorBin(aColorRID), aSizeRID, aStoreList);
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aColor">HdrColorBin for the color where the size resides.</param>
        /// <param name="aSizeRID">RID for the size.</param>
        /// <param name="aStoreList">ProfileList of stores for which a total is desired</param>
        /// <returns>Total Imo Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalImoQtyAllocated(HdrColorBin aColor, int aSizeRID, ProfileList aStoreList)
        {
            return GetStoreListTotalImoQtyAllocated(aColor.GetSizeBin(aSizeRID), aStoreList);
        }

        /// <summary>
        /// Gets StoreListTotal Imo Quantity Allocated for specified StoreList on specified color node.
        /// </summary>
        /// <param name="aSize">HdrSizeBin for the size where the StoreList resides.</param>
        /// <param name="aStoreList">ProfileList of stores for which a total is desired.</param>
        /// <returns>Total Imo Quantity Allocated to the StoreList for the specified node.</returns>
        internal int GetStoreListTotalImoQtyAllocated(HdrSizeBin aSize, ProfileList aStoreList)
        {
            int allocated = 0;
            Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                if (this.StoreIsVisible(storeIdxRID))
                {
                    allocated += GetStoreImoQtyAllocated(aSize, storeIdxRID);
                }
            }
            return allocated;
        }
        #endregion GetStoreListTotalITemQuantityAllocated

        #endregion StoreListTotalImoQuantityAllocated
        // end TT#1401 - Jellis - Urban Reservation Store pt 7

		#region StoreListTotalOrigQuantityAllocated
		//===================================//
		// Total Original Quantity Allocated //
		//===================================//
		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified Volume Grade in specified StoreGrpLvl on specified component of the specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
		public int GetStoreListTotalOrigQtyAllocated(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreListTotalOrigQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
			}
			else
			{
				return aAllocationProfile.GetStoreListTotalOrigQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
			}
		}
		
		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified Volume Grade in specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
		public int GetStoreListTotalOrigQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalOrigQtyAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}


		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>Quantity Allocated to the StoreGrpLvl for the specified component.</returns>
		public int GetStoreListTotalOrigQtyAllocated(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOrigQtyAllocated(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified Store List on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">List of Stores for which a total is desired.</param>
		/// <returns>Total Quantity Allocated across all stores in the list for the specified component.</returns>
		internal int GetStoreListTotalOrigQtyAllocated(GeneralComponent aComponent, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreOrigQtyAllocated(aComponent, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		public int GetStoreListTotalOrigQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOrigQtyAllocated(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreList">StoreList for which a total is desired</param>
		/// <returns>Total Original Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalOrigQtyAllocated(eAllocationSummaryNode aAllocationSummaryNode, ProfileList aStoreList)
		{
			int allocated =0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreOrigQtyAllocated(aAllocationSummaryNode, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl.</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		public int GetStoreListTotalOrigQtyAllocated(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOrigQtyAllocated(aPackName, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreList">Profile List of stores for which a total allocation is desired</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalOrigQtyAllocated(string aPackName, ProfileList aStoreList)
		{
			return GetStoreListTotalOrigQtyAllocated(GetSubtotalPackHdr(aPackName), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where StoreList resides.</param>
		/// <param name="aStoreList">Profile list of stores for which a total allocation is desired</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalOrigQtyAllocated(PackHdr aPack, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreOrigQtyAllocated(aPack, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
		/// <returns>Quantity Allocated to the StoreList for the specified node.</returns>
		public int GetStoreListTotalOrigQtyAllocated(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOrigQtyAllocated(aColorRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreList">Profile list for the Stores for which a total is desired.</param>
		/// <returns>Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalOrigQtyAllocated(int aColorRID, ProfileList aStoreList)
		{
			return GetStoreListTotalOrigQtyAllocated(GetSubtotalHdrColorBin(aColorRID), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalOrigQtyAllocated(HdrColorBin aColor, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
            foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreOrigQtyAllocated(aColor, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified color-size node.
		/// </summary>
		/// <param name="aColorRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
		/// <returns>Quantity Allocated to the StoreList for the specified node.</returns>
		public int GetStoreListTotalOrigQtyAllocated(int aColorRID, int aSizeRID, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalOrigQtyAllocated(aColorRID, aSizeRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified color-size node.
		/// </summary>
		/// <param name="aColorRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalOrigQtyAllocated(int aColorRID, int aSizeRID, ProfileList aStoreList)
		{
			return GetStoreListTotalOrigQtyAllocated(GetSubtotalHdrColorBin(aColorRID), aSizeRID, aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Original Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <param name="aStoreList">ProfileList of stores for which a total is desired</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalOrigQtyAllocated(HdrColorBin aColor, int aSizeRID, ProfileList aStoreList)
		{
			return GetStoreListTotalOrigQtyAllocated(aColor.GetSizeBin(aSizeRID), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the StoreList resides.</param>
		/// <param name="aStoreList">ProfileList of stores for which a total is desired.</param>
		/// <returns>Total Quantity Allocated to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalOrigQtyAllocated(HdrSizeBin aSize, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
                    allocated += GetStoreOrigQtyAllocated(aSize.Color, aSize.SizeCodeRID, storeIdxRID); // Assortment: color/size changes
				}
			}
			return allocated;
		}
		#endregion StoreListTotalQuantityAllocated

		#region StoreListTotalQuantityAllocatedByRule
		//==================================//
		// Total Quantity Allocated By Rule //
		//==================================//
		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified Volume Grade in StoreGrpLvl on specified component of the specified Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Quantity Allocated By Rule to the StoreGrpLvl for the specified component.</returns>
		public int GetStoreListTotalQtyAllocatedByRule(AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreListTotalQtyAllocatedByRule(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
			}
			return aAllocationProfile.GetStoreListTotalQtyAllocatedByRule(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}
		
		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified Volume Grade in StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Quantity Allocated By Rule to the StoreGrpLvl for the specified component.</returns>
		public int GetStoreListTotalQtyAllocatedByRule(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalQtyAllocatedByRule(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		
		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified StoreGrpLvl on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>Quantity Allocated By Rule to the StoreGrpLvl for the specified component.</returns>
		public int GetStoreListTotalQtyAllocatedByRule(GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalQtyAllocatedByRule(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified Store List on specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">List of Stores for which a total is desired.</param>
		/// <returns>Total Quantity Allocated By Rule across all stores in the list for the specified component.</returns>
		internal int GetStoreListTotalQtyAllocatedByRule(GeneralComponent aComponent, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible (storeIdxRID))
				{
					allocated += GetStoreQtyAllocatedByRule(aComponent, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl</param>
		/// <returns>Total Quantity Allocated By Rule to the StoreList for the specified node.</returns>
		public int GetStoreListTotalQtyAllocatedByRule(eAllocationSummaryNode aAllocationSummaryNode, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalQtyAllocatedByRule(aAllocationSummaryNode, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified StoreList on specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <param name="aStoreList">StoreList for which a total is desired</param>
		/// <returns>Total Quantity Allocated By Rule to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocatedByRule(eAllocationSummaryNode aAllocationSummaryNode, ProfileList aStoreList)
		{
			int allocated =0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreQtyAllocatedByRule(aAllocationSummaryNode, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreGrpRID">RID for StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for StoreGrpLvl.</param>
		/// <returns>Total Quantity Allocated By Rule to the StoreList for the specified node.</returns>
		public int GetStoreListTotalQtyAllocatedByRule(string aPackName, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalQtyAllocatedByRule(aPackName, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <param name="aStoreList">Profile List of stores for which a total allocation is desired</param>
		/// <returns>Total Quantity Allocated By Rule to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocatedByRule(string aPackName, ProfileList aStoreList)
		{
			return GetStoreListTotalQtyAllocatedByRule(GetSubtotalPackHdr(aPackName), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified StoreList on specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where StoreList resides.</param>
		/// <param name="aStoreList">Profile list of stores for which a total allocation is desired</param>
		/// <returns>Total Quantity Allocated By Rule to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocatedByRule(PackHdr aPack, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreQtyAllocatedByRule(aPack, storeIdxRID);
				}
			}
			return allocated;
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreGrpRID">RID for the StoreGrp</param>
		/// <param name="aStoreGrpLvlRID">RID for the StoreGrpLvl</param>
		/// <returns>Quantity Allocated By Rule to the StoreList for the specified node.</returns>
		public int GetStoreListTotalQtyAllocatedByRule(int aColorRID, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalQtyAllocatedByRule(aColorRID, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <param name="aStoreList">Profile list for the Stores for which a total is desired.</param>
		/// <returns>Quantity Allocated By Rule to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocatedByRule(int aColorRID, ProfileList aStoreList)
		{
			return GetStoreListTotalQtyAllocatedByRule(GetSubtotalHdrColorBin(aColorRID), aStoreList);
		}

		/// <summary>
		/// Gets StoreListTotal Quantity Allocated By Rule for specified StoreList on specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <param name="aStoreList">Profile list of stores for which a total is desired.</param>
		/// <returns>Total Quantity Allocated By Rule to the StoreList for the specified node.</returns>
		internal int GetStoreListTotalQtyAllocatedByRule(HdrColorBin aColor, ProfileList aStoreList)
		{
			int allocated = 0;
			Index_RID storeIdxRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIdxRID))
				{
					allocated += GetStoreQtyAllocatedByRule(aColor, storeIdxRID);
				}
			}
			return allocated;
		}
		#endregion StoreListTotalQuantityAllocated

		#region StoreListTotalStoreCount
		/// <summary>
		/// Gets number of stores with an allocation for the specified component, store group, store group level and volume grade.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Number of stores satisfying specified criteria and having an allocation OR if allocation is zero number of non-out eligible stores</returns>
		public int GetStoreListTotalStoreCount (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalStoreCount(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		/// <summary>
		/// Gets number of stores with an allocation for the specified component, store group, and store group level.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <returns>Number of stores satisfying specified criteria and having an allocation OR if allocation is zero number of non-out eligible stores</returns>
		public int GetStoreListTotalStoreCount (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalStoreCount(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets number of stores with an allocation for the specified component and store list.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">List of stores</param>
		/// <returns>Number of stores satisfying specified criteria and having an allocation OR if allocation is zero number of non-out eligible stores</returns>
		public int GetStoreListTotalStoreCount (GeneralComponent aComponent, ProfileList aStoreList)
		{
			int storeCount = 0;
			foreach (StoreProfile sp in aStoreList)
			{
				if (this.GetStoreQtyAllocated(aComponent, sp.Key) > 0)
				{
					storeCount += 1;
				}
			}
			if (storeCount == 0)
			{
				return this.GetStoreListTotalEligibleCount(aComponent, aStoreList);
			}
			return storeCount;
		}

		/// <summary>
		/// Gets number of stores with an allocation for the specified allocation profile, component, store group, and store group level.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <returns>Number of stores satisfying specified criteria and having an allocation OR if allocation is zero number of non-out eligible stores</returns>
		public int GetStoreListTotalStoreCount (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalStoreCount(aAllocationProfile, aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets number of stores with an allocation for the specified allocation profile, component, store group,store group level, and volume grade.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Number of stores satisfying specified criteria and having an allocation OR if allocation is zero number of non-out eligible stores</returns>
		public int GetStoreListTotalStoreCount (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreListTotalStoreCount(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
			}
			return GetStoreListTotalStoreCount (aAllocationProfile, aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}
		 
		/// <summary>
		/// Gets number of stores with an allocation for the specified allocation profile, component, store group,store group level, and volume grade.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">List of stores to check</param>
		/// <returns>Number of stores satisfying specified criteria and having an allocation OR if allocation is zero number of non-out eligible stores</returns>
		public int GetStoreListTotalStoreCount (AllocationProfile aAllocationProfile, GeneralComponent aComponent, ProfileList aStoreList)
		{
			int storeCount = 0;
			foreach (StoreProfile sp in aStoreList)
			{
				if (this.GetStoreQtyAllocated(aAllocationProfile, aComponent, sp.Key) > 0)
				{
					storeCount += 1;
				}
			}
			if (storeCount == 0)
			{
				return this.GetStoreListTotalEligibleCount(aAllocationProfile, aComponent, aStoreList);
			}
			return storeCount;
		}

		/// <summary>
		/// Gets number of stores with a positive onhand or intransit
		/// </summary>
		/// <param name="aIKT">Intransit Key Type to use to identify the onhand or intransit (TOTAL, Color or Size)</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aOnHandStoreCount">True: count stores with onhand; False: count stores with intransit</param>
		/// <returns>Number of stores with positive onhand or intransit</returns>
		public int GetStoreListTotalStoreCount (IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, bool aOnHandStoreCount)
		{
			return GetStoreListTotalStoreCount (aIKT, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aOnHandStoreCount);
		}

		/// <summary>
		/// Gets number of stores with a positive onhand or intransit
		/// </summary>
		/// <param name="aIKT">Intransit Key Type to use to identify the onhand or intransit (TOTAL, Color or Size)</param>
		/// <param name="aStoreList">Profile list of stores</param>
		/// <param name="aOnHandStoreCount">True: count stores with onhand; False: count stores with intransit</param>
		/// <returns>Number of stores with positive onhand or intransit</returns>
		public int GetStoreListTotalStoreCount (IntransitKeyType aIKT, ProfileList aStoreList, bool aOnHandStoreCount)
		{
			int storeCount = 0;
			if (aOnHandStoreCount)
			{
				foreach (StoreProfile sp in aStoreList)
				{
					if (GetStoreOnHand(aIKT, StoreIndex(sp.Key)) > 0 &&
						GetStoreIsEligible(sp.Key))
					{
						storeCount += 1;
					}
				}
			}
			else
			{
				foreach (StoreProfile sp in aStoreList)
				{
					if (this.GetStoreInTransit(aIKT, sp.Key) > 0)
					{
						storeCount += 1;
					}
				}
			}
			return storeCount;
		}

		/// <summary>
		/// Gets number of stores with positive need (before or after allocation)
		/// </summary>
		/// <param name="aNeedAfterAllocation">True: Get need after allocation; False: Get need before allocation</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Number of stores with positive need</returns>
		public int GetStoreListTotalStoreCount (bool aNeedAfterAllocation, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalStoreCount (aNeedAfterAllocation, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		/// <summary>
		/// Gets number of stores with positive need (before or after allocation)
		/// </summary>
		/// <param name="aNeedAfterAllocation">True: Get need after allocation; False: Get need before allocation</param>
		/// <param name="aStoreList">Profile List of stores</param>
		/// <returns>Number of stores with positive need</returns>
		public int GetStoreListTotalStoreCount (bool aNeedAfterAllocation, ProfileList aStoreList)
		{
			int storeCount = 0;
			if (aNeedAfterAllocation)
			{
				foreach (StoreProfile sp in aStoreList)
				{
					if (this.GetStoreUnitNeed(sp.Key) > 0)
					{
						storeCount += 1;
					}
				}
			}
			else
			{
				foreach (StoreProfile sp in aStoreList)
				{
					if (this.GetStoreUnitNeed(sp.Key) > this.GetStoreQtyAllocated(eAllocationSummaryNode.Total, sp.Key))
					{
						storeCount += 1;
					}
				}
			}
			return storeCount;
		}
		#endregion StoreListTotalStoreCount

		#region StoreListTotalEligibleCount
		/// <summary>
		/// Gets number of stores eligible for the specified component, store group, store group level and volume grade.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Number of eligible non-out stores satisfying specified criteria</returns>
		public int GetStoreListTotalEligibleCount (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalEligibleCount(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		/// <summary>
		/// Gets number of stores eligible for the specified component, store group, and store group level.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <returns>Number of eligible non-out stores satisfying specified criteria</returns>
		public int GetStoreListTotalEligibleCount (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalEligibleCount(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets number of stores eligible for the specified component and store list.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">List of stores</param>
		/// <returns>Number of eligible non-out stores satisfying specified criteria</returns>
		public int GetStoreListTotalEligibleCount (GeneralComponent aComponent, ProfileList aStoreList)
		{
			int storeCount = 0;
			foreach (StoreProfile sp in aStoreList)
			{
				if (this.GetStoreIsEligible(sp.Key) &&
                    GetIncludeStoreInAllocation(sp.Key) &&  // TT#1401 - JEllis - Urban Reservation Store pt 11
					!this.GetStoreOut(aComponent, sp.Key))
				{
					storeCount += 1;
				}
			}
			return storeCount;
		}

		/// <summary>
		/// Gets number of stores eligible for the specified allocation profile, component, store group, and store group level.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <returns>Number of eligible non-out stores satisfying specified criteria</returns>
		public int GetStoreListTotalEligibleCount (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalEligibleCount(aAllocationProfile, aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets number of stores eligible for the specified allocation profile, component, store group,store group level, and volume grade.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Number of eligible non-out stores satisfying specified criteria</returns>
		public int GetStoreListTotalEligibleCount (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreListTotalEligibleCount(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
			}
			return GetStoreListTotalEligibleCount (aAllocationProfile, aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}
		 
		/// <summary>
		/// Gets number of stores eligible for the specified allocation profile, component, store group,store group level, and volume grade.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <param name="aStoreList">List of stores to check</param>
		/// <returns>Number of eligible non-out stores satisfying specified criteria</returns>
		public int GetStoreListTotalEligibleCount (AllocationProfile aAllocationProfile, GeneralComponent aComponent, ProfileList aStoreList)
		{
			int storeCount = 0;
			foreach (StoreProfile sp in aStoreList)
			{
				if (this.GetStoreIsEligible(sp.Key) &&
                    aAllocationProfile.GetIncludeStoreInAllocation(sp.Key) && // TT#1401 - JEllis - Urban Reservation Store pt 11
					!this.GetStoreOut(aAllocationProfile, aComponent, sp.Key))
				{
					storeCount += 1;
				}
			}
			return storeCount;
		}
		#endregion StoreListTotalEligibleCount

		#region StoreListAverageAllocation
		#region GetStoreListAverageAllocation
		/// <summary>
		/// Gets the average allocation for a specified set of stores with same volume grade for a specified component across all allocation profiles in the total 
		/// </summary>
		/// <param name="aComponent">Description of the component.</param>
		/// <param name="aStoreGrpRID">RID of the store Group </param>
		/// <param name="aStoreGrpLvlRID">RID of the store Group Level</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Average store allocation on the component for stores satisfying other criteria</returns>
		public int GetStoreListTotalAvgAllocated (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalAvgAllocated (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}
		
		/// <summary>
		/// Gets the average allocation for a specified set of stores for a specified component across all allocation profiles in the total 
		/// </summary>
		/// <param name="aComponent">Description of the component.</param>
		/// <param name="aStoreGrpRID">RID of the store Group </param>
		/// <param name="aStoreGrpLvlRID">RID of the store Group Level</param>
		/// <returns>Average store allocation on the component for stores satisfying other criteria</returns>
		public int GetStoreListTotalAvgAllocated (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalAvgAllocated(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Gets the average allocation for a specified set of stores for a specified component across all allocation profiles in the total 
		/// </summary>
		/// <param name="aComponent">Description of the component.</param>
		/// <param name="aStoreList">List of stores</param>
		/// <returns>Average store allocation on the component for stores in the list with an allocation.</returns>
		public int GetStoreListTotalAvgAllocated (GeneralComponent aComponent, ProfileList aStoreList)
		{
			int storeCount = this.GetStoreListTotalStoreCount(aComponent, aStoreList);
			if (storeCount > 0)
			{
				return (int)
					((double)this.GetStoreListTotalQtyAllocated(aComponent, aStoreList)
					/ (double) storeCount);
			}
			return 0;
		}

		/// <summary>
		/// Gets the average allocation for  a specified set of stores for a specified component in a given allocation profile.
		/// </summary>
		/// <param name="aAllocationProfile">The Allocation Profile</param>
		/// <param name="aComponent">The Component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <returns>Average allocation for specified set of stores on the specified component of the allocation profile</returns>
		public int GetStoreListTotalAvgAllocated (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreListTotalAvgAllocated(aComponent, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
			}
			return GetStoreListTotalAvgAllocated(aAllocationProfile, aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		/// <summary>
		/// Gets the average allocation for  a specified set of stores for a specified component in a given allocation profile.
		/// </summary>
		/// <param name="aAllocationProfile">The Allocation Profile</param>
		/// <param name="aComponent">The Component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <returns>Average allocation for specified set of stores on the specified component of the allocation profile</returns>
		public int GetStoreListTotalAvgAllocated (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID)
		{
			return GetStoreListTotalAvgAllocated(aAllocationProfile, aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID)); //MID Track 5820 - Unhandled Exception After Store Activation
		}
		
		/// <summary>
		/// Gets the average allocation for  a specified set of stores for a specified component in a given allocation profile.
		/// </summary>
		/// <param name="aAllocationProfile">The Allocation Profile</param>
		/// <param name="aComponent">The Component</param>
		/// <param name="aStoreList">List of stores</param>
		/// <returns>Average allocation for specified set of stores on the specified component of the allocation profile</returns>
		private int GetStoreListTotalAvgAllocated (AllocationProfile aAllocationProfile, GeneralComponent aComponent, ProfileList aStoreList)
		{
			int storeCount = this.GetStoreListTotalStoreCount(aAllocationProfile, aComponent, aStoreList);
			if (storeCount > 0)
			{
				return (int) 
					((double) aAllocationProfile.GetStoreListTotalQtyAllocated(aComponent, aStoreList)
					/ (double) storeCount);
			}
			return 0;
		}
		#endregion GetStoreListAverageAllocation

		#region SetStoreListAverageAllocation
		/// <summary>
		/// Sets the average allocation for a specified set of stores with same volume grade for a specified component across all allocation profiles in the total 
		/// </summary>
		/// <param name="aComponent">Description of the component.</param>
		/// <param name="aStoreGrpRID">RID of the store Group </param>
		/// <param name="aStoreGrpLvlRID">RID of the store Group Level</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aAverageQty">Average Allocation per store</param>
		public void SetStoreListTotalAvgAllocated (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aAverageQty)
		{
			SetStoreListTotalAvgAllocated (aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aAverageQty);
		}
		
		/// <summary>
		/// Sets the average allocation for a specified set of stores for a specified component across all allocation profiles in the total 
		/// </summary>
		/// <param name="aComponent">Description of the component.</param>
		/// <param name="aStoreGrpRID">RID of the store Group </param>
		/// <param name="aStoreGrpLvlRID">RID of the store Group Level</param>
		/// <param name="aAverageQty">Average Allocation per store</param>
		public void SetStoreListTotalAvgAllocated (GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, int aAverageQty)
		{
			SetStoreListTotalAvgAllocated(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), aAverageQty); //MID Track 5820 - Unhandled Exception After Store Activation
		}

		/// <summary>
		/// Sets the average allocation for a specified set of stores for a specified component across all allocation profiles in the total 
		/// </summary>
		/// <param name="aComponent">Description of the component.</param>
		/// <param name="aStoreList">List of stores</param>
		/// <param name="aAverageQty">Average Allocation per store</param>
		public void SetStoreListTotalAvgAllocated (GeneralComponent aComponent, ProfileList aStoreList, int aAverageQty)
		{
			int storeCount = this.GetStoreListTotalStoreCount(aComponent, aStoreList);
			if (this.GetStoreListTotalQtyAllocated(aComponent, aStoreList) > 0)
			{
				this.SetStoreListTotalQtyAllocated(
					aComponent,
					aStoreList,
					aAverageQty * storeCount);
			}
			else
			{
				foreach (StoreProfile sp in aStoreList)
				{
					if (this.GetStoreIsEligible(sp.Key) &&
                        GetIncludeStoreInAllocation(sp.Key) && // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28A
						!this.GetStoreOut(aComponent, sp.Key))
					{
						this.SetStoreQtyAllocated(aComponent, sp.Key, aAverageQty);
					}
				}
			}
		}

		/// <summary>
		/// Sets the average allocation for  a specified set of stores for a specified component in a given allocation profile.
		/// </summary>
		/// <param name="aAllocationProfile">The Allocation Profile</param>
		/// <param name="aComponent">The Component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aVolumeGrade">Volume Grade</param>
		/// <param name="aAverageQty">Average Allocation per store</param>
		public void SetStoreListTotalAvgAllocated (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aAverageQty)
		{
			if (aAllocationProfile == null)
			{
				SetStoreListTotalAvgAllocated(aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aAverageQty);
			}
			else
			{
				SetStoreListTotalAvgAllocated(aAllocationProfile, aComponent, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade), aAverageQty);
			}
		}

		/// <summary>
		/// Sets the average allocation for  a specified set of stores for a specified component in a given allocation profile.
		/// </summary>
		/// <param name="aAllocationProfile">The Allocation Profile</param>
		/// <param name="aComponent">The Component</param>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID</param>
		/// <param name="aAverageQty">Average Allocation per store</param>
		public void SetStoreListTotalAvgAllocated (AllocationProfile aAllocationProfile, GeneralComponent aComponent, int aStoreGrpRID, int aStoreGrpLvlRID, int aAverageQty)
		{
			if (aAllocationProfile == null)
			{
				SetStoreListTotalAvgAllocated(aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), aAverageQty); //MID Track 5820 - Unhandled Exception After Store Activation
			}
			else
			{
				SetStoreListTotalAvgAllocated(aAllocationProfile, aComponent, Transaction.GetActiveStoresInGroup(aStoreGrpRID, aStoreGrpLvlRID), aAverageQty); //MID Track 5820 - Unhandled Exception After Store Activation
			}
		}
		
		/// <summary>
		/// Sets the average allocation for  a specified set of stores for a specified component in a given allocation profile.
		/// </summary>
		/// <param name="aAllocationProfile">The Allocation Profile</param>
		/// <param name="aComponent">The Component</param>
		/// <param name="aStoreList">List of stores</param>
		/// <param name="aAverageQty">Average Allocation per store</param>
		private void SetStoreListTotalAvgAllocated (AllocationProfile aAllocationProfile, GeneralComponent aComponent, ProfileList aStoreList, int aAverageQty)
		{
			int storeCount = this.GetStoreListTotalStoreCount(aAllocationProfile, aComponent, aStoreList);
			if (aAllocationProfile.GetStoreListTotalQtyAllocated(aComponent, aStoreList) > 0)
			{
				aAllocationProfile.SetStoreListTotalQtyAllocated(
					aComponent,
					aStoreList,
					aAverageQty * storeCount);
			}
			else
			{
				foreach (StoreProfile sp in aStoreList)
				{
					if (this.GetStoreIsEligible(sp.Key) &&
                        aAllocationProfile.GetIncludeStoreInAllocation(sp.Key) &&  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28A
						!aAllocationProfile.GetStoreOut(aComponent, sp.Key))
					{
						aAllocationProfile.SetStoreQtyAllocated(aComponent, sp.Key, aAverageQty);
					}
				}
			}
		}
		#endregion SetStoreListAverageAllocation
		#endregion StoreListAverageAllocation

		#region StoreListAverageOnHand
		public int GetStoreListTotalAvgOnHand (IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalAvgOnHand (aIKT, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		public int GetStoreListTotalAvgOnHand (IntransitKeyType aIKT, ProfileList aStoreList)
		{
			int average = 0;
			int storeCount = GetStoreListTotalStoreCount(aIKT, aStoreList, true);
			double intermediateValue;
			if (storeCount > 0)
			{
				intermediateValue = 
					(double)GetStoreListTotalOnHand(aIKT,aStoreList)
					/ (double) storeCount;
				if (intermediateValue < 0)
				{
					average = (int) (intermediateValue - .5d);
				}
				else
				{
					average = (int) (intermediateValue + .5d);
				}
			}
			return average;
		}
		#endregion StoreList AverageOnHand

		#region StoreListAverageInTransit
		public int GetStoreListTotalAvgInTransit (IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalAvgInTransit (aIKT, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		public int GetStoreListTotalAvgInTransit (IntransitKeyType aIKT, ProfileList aStoreList)
		{
			int average = 0;
			int storeCount = GetStoreListTotalStoreCount(aIKT, aStoreList, false);
			double intermediateValue;
			if (storeCount > 0)
			{
				intermediateValue = 
					(double)this.GetStoreListTotalInTransit(aIKT,aStoreList)
					/ (double) storeCount;
				if (intermediateValue < 0)
				{
					average = (int) (intermediateValue - .5d);
				}
				else
				{
					average = (int)(intermediateValue + .5d);
				}
			}
			return average;
		}
		#endregion StoreListAverageInTransit

		#region StoreListAverageNeed
		public int GetStoreListTotalAvgNeed (bool aNeedAfterAllocation, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalAvgNeed (aNeedAfterAllocation, this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}

		public int GetStoreListTotalAvgNeed(bool aNeedAfterAllocation, ProfileList aStoreList)
		{
			int average = 0;
			int storeCount = GetStoreListTotalStoreCount(aNeedAfterAllocation, aStoreList);
			if (storeCount > 0)
			{
				// this average is not quite right since some store needs may be negative!
				double intermediateValue;
				if (aNeedAfterAllocation)
				{
					intermediateValue = 
						(double)this.GetStoreListTotalUnitNeed(aStoreList)
						/ (double) storeCount;
				}
				else
				{
					intermediateValue =
						((double)this.GetStoreListTotalUnitNeed(aStoreList)
						- (double)this.GetStoreListTotalQtyAllocated(eAllocationSummaryNode.Total, aStoreList))
						/ (double) storeCount;
				}
				if (intermediateValue < 0)
				{
					average = (int)(intermediateValue - .5d);
				}
				else
				{
					average = (int)(intermediateValue + .5d);
				}
			}
			return average;
		}
		#endregion StoreListAverageNeed

        private bool _writeDebug = false;
		#region StoreListVelocity
		#region StoreListVelocity Total Basis Sales
		/// <summary>
		/// Gets Store List Velocity Total Basis Sales
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
		/// <param name="aVelocityGrade">Filters the store list by volume grade.</param>
		/// <returns>Velocity Total Basis Sales for the requested store List.</returns>
		public int GetStoreListVelocityTtlBasisSales(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
		{
            Debug.WriteLine("GetStoreListVelocityTtlBasisSales aStoreGrpLvlRID= " + aStoreGrpLvlRID + ",aVelocityGrade=" + aVelocityGrade);
            _writeDebug = true;
			return GetStoreListVelocityTtlBasisSales(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, aVelocityGrade));
		}
		/// <summary>
		/// Get Store List Velocity Total Basis Sales
		/// </summary>
		/// <param name="aStoreList">Store List</param>
		/// <returns>Total Basis sales for eligible stores in list</returns>
		public int GetStoreListVelocityTtlBasisSales(ProfileList aStoreList)
		{
			int basisSales = 0;
//			int basisStoreSales = 0;
//			Index_RID storeIdxRID;
//			foreach (StoreProfile sp in aStoreList)
//			{
//				storeIdxRID = StoreIndex(sp.Key);
//				if (this.GetStoreIsEligible(storeIdxRID))
//				{
//					basisSales += this.GetStoreBasisSales(storeIdxRID.RID);
//				}
//			}
			int[] basisStoreRID = new int[aStoreList.Count];
			int i = 0;
			int[] basisStoreSales;
			Index_RID[] storeIdxRIDArray = new Index_RID[aStoreList.Count];
			foreach (Index_RID storeIdxRID in this.Transaction.StoreIndexRIDArray())
			{
				if (aStoreList.Contains(storeIdxRID.RID))
				{
					basisStoreRID[i] = storeIdxRID.RID;
					storeIdxRIDArray[i] = storeIdxRID;
					i++;
				}
			}
            basisStoreSales = this.GetStoreBasisSales(basisStoreRID);
			for (int j=0; j<basisStoreRID.Length; j++)
			{
                //if (this.GetStoreIsEligible(basisStoreRID[j])               // TT#533 velocity variables not calculated correctly
                if (this.Transaction.Velocity.IncludeStoreOnMatrix(basisStoreRID[j]))   // TT#533 velocity variables not calculated correctly
                {
					basisSales += basisStoreSales[j];
				}
                if (_writeDebug)
                {
                    Debug.WriteLine("GetStoreListVelocityTtlBasisSales basisStoreRID[j]," + basisStoreRID[j] + ",basisStoreSales[j]," + basisStoreSales[j] + ",basisSales," + basisSales);
                }
			}
            _writeDebug = false;
			return basisSales;
		}
		#endregion StoreListVelocity Total Basis Sales

        //begin tt#153 - velocity matrix variables - apicchetti
        #region StoreListVelocity Total Allocated
        /// <summary>
        /// Gets Store List Velocity Total Allocated
        /// </summary>
        /// <param name="aStoreGrpRID">Store Group RID</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
        /// <param name="aVelocityGrade">Filters the store list by volume grade.</param>
        /// <returns>Velocity Total Basis Sales for the requested store List.</returns>
        public int GetStoreListVelocityTtlAllocated(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
        {
            return GetStoreListVelocityTtlAllocated(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, aVelocityGrade));
        }
        /// <summary>
        /// Get Store List Velocity Total Allocated
        /// </summary>
        /// <param name="aStoreList">Store List</param>
        /// <returns>Total Basis sales for eligible stores in list</returns>
        public int GetStoreListVelocityTtlAllocated(ProfileList aStoreList)
        {
            GeneralComponent totalComponent = new GeneralComponent(eComponentType.Total);
            int basisAllocated = 0;
            int[] basisStoreRID = new int[aStoreList.Count];
            int i = 0;

            Index_RID[] storeIdxRIDArray = new Index_RID[aStoreList.Count];
            foreach (Index_RID storeIdxRID in this.Transaction.StoreIndexRIDArray())
            {
                if (aStoreList.Contains(storeIdxRID.RID))
                {
                    basisStoreRID[i] = storeIdxRID.RID;
                    storeIdxRIDArray[i] = storeIdxRID;
                    i++;
                }
            }
            
            for (int j = 0; j < basisStoreRID.Length; j++)
            {
                //if (this.GetStoreIsEligible(basisStoreRID[j])               // TT#533 velocity variables not calculated correctly
                if (this.Transaction.Velocity.IncludeStoreOnMatrix(basisStoreRID[j]))   // TT#533 velocity variables not calculated correctly
                {
                    basisAllocated += this.GetStoreQtyAllocated(totalComponent, storeIdxRIDArray[j]);
                }
            }
            return basisAllocated;
        }
        #endregion StoreListVelocity Total Allocated
        //end tt#153 - velocity matrix variables - apicchetti

		#region StoreListVelocity Average Basis Sales
		/// <summary>
		/// Gets Store List Velocity Average Basis Sales
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
		/// <param name="aVelocityGrade">Filters the store list by volume grade.</param>
		/// <returns>Velocity Total Basis Sales for the requested store List.</returns>
		public double GetStoreListVelocityAvgBasisSales(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
		{
			return GetStoreListVelocityAvgBasisSales(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, aVelocityGrade));
		}
		/// <summary>
		/// Gets Store List Velocity Average Basis Sales
		/// </summary>
		/// <param name="aStoreList">Store Profile List</param>
		/// <returns>Velocity Average Basis Sales for eligible stores in requested store list</returns>
		public double GetStoreListVelocityAvgBasisSales(ProfileList aStoreList)
		{
			int basisSales = GetStoreListVelocityTtlBasisSales(aStoreList);
			Index_RID storeIdxRID;
			ProfileList spl = new ProfileList(eProfileType.Store);
			foreach (StoreProfile sp in aStoreList)
			{
				storeIdxRID = StoreIndex(sp.Key);
				//if (this.GetStoreIsEligible(storeIdxRID)               // TT#533 velocity variables not calculated correctly
                if (this.Transaction.Velocity.IncludeStoreOnMatrix(storeIdxRID.RID))   // TT#533 velocity variables not calculated correctly
				{
					spl.Add(sp);
				}
			}
			if (spl.Count > 0)
			{
				return (double)((double)GetStoreListVelocityTtlBasisSales(spl) / (double)spl.Count);
			}
			return 0d;
		}
		#endregion StoreListVelocity Average Basis Sales

        //BEGIN TT#153  add variables to velocity matrix - apicchetti
        #region StoreListVelocity Total Number of Stores
        /// <summary>
        /// Gets Store List Velocity Total Number of Stores
        /// </summary>
        /// <param name="aStoreGrpRID">Store Group RID</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
        /// <param name="aVelocityGrade">Filters the store list by volume grade.</param>
        /// <returns>Velocity Total Number of stores for the requested store List.</returns>
        public double GetStoreListVelocityTotalNumberOfStores(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
        {
            return GetStoreListVelocityTotalNumberOfStores(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, aVelocityGrade));
        }
        /// <summary>
        /// Gets Store List Velocity Total Number of stores
        /// </summary>
        /// <param name="aStoreList">Store Profile List</param>
        /// <returns>Velocity Average total number of stores for eligible stores in requested store list</returns>
        public double GetStoreListVelocityTotalNumberOfStores(ProfileList aStoreList)
        {
            Index_RID storeIdxRID;
            ProfileList spl = new ProfileList(eProfileType.Store);
            foreach (StoreProfile sp in aStoreList)
            {
                if (this.Transaction.ReserveStore.RID != sp.Key)
                {
                    storeIdxRID = StoreIndex(sp.Key);
				//if (this.GetStoreIsEligible(storeIdxRID)               // TT#533 velocity variables not calculated correctly
                    if (this.Transaction.Velocity.IncludeStoreOnMatrix(storeIdxRID.RID))   // TT#533 velocity variables not calculated correctly
                    {
                        spl.Add(sp);
                    }
                }
            }

            return spl.Count;
        }
        #endregion StoreListVelocity Total Number of Stores

        #region StoreListVelocity Total Basis Stock
        /// <summary>
        /// Gets Store List Velocity Total Basis Stock
        /// </summary>
        /// <param name="aStoreGrpRID">Store Group RID</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
        /// <param name="aVelocityGrade">Filters the store list by volume grade.</param>
        /// <returns>Velocity Total Basis Stock for the requested store List.</returns>
        public double GetStoreListVelocityTtlBasisStock(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
        {
            return GetStoreListVelocityTtlBasisStock(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, aVelocityGrade));
        }
        /// <summary>
        /// Get Store List Velocity Total Basis Sales
        /// </summary>
        /// <param name="aStoreList">Store List</param>
        /// <returns>Total Basis sales for eligible stores in list</returns>
        public double GetStoreListVelocityTtlBasisStock(ProfileList aStoreList)
        {
            double basisStock = 0;

            int[] basisStoreRID = new int[aStoreList.Count];
            int i = 0;
            double[] basisStoreStock;
            Index_RID[] storeIdxRIDArray = new Index_RID[aStoreList.Count];
            foreach (Index_RID storeIdxRID in this.Transaction.StoreIndexRIDArray())
            {
                if (aStoreList.Contains(storeIdxRID.RID))
                {
                    basisStoreRID[i] = storeIdxRID.RID;
                    storeIdxRIDArray[i] = storeIdxRID;
                    i++;
                }
            }
            
            //basisStoreStock = this.GetStoreBasisStock(basisStoreRID);
            basisStoreStock = this.GetStoreAvgWeeklyStock(basisStoreRID);

            for (int j = 0; j < basisStoreRID.Length; j++)
            {
				//if (this.GetStoreIsEligible(basisStoreRID[j])               // TT#533 velocity variables not calculated correctly
                if (this.Transaction.Velocity.IncludeStoreOnMatrix(basisStoreRID[j]))   // TT#533 velocity variables not calculated correctly
                {
                    basisStock += basisStoreStock[j];
                }
            }
            return basisStock;
        }
        #endregion StoreListVelocity Total Basis Stock

        #region StoreListVelocity Average Basis Stock
        /// <summary>
        /// Gets Store List Velocity Average Basis Stock
        /// </summary>
        /// <param name="aStoreGrpRID">Store Group RID</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
        /// <param name="aVelocityGrade">Filters the store list by volume grade.</param>
        /// <returns>Velocity Total Basis Stock for the requested store List.</returns>
        public double GetStoreListVelocityAvgBasisStock(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
        {
            return GetStoreListVelocityAvgBasisStock(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, aVelocityGrade));
        }
        /// <summary>
        /// Gets Store List Velocity Average Basis Stock
        /// </summary>
        /// <param name="aStoreList">Store Profile List</param>
        /// <returns>Velocity Average Basis Stock for eligible stores in requested store list</returns>
        public double GetStoreListVelocityAvgBasisStock(ProfileList aStoreList)
        {
            //int basisSales = GetStoreListVelocityTtlBasisStock(aStoreList);
            Index_RID storeIdxRID;
            ProfileList spl = new ProfileList(eProfileType.Store);
            foreach (StoreProfile sp in aStoreList)
            {
                storeIdxRID = StoreIndex(sp.Key);
                //if (this.GetStoreIsEligible(storeIdxRID)               // TT#533 velocity variables not calculated correctly
                if (this.Transaction.Velocity.IncludeStoreOnMatrix(storeIdxRID.RID))   // TT#533 velocity variables not calculated correctly
                {
                    spl.Add(sp);
                }
            }
            if (spl.Count > 0)
            {
                return (double)((double)GetStoreListVelocityTtlBasisStock(spl) / (double)spl.Count);
            }
            return 0d;
        }
        #endregion StoreListVelocity Average Basis Stock

        #region StoreListVelocity Stock Percentage Total
        /// <summary>
        /// Gets Store List Velocity Total Basis Sales
        /// </summary>
        /// <param name="aStoreGrpRID">Store Group RID</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
        /// <param name="aVelocityGrade">Filters the store list by volume grade.</param>
        /// <returns>Velocity Total Basis Sales for the requested store List.</returns>
        public double GetStoreListVelocityStockPercentOfTotal(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
        {
            return GetStoreListVelocityStockPercentOfTotal(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, aVelocityGrade));
        }
        /// <summary>
        /// Get Store List Velocity Total Basis Sales
        /// </summary>
        /// <param name="aStoreList">Store List</param>
        /// <returns>Total Basis sales for eligible stores in list</returns>
        public double GetStoreListVelocityStockPercentOfTotal(ProfileList aStoreList)
        {
            //find the stock counts for the stores in the (eligible) store grade collection
            int basisStock = 0;
            int[] basisStoreRID = new int[aStoreList.Count];
            int i = 0;
            int[] basisStoreStock;
            Index_RID[] storeIdxRIDArray = new Index_RID[aStoreList.Count];
            foreach (Index_RID storeIdxRID in this.Transaction.StoreIndexRIDArray())
            {
                if (aStoreList.Contains(storeIdxRID.RID))
                {
                    basisStoreRID[i] = storeIdxRID.RID;
                    storeIdxRIDArray[i] = storeIdxRID;
                    i++;
                }
            }
            basisStoreStock = this.GetStoreBasisStock(basisStoreRID);
            for (int j = 0; j < basisStoreRID.Length; j++)
            {
                //if (this.GetStoreIsEligible(basisStoreRID[j])               // TT#533 velocity variables not calculated correctly
                if (this.Transaction.Velocity.IncludeStoreOnMatrix(basisStoreRID[j]))   // TT#533 velocity variables not calculated correctly
                {
                    basisStock += basisStoreStock[j];
                }
            }


            //find the stock counts for the stores in the total (eligible) store collections
            int allStock = 0;
            int[] allStoreRID = new int[_allStoreList.Count];
            int n = 0;
            int[] allStoreStock;
            Index_RID[] allStoreIdxRIDArray = new Index_RID[_allStoreList.Count];
            foreach (Index_RID allStoreIdxRID in this.Transaction.StoreIndexRIDArray())
            {
                if (_allStoreList.Contains(allStoreIdxRID.RID))
                {
                    allStoreRID[n] = allStoreIdxRID.RID;
                    allStoreIdxRIDArray[n] = allStoreIdxRID;
                    n++;
                }
            }
            allStoreStock = this.GetStoreBasisStock(allStoreRID);
            for (int m = 0; m < allStoreRID.Length; m++)
            {
                //if (this.GetStoreIsEligible(allStoreRID[m])               // TT#533 velocity variables not calculated correctly
                if (this.Transaction.Velocity.IncludeStoreOnMatrix(allStoreRID[m]))   // TT#533 velocity variables not calculated correctly
                {
                    allStock += allStoreStock[m];
                }
            }

            //calculate the percent of store grade stock to total
            double StockPercentOfTotal = 0; //tt#317 - changing the viewed format of the added column
            if (allStock > 0)
            {
                StockPercentOfTotal = ((double)basisStock / (double)allStock) * 100;
            }
              
            //return value
            return StockPercentOfTotal;

        }
        #endregion StoreListVelocity Stock Percentage Total

        #region StoreListVelocity Allocation Percentage of Total

        /// <summary>
        /// Gets Store List Velocity Allocation Percentage of Total
        /// </summary>
        /// <param name="aStoreGrpRID">Store Group RID</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
        /// <param name="aVelocityGrade">Filters the store list by volume grade.</param>
        /// <returns>Velocity Allocation Percentage of Total for the requested store List.</returns>
        public double GetStoreListVelocityAllocationPercentOfTotal(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
        {
            return GetStoreListVelocityAllocationPercentOfTotal(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, aVelocityGrade));
        }
        /// <summary>
        /// Gets Store List Velocity Allocation Percentage of Total
        /// </summary>
        /// <param name="aStoreList">Store Profile List</param>
        /// <returns>Velocity Allocation Percentage of Total for eligible stores in requested store list</returns>
        public double GetStoreListVelocityAllocationPercentOfTotal(ProfileList aStoreList)
        {
            //total allocation general compoment
            GeneralComponent totalComponent = new GeneralComponent(eComponentType.Total);

            //find the allocation total for the (eligible) stores in the store grade collections
            double storeAllocationTotal = 0;
            int[] basisStoreRID = new int[aStoreList.Count];
            int i = 0;
            Index_RID[] storeIdxRIDArray = new Index_RID[aStoreList.Count];
            foreach (Index_RID storeIdxRID in this.Transaction.StoreIndexRIDArray())
            {
                if (aStoreList.Contains(storeIdxRID.RID))
                {
                    basisStoreRID[i] = storeIdxRID.RID;
                    storeIdxRIDArray[i] = storeIdxRID;
                    i++;
                }
            }

            for (int j = 0; j < basisStoreRID.Length; j++)
            {
                //if (this.GetStoreIsEligible(basisStoreRID[j])               // TT#533 velocity variables not calculated correctly
                if (this.Transaction.Velocity.IncludeStoreOnMatrix(basisStoreRID[j]))   // TT#533 velocity variables not calculated correctly
                {
                    storeAllocationTotal += GetStoreQtyAllocated(totalComponent, storeIdxRIDArray[j]);
                }
            }

            //find the allocation total for the (eligible) stores in the total store collections
            double allStoreAllocationTotal = 0;
            int[] allStoreRID = new int[_allStoreList.Count];
            int n = 0;
            Index_RID[] allStoreIdxRIDArray = new Index_RID[_allStoreList.Count];
            foreach (Index_RID allStoreIdxRID in this.Transaction.StoreIndexRIDArray())
            {
                if (_allStoreList.Contains(allStoreIdxRID.RID))
                {
                    allStoreRID[n] = allStoreIdxRID.RID;
                    allStoreIdxRIDArray[n] = allStoreIdxRID;
                    n++;
                }
            }

            for (int m = 0; m < allStoreRID.Length; m++)
            {
                //if (this.GetStoreIsEligible(allStoreRID[m])               // TT#533 velocity variables not calculated correctly
                if (this.Transaction.Velocity.IncludeStoreOnMatrix(allStoreRID[m]))   // TT#533 velocity variables not calculated correctly
                {
                    allStoreAllocationTotal += GetStoreQtyAllocated(totalComponent, allStoreIdxRIDArray[m]);
                }
            }

            //calculate the percent of store grade stock to total
            double AllocationPercentOfTotal = 0;  
            if (allStoreAllocationTotal > 0)
            {
                AllocationPercentOfTotal = ((double)storeAllocationTotal / (double)allStoreAllocationTotal) * 100;
            }

            //return value
            return AllocationPercentOfTotal;
        }

        #endregion StoreListVelocity Allocation Percentage of Total

        //END TT#153  add variables to velocity matrix - apicchetti

        #region StoreListVelocity Basis Sales Percent to Total
        /// <summary>
		/// Gets Store List Velocity Basis Sales Percent to Total
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
		/// <param name="aVelocityGrade">Filters the store list by volume grade.</param>
		/// <returns>Velocity Total Basis Sales for the requested store List.</returns>
		public double GetStoreListVelocityBasisPctToTotal(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
		{
			int basisSales = GetStoreListVelocityTtlBasisSales(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, aVelocityGrade));
			int totalSales;
            // begin TT#587 Velocity Matrix Totals wrong (matrix totals should reflect the "set" data you are viewing (Joan, Denise and Jim Conversation 4-30-2010 relating to this track))
            if (this.Transaction.VelocityCalculateAverageUsingChain)
            {
                totalSales = GetStoreListVelocityTtlBasisSales(GetStoresInVelocityGrade(Include.AllStoreTotal, Include.AllStoreTotal, null));
            }
            else
            {
                totalSales = GetStoreListVelocityTtlBasisSales(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, null));
            }
			//totalSales = GetStoreListVelocityTtlBasisSales(GetStoresInVelocityGrade(Include.AllStoreTotal, Include.AllStoreTotal, null));
            // end TT#587 Velocity Matrix Totals wrong (matrix totals should reflect the "set" data you are viewing (Joan, Denise and Jim Conversation 4-30-2010 relating to this track))

			if (totalSales > 0)
			{
				return (double)(((double)basisSales * 100) / totalSales);
			}
			return 0.0d;
		}	
		#endregion StoreListVelocity Basis Sales 

		#region StoreListVelocity Average Basis Sales Index
		/// <summary>
		/// Gets Store List Velocity Average Basis Sales Index
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID identifies the list of stores to consider</param>
		/// <param name="aVelocityGrade">Filters the store list by volume grade.</param>
		/// <returns>Velocity Average Basis Sales Index for the requested store List.</returns>
		public double GetStoreListVelocityAvgBasisIndex(int aStoreGrpRID, int aStoreGrpLvlRID, string aVelocityGrade)
		{
			double basisSales = GetStoreListVelocityAvgBasisSales (aStoreGrpRID, aStoreGrpLvlRID, aVelocityGrade);
			double totalAvgSales;
            // begin TT#587 Velocity Matrix Totals wrong (matrix totals should reflect the "set" data you are viewing (Joan, Denise and Jim Conversation 4-30-2010 relating to this track))
            if (this.Transaction.VelocityCalculateAverageUsingChain)
            {
                totalAvgSales = GetStoreListVelocityAvgBasisSales(GetStoresInVelocityGrade(Include.AllStoreTotal, Include.AllStoreTotal, null));
            }
            else
            {
                totalAvgSales = GetStoreListVelocityAvgBasisSales(GetStoresInVelocityGrade(aStoreGrpRID, aStoreGrpLvlRID, null));
            }
            //totalAvgSales = GetStoreListVelocityAvgBasisSales(GetStoresInVelocityGrade(Include.AllStoreTotal, Include.AllStoreTotal, null));
            // end TT#587 Velocity Matrix Totals wrong (matrix totals should reflect the "set" data you are viewing)
            if (totalAvgSales > 0)
			{
				return ((basisSales * 100) / totalAvgSales);
			}
			return 0.0d;
		}
		#endregion StoreListVelocity Average Basis Sales Index

		#endregion StoreListVelocity

		#region StoreListSizeAllocatedPctToColorAllocated

		public double GetStoreListSizeAllocatedPctToColorAllocated(
			AllocationProfile aAllocationProfile, AllocationColorSizeComponent aColorSize, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			if (aAllocationProfile == null)
			{
				return GetStoreListSizeAllocatedPctToColorAllocated(aColorSize, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
			}
			return aAllocationProfile.GetStoreListSizeAllocatedPctToColorAllocated(aColorSize, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
		}
		private double GetStoreListSizeAllocatedPctToColorAllocated(
			AllocationColorSizeComponent aColorSize, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			double percentToTotal = 0.0d;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			if (aColorSize.ColorComponent.ComponentType != eComponentType.SpecificColor)
			{
				return percentToTotal;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			}
			AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)aColorSize.ColorComponent;
			if (_storeListSizePctToColorHash == null)
			{
				_storeListSizePctToColorHash = new Hashtable();
			}
			int colorRID = colorComponent.ColorRID;
			if (this.BulkColorIsOnSubtotal(colorRID))
			{
				HdrColorBin colorBin = this.GetSubtotalHdrColorBin(colorRID);
				Hashtable storeGrpLvlSizePctToColorHash;
				if (_storeListSizePctToColorHash.Contains(colorRID))
				{
					storeGrpLvlSizePctToColorHash = (Hashtable)_storeListSizePctToColorHash[colorRID];
				}
				else
				{
					storeGrpLvlSizePctToColorHash = new Hashtable();
					_storeListSizePctToColorHash.Add(colorRID, storeGrpLvlSizePctToColorHash);
				}
				long storeGrpLvlKey = aStoreGrpRID;
				storeGrpLvlKey = storeGrpLvlKey << 32;
				storeGrpLvlKey = storeGrpLvlKey + aStoreGrpLvlRID;
				Hashtable storeVGSizePctToColorHash;
				if (storeGrpLvlSizePctToColorHash.Contains(storeGrpLvlKey))
				{
					storeVGSizePctToColorHash = (Hashtable)storeGrpLvlSizePctToColorHash[storeGrpLvlKey];
				}
				else
				{
					storeVGSizePctToColorHash = new Hashtable();
					storeGrpLvlSizePctToColorHash.Add(storeGrpLvlKey, storeVGSizePctToColorHash);
				}
				Hashtable sizePctToColorHash;
				string volumeGradeKey = "grade_" + aVolumeGrade;
				if (storeVGSizePctToColorHash.Contains(volumeGradeKey))
				{
					sizePctToColorHash = (Hashtable)storeVGSizePctToColorHash[volumeGradeKey];
				}
				else
				{
					sizePctToColorHash = CalculateStoreListSizeAllocatedPctToColor(colorBin, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
					storeVGSizePctToColorHash.Add(volumeGradeKey, sizePctToColorHash);
				}
				switch (aColorSize.SizeComponent.ComponentType)
				{
					case (eComponentType.SpecificSize):
					{
						int sizeRID = ((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SizeRID;
						if (colorBin.SizeIsInColor(sizeRID))
						{
							percentToTotal = (double)sizePctToColorHash[sizeRID];
						}
						break;
					}
					case (eComponentType.SpecificSizePrimaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).PrimarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							if (colorBin.SizeIsInColor(scp.Key))
							{
								percentToTotal += (double)sizePctToColorHash[scp.Key];
							}
						}
						break;
					}
					case (eComponentType.SpecificSizeSecondaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SecondarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							if (colorBin.SizeIsInColor(scp.Key))
							{
								percentToTotal += (double)sizePctToColorHash[scp.Key];
							}
						}
						break;
					}
					case (eComponentType.AllSizes):
					{
						percentToTotal = (double)sizePctToColorHash[0];
						break;
					}
					default:
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_UnknownSizeComponent,
							this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownSizeComponent));
					}
				}
			}
			return percentToTotal;
		}

		private Hashtable CalculateStoreListSizeAllocatedPctToColor(HdrColorBin aColorBin, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			Hashtable storeListSizeToColorTotalHash = new Hashtable();
			ProfileList storeList = this.Transaction.GetAllocationGrandTotalProfile().GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
			long totalValue = (long)this.GetStoreListTotalQtyAllocated(aColorBin, storeList);
			AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor,aColorBin.ColorCodeRID);
			GeneralComponent sizeComponent = new GeneralComponent(eComponentType.AllSizes);
			long totalSizeValue = (long)this.GetStoreListTotalQtyAllocated(
				new AllocationColorSizeComponent(colorComponent, sizeComponent), 
				storeList);
			long newTotalPct = 0;
			if (totalValue > 0)
			{
				newTotalPct = 
					(long)(((double)totalSizeValue
					* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision * 100.0d
					/ (double) totalValue) + .5d);
			}
			storeListSizeToColorTotalHash.Add(0, (double)((double)newTotalPct/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision ));
			long sizeValue;
			long sizePercent;
			foreach (HdrSizeBin sizeBin in aColorBin.ColorSizes.Values)
			{
				if (totalSizeValue > 0)
				{
					sizeValue = this.GetStoreListTotalQtyAllocated (sizeBin, storeList);
					sizePercent = (long)
						(
						((double)sizeValue 
						* (double)newTotalPct
						/ (double) totalSizeValue
						) + .5d);
                    storeListSizeToColorTotalHash.Add(sizeBin.SizeCodeRID, (double)((double)sizePercent / (double)this.Transaction.StoreSizePctToTotalDecimalPrecision)); // Assortment: color/size changes
					totalSizeValue -= sizeValue;
					newTotalPct -= sizePercent;
				}
				else
				{
                    storeListSizeToColorTotalHash.Add(sizeBin.SizeCodeRID, 0.0d); // Assortment: color/size changes
				}                                                                                                                                                              
			}
			return storeListSizeToColorTotalHash;
		}
		#endregion StoreSizeAllocatedPctToColorAllocated

		#region StoreListSizeInTransitPctToColorInTransit
        /// <summary>
        /// Gets the size intransit percent to color total intransit for a given list of stores.
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile (currently ignored)</param>
        /// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
        /// <param name="aStoreGrpRID">Store Group RID that identifies the store group</param>
        /// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the general list of stores.</param>
        /// <param name="aVolumeGrade">The volume grade (when null, returned percent is for all selected stores across all volume grades)</param>
        /// <returns>Percent of size intransit to total color </returns>
		public double GetStoreListSizeInTransitPctToColorInTransit(
			AllocationProfile aAllocationProfile, AllocationColorSizeComponent aColorSize, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListSizeInTransitPctToColorInTransit(aColorSize, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
		}

		/// <summary>
		/// Gets the size intransit percent to color total intransit for a given list of stores.
		/// </summary>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies the store group</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the general list of stores.</param>
		/// <param name="aVolumeGrade">The volume grade (when null, returned percent is for all selected stores across all volume grades)</param>
		/// <returns>Percent of size intransit to total color </returns>
		private double GetStoreListSizeInTransitPctToColorInTransit(
			AllocationColorSizeComponent aColorSize, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			double percentToTotal = 0.0d;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			if (aColorSize.ColorComponent.ComponentType != eComponentType.SpecificColor)
			{
				return percentToTotal;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			}
			AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)aColorSize.ColorComponent;
			if (_storeListSizeIntransitPctToColorHash == null)
			{
				_storeListSizeIntransitPctToColorHash = new Hashtable();
			}
			int colorRID = colorComponent.ColorRID;
			if (this.BulkColorIsOnSubtotal(colorRID))
			{
				long storeGrpLvlKey = aStoreGrpRID;
				storeGrpLvlKey = storeGrpLvlKey << 32;
				storeGrpLvlKey = storeGrpLvlKey + aStoreGrpLvlRID;
				Hashtable storeVGSizePctToColorHash;
				if (_storeListSizeIntransitPctToColorHash.Contains(storeGrpLvlKey))
				{
					storeVGSizePctToColorHash = (Hashtable)_storeListSizeIntransitPctToColorHash[storeGrpLvlKey];
				}
				else
				{
					storeVGSizePctToColorHash = new Hashtable();
					_storeListSizeIntransitPctToColorHash.Add(storeGrpLvlKey, storeVGSizePctToColorHash);
				}
				Hashtable sizePctToColorHash;
				string volumeGradeKey = "grade_" + aVolumeGrade;
				if (storeVGSizePctToColorHash.Contains(volumeGradeKey))
				{
					sizePctToColorHash = (Hashtable)storeVGSizePctToColorHash[volumeGradeKey];
				}
				else
				{
					sizePctToColorHash = CalculateStoreListSizeInTransitPctToColor(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
					storeVGSizePctToColorHash.Add(volumeGradeKey, sizePctToColorHash);
				}

				HdrColorBin colorBin = this.GetSubtotalHdrColorBin(colorRID);
				IntransitKeyType sizeIKT;
				switch (aColorSize.SizeComponent.ComponentType)
				{
					case (eComponentType.SpecificSize):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID, 
							((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SizeRID
							);
						if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
						{
							percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						}
						break;
					}
					case (eComponentType.SpecificSizePrimaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).PrimarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.SpecificSizeSecondaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SecondarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.AllSizes):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID,
							Include.IntransitKeyTypeNoSize
							);
						percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						break;
					}
					default:
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_UnknownSizeComponent,
							this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownSizeComponent));
					}
				}
			}
			return percentToTotal;
		}
        
		/// <summary>
		/// Calculates the size intransit percent to color total intransit for a given list of stores.
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores within the store group rid</param>
		/// <param name="aVolumeGrade">Volume Grade (when null, the percent returned is for all selected stores across all volume grades)</param>
		/// <returns>Hashtable containing the color size intransit percents to color (key is the Intransit Key Type key identifying a color and a size--all sizes are represented by the no size intransit key type).</returns>
		private Hashtable CalculateStoreListSizeInTransitPctToColor(int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			Hashtable colorSizeIntransitPctToColorHash = new Hashtable();
			ProfileList storeList = this.Transaction.GetAllocationGrandTotalProfile().GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
	
//Begin Track #4037 - JSmith - Optionally include dummy color in child list
			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color, eNodeSelectType.All);  // MID Change j.ellis Performance--cache ancestor and descendant data
//			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color);  // MID Change j.ellis Performance--cache ancestor and descendant data
//End Track #4037
			//HierarchyNodeList hnlColor = this.Transaction.SAB.HierarchyServerSession.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color); // MID Change Performance--cache ancestor and descendant data
			long sizeValue;
			long totalValue; 
			long totalSizeValue;
			foreach (HdrColorBin colorBin in this.BulkColors.Values)
			{
				IntransitKeyType iktColor = new IntransitKeyType(colorBin.ColorCodeRID, Include.IntransitKeyTypeNoSize);
				IntransitKeyType iktSize;
				totalValue = (long)this.GetStoreListTotalInTransit(iktColor, storeList);
				totalSizeValue = 0;

				ArrayList iktArray = new ArrayList();
				ArrayList sizeValueArray = new ArrayList();
				foreach(HierarchyNodeProfile hnpColor in hnlColor)
				{
					if (hnpColor.ColorOrSizeCodeRID == colorBin.ColorCodeRID)
					{
						foreach (SizeCodeProfile sizeProfile in this._sizeList)
						{
							iktSize = new IntransitKeyType(colorBin.ColorCodeRID, sizeProfile.Key);
							sizeValue = (long)this.GetStoreListTotalInTransit(iktSize, storeList);
							iktArray.Add(iktSize);
							sizeValueArray.Add(sizeValue);
							totalSizeValue += sizeValue;
						}
						break;
					}
				}

				long newTotalPct = 0;
				if (totalValue > 0)
				{
					newTotalPct = 
						(long)(((double)totalSizeValue
						* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision * 100.0d
						/ (double) totalValue) + .5d);
				}
				colorSizeIntransitPctToColorHash .Add(
					iktColor.IntransitTypeKey, 
					(double)((double)newTotalPct/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision ));
				long sizePercent;
				for (int i=0; i < iktArray.Count; i++)
				{
					iktSize = (IntransitKeyType)iktArray[i];
					sizeValue = (long)sizeValueArray[i];
					if (totalSizeValue > 0)
					{
						sizePercent = (long)
							(
							((double)sizeValue 
							* (double)newTotalPct
							/ (double) totalSizeValue
							) + .5d);
						colorSizeIntransitPctToColorHash.Add(
							iktSize.IntransitTypeKey, 
							(double)((double)sizePercent/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision));
						totalSizeValue -= sizeValue;
						newTotalPct -= sizePercent;
					}
					else
					{
						colorSizeIntransitPctToColorHash.Add(iktSize.IntransitTypeKey,0.0d);
					}                                                                                                                                                              
				}
			}
			return colorSizeIntransitPctToColorHash;
		}
		#endregion StoreSizeInTransitPctToColorAllocated

		#region StoreListSizeOnHandPctToColorOnHand
		/// <summary>
		/// Gets the size OnHand percent to color total intransit for a given list of stores.
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile (currently ignored)</param>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies the store group</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the general list of stores.</param>
		/// <param name="aVolumeGrade">The volume grade (when null, returned percent is for all selected stores across all volume grades)</param>
		/// <returns>Percent of size OnHand to total color </returns>
		public double GetStoreListSizeOnHandPctToColorOnHand(
			AllocationProfile aAllocationProfile, AllocationColorSizeComponent aColorSize, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{

			return GetStoreListSizeOnHandPctToColorOnHand(aColorSize, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
		}
		/// <summary>
		/// Gets the size OnHand percent to color total intransit for a given list of stores.
		/// </summary>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies the store group</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the general list of stores.</param>
		/// <param name="aVolumeGrade">The volume grade (when null, returned percent is for all selected stores across all volume grades)</param>
		/// <returns>Percent of size Onhand to total color </returns>
		private double GetStoreListSizeOnHandPctToColorOnHand(
			AllocationColorSizeComponent aColorSize, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			double percentToTotal = 0.0d;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			if (aColorSize.ColorComponent.ComponentType != eComponentType.SpecificColor)
			{
				return percentToTotal;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			}
			AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)aColorSize.ColorComponent;
			if (_storeListSizeOnHandPctToColorHash == null)
			{
				_storeListSizeOnHandPctToColorHash = new Hashtable();
			}
			int colorRID = colorComponent.ColorRID;
			if (this.BulkColorIsOnSubtotal(colorRID))
			{
				long storeGrpLvlKey = aStoreGrpRID;
				storeGrpLvlKey = storeGrpLvlKey << 32;
				storeGrpLvlKey = storeGrpLvlKey + aStoreGrpLvlRID;
				Hashtable storeVGSizePctToColorHash;
				if (_storeListSizeOnHandPctToColorHash.Contains(storeGrpLvlKey))
				{
					storeVGSizePctToColorHash = (Hashtable)_storeListSizeOnHandPctToColorHash[storeGrpLvlKey];
				}
				else
				{
					storeVGSizePctToColorHash = new Hashtable();
					_storeListSizeOnHandPctToColorHash.Add(storeGrpLvlKey, storeVGSizePctToColorHash);
				}
				Hashtable sizePctToColorHash;
				string volumeGradeKey = "grade_" + aVolumeGrade;
				if (storeVGSizePctToColorHash.Contains(volumeGradeKey))
				{
					sizePctToColorHash = (Hashtable)storeVGSizePctToColorHash[volumeGradeKey];
				}
				else
				{
					sizePctToColorHash = CalculateStoreListSizeOnHandPctToColor(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
					storeVGSizePctToColorHash.Add(volumeGradeKey, sizePctToColorHash);
				}

				HdrColorBin colorBin = this.GetSubtotalHdrColorBin(colorRID);
				IntransitKeyType sizeIKT;
				switch (aColorSize.SizeComponent.ComponentType)
				{
					case (eComponentType.SpecificSize):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID, 
							((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SizeRID
							);
						if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
						{
							percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						}
						break;
					}
					case (eComponentType.SpecificSizePrimaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).PrimarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.SpecificSizeSecondaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SecondarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.AllSizes):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID,
							Include.IntransitKeyTypeNoSize
							);
						percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						break;
					}
					default:
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_UnknownSizeComponent,
							this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownSizeComponent));
					}
				}
			}
			return percentToTotal;
		}
		/// <summary>
		/// Calculates the size OnHand percent to color total OnHand for a given list of stores.
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores within the store group rid</param>
		/// <param name="aVolumeGrade">Volume Grade (when null, the percent returned is for all selected stores across all volume grades)</param>
		/// <returns>Hashtable containing the color size OnHand percents to color (key is the Intransit Key Type key identifying a color and a size--all sizes are represented by the no size intransit key type).</returns>
		private Hashtable CalculateStoreListSizeOnHandPctToColor(int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			Hashtable colorSizeOnHandPctToColorHash = new Hashtable();
			ProfileList storeList = this.Transaction.GetAllocationGrandTotalProfile().GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
	
//Begin Track #4037 - JSmith - Optionally include dummy color in child list
			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color, eNodeSelectType.All);  // MID Change j.ellis Performance--cache ancestor and descendant data
//			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color);  // MID Change j.ellis Performance--cache ancestor and descendant data
//End Track #4037
			//HierarchyNodeList hnlColor = this.Transaction.SAB.HierarchyServerSession.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color); // MID Change Performance--cache ancestor and descendant data
			long sizeValue;
			long totalValue; 
			long totalSizeValue;
			foreach (HdrColorBin colorBin in this.BulkColors.Values)
			{
				IntransitKeyType iktColor = new IntransitKeyType(colorBin.ColorCodeRID, Include.IntransitKeyTypeNoSize);
				IntransitKeyType iktSize;
				totalValue = (long)this.GetStoreListTotalOnHand(iktColor, storeList);
				totalSizeValue = 0;

				ArrayList iktArray = new ArrayList();
				ArrayList sizeValueArray = new ArrayList();
				foreach(HierarchyNodeProfile hnpColor in hnlColor)
				{
					if (hnpColor.ColorOrSizeCodeRID == colorBin.ColorCodeRID)
					{
						foreach (SizeCodeProfile sizeProfile in this._sizeList)
						{
							iktSize = new IntransitKeyType(colorBin.ColorCodeRID, sizeProfile.Key);
							sizeValue = (long)this.GetStoreListTotalOnHand(iktSize, storeList);
							iktArray.Add(iktSize);
							sizeValueArray.Add(sizeValue);
							totalSizeValue += sizeValue;
						}
						break;
					}
				}

				long newTotalPct = 0;
				if (totalValue > 0)
				{
					newTotalPct = 
						(long)(((double)totalSizeValue
						* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision * 100.0d
						/ (double) totalValue) + .5d);
				}
				colorSizeOnHandPctToColorHash .Add(
					iktColor.IntransitTypeKey, 
					(double)((double)newTotalPct/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision ));
				long sizePercent;
				for (int i=0; i < iktArray.Count; i++)
				{
					iktSize = (IntransitKeyType)iktArray[i];
					sizeValue = (long)sizeValueArray[i];
					if (totalSizeValue > 0)
					{
						sizePercent = (long)
							(
							((double)sizeValue 
							* (double)newTotalPct
							/ (double) totalSizeValue
							) + .5d);
						colorSizeOnHandPctToColorHash.Add(
							iktSize.IntransitTypeKey, 
							(double)((double)sizePercent/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision));
						totalSizeValue -= sizeValue;
						newTotalPct -= sizePercent;
					}
					else
					{
						colorSizeOnHandPctToColorHash.Add(iktSize.IntransitTypeKey,0.0d);
					}                                                                                                                                                              
				}
			}
			return colorSizeOnHandPctToColorHash;
		}
		#endregion StoreSizeOnHandPctToColorOnHand

		#region StoreListSize_OHplusIT_PctToColorOHplusIT
		/// <summary>
		/// Gets the size OnHand plus Intransit percent to color total OnHand plus intransit for a given list of stores.
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile (currently ignored)</param>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies the store group</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the general list of stores.</param>
		/// <param name="aVolumeGrade">The volume grade (when null, returned percent is for all selected stores across all volume grades)</param>
		/// <returns>Percent of size OnHand plus Intransit to total color </returns>
		public double GetStoreListSize_OHplusIT_PctToColorOHplusIT(
			AllocationProfile aAllocationProfile, AllocationColorSizeComponent aColorSize, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListSize_OHplusIT_PctToColorOHplusIT(aColorSize, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
		}
		/// <summary>
		/// Gets the size OnHand plus Intransit percent to color total OnHand plus intransit for a given list of stores.
		/// </summary>
		/// <param name="aColorSize">An AllocationColorSizeComponent that describes the color and size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies the store group</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the general list of stores.</param>
		/// <param name="aVolumeGrade">The volume grade (when null, returned percent is for all selected stores across all volume grades)</param>
		/// <returns>Percent of size OnHand plus Intransit to total color </returns>
		private double GetStoreListSize_OHplusIT_PctToColorOHplusIT(
			AllocationColorSizeComponent aColorSize, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			double percentToTotal = 0.0d;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			if (aColorSize.ColorComponent.ComponentType != eComponentType.SpecificColor)
			{
				return percentToTotal;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			}
			AllocationColorOrSizeComponent colorComponent = (AllocationColorOrSizeComponent)aColorSize.ColorComponent;
			if (_storeListSizeOHplusITPctToColorHash == null)
			{
				_storeListSizeOHplusITPctToColorHash = new Hashtable();
			}
			int colorRID = colorComponent.ColorRID;
			if (this.BulkColorIsOnSubtotal(colorRID))
			{
				long storeGrpLvlKey = aStoreGrpRID;
				storeGrpLvlKey = storeGrpLvlKey << 32;
				storeGrpLvlKey = storeGrpLvlKey + aStoreGrpLvlRID;
				Hashtable storeVGSizePctToColorHash;
				if (_storeListSizeOHplusITPctToColorHash.Contains(storeGrpLvlKey))
				{
					storeVGSizePctToColorHash = (Hashtable)_storeListSizeOHplusITPctToColorHash[storeGrpLvlKey];
				}
				else
				{
					storeVGSizePctToColorHash = new Hashtable();
					_storeListSizeOHplusITPctToColorHash.Add(storeGrpLvlKey, storeVGSizePctToColorHash);
				}
				Hashtable sizePctToColorHash;
				string volumeGradeKey = "grade_" + aVolumeGrade;
				if (storeVGSizePctToColorHash.Contains(volumeGradeKey))
				{
					sizePctToColorHash = (Hashtable)storeVGSizePctToColorHash[volumeGradeKey];
				}
				else
				{
					sizePctToColorHash = CalculateStoreListSize_OHplusIT_PctToColor(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
					storeVGSizePctToColorHash.Add(volumeGradeKey, sizePctToColorHash);
				}

				HdrColorBin colorBin = this.GetSubtotalHdrColorBin(colorRID);
				IntransitKeyType sizeIKT;
				switch (aColorSize.SizeComponent.ComponentType)
				{
					case (eComponentType.SpecificSize):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID, 
							((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SizeRID
							);
						if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
						{
							percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						}
						break;
					}
					case (eComponentType.SpecificSizePrimaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).PrimarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.SpecificSizeSecondaryDim):
					{
						SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(((AllocationColorOrSizeComponent)aColorSize.SizeComponent).SecondarySizeDimRID);
						foreach (SizeCodeProfile scp in scl)
						{
							sizeIKT = new IntransitKeyType
								(
								colorRID,
								scp.Key
								);
							if (sizePctToColorHash.Contains(sizeIKT.IntransitTypeKey))
							{
								percentToTotal += (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
							}
						}
						break;
					}
					case (eComponentType.AllSizes):
					{
						sizeIKT = new IntransitKeyType
							(
							colorRID,
							Include.IntransitKeyTypeNoSize
							);
						percentToTotal = (double)sizePctToColorHash[sizeIKT.IntransitTypeKey];
						break;
					}
					default:
					{
						throw new MIDException(eErrorLevel.severe,
							(int)eMIDTextCode.msg_UnknownSizeComponent,
							this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownSizeComponent));
					}
				}
			}
			return percentToTotal;
		}
		/// <summary>
		/// Calculates the size OnHand plus intransit percent to color total OnHand plus intransit for a given list of stores.
		/// </summary>
		/// <param name="aStoreGrpRID">Store Group RID</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores within the store group rid</param>
		/// <param name="aVolumeGrade">Volume Grade (when null, the percent returned is for all selected stores across all volume grades)</param>
		/// <returns>Hashtable containing the color size onhand plus intransit percents to color (key is the Intransit Key Type key identifying a color and a size--all sizes are represented by the no size intransit key type).</returns>
		private Hashtable CalculateStoreListSize_OHplusIT_PctToColor(int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			Hashtable colorSize_OHplustIT_PctToColorHash = new Hashtable();
			ProfileList storeList = this.Transaction.GetAllocationGrandTotalProfile().GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
	
//Begin Track #4037 - JSmith - Optionally include dummy color in child list
			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color, eNodeSelectType.All);  // MID Change j.ellis Performance--cache ancestor and descendant data
//			HierarchyNodeList hnlColor = this.Transaction.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color);  // MID Change j.ellis Performance--cache ancestor and descendant data
//End Track #4037
			//HierarchyNodeList hnlColor = this.Transaction.SAB.HierarchyServerSession.GetDescendantData(this.OnHandHnRID, eHierarchyLevelType.Color); // MID Change Performance--cache ancestor and descendant data
			long sizeValue;
			long totalValue; 
			long totalSizeValue;
			foreach (HdrColorBin colorBin in this.BulkColors.Values)
			{
				IntransitKeyType iktColor = new IntransitKeyType(colorBin.ColorCodeRID, Include.IntransitKeyTypeNoSize);
				IntransitKeyType iktSize;
				totalValue = 
					(long)this.GetStoreListTotalOnHand(iktColor, storeList)
					+ (long)this.GetStoreListTotalInTransit(iktColor, storeList);
				totalSizeValue = 0;

				ArrayList iktArray = new ArrayList();
				ArrayList sizeValueArray = new ArrayList();
				foreach(HierarchyNodeProfile hnpColor in hnlColor)
				{
					if (hnpColor.ColorOrSizeCodeRID == colorBin.ColorCodeRID)
					{
						foreach (SizeCodeProfile sizeProfile in this._sizeList)
						{
							iktSize = new IntransitKeyType(colorBin.ColorCodeRID, sizeProfile.Key);
							sizeValue = 
								(long)this.GetStoreListTotalOnHand(iktSize, storeList)
								+ (long)this.GetStoreListTotalInTransit(iktSize, storeList);
							iktArray.Add(iktSize);
							sizeValueArray.Add(sizeValue);
							totalSizeValue += sizeValue;
						}
						break;
					}
				}

				long newTotalPct = 0;
				if (totalValue > 0)
				{
					newTotalPct = 
						(long)(((double)totalSizeValue
						* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision * 100.0d
						/ (double) totalValue) + .5d);
				}
				colorSize_OHplustIT_PctToColorHash.Add(
					iktColor.IntransitTypeKey, 
					(double)((double)newTotalPct/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision ));
				long sizePercent;
				for (int i=0; i < iktArray.Count; i++)
				{
					iktSize = (IntransitKeyType)iktArray[i];
					sizeValue = (long)sizeValueArray[i];
					if (totalSizeValue > 0)
					{
						sizePercent = (long)
							(
							((double)sizeValue 
							* (double)newTotalPct
							/ (double) totalSizeValue
							) + .5d);
						colorSize_OHplustIT_PctToColorHash.Add(
							iktSize.IntransitTypeKey, 
							(double)((double)sizePercent/(double)this.Transaction.StoreSizePctToTotalDecimalPrecision));
						totalSizeValue -= sizeValue;
						newTotalPct -= sizePercent;
					}
					else
					{
						colorSize_OHplustIT_PctToColorHash.Add(iktSize.IntransitTypeKey,0.0d);
					}                                                                                                                                                              
				}
			}
			return colorSize_OHplustIT_PctToColorHash;
		}
		#endregion StoreSize_OHplustIT_PctToColorOHplusIT

		// BEGIN MID Track #2230   Display Current Week-to-Day Sales on Sku Review
		#region StoreListWeekToDaySales
		/// <summary>
		/// Gets Store List Week To Day Sales for the current sales week.
		/// </summary>
		/// <param name="aIKT">Array of the Key types for the sales to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
		/// <returns>Total Week To Day Sales for the requested store list.</returns>
		public int GetStoreListTotalWeekToDaySales(ArrayList aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalWeekToDaySales(aIKT, GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}
		/// <summary>
		/// Gets Store List Week To Day Sales for the current sales week.
		/// </summary>
		/// <param name="aIKT">Intransit Key type for the sales to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreGrpRID">Store Group RID that identifies how the store attribute.</param>
		/// <param name="aStoreGrpLvlRID">Store Group Level RID that identifies the list of stores</param>
		/// <returns>Total Week To Day Sales for the requested store list.</returns>
		public int GetStoreListTotalWeekToDaySales(IntransitKeyType aIKT, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade)
		{
			return GetStoreListTotalWeekToDaySales(aIKT, GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
		}


		/// <summary>
		/// Gets Store List Total Week To Day Sales for the current sales week.
		/// </summary>
		/// <param name="aIKT">Array of the Key types for the sales to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreList">ProfileList of stores for which total Week To Day Sales is desired</param>
		/// <returns>Week To Day Sales for the requested store.</returns>
		public int GetStoreListTotalWeekToDaySales(ArrayList aIKT, ProfileList aStoreList)
		{
			Index_RID storeIndexRID;
			int weekToDaySales = 0;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIndexRID =  this.StoreIndex(sp.Key);
				// begin MID Track 3722 WTD Sales All Store and Set Totals not correct
				//foreach (IntransitKeyType ikt in aIKT)
				//{
				//	weekToDaySales += GetStoreWeekToDaySales(ikt, storeIndexRID);
				//}
				if (this.StoreIsVisible(storeIndexRID))
				{
					foreach (IntransitKeyType ikt in aIKT)
					{
						weekToDaySales += GetStoreWeekToDaySales(ikt, storeIndexRID);
					}
				}
				// end MID Track 3722 WTD Sales All Store and Set Totals not correct
			}
			return weekToDaySales;
		}


		/// <summary>
		/// Gets Store List Total Week To Day Sales for the current sales week.
		/// </summary>
		/// <param name="aIKT">Key type of the sales to retrieve: Total, Color or Color-Size</param>
		/// <param name="aStoreList">Profile List of stores for which week to day sales is desired</param>
		/// <returns>Total Week To Day Sales for the requested store list.</returns>
		public int GetStoreListTotalWeekToDaySales(IntransitKeyType aIKT, ProfileList aStoreList)
		{
			int weekToDaySales = 0;
			// begin MID Track 3722 WTD Sales All Store and Set Totals not correct
			//foreach (StoreProfile sp in aStoreList)
			//{
			//	weekToDaySales += GetStoreWeekToDaySales(aIKT, sp.Key);
			//}
			Index_RID storeIndexRID;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIndexRID = this.StoreIndex(sp.Key);
				if (this.StoreIsVisible(storeIndexRID))
				{
					weekToDaySales += GetStoreWeekToDaySales(aIKT, sp.Key);
				}
			}
			// end MID Track 3722 WTD Sales All Store and Set Totals not correct
			return weekToDaySales;
		}

		#endregion StoreWeekToDaySales
		// END MID Track #2230   Display Current Week-to-Day Sales on Sku Review

		// BEGIN MID Track # 2937 Size OnHand Incorrect
		#region StoreListTotalSizeCurvePct
		public double GetStoreListTotalSizeCurvePct(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, GeneralComponent aComponent)
		{
			if (aAllocationProfile == null)
			{
				if (aComponent.ComponentType != eComponentType.ColorAndSize)
				{
					return 0.0d;
				}
				int totalPlan = GetStoreListTotalSizePlan(
					aAllocationProfile, 
					aStoreGrpRID, 
					aStoreGrpLvlRID, 
					aVolumeGrade, 
					new AllocationColorSizeComponent(((AllocationColorSizeComponent)aComponent).ColorComponent, new GeneralComponent(eComponentType.AllSizes)), // MID Track 4291 add fill variables to size review
					false,  // MID track 4291 add fill variables to size review  // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
					false); // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
				if (totalPlan > 0)
				{
					int sizePlan = GetStoreListTotalSizePlan(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, false, false); // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
					double sizeCurveValue = (double)
                        ((long)(((double)sizePlan * this.Transaction.StoreSizePctToTotalDecimalPrecision
						/ (double)totalPlan) + .5d)
						/ (double)this.Transaction.StoreSizePctToTotalDecimalPrecision);
					return (sizeCurveValue * 100.0d);
				}
				return 0.0d;
			}
			return aAllocationProfile.GetStoreListTotalSizeCurvePct(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent);
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
        //public double GetStoreListTotalSizeCurvePct(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, HdrColorBin aColor, int aSizeRID)
        //{
        //    return GetStoreListTotalSizeCurvePct(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColor.ColorCodeRID, aSizeRID);
        //}
        
        //public double GetStoreListTotalSizeCurvePct(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aColorRID, int aSizeRID)
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
        //        AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
        //        return this.GetStoreListTotalSizeCurvePct(
        //            aAllocationProfile,
        //            aStoreGrpRID,
        //            aStoreGrpLvlRID, 
        //            aVolumeGrade,
        //            new AllocationColorSizeComponent(colorComponent, sizeComponent));	
        //    }
        //    return aAllocationProfile.GetStoreListTotalSizeCurvePct(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID);
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreSizeCurvePct

		#region StoreListTotalSizeOnHand
		public int GetStoreListTotalSizeOnHand(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, GeneralComponent aComponent, bool curveAdjusted) // MID Track 3209 Show actual OH and IT on Size Review
		{
			if (aAllocationProfile == null)
			{
				int sizeOnHand = 0;
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					sizeOnHand += GetStoreListTotalSizeOnHand(ap, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
				}
				return sizeOnHand;
			}
			return aAllocationProfile.GetStoreListTotalSizeOnHand(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
		}
        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
        //public double GetStoreListTotalSizeOnHand(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, HdrColorBin aColor, int aSizeRID, bool curveAdjusted) // MID Track 3209 Show actual OH and IT on Size Review 
        //{
        //    return GetStoreListTotalSizeOnHand(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColor.ColorCodeRID, aSizeRID, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
        //}
        
        //public double GetStoreListTotalSizeOnHand(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aColorRID, int aSizeRID, bool curveAdjusted) // MID Track 3209 Show actual OH and IT on Size Review
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
        //        AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
        //        return this.GetStoreListTotalSizeOnHand(
        //            aAllocationProfile,
        //            aStoreGrpRID,
        //            aStoreGrpLvlRID, 
        //            aVolumeGrade,
        //            new AllocationColorSizeComponent(colorComponent, sizeComponent), // MID Track 3209 Show actual OH and IT on Size Review
        //            curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review	
        //    }
        //    return aAllocationProfile.GetStoreListTotalSizeOnHand(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID, curveAdjusted);
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreSizeOnHand

		#region StoreListTotalSizeInTransit
		public int GetStoreListTotalSizeInTransit(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, GeneralComponent aComponent, bool curveAdjusted) // MID Track 3209 Show actual OH and IT on Size Review
		{
			if (aAllocationProfile == null)
			{
				int sizeInTransit = 0;
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					sizeInTransit += GetStoreListTotalSizeInTransit(ap, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
				}
				return sizeInTransit;
			}
			return aAllocationProfile.GetStoreListTotalSizeInTransit(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
        //public double GetStoreListTotalSizeInTransit(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, HdrColorBin aColor, int aSizeRID, bool curveAdjusted) // MID Track 3209 Show actual OH and IT on Size Review
        //{
        //    return GetStoreListTotalSizeInTransit(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColor.ColorCodeRID, aSizeRID, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function

		public double GetStoreListTotalSizeInTransit(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aColorRID, int aSizeRID, bool curveAdjusted) // MID Track 3209 Show actual OH and IT on Size Review
		{
			if (aAllocationProfile == null)
			{
				AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
				AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
				return this.GetStoreListTotalSizeInTransit(
					aAllocationProfile,
					aStoreGrpRID,
					aStoreGrpLvlRID, 
					aVolumeGrade,
					new AllocationColorSizeComponent(colorComponent, sizeComponent), // MID Track 3209 Show actual OH and IT on Size Review
					curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review	
			}
			return aAllocationProfile.GetStoreListTotalSizeInTransit(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID, curveAdjusted); // MID Track 3209 Show actual OH and IT on Size Review
		}
		#endregion StoreListTotalSizeInTransit

		#region StoreListTotalSizePlan
		/// <summary>
		/// Get Total Size Plan for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  "null" returns plan across all headers</param>
		/// <param name="aStoreGrpRID">RID that identifies the attribute (group)</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies the attribute set (group level) within the attribute (group)</param>
		/// <param name="aVolumeGrade">Volume Grade.  "null" returns plan for all stores in set regardless of grade</param>
		/// <param name="aComponent">Component that identifies the color and size</param>
		/// <param name="aReturnFillSizePlan">True: returns plan used by Fill Size Holes (units allocated not in the plan); False: returns plan used by Size Need (includes units allocated in plan calculation)</param>
		/// <param name="aUseBasisPlan">True: Fill Size Plan Based on Basis Plan; False: Fill Size Plan Based on Ownership</param>		
		/// <returns>Total Size Plan for the indicated stores</returns>
		public int GetStoreListTotalSizePlan(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, GeneralComponent aComponent, bool aReturnFillSizePlan, bool aUseBasisPlan) // MID Track 4291 add fill variables to size review // MID track 4921 AnF#666 Fill to Size Plan Enhancement
		{
			if (aAllocationProfile == null)
			{
				int sizePlan = 0;
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					sizePlan += GetStoreListTotalSizePlan(ap, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, aReturnFillSizePlan, aUseBasisPlan); // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
				}
				return sizePlan;
			}
			return aAllocationProfile.GetStoreListTotalSizePlan(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, aReturnFillSizePlan, aUseBasisPlan); // MID Track 4291 add fill variables to size review // MID track 4921 AnF#666 Fill to Size Plan Enhancement
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get Total Size Plan for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile. "null" returns plan across all headers</param>
		/// <param name="aStoreGrpRID">RID that identifies the attribute (group)</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies the attribute set (group level) within the attribute (group)</param>
		/// <param name="aVolumeGrade">Volume Grade.  "null" returns plan for all stores in set regardless of grade</param>
		/// <param name="aColor">HdrColorBin that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizePlan">True: returns plan used by Fill Size Holes (units allocated not in the plan). False: return plan used by Size Need (includes units allocated in plan calculation)</param>
		/// <param name="aUseBasisPlan">True: Fill Size Plan Based on Basis Plan; False: Fill Size Plan Based on Ownership</param>		
		/// <returns>Total Size Plan for the indicated stores</returns>
        //public double GetStoreListTotalSizePlan(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, HdrColorBin aColor, int aSizeRID, bool aReturnFillSizePlan, bool aUseBasisPlan) // MID Track 4291 add fill variables to size review // MID track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    return GetStoreListTotalSizePlan(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColor.ColorCodeRID, aSizeRID, aReturnFillSizePlan, aUseBasisPlan); // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        

		/// <summary>
		/// Get Total Size Plan for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile. "null" returns plan across all headers</param>
		/// <param name="aStoreGrpRID">RID that identifies the attribute (group)</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies the attribute set (group level) within the attribute (group)</param>
		/// <param name="aVolumeGrade">Volume Grade.  "null" returns plan for all stores in set regardless of grade</param>
		/// <param name="aColorRID">Color Code RID that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizePlan">True: returns plan used by Fill Size Holes (units allocated not in the plan). False: return plan used by Size Need (includes units allocated in plan calculation)</param>
		/// <param name="aUseBasisPlan">True: Fill Size Plan Based on Basis Plan; False: Fill Size Plan Based on Ownership</param>		
		/// <returns>Total Size Plan for the indicated stores</returns>
        //public double GetStoreListTotalSizePlan(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aColorRID, int aSizeRID, bool aReturnFillSizePlan, bool aUseBasisPlan) // MID track 4291 add fill variables to size review  // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
        //        AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
        //        return this.GetStoreListTotalSizePlan(
        //            aAllocationProfile,
        //            aStoreGrpRID,
        //            aStoreGrpLvlRID, 
        //            aVolumeGrade,
        //            new AllocationColorSizeComponent(colorComponent, sizeComponent), // MID Track 4291 add Fill Variables to size review
        //            aReturnFillSizePlan,                                            // MID Track 4291 add Fill Variables to size review	 // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //            aUseBasisPlan);                                                 // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //    }
        //    return aAllocationProfile.GetStoreListTotalSizePlan(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID, aReturnFillSizePlan, aUseBasisPlan); // MID Track 4291 add Fill Variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreListTotalSizePlan

		#region StoreListTotalSizeNeed
        /// <summary>
        /// Get Size Need for a list of stores
        /// </summary>
        /// <param name="aAllocationProfile">Allocation Profile.  When "null", size need across all selected headers returned</param>
        /// <param name="aStoreGrpRID">RID that identifies attribute (group).</param>
        /// <param name="aStoreGrpLvlRID">RID that identifies set of stores (group level) within attribute (group)</param>
        /// <param name="aVolumeGrade">Volume Grade.  When "null", size need across all stores within the selected set regardless of grade is returned</param>
        /// <param name="aComponent">Component that identifies the color and size</param>
        /// <param name="aReturnFillSizeNeed">True: Return Size Need used in Fill Size Holes (plan calculation does not include quantity allocated); Fales: Return Size Need used by "Size Need Allocation" (plan calculation does include quantity allocated)</param>
		/// <param name="aUseBasisPlan">True: Fill Size Plan Based on Basis Plan; False: Fill Size Plan Based on Ownership</param>		
		/// <returns>Total Size Need for the selected list of stores</returns>
		public int GetStoreListTotalSizeNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, GeneralComponent aComponent, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID Track 4291 add Fill Variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
		{
			if (aAllocationProfile == null)
			{
				return (int)Need.UnitNeed(
					this.GetStoreListTotalSizePlan (aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, aReturnFillSizeNeed, aUseBasisPlan),  // MID track 4291 add fill variables to size review  // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
					this.GetStoreListTotalSizeOnHand(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, true),
					this.GetStoreListTotalSizeInTransit(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, true),
					this.GetStoreListTotalQtyAllocated(aAllocationProfile, aComponent, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade));
			}
			return aAllocationProfile.GetStoreListTotalSizeNeed(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, aReturnFillSizeNeed, aUseBasisPlan); // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get Size Need for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", size need across all selected headers returned</param>
		/// <param name="aStoreGrpRID">RID that identifies attribute (group).</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies set of stores (group level) within attribute (group)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", size need across all stores within the selected set regardless of grade is returned</param>
		/// <param name="aColor">HdrColorBin that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizeNeed">True: Return Size Need used in Fill Size Holes (plan calculation does not include quantity allocated); Fales: Return Size Need used by "Size Need Allocation" (plan calculation does include quantity allocated)</param>
        /// <param name="aUseBasisPlan">True: Fill Size Plan Based on Basis Plan; False: Fill Size Plan Based on Ownership</param>		
		/// <returns>Total Size Need for the selected list of stores</returns>
        //public int GetStoreListTotalSizeNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, HdrColorBin aColor, int aSizeRID, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID track 4291 add Fill Variables to size review // MID track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    return GetStoreListTotalSizeNeed(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColor.ColorCodeRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan); // MID track 4291 add fill variables to size review // MID track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        

		/// <summary>
		/// Get Size Need for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", size need across all selected headers returned</param>
		/// <param name="aStoreGrpRID">RID that identifies attribute (group).</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies set of stores (group level) within attribute (group)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", size need across all stores within the selected set regardless of grade is returned</param>
		/// <param name="aColorRID">Color Code RID that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizeNeed">True: Return Size Need used in Fill Size Holes (plan calculation does not include quantity allocated); Fales: Return Size Need used by "Size Need Allocation" (plan calculation does include quantity allocated)</param>
        /// <param name="aUseBasisPlan">True: Fill Size Plan Based on Basis Plan; False: Fill Size Plan Based on Ownership</param>		
		/// <returns>Total Size Need for the selected list of stores</returns>
        //public int GetStoreListTotalSizeNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aColorRID, int aSizeRID, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
        //        AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
        //        return this.GetStoreListTotalSizeNeed(
        //            aAllocationProfile,
        //            aStoreGrpRID,
        //            aStoreGrpLvlRID, 
        //            aVolumeGrade,
        //            new AllocationColorSizeComponent(colorComponent, sizeComponent), // MID track 4291 add fill variables to size review
        //            aReturnFillSizeNeed,                                            // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan
        //            aUseBasisPlan);                                                 // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //    }
        //    return aAllocationProfile.GetStoreListTotalSizeNeed(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan);  // MID Track 4291 add fill variables to size review  // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreListTotalSizeNeed

		#region StoreListTotalSizePctNeed
		/// <summary>
		/// Get the Total Size Percent Need for a list of stores 
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", the Size Percent need across all headers of the subtotal is returned</param>
		/// <param name="aStoreGrpRID">RID that identifies attribute (group).</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies set of stores (group level) within attribute (group)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", size need across all stores within the selected set regardless of grade is returned</param>
		/// <param name="aComponent">Component that identifies the color and size</param>
		/// <param name="aReturnFillSizeNeed">True: Return Size Percent Need used in Fill Size Holes (plan calculation does not include quantity allocated); Fales: Return Size Need used by "Size Need Allocation" (plan calculation does include quantity allocated)</param>
		/// <param name="aUseBasisPlan">True: Fill Size Plan Based on Basis Plan; False: Fill Size Plan Based on Ownership</param>		
		/// <returns>Total Size Percent Need for the selected list of stores</returns>
		public double GetStoreListTotalSizePctNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, GeneralComponent aComponent, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID Track 4291 add fill variables to size review // MID track 4921 AnF#666 Fill to Size Plan Enhancement
		{
			if (aAllocationProfile == null)
			{
				return (double)(((long)(Need.PctUnitNeed(this.GetStoreListTotalSizeNeed(null, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, aReturnFillSizeNeed, aUseBasisPlan), this.GetStoreListTotalSizePlan(null, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, aReturnFillSizeNeed, aUseBasisPlan)) // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan ENhancement
					* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision + .5d))
					/ (double)this.Transaction.StoreSizePctToTotalDecimalPrecision);
			}
			return aAllocationProfile.GetStoreListTotalSizePctNeed(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, aReturnFillSizeNeed, aUseBasisPlan); // MID track 4291 add fill variables to size review // MID track 4921 AnF#666 Fill to Size Plan Enhancement
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get the Total Size Percent Need for a list of stores 
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", the Size Percent need across all headers of the subtotal is returned</param>
		/// <param name="aStoreGrpRID">RID that identifies attribute (group).</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies set of stores (group level) within attribute (group)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", size need across all stores within the selected set regardless of grade is returned</param>
		/// <param name="aColor">HdrColorBin that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizeNeed">True: Return Size Percent Need used in Fill Size Holes (plan calculation does not include quantity allocated); Fales: Return Size Need used by "Size Need Allocation" (plan calculation does include quantity allocated)</param>
		/// <param name="aUseBasisPlan">True: Fill Size Plan Based on Basis Plan; False: Fill Size Plan Based on Ownership</param>		
		/// <returns>Total Size Percent Need for the selected list of stores</returns>
        //public double GetStoreListTotalSizePctNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, HdrColorBin aColor, int aSizeRID, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    return GetStoreListTotalSizePctNeed(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColor.ColorCodeRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan); // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan ENhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get the Total Size Percent Need for a list of stores 
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", the Size Percent need across all headers of the subtotal is returned</param>
		/// <param name="aStoreGrpRID">RID that identifies attribute (group).</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies set of stores (group level) within attribute (group)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", size need across all stores within the selected set regardless of grade is returned</param>
		/// <param name="aColorRID">Color Code RID that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <param name="aReturnFillSizeNeed">True: Return Size Percent Need used in Fill Size Holes (plan calculation does not include quantity allocated); Fales: Return Size Need used by "Size Need Allocation" (plan calculation does include quantity allocated)</param>
		/// <param name="aUseBasisPlan">True: Fill Size Plan Based on Basis Plan; False: Fill Size Plan Based on Ownership</param>		
		/// <returns>Total Size Percent Need for the selected list of stores</returns>
        //public double GetStoreListTotalSizePctNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aColorRID, int aSizeRID, bool aReturnFillSizeNeed, bool aUseBasisPlan) // MID Track 4291 add fill variables to size review // MID track 4921 AnF#666 Fill to Size Plan Enhancement
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        return (double)(((long)(Need.PctUnitNeed(this.GetStoreListTotalSizeNeed(null, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan), this.GetStoreListTotalSizePlan(null, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan)) // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //            * (double)this.Transaction.StoreSizePctToTotalDecimalPrecision + .5d))
        //            / (double)this.Transaction.StoreSizePctToTotalDecimalPrecision);
        //    }
        //    return aAllocationProfile.GetStoreListTotalSizePctNeed(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID, aReturnFillSizeNeed, aUseBasisPlan); // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreListTotalSizePctNeed

		#region StoreListTotalSizePosNeed
		/// <summary>
		/// Get Total Size Positive Need for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", returns total size positive need across all headers of the subtotal</param>
		/// <param name="aStoreGrpRID">RID that identifies the attribute (store group)</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies the set of stores within the attribute (store group level)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", returns total size positive need for all stores in set regardless of grade</param>
		/// <param name="aComponent">Component identifies the color and size</param>
		/// <returns>Total Size Positive Need for stores in the specified set</returns>
		public int GetStoreListTotalSizePosNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, GeneralComponent aComponent)
		{
			if (aAllocationProfile == null)
			{
				int posNeed = 0;
				ProfileList spl = this.GetStoresInVolumeGrade(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade);
				foreach (AllocationProfile ap in this.SubtotalMembers)
				{
					posNeed += ap.GetStoreListTotalSizePosNeed(spl, aComponent);
				}
				return posNeed;
			}
			return aAllocationProfile.GetStoreListTotalSizePosNeed(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent);
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get Total Size Positive Need for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", returns total size positive need across all headers of the subtotal</param>
		/// <param name="aStoreGrpRID">RID that identifies the attribute (store group)</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies the set of stores within the attribute (store group level)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", returns total size positive need for all stores in set regardless of grade</param>
		/// <param name="aColor">HdrColorBin that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <returns>Total Size Positive Need for stores in the specified set</returns>
        //public int GetStoreListTotalSizePosNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, HdrColorBin aColor, int aSizeRID)
        //{
        //    return GetStoreListTotalSizePosNeed(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColor.ColorCodeRID, aSizeRID);
        //}
        

		/// <summary>
		/// Get Total Size Positive Need for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", returns total size positive need across all headers of the subtotal</param>
		/// <param name="aStoreGrpRID">RID that identifies the attribute (store group)</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies the set of stores within the attribute (store group level)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", returns total size positive need for all stores in set regardless of grade</param>
		/// <param name="aColorRID">Color Code RID that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <returns></returns>
        //public int GetStoreListTotalSizePosNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aColorRID, int aSizeRID)
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColorRID);
        //        AllocationColorOrSizeComponent sizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSizeRID);
        //        return this.GetStoreListTotalSizePosNeed(
        //            aAllocationProfile,
        //            aStoreGrpRID,
        //            aStoreGrpLvlRID, 
        //            aVolumeGrade,
        //            new AllocationColorSizeComponent(colorComponent, sizeComponent));
        //    }
        //    return aAllocationProfile.GetStoreListTotalSizePosNeed(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID);
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		#endregion StoreListTotalSizePosNeed

		#region StoreListTotalSizePosPctNeed
		/// <summary>
		/// Get the Total Size Positive Percent Need for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", returns total size positive need across all headers of the subtotal</param>
		/// <param name="aStoreGrpRID">RID that identifies the attribute (store group)</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies the set of stores within the attribute (store group level)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", returns total size positive need for all stores in set regardless of grade</param>
		/// <param name="aComponent">Component identifies the color and size</param>
		/// <returns>Total Size Positive Percent Need for the specified list of stores</returns>
		public double GetStoreListTotalSizePosPctNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, GeneralComponent aComponent)
		{
			if (aAllocationProfile == null)
			{
				return Math.Max(
					0,
					(double)(((long)(Need.PctUnitNeed(this.GetStoreListTotalSizeNeed(null, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, false, false), this.GetStoreListTotalSizePlan(null, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent, false, false)) // MID track 4291 add fill variables to size review  // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
					* (double)this.Transaction.StoreSizePctToTotalDecimalPrecision + .5d))
					/ (double)this.Transaction.StoreSizePctToTotalDecimalPrecision)
					);
			}
			return aAllocationProfile.GetStoreListTotalSizePosPctNeed(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aComponent);
		}

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get the Total Size Positive Percent Need for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", returns total size positive need across all headers of the subtotal</param>
		/// <param name="aStoreGrpRID">RID that identifies the attribute (store group)</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies the set of stores within the attribute (store group level)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", returns total size positive need for all stores in set regardless of grade</param>
		/// <param name="aColor">HdrColorBin that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <returns>Total Size Positive Percent Need for the specified list of stores</returns>
        //public double GetStoreListTotalSizePosPctNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, HdrColorBin aColor, int aSizeRID)
        //{
        //    return GetStoreListTotalSizePosPctNeed(aAllocationProfile, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColor.ColorCodeRID, aSizeRID);
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function

        //Begin TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function
		/// <summary>
		/// Get the Total Size Positive Percent Need for a list of stores
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile.  When "null", returns total size positive need across all headers of the subtotal</param>
		/// <param name="aStoreGrpRID">RID that identifies the attribute (store group)</param>
		/// <param name="aStoreGrpLvlRID">RID that identifies the set of stores within the attribute (store group level)</param>
		/// <param name="aVolumeGrade">Volume Grade.  When "null", returns total size positive need for all stores in set regardless of grade</param>
		/// <param name="aColorRID">Color Code RID that identifies the color</param>
		/// <param name="aSizeRID">Size Code RID that identifies the size</param>
		/// <returns>Total Size Positive Percent Need for the specified list of stores</returns>
        //public double GetStoreListTotalSizePosPctNeed(AllocationProfile aAllocationProfile, int aStoreGrpRID, int aStoreGrpLvlRID, string aVolumeGrade, int aColorRID, int aSizeRID)
        //{
        //    if (aAllocationProfile == null)
        //    {
        //        return Math.Max(
        //            0, 
        //            (double)(((long)(Need.PctUnitNeed(this.GetStoreListTotalSizeNeed(null, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID, false, false), this.GetStoreListTotalSizePlan(null, aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID, false, false)) // MID Track 4291 add fill variables to size review // MID Track 4921 AnF#666 Fill to Size Plan Enhancement
        //            * (double)this.Transaction.StoreSizePctToTotalDecimalPrecision + .5d))
        //            / (double)this.Transaction.StoreSizePctToTotalDecimalPrecision)
        //            );
        //    }
        //    return aAllocationProfile.GetStoreListTotalSizePosPctNeed(aStoreGrpRID, aStoreGrpLvlRID, aVolumeGrade, aColorRID, aSizeRID);
        //}
        //End TT#846-MD -jsobek -Fill to Size Plan Presentation -unused function

		#endregion StoreListTotalSizePodPctNeed
		// END MID Track # 2937 Size OnHand Incorrect
		#endregion StoreGrpLvls

		#region AllocatedBalance
		#region GetOrigAllocatedBalance
		//===================//
		// Allocated Balance //
		//===================//
		/// <summary>
		/// Gets Original Allocated Balance for specified component.
		/// </summary>
		/// <param name="aObject">Description of the allocation component: eAllocationSummaryNode, PackHdr, HdrColorBin or HdrSizeBin.</param>
		/// <returns>Allocation Balance</returns>
		internal int GetOrigAllocatedBalanceInObj(object aObject)
		{
			if (aObject is eAllocationSummaryNode)
			{
				return GetOrigAllocatedBalance((eAllocationSummaryNode)aObject);
			}
			if (aObject is PackHdr)
			{
				return GetOrigAllocatedBalance((PackHdr)aObject);
			}
			if (aObject is HdrColorBin)
			{
				return GetOrigAllocatedBalance((HdrColorBin)aObject);
			}
			if (aObject is HdrSizeBin)
			{
				return GetOrigAllocatedBalance((HdrSizeBin)aObject);
			}
			if (aObject is GeneralComponent)
			{
				return GetOrigAllocatedBalance((GeneralComponent)aObject);
			}
			throw new MIDException(eErrorLevel.severe,
				(int)(eMIDTextCode.msg_UnknownAllocationComponent),
				this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownAllocationComponent));
		}

		/// <summary>
		/// Gets Original Allocated Balance for specified component of the specified AllocationProfile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <returns>Original Allocated Balance for the specified component.</returns>
		internal int GetOrigAllocatedBalance(AllocationProfile aAllocationProfile,GeneralComponent aComponent)
		{
			if (aAllocationProfile == null)
			{
				return GetOrigAllocatedBalance(aComponent);
			}
			return aAllocationProfile.GetOrigAllocatedBalance(aComponent);
		}

		/// <summary>
		/// Gets Original Allocated Balance for specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <returns>Original Allocated Balance for the specified component.</returns>
		internal int GetOrigAllocatedBalance(GeneralComponent aComponent)
		{
			int allocatedBalance;
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetOrigAllocatedBalance(eAllocationSummaryNode.BulkColorTotal);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetOrigAllocatedBalance(eAllocationSummaryNode.GenericType);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							(GetOrigAllocatedBalance (eAllocationSummaryNode.DetailSubType)
							- GetOrigAllocatedBalance (eAllocationSummaryNode.Bulk));
					}
					return GetOrigAllocatedBalance(eAllocationSummaryNode.DetailSubType);
				}
				case (eComponentType.AllPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							GetOrigAllocatedBalance (eAllocationSummaryNode.GenericType)
							+ GetOrigAllocatedBalance (eAllocationSummaryNode.DetailSubType)
							- GetOrigAllocatedBalance (eAllocationSummaryNode.Bulk);
					}
					return
						GetOrigAllocatedBalance (eAllocationSummaryNode.GenericType)
						+ GetOrigAllocatedBalance (eAllocationSummaryNode.DetailSubType);
				}
				case (eComponentType.AllSizes):
				{
					allocatedBalance = 0;
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						foreach (HdrColorBin hcb in ap.BulkColors.Values)
						{
							foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
							{
								allocatedBalance += ap.GetOrigAllocatedBalance(hsb);
							}
						}
					}
					return allocatedBalance;
				}
				case (eComponentType.Bulk):
				{
					return GetOrigAllocatedBalance (eAllocationSummaryNode.Bulk);
				}
				case (eComponentType.ColorAndSize):
				{
					allocatedBalance = 0;
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (AllocationProfile ap in this.SubtotalMembers)
									{
										foreach (HdrColorBin hcb in ap.BulkColors.Values)
										{
											foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
											{
												allocatedBalance += ap.GetOrigAllocatedBalance(hsb);
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									foreach (AllocationProfile ap in this.SubtotalMembers)
									{
										foreach (HdrColorBin hcb in ap.BulkColors.Values)
										{
											if (hcb.SizeIsInColor(sizeComponent.SizeRID))
											{
												allocatedBalance += ap.GetOrigAllocatedBalance(hcb, sizeComponent.SizeRID);
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (AllocationProfile ap in this.SubtotalMembers)
									{
										foreach (HdrColorBin hcb in ap.BulkColors.Values)
										{
											foreach (SizeCodeProfile scp in scl)
											{
												if (hcb.SizeIsInColor (scp.Key))
												{
													allocatedBalance += ap.GetOrigAllocatedBalance(hcb, scp.Key);
												}
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;   // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (AllocationProfile ap in this.SubtotalMembers)
									{
										foreach (HdrColorBin hcb in ap.BulkColors.Values)
										{
											foreach (SizeCodeProfile scp in scl)
											{
												if (hcb.SizeIsInColor (scp.Key))
												{
													allocatedBalance += ap.GetOrigAllocatedBalance(hcb, scp.Key);
												}
											}
										}
									}
									break;
								}
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							foreach (AllocationProfile ap in this.SubtotalMembers)
							{
								if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
								{
									switch (size.ComponentType)
									{
										case (eComponentType.AllSizes):
										{
											foreach(HdrSizeBin hsb in ap.GetHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
											{
												allocatedBalance += ap.GetOrigAllocatedBalance(hsb);
											}
											break;
										}
										case (eComponentType.SpecificSize):
										{
											sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
											if (ap.GetHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
											{
												allocatedBalance += ap.GetOrigAllocatedBalance(colorComponent.ColorRID, sizeComponent.SizeRID);
											}
											break;
										}
										// BEGIN MID Track #2412 Unknown Component
										case (eComponentType.SpecificSizePrimaryDim):
										{
											sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
											SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
											HdrColorBin hcb = ap.GetHdrColorBin(colorComponent.ColorRID);
											foreach (SizeCodeProfile scp in scl)
											{
												if (hcb.SizeIsInColor (scp.Key))
												{
													allocatedBalance += ap.GetOrigAllocatedBalance(hcb, scp.Key);
												}
											}
											break;
										}
										case (eComponentType.SpecificSizeSecondaryDim):
										{
											sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
											SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
											HdrColorBin hcb = ap.GetHdrColorBin(colorComponent.ColorRID);
											foreach (SizeCodeProfile scp in scl)
											{
												if (hcb.SizeIsInColor (scp.Key))
												{
													allocatedBalance += ap.GetOrigAllocatedBalance(hcb, scp.Key);
												}
											}
											break;
										}
										// END MID Track #2412 Unknown Component
										default:
										{
											throw new MIDException(eErrorLevel.severe,
												(int)(eMIDTextCode.msg_al_UnknownComponentType),
												this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
										}
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					return allocatedBalance;
				}
				case (eComponentType.DetailType):
				{
					return GetOrigAllocatedBalance(eAllocationSummaryNode.DetailType);
				}
				case (eComponentType.GenericType):
				{
					return GetOrigAllocatedBalance(eAllocationSummaryNode.GenericType);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetOrigAllocatedBalance(colorComponent.ColorRID);
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					allocatedBalance = 0;
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						foreach (HdrColorBin hcb in ap.BulkColors.Values)
						{
							if (hcb.SizeIsInColor(sizeComponent.SizeRID))
							{
								allocatedBalance += ap.GetOrigAllocatedBalance(hcb, sizeComponent.SizeRID);
							}
						}
					}
					return allocatedBalance;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetOrigAllocatedBalance (packComponent.PackName);
				}
				case (eComponentType.Total):
				{
					return GetOrigAllocatedBalance (eAllocationSummaryNode.Total);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Gets Original AllocatedBalance for specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <returns>Original Allocation Balance for the specified node.</returns>
		public int GetOrigAllocatedBalance(eAllocationSummaryNode aAllocationSummaryNode)
		{
			int allocatedBalance = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				allocatedBalance += ap.GetOrigAllocatedBalance(aAllocationSummaryNode);
			}
			return allocatedBalance;
		}

		/// <summary>
		/// Gets Original Allocated Balance for specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <returns>Original Allocation Balance for the specified node.</returns>
		public int GetOrigAllocatedBalance(string aPackName)
		{
			return GetOrigAllocatedBalance(GetSubtotalPackHdr(aPackName));
		}

		/// <summary>
		/// Gets Original Allocated Balance for specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where store resides.</param>
		/// <returns>Origainal Allocation Balance for the specified node.</returns>
		internal int GetOrigAllocatedBalance(PackHdr aPack)
		{
			int allocatedBalance = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aPack.PackName) &&
					ap.GetSubtotalPackName (aPack.PackName) == aPack.SubtotalPackName)
				{
					allocatedBalance += ap.GetAllocatedBalance(aPack.PackName);
				}
			}
			return allocatedBalance;
		}

		/// <summary>
		/// Gets Original  Allocated Balance for specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <returns>Original Allocated Balance for the specified node.</returns>
		public int GetOrigAllocatedBalance(int aColorRID)
		{
			return GetOrigAllocatedBalance(GetSubtotalHdrColorBin(aColorRID));
		}

		/// <summary>
		/// Gets Original Allocated Balance for specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <returns>Original Allocation Balance for the specified node.</returns>
		internal int GetOrigAllocatedBalance(HdrColorBin aColor)
		{
			int allocatedBalance = 0;
			foreach(AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					allocatedBalance += ap.GetOrigAllocatedBalance(aColor.ColorCodeRID);
				}
			}
			return allocatedBalance;
		}

		/// <summary>
		/// Gets Original Allocated Balance for specified color-size node.
		/// </summary>
		/// <param name="aColorRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <returns>Original Allocation Balance for the specified node.</returns>
		public int GetOrigAllocatedBalance(int aColorRID, int aSizeRID)
		{
			return GetOrigAllocatedBalance(GetSubtotalHdrColorBin(aColorRID), aSizeRID);
		}

		/// <summary>
		/// Gets Original Allocated Balance for specified color-size node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <returns>Original Allocated Balance for the specified node.</returns>
		internal int GetOrigAllocatedBalance(HdrColorBin aColor, int aSizeRID)
		{
			return GetOrigAllocatedBalance(aColor.GetSizeBin(aSizeRID));
		}

		/// <summary>
		/// Gets Original Allocated Balance for specified color-size node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <returns>Original Allocated Balance for the specified node.</returns>
		internal int GetOrigAllocatedBalance(HdrSizeBin aSize)
		{
			HdrColorBin color;
			int allocatedBalance = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
				{
					color = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (color.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
					{
                        allocatedBalance += ap.GetAllocatedBalance(color, aSize.SizeCodeRID); // Assortment: color/size changes
					}
				}
			}
			return allocatedBalance;
		}
		#endregion GetOrigAllocatedBalance

		#region GetAllocatedBalance
		//===================//
		// Allocated Balance //
		//===================//
		/// <summary>
		/// Gets Allocated Balance for specified component.
		/// </summary>
		/// <param name="aObject">Description of the allocation component: eAllocationSummaryNode, PackHdr, HdrColorBin or HdrSizeBin.</param>
		/// <returns>Allocation Balance</returns>
		internal int GetAllocatedBalanceInObj(object aObject)
		{
			if (aObject is eAllocationSummaryNode)
			{
				return GetAllocatedBalance((eAllocationSummaryNode)aObject);
			}
			if (aObject is PackHdr)
			{
				return GetAllocatedBalance((PackHdr)aObject);
			}
			if (aObject is HdrColorBin)
			{
				return GetAllocatedBalance((HdrColorBin)aObject);
			}
			if (aObject is HdrSizeBin)
			{
				return GetAllocatedBalance((HdrSizeBin)aObject);
			}
			if (aObject is GeneralComponent)
			{
				return GetAllocatedBalance((GeneralComponent)aObject);
			}
			throw new MIDException(eErrorLevel.severe,
				(int)(eMIDTextCode.msg_UnknownAllocationComponent),
				this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownAllocationComponent));
		}

		/// <summary>
		/// Gets Allocated Balance for specified component of the Allocation Profile.
		/// </summary>
		/// <param name="aAllocationProfile">Allocaiton Profile</param>
		/// <param name="aComponent">Description of the component</param>
		/// <returns>Allocated Balance for the specified component.</returns>
		internal int GetAllocatedBalance(AllocationProfile aAllocationProfile, GeneralComponent aComponent)
		{
			if (aAllocationProfile == null)
			{
				return GetAllocatedBalance(aComponent);
			}
			return aAllocationProfile.GetAllocatedBalance(aComponent);
		}

		/// <summary>
		/// Gets Allocated Balance for specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <returns>Allocated Balance for the specified component.</returns>
		internal int GetAllocatedBalance(GeneralComponent aComponent)
		{
			int allocatedBalance;
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetAllocatedBalance(eAllocationSummaryNode.BulkColorTotal);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetAllocatedBalance(eAllocationSummaryNode.GenericType);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							(GetAllocatedBalance (eAllocationSummaryNode.DetailSubType)
							- GetAllocatedBalance (eAllocationSummaryNode.Bulk));
					}
					return GetAllocatedBalance(eAllocationSummaryNode.DetailSubType);
				}
				case (eComponentType.AllPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							GetAllocatedBalance (eAllocationSummaryNode.GenericType)
							+ GetAllocatedBalance (eAllocationSummaryNode.DetailSubType)
							- GetAllocatedBalance (eAllocationSummaryNode.Bulk);
					}
					return
						GetAllocatedBalance (eAllocationSummaryNode.GenericType)
						+ GetAllocatedBalance (eAllocationSummaryNode.DetailSubType);
				}
				case (eComponentType.AllSizes):
				{
					allocatedBalance = 0;
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						foreach (HdrColorBin hcb in ap.BulkColors.Values)
						{
							foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
							{
								allocatedBalance += ap.GetAllocatedBalance(hsb);
							}
						}
					}
					return allocatedBalance;
				}
				case (eComponentType.Bulk):
				{
					return GetAllocatedBalance (eAllocationSummaryNode.Bulk);
				}
				case (eComponentType.ColorAndSize):
				{
					allocatedBalance = 0;
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									foreach (AllocationProfile ap in this.SubtotalMembers)
									{
										foreach (HdrColorBin hcb in ap.BulkColors.Values)
										{
											foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
											{
												allocatedBalance += ap.GetAllocatedBalance(hsb);
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSize):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color 
									foreach (AllocationProfile ap in this.SubtotalMembers)
									{
										foreach (HdrColorBin hcb in ap.BulkColors.Values)
										{
											if (hcb.SizeIsInColor(sizeComponent.SizeRID))
											{
												allocatedBalance += ap.GetAllocatedBalance(hcb, sizeComponent.SizeRID);
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
									foreach (AllocationProfile ap in this.SubtotalMembers)
									{
										foreach (HdrColorBin hcb in ap.BulkColors.Values)
										{
											foreach (SizeCodeProfile scp in scl)
											{
												if (hcb.SizeIsInColor(scp.Key))
												{
													allocatedBalance += ap.GetAllocatedBalance(hcb, scp.Key);
												}
											}
										}
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
									foreach (AllocationProfile ap in this.SubtotalMembers)
									{
										foreach (HdrColorBin hcb in ap.BulkColors.Values)
										{
											foreach (SizeCodeProfile scp in scl)
											{
												if (hcb.SizeIsInColor(scp.Key))
												{
													allocatedBalance += ap.GetAllocatedBalance(hcb, scp.Key);
												}
											}
										}
									}
									break;
								}
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							break;
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							foreach (AllocationProfile ap in this.SubtotalMembers)
							{
								if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
								{
									switch (size.ComponentType)
									{
										case (eComponentType.AllSizes):
										{
											foreach(HdrSizeBin hsb in ap.GetHdrColorBin(colorComponent.ColorRID).ColorSizes.Values)
											{
												allocatedBalance += ap.GetAllocatedBalance(hsb);
											}
											break;
										}
										case (eComponentType.SpecificSize):
										{
											sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
											if (ap.GetHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
											{
												allocatedBalance += ap.GetAllocatedBalance(colorComponent.ColorRID, sizeComponent.SizeRID);
											}
											break;
										}
                                        // BEGIN MID Track #2412 Unknown Component
										case (eComponentType.SpecificSizePrimaryDim):
										{
											sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
											SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
											HdrColorBin hcb = ap.GetHdrColorBin(colorComponent.ColorRID);
											foreach (SizeCodeProfile scp in scl)
											{
												if (hcb.SizeIsInColor (scp.Key))
												{
													allocatedBalance += ap.GetAllocatedBalance(hcb, scp.Key);
												}
											}
											break;
										}
										case (eComponentType.SpecificSizeSecondaryDim):
										{
											sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
											SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
											HdrColorBin hcb = ap.GetHdrColorBin(colorComponent.ColorRID);
											foreach (SizeCodeProfile scp in scl)
											{
												if (hcb.SizeIsInColor (scp.Key))
												{
													allocatedBalance += ap.GetAllocatedBalance(hcb, scp.Key);
												}
											}
											break;
										}
                                        // END MID Track #2412 
										default:
										{
											throw new MIDException(eErrorLevel.severe,
												(int)(eMIDTextCode.msg_al_UnknownComponentType),
												this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
										}
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					return allocatedBalance;
				}
				case (eComponentType.DetailType):
				{
					return GetAllocatedBalance(eAllocationSummaryNode.DetailType);
				}
				case (eComponentType.GenericType):
				{
					return GetAllocatedBalance(eAllocationSummaryNode.GenericType);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetAllocatedBalance(colorComponent.ColorRID);
				}
				case (eComponentType.SpecificSize):
				{
					sizeComponent = (AllocationColorOrSizeComponent)aComponent;
					allocatedBalance = 0;
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						foreach (HdrColorBin hcb in ap.BulkColors.Values)
						{
							if (hcb.SizeIsInColor(sizeComponent.SizeRID))
							{
								allocatedBalance += ap.GetAllocatedBalance(hcb, sizeComponent.SizeRID);
							}
						}
					}
					return allocatedBalance;
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetAllocatedBalance (packComponent.PackName);
				}
				case (eComponentType.Total):
				{
					return GetAllocatedBalance (eAllocationSummaryNode.Total);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Gets AllocatedBalance for specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <returns>Allocation Balance for the specified node.</returns>
		public int GetAllocatedBalance(eAllocationSummaryNode aAllocationSummaryNode)
		{
            int allocatedBalance = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				allocatedBalance += ap.GetAllocatedBalance(aAllocationSummaryNode);
			}
			return allocatedBalance;
		}

		/// <summary>
		/// Gets Allocated Balance for specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <returns>Allocation Balance for the specified node.</returns>
		public int GetAllocatedBalance(string aPackName)
		{
			return GetAllocatedBalance(GetSubtotalPackHdr(aPackName));
		}

		/// <summary>
		/// Gets Allocated Balance for specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where store resides.</param>
		/// <returns>Allocation Balance for the specified node.</returns>
		internal int GetAllocatedBalance(PackHdr aPack)
		{
			int allocatedBalance = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.PackIsOnHeader(aPack.PackName) &&
					ap.GetSubtotalPackName(aPack.PackName) == aPack.SubtotalPackName)
				{
					allocatedBalance += ap.GetAllocatedBalance(aPack.PackName);
				}
			}
			return allocatedBalance; 
		}

		/// <summary>
		/// Gets Allocated Balance for specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <returns>Allocated Balance for the specified node.</returns>
		public int GetAllocatedBalance(int aColorRID)
		{
			return GetAllocatedBalance(GetSubtotalHdrColorBin(aColorRID));
		}

		/// <summary>
		/// Gets Allocated Balance for specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <returns>Allocated Balance for the specified node.</returns>
		internal int GetAllocatedBalance(HdrColorBin aColor)
		{
			int allocatedBalance = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aColor.ColorCodeRID))
				{
					allocatedBalance += ap.GetAllocatedBalance(aColor.ColorCodeRID);
				}
			}
			return allocatedBalance; 
		}

		/// <summary>
		/// Gets Allocated Balance for specified color-size node.
		/// </summary>
		/// <param name="aColorRID">RID for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <returns>Allocation Balance for the specified node.</returns>
		public int GetAllocatedBalance(int aColorRID, int aSizeRID)
		{
			return GetAllocatedBalance(GetSubtotalHdrColorBin(aColorRID), aSizeRID);
		}

		/// <summary>
		/// Gets Allocated Balance for specified color-size node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color where the size resides.</param>
		/// <param name="aSizeRID">RID for the size.</param>
		/// <returns>Allocated Balance for the specified node.</returns>
		internal int GetAllocatedBalance(HdrColorBin aColor, int aSizeRID)
		{
			return GetAllocatedBalance(aColor.GetSizeBin(aSizeRID));
		}

		/// <summary>
		/// Gets Allocated Balance for specified color-size node.
		/// </summary>
		/// <param name="aSize">HdrSizeBin for the size where the store resides.</param>
		/// <returns>Allocated Balance for the specified node.</returns>
		internal int GetAllocatedBalance(HdrSizeBin aSize)
		{
			int allocatedBalance = 0;
			HdrColorBin color;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (ap.BulkColorIsOnHeader(aSize.Color.ColorCodeRID))
				{
					color = ap.GetHdrColorBin(aSize.Color.ColorCodeRID);
                    if (color.SizeIsInColor(aSize.SizeCodeRID)) // Assortment: color/size changes
					{
                        allocatedBalance += ap.GetAllocatedBalance(color.ColorCodeRID, aSize.SizeCodeRID); // Assortment: color/size changes
					}
				}
			}
			return allocatedBalance; 
		}
		#endregion GetAllocatedBalance

		#region GetRuleAllocatedBalance
		//========================//
		// Rule Allocated Balance //
		//========================//
		/// <summary>
		/// Gets Rule Allocated Balance for specified component.
		/// </summary>
		/// <param name="aObject">Description of the allocation component: eAllocationSummaryNode, PackHdr, HdrColorBin or HdrSizeBin.</param>
		/// <returns>Rule Allocation Balance</returns>
		internal int GetRuleAllocatedBalanceInObj(object aObject)
		{
			if (aObject is eAllocationSummaryNode)
			{
				return GetRuleAllocatedBalance((eAllocationSummaryNode)aObject);
			}
			if (aObject is PackHdr)
			{
				return GetRuleAllocatedBalance((PackHdr)aObject);
			}
			if (aObject is HdrColorBin)
			{
				return GetRuleAllocatedBalance((HdrColorBin)aObject);
			}
			if (aObject is HdrSizeBin)
			{
				throw new MIDException(eErrorLevel.severe,
					(int)eMIDTextCode.msg_al_RuleNotTrackedBySize,
					this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_RuleNotTrackedBySize));
			}
			if (aObject is GeneralComponent)
			{
				return GetRuleAllocatedBalance((GeneralComponent)aObject);
			}
			throw new MIDException(eErrorLevel.severe,
				(int)(eMIDTextCode.msg_UnknownAllocationComponent),
				this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownAllocationComponent));
		}

		/// <summary>
		/// Gets Rule Allocated Balance for specified component.
		/// </summary>
		/// <param name="aComponent">Description of the component</param>
		/// <returns>Rule Allocated Balance for the specified component.</returns>
		internal int GetRuleAllocatedBalance(GeneralComponent aComponent)
		{
			AllocationPackComponent packComponent;
			AllocationColorOrSizeComponent colorComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					return GetRuleAllocatedBalance(eAllocationSummaryNode.BulkColorTotal);
				}
				case (eComponentType.AllGenericPacks):
				{
					return GetRuleAllocatedBalance(eAllocationSummaryNode.GenericType);
				}
				case (eComponentType.AllNonGenericPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							(GetRuleAllocatedBalance (eAllocationSummaryNode.DetailSubType)
							- GetRuleAllocatedBalance (eAllocationSummaryNode.Bulk));
					}
					return GetRuleAllocatedBalance(eAllocationSummaryNode.DetailSubType);
				}
				case (eComponentType.AllPacks):
				{
					if (this.BulkIsDetail)
					{
						return 
							GetRuleAllocatedBalance (eAllocationSummaryNode.GenericType)
							+ GetRuleAllocatedBalance (eAllocationSummaryNode.DetailSubType)
							- GetRuleAllocatedBalance (eAllocationSummaryNode.Bulk);
					}
					return
						GetRuleAllocatedBalance (eAllocationSummaryNode.GenericType)
						+ GetRuleAllocatedBalance (eAllocationSummaryNode.DetailSubType);
				}
				case (eComponentType.AllSizes):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_RuleNotTrackedBySize,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_RuleNotTrackedBySize));
				}
				case (eComponentType.Bulk):
				{
					return GetRuleAllocatedBalance (eAllocationSummaryNode.Bulk);
				}
				case (eComponentType.ColorAndSize):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_RuleNotTrackedBySize,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_RuleNotTrackedBySize));
				}
				case (eComponentType.DetailType):
				{
					return GetRuleAllocatedBalance(eAllocationSummaryNode.DetailType);
				}
				case (eComponentType.GenericType):
				{
					return GetRuleAllocatedBalance(eAllocationSummaryNode.GenericType);
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					return GetRuleAllocatedBalance(colorComponent.ColorRID);
				}
				case (eComponentType.SpecificSize):
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_RuleNotTrackedBySize,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_RuleNotTrackedBySize));
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					return GetRuleAllocatedBalance (packComponent.PackName);
				}
				case (eComponentType.Total):
				{
					return GetRuleAllocatedBalance (eAllocationSummaryNode.Total);
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
		}

		/// <summary>
		/// Gets Rule Allocated Balance for specified node.
		/// </summary>
		/// <param name="aAllocationSummaryNode">Allocation summary node.</param>
		/// <returns>Rule Allocation Balance for the specified node.</returns>
		public int GetRuleAllocatedBalance(eAllocationSummaryNode aAllocationSummaryNode)
		{
			int allocatedBalance = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				allocatedBalance += ap.GetRuleAllocatedBalance(aAllocationSummaryNode);
			}
			return allocatedBalance;
		}

		/// <summary>
		/// Gets Rule Allocated Balance for specified pack node.
		/// </summary>
		/// <param name="aPackName">Pack name.</param>
		/// <returns>Rule Allocation Balance for the specified node.</returns>
		public int GetRuleAllocatedBalance(string aPackName)
		{
			return GetRuleAllocatedBalance(GetSubtotalPackHdr(aPackName));
		}

		/// <summary>
		/// Gets Rule Allocated Balance for specified pack node.
		/// </summary>
		/// <param name="aPack">Pack header object where store resides.</param>
		/// <returns>Rule Allocation Balance for the specified node.</returns>
		internal int GetRuleAllocatedBalance(PackHdr aPack)
		{
			int allocatedBalance = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				allocatedBalance += ap.GetRuleAllocatedBalance(aPack.PackName);
			}
			return allocatedBalance;
		}

		/// <summary>
		/// Gets Rule Allocated Balance for specified color node.
		/// </summary>
		/// <param name="aColorRID">RID for the color.</param>
		/// <returns>Rule Allocated Balance for the specified node.</returns>
		public int GetRuleAllocatedBalance(int aColorRID)
		{
			return GetRuleAllocatedBalance(GetSubtotalHdrColorBin(aColorRID));
		}

		/// <summary>
		/// Gets Rule Allocated Balance for specified color node.
		/// </summary>
		/// <param name="aColor">HdrColorBin for the color.</param>
		/// <returns>Rule Allocated Balance for the specified node.</returns>
		internal int GetRuleAllocatedBalance(HdrColorBin aColor)
		{
			int allocatedBalance = 0;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				allocatedBalance += ap.GetRuleAllocatedBalance(aColor.ColorCodeRID);
			}
			return allocatedBalance;
		}
		#endregion GetRuleAllocatedBalance
		#endregion AllocatedBalance

		#region Spreads
		#region SpreadStoreSubtotalToStoreHeaders
		/// <summary>
		/// Spreads a change to a store's subtotal to the headers that make up that subtotal 
		/// </summary>
		/// <param name="aGeneralComponent">The component where the change was made</param>
		/// <param name="aStore">The store RID where the change was made</param>
		/// <param name="aQtyAllocated">Quantity to spread</param>
		/// <param name="aDistributeChange">How to distribute this change to other components</param>
		/// <param name="aIsManual">True indicates the change was manually keyed by the user.</param>
		/// <returns>True when the spread is successful; false otherwise.</returns>
		private bool SpreadStoreSubtotalToHeaders(
			GeneralComponent aGeneralComponent, 
			Index_RID aStore, 
			int aQtyAllocated, 
			eDistributeChange aDistributeChange, 
			bool aIsManual) 
		{
			bool success = true;
			int oldTotal = GetStoreQtyAllocated(aGeneralComponent, aStore);
			int newTotal = aQtyAllocated;
			int lockTotal = 0;
			int qtyAllocated;
			int oldStoreValue;
			int multiple;
			int maximum;
			GeneralComponent gc;
			AllocationProfileStoreComparer comparer = 
				new AllocationProfileStoreComparer(aGeneralComponent, aStore);
			SortedList sl = new SortedList(comparer);
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			HdrColorBin hcb;
			if (aGeneralComponent is AllocationColorOrSizeComponent)
			{
				gc = aGeneralComponent;
				if (aGeneralComponent.ComponentType == eComponentType.SpecificColor)
				{
					colorComponent = (AllocationColorOrSizeComponent)aGeneralComponent;
					foreach (AllocationProfile ap in this.SubtotalMembers)
					{
						if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
						{
							if (ap.StyleIntransitUpdated
								|| ap.GetStoreTempLock(aGeneralComponent, aStore)
								|| ap.GetStoreLocked(aGeneralComponent, aStore))
							{
								lockTotal += ap.GetStoreQtyAllocated(aGeneralComponent, aStore);
							}
							else
							{
								sl.Add(ap, ap);
							}
						}
					}
				}
				else 
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent));
				}
			}
			else if (aGeneralComponent is AllocationColorSizeComponent)
			{
				AllocationColorSizeComponent colorSizeComponent = (AllocationColorSizeComponent)aGeneralComponent;
				gc = aGeneralComponent;
				if (colorSizeComponent.ColorComponent.ComponentType == eComponentType.SpecificColor)
				{
					colorComponent = (AllocationColorOrSizeComponent)colorSizeComponent.ColorComponent;
					if (colorSizeComponent.SizeComponent.ComponentType == eComponentType.SpecificSize)
					{
						sizeComponent = (AllocationColorOrSizeComponent)colorSizeComponent.SizeComponent;
						foreach (AllocationProfile ap in this.SubtotalMembers)
						{
							if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
							{
								hcb = ap.GetHdrColorBin(colorComponent.ColorRID);
								if (hcb.SizeIsInColor(sizeComponent.SizeRID))
								{
									if (ap.BulkSizeIntransitUpdated
										|| ap.GetStoreTempLock(aGeneralComponent, aStore)
										|| ap.GetStoreLocked(aGeneralComponent, aStore))
									{
										lockTotal += ap.GetStoreQtyAllocated(aGeneralComponent, aStore);
									}
									else
									{
										sl.Add(ap, ap);
									}
								}
							}
						}
					}
					else
					{
						throw new MIDException(eErrorLevel.severe,
							(int)(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent),
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent));
					}
				}
				else
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent));
				}
			}
			else
			{
				switch (aGeneralComponent.ComponentType)
				{
					case (eComponentType.SpecificPack):
						// else if (aGeneralComponent.ComponentType == eComponentType.SpecificPack)
					{
						PackHdr pack = this.GetSubtotalPackHdr(((AllocationPackComponent)aGeneralComponent).PackName);
						// aGeneralComponent is constructed for a subtotal pack
						// Must set gc to a header pack component
						gc = new AllocationPackComponent(pack.PackName);
						foreach (AllocationProfile ap in this.SubtotalMembers)
						{
							if (ap.PackIsOnHeader(pack.PackName))
							{
								PackHdr apPack = ap.GetPackHdr(pack.PackName);
								if (apPack.PackMultiple == pack.PackMultiple)
								{
									if (ap.StyleIntransitUpdated
										|| ap.GetStoreTempLock(apPack, aStore)
										|| ap.GetStoreLocked(apPack, aStore))
									{
										lockTotal += ap.GetStoreQtyAllocated(apPack, aStore);
									}
									else
									{
										sl.Add(ap, ap);
									}
								}
							}
						}
						break;
					}
					case (eComponentType.Bulk):
					case (eComponentType.DetailType):
					case (eComponentType.Total):
						//  else
						// {
						//if (aGeneralComponent.ComponentType == eComponentType.Bulk ||
						//	aGeneralComponent.ComponentType == eComponentType.DetailType ||
						//	aGeneralComponent.ComponentType == eComponentType.Total)
					{
						gc = aGeneralComponent;
						foreach (AllocationProfile ap in this.SubtotalMembers)
						{
							if (ap.StyleIntransitUpdated
								|| ap.GetStoreTempLock(aGeneralComponent, aStore)
								|| ap.GetStoreLocked(aGeneralComponent, aStore))
							{
								lockTotal += ap.GetStoreQtyAllocated(aGeneralComponent, aStore);
							}
							else
							{
								sl.Add(ap, ap);
							}
						}
						break;
					}
					case (eComponentType.AllColors):
					{
						gc = aGeneralComponent;
						foreach (AllocationProfile ap in this.SubtotalMembers)
						{
							if (ap.BulkColors.Count > 0)
							{
								if (ap.StyleIntransitUpdated)
								{
									lockTotal += ap.GetStoreQtyAllocated(aGeneralComponent, aStore);
								}
								else
								{
									int lockCount = 0;
									foreach (HdrColorBin colorBin in ap.BulkColors.Values)
									{
										if (ap.GetStoreLocked( colorBin, aStore)
											|| ap.GetStoreTempLock(colorBin, aStore))
										{
											lockCount++;
										}
									}
									if (lockCount == ap.BulkColors.Count)
									{
										lockTotal += ap.GetStoreQtyAllocated(aGeneralComponent, aStore);
									}
									else
									{
										sl.Add(ap,ap);
									}
								}
							}
						}
						break;		
					}
					default:
						// else 
					{
						throw new MIDException(eErrorLevel.severe,
							(int)(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent),
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent));
					}
				}
			}

			if (lockTotal > newTotal)
			{
				throw new MIDException(eErrorLevel.warning,
					(int)(eMIDTextCode.msg_al_LockTotalExceedsNew),
					this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew));
						
			}							

			oldTotal -= lockTotal;
			newTotal -= lockTotal;
            int capacityMaximum; // TT#1074 - MD - Jellis - Group Allocation - Inventory min/max broken
			foreach (AllocationProfile ap in sl.Values)
			{
				if (oldTotal > 0)
				{
					oldStoreValue = ap.GetStoreQtyAllocated(gc, aStore);
					maximum = int.MaxValue;
					// grade maximum not observed?
					if (maximum > ap.GetStorePrimaryMaximum(gc, aStore) &&
						!ap.GetStoreMayExceedPrimaryMaximum(aStore))
					{
						maximum = ap.GetStorePrimaryMaximum(gc, aStore);
					}

                    
                    //if (maximum > ap.GetStoreCapacityMaximum(aStore) &&  // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
                    capacityMaximum = ap.GetStoreCapacityMaximum(gc, aStore, true);   // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
                    if (maximum > capacityMaximum &&    // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
                        !ap.GetStoreMayExceedCapacity(aStore))
                    {
                        //maximum = ap.GetStoreCapacityMaximum(aStore); // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
                        maximum = capacityMaximum;   // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
                    }

					if (gc.ComponentType == eComponentType.SpecificPack)
					{
						// allocated quantity is number of packs (not units).
						multiple = 1;
					}
					else
					{
						multiple = ap.GetMultiple(aGeneralComponent);
					}
					maximum = maximum / multiple;
					maximum = maximum * multiple; // round maximum down to largest multiple.
					qtyAllocated = 
						(int)((((double) oldStoreValue
						* (double) newTotal)
						/ (double) oldTotal) + 0.5d);
					qtyAllocated = 
						(int) (((double) qtyAllocated
						/ (double) multiple) + 0.5d);    
					qtyAllocated = 
						qtyAllocated * multiple;  // round qtyAllocated to nearest multiple;
					if (qtyAllocated > maximum)
					{
						qtyAllocated = maximum;
					}
					if (ap.SetStoreQtyAllocated(gc, aStore, qtyAllocated, aDistributeChange, aIsManual)
						!= eAllocationUpdateStatus.Successful)
					{
						_errorMsg = String.Format
							(
							MIDText.GetText(eMIDTextCode.msg_al_SubtotalSpreadFailed),
							this.SubtotalName,
							ap.HeaderID.ToString(CultureInfo.CurrentUICulture),
							MIDText.GetText((int)gc.ComponentType),
							aStore.RID.ToString(CultureInfo.CurrentUICulture)
							);
						this.SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Severe, _errorMsg, this.GetType().Name);
						throw new MIDException (eErrorLevel.severe,
							(int)eMIDTextCode.msg_al_SubtotalSpreadFailed,
							_errorMsg
							);
					}
					newTotal -= ap.GetStoreQtyAllocated(gc, aStore);
					oldTotal -= oldStoreValue;
				}
				else
				{
					ap.SetStoreQtyAllocated(gc, aStore, 0, aDistributeChange, aIsManual);
				}
			}
			return success;
		}
		#endregion SpreadStoreSubtotalToStoreHeaders

		#region SpreadTotalsOfStoreSubtotalsToStores

		// Begin MID Track 3326 Cannot manually key size qty when no secondary size
		/// <summary>
		/// Spreads store All Color Size allocation to color size.
		/// </summary>
		/// <param name="aSizeComponent">Size Component that identifies the sizes</param>
		/// <param name="aStore">Index_RID that identifies the store.</param>
		/// <param name="aNewTotal">New Total</param>
		/// <param name="aDistributeChange">eDistributeChange to indicate how to distribute the change to parents and children.</param>
		/// <param name="aIsManuallyAllocated">True: Spread is result of manual change; False: change is result of auto change.</param>
		internal bool SpreadStoreAllColorSizeToColorSize(GeneralComponent aSizeComponent, Index_RID aStore, int aNewTotal, eDistributeChange aDistributeChange, bool aIsManuallyAllocated)
		{
			int colorSizeAllocated;
			int oldTotal = 0;
			int lockTotal = 0;
			ArrayList colorSizes = new ArrayList();
			ArrayList sizeHeader = new ArrayList();
			ArrayList sizeRIDs = new ArrayList();
			switch (aSizeComponent.ComponentType)
			{
				case (eComponentType.AllSizes):
				{
					// empty sizeRIDs implies all sizes
					break;			
				}
				case (eComponentType.SpecificSize):
				{
					sizeRIDs.Add(((AllocationColorOrSizeComponent)aSizeComponent).SizeRID);
					break;
				}
				case (eComponentType.SpecificSizePrimaryDim):
				{
					AllocationColorOrSizeComponent sizeComponent = (AllocationColorOrSizeComponent)aSizeComponent;
					SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.PrimarySizeDimRID);
					foreach(SizeCodeProfile scp in scl)
					{
						sizeRIDs.Add(scp.Key);
					}
					break;
				}
				case (eComponentType.SpecificSizeSecondaryDim):
				{
					AllocationColorOrSizeComponent sizeComponent = (AllocationColorOrSizeComponent)aSizeComponent;
					SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
					foreach(SizeCodeProfile scp in scl)
					{
						sizeRIDs.Add(scp.Key);
					}
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}
			
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				foreach (HdrColorBin c in ap.BulkColors.Values)
				{
					if (sizeRIDs.Count > 0)
					{
						foreach (int sizeRID in sizeRIDs)
						{
							if (c.SizeIsInColor(sizeRID))
							{
								HdrSizeBin hsb = c.GetSizeBin(sizeRID); 
								if (GetStoreLocked(hsb, aStore)
									|| GetStoreTempLock(hsb, aStore))
								{
									lockTotal += GetStoreQtyAllocated(hsb, aStore);
								}
								else
								{
									colorSizes.Add(hsb);
									sizeHeader.Add(ap);
									oldTotal += GetStoreQtyAllocated(hsb, aStore);
								}
							}
						}
					}
					else
					{
						foreach (HdrSizeBin hsb in c.ColorSizes.Values)  // MID Track 4333 Invalid Cast in Size Review when 2 or more bulk headers selected and All DIM total changed
						{
							if (GetStoreLocked(hsb, aStore)
								|| GetStoreTempLock(hsb, aStore))
							{
								lockTotal += GetStoreQtyAllocated(hsb, aStore);
							}
							else
							{
								colorSizes.Add(hsb);
								sizeHeader.Add(ap);
								oldTotal += GetStoreQtyAllocated(hsb, aStore);
							}
						}
					}
				}
			}
			if (lockTotal > aNewTotal)
			{
				throw new MIDException(eErrorLevel.warning,
					(int)(eMIDTextCode.msg_al_LockTotalExceedsNew),
					this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew));
			}
			
			HdrSizeBin[] sortedColorSizes = new HdrSizeBin[colorSizes.Count];
			colorSizes.CopyTo(sortedColorSizes);
			AllocationProfile[] sortedHeaders = new AllocationProfile[sizeHeader.Count];
			sizeHeader.CopyTo(sortedHeaders);
			Array.Sort(sortedColorSizes, sortedHeaders, new StoreHdrSizeBinProcessOrder(aStore.Index));
			int newTotal = aNewTotal - lockTotal;
			HdrSizeBin sizeBin;
			AllocationProfile allocationProfile;

			for(int sortItem=0; sortItem < sortedColorSizes.Length; sortItem++)
			{
				sizeBin = sortedColorSizes[sortItem];
				allocationProfile = sortedHeaders[sortItem];
				if (oldTotal > 0)
				{
					colorSizeAllocated = 
						(int)(((double)sizeBin.GetStoreSizeUnitsAllocated(aStore.Index)
						* (double)newTotal
						/ (double)oldTotal) + 0.5d);
					colorSizeAllocated = 
						(int) (((double)colorSizeAllocated
						/ (double)sizeBin.SizeMultiple) + 0.5d);
					colorSizeAllocated = (colorSizeAllocated * sizeBin.SizeMultiple);
					if (colorSizeAllocated < sizeBin.SizeMinimum)
					{
						colorSizeAllocated = 0;
					}
					else
					{
                        // begin TT#1391 - TMW New Action (There are no constraints on this spread)
                        //if (colorSizeAllocated > sizeBin.GetStoreSizeMaximum(aStore.Index)
                        //    && !allocationProfile.GetStoreMayExceedMax(aStore))
                        //{
                        //    colorSizeAllocated = sizeBin.GetStoreSizeMaximum(aStore.Index);
                        //}
                        // end TT#1391 - TMW New Action (There are no constraints on this spread)
						if (colorSizeAllocated > sizeBin.GetStoreSizePrimaryMaximum(aStore.Index)
							&& !allocationProfile.GetStoreMayExceedPrimaryMaximum(aStore))
						{
							colorSizeAllocated = sizeBin.GetStoreSizePrimaryMaximum(aStore.Index);
						}
					}
				}
				else
				{
					colorSizeAllocated = 0;
				}
				oldTotal -= sizeBin.GetStoreSizeUnitsAllocated(aStore.Index);
				newTotal -= colorSizeAllocated;
				if (aDistributeChange == eDistributeChange.ToAll
					|| aDistributeChange == eDistributeChange.ToChildren)
				{
					allocationProfile.SetStoreQtyAllocated(sizeBin, aStore, colorSizeAllocated, 
						eDistributeChange.ToChildren, aIsManuallyAllocated);
				}
				else
				{
					allocationProfile.SetStoreQtyAllocated(sizeBin, aStore, colorSizeAllocated,
						eDistributeChange.ToNone, aIsManuallyAllocated);
				}
			}
			return true;
		}
		// End MID Track 3326 Cannot manually key size qty when no secondary size


		/// <summary>
		/// Spreads StoreListTotal Quantity Allocated to stores in list.
		/// </summary>
		/// <param name="aComponent">Description of the Allocation Component Node</param>
		/// <param name="aStoreList">Profile List of stores for which a total is to be set.</param>
		/// <param name="aQtyAllocated">Total Quantity Allocated</param>
		/// <returns>True when update successful; false otherwise</returns>
		internal bool SpreadStoreListTotalQtyAllocated(
			GeneralComponent aComponent, 
			ProfileList aStoreList, 
			int aQtyAllocated)
		{
			bool success = false;
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				if (!ap.StyleIntransitUpdated)
				{
					success = true;
				}
			}
			if (success == false)
			{
				return success;
			}
			eDistributeChange distributeChange;
			if (aComponent.ComponentType == eComponentType.SpecificColor // MID Track 3326 cannot manually key size qty when no secondary dimension
				|| aComponent.ComponentType == eComponentType.AllColors) // MID Track 3326 cannot manually key size qty when no secondary dimension
			{
				distributeChange = eDistributeChange.ToParent;
			}
			else
			{
				if (aComponent.ComponentType == eComponentType.ColorAndSize)
				{
					distributeChange = eDistributeChange.ToNone;
				}
				else
				{
					distributeChange = eDistributeChange.ToAll;
				}
			}
            int multiple = 1;
			Index_RID[] storeIndexRIDs = new Index_RID[aStoreList.Count];
			int s = 0;
			foreach (StoreProfile sp in aStoreList)
			{
				storeIndexRIDs[s] = this.StoreIndex(sp.Key);
				s++;
			}
			AllocationColorOrSizeComponent colorComponent;
			AllocationColorOrSizeComponent sizeComponent;
			AllocationPackComponent packComponent;
			switch (aComponent.ComponentType)
			{
				case (eComponentType.AllColors):
				{
					multiple = this.GetSubtotalMultiple(eAllocationSummaryNode.Bulk);
					break;
				}
				case (eComponentType.AllGenericPacks):
				{
					multiple = this.GetSubtotalMultiple(eAllocationSummaryNode.GenericType);
					break;
				}
				case (eComponentType.AllNonGenericPacks):
				{
					multiple = this.GetSubtotalMultiple(eAllocationSummaryNode.DetailSubType);
					break;
				}
				case (eComponentType.AllPacks):
				{
					multiple = this.GetSubtotalMultiple(eAllocationSummaryNode.Total);
					break;
				}
				case (eComponentType.AllSizes):
				{
					throw new MIDException(eErrorLevel.warning,
						(int)eMIDTextCode.msg_al_AllSizesAllocatedReadOnly,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizesAllocatedReadOnly));
				}
				case (eComponentType.Bulk):
				{
					multiple = this.BulkMultiple;
					break;
				}
				case (eComponentType.ColorAndSize):
				{
					AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
					GeneralComponent color = acs.ColorComponent;
					GeneralComponent size = acs.SizeComponent;
					switch (color.ComponentType)
					{
						case (eComponentType.AllColors):
						{
							// Begin MID Track 3326 Cannot manually key size qty when no secondary dimension
							//throw new MIDException(eErrorLevel.warning,
							//	(int)eMIDTextCode.msg_al_AllColorAllocatedReadOnly,
							//	_session.Audit.GetText(eMIDTextCode.msg_al_AllColorAllocatedReadOnly));

							ArrayList sizeRIDs = new ArrayList();

							switch (size.ComponentType)
							{
								case (eComponentType.AllSizes):
								{
									// empty sizeRIDs implies all sizes
									break;			
								}
								case (eComponentType.SpecificSize):
								{
									sizeRIDs.Add(((AllocationColorOrSizeComponent)size).SizeRID);
									break;
								}
								case (eComponentType.SpecificSizePrimaryDim):
								{
									AllocationColorOrSizeComponent pSizeComponent = (AllocationColorOrSizeComponent)size;
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(pSizeComponent.PrimarySizeDimRID);
									foreach(SizeCodeProfile scp in scl)
									{
										sizeRIDs.Add(scp.Key);
									}
									break;
								}
								case (eComponentType.SpecificSizeSecondaryDim):
								{
									AllocationColorOrSizeComponent sSizeComponent = (AllocationColorOrSizeComponent)size;
									SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sSizeComponent.SecondarySizeDimRID);
									foreach(SizeCodeProfile scp in scl)
									{
										sizeRIDs.Add(scp.Key);
									}
									break;
								}
								default:
								{
									throw new MIDException(eErrorLevel.severe,
										(int)(eMIDTextCode.msg_al_UnknownComponentType),
										this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
								}
							}
							ArrayList oldColorTotalArray = new ArrayList();
							ArrayList oldColorLockTotalArray = new ArrayList();
							int oldAllColorTotal = 0;
							int oldAllColorLockTotal = 0;
							ArrayList colorSizeComponentArray = new ArrayList();
							ArrayList colorPosition = new ArrayList();
							ArrayList correspondingAP = new ArrayList();
							int i = 0;
							foreach (AllocationProfile ap in this.SubtotalMembers)
							{
								foreach (HdrColorBin hcb in ap.BulkColors.Values)
								{
									AllocationColorSizeComponent colorSizeComponent = new AllocationColorSizeComponent(
										new  AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, hcb.ColorCodeRID),
										size);
									colorSizeComponentArray.Add(colorSizeComponent);
									int oldColorTotal = 0;
									int oldColorLockTotal = 0;
									if (sizeRIDs.Count > 0)
									{
										foreach(int sizeRID in sizeRIDs)
										{
											if (hcb.SizeIsInColor(sizeRID))
											{
												HdrSizeBin hsb = hcb.GetSizeBin(sizeRID);
												foreach(Index_RID strIndexRID in storeIndexRIDs)
												{
													oldColorTotal += ap.GetStoreQtyAllocated(
														hsb,
														strIndexRID);
													if (ap.GetStoreLocked(hsb, strIndexRID)
														|| ap.GetStoreTempLock(hsb, strIndexRID))
													{
														oldColorLockTotal += ap.GetStoreQtyAllocated(hsb, strIndexRID);
													}
												}

											}
										}
									}
									else
									{
										foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
										{
											foreach(Index_RID strIndexRID in storeIndexRIDs)
											{
												oldColorTotal += ap.GetStoreQtyAllocated(
													hsb,
													strIndexRID);
												if (ap.GetStoreLocked(hsb, strIndexRID)
													|| ap.GetStoreTempLock(hsb, strIndexRID))
												{
													oldColorLockTotal += ap.GetStoreQtyAllocated(hsb, strIndexRID);
												}
											}
										}
									}
									oldColorTotalArray.Add(oldColorTotal);
									oldColorLockTotalArray.Add(oldColorLockTotal);
									oldAllColorTotal += oldColorTotal;
									oldAllColorLockTotal += oldColorLockTotal;
									correspondingAP.Add(ap);
									colorPosition.Add(i);
									i++;
								}
							}
							int newAllColorTotal = 0;
							if (oldAllColorLockTotal <= aQtyAllocated)
							{
								newAllColorTotal = aQtyAllocated - oldAllColorLockTotal;
							}
							else
							{
								throw new MIDException(eErrorLevel.warning,
									(int)(eMIDTextCode.msg_al_LockTotalExceedsNew),
									this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew)); 
							}
							int[] oldColorTotalFixedArray = new int[oldColorTotalArray.Count];
							int[] colorPositionFixedArray = new int[oldColorTotalArray.Count];
							oldColorTotalArray.CopyTo(oldColorTotalFixedArray);
							colorPosition.CopyTo(colorPositionFixedArray);
							Array.Sort(oldColorTotalFixedArray, colorPositionFixedArray);
							int colorNewTotal;
							for (int sortPosition=0; sortPosition< oldColorTotalFixedArray.Length; sortPosition++)
							{
								colorNewTotal = 0;
								i=colorPositionFixedArray[sortPosition];
								if (oldAllColorTotal > oldAllColorLockTotal)
								{
									colorNewTotal = 
										((int)oldColorTotalArray[sortPosition] - (int)oldColorLockTotalArray[i])
										* newAllColorTotal
										/ (oldAllColorTotal - oldAllColorLockTotal);
								}
								((AllocationProfile)correspondingAP[i]).SpreadStoreListTotalQtyAllocated((AllocationColorSizeComponent)colorSizeComponentArray[i], aStoreList, colorNewTotal + (int)oldColorLockTotalArray[i]);
								oldAllColorTotal -= (int)oldColorTotalArray[sortPosition];
								oldAllColorLockTotal -= (int)oldColorLockTotalArray[i];
								newAllColorTotal -= colorNewTotal;
							}
							return true;
							// End MID Track 3326 Cannot manually key size qty when no secondary dimension
						}
						case (eComponentType.SpecificColor):
						{
							colorComponent = (AllocationColorOrSizeComponent)color;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
							if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
							{
								switch (size.ComponentType)
								{
									case (eComponentType.AllSizes):
									{
										multiple = GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorMultiple;
										break;
									}
									case (eComponentType.SpecificSize):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
										{
											multiple = this.GetSubtotalHdrColorBin(colorComponent.ColorRID).GetSizeBin(sizeComponent.SizeRID).SizeMultiple;
										}
										break;
									}
									case (eComponentType.SpecificSizePrimaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size; // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color 
										SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										multiple = 0;
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (multiple == 0)
												{
													multiple = hcb.GetSizeBin(scp.Key).SizeMultiple;
												}
												else
												{
													multiple = MIDMath.GreatestCommonDivisor(multiple, hcb.GetSizeBin(scp.Key).SizeMultiple);
												}
											}
										}
										if (multiple == 0)
										{
											multiple = 1;
										}
										break;
									}
									case (eComponentType.SpecificSizeSecondaryDim):
									{
										sizeComponent = (AllocationColorOrSizeComponent)size;  // MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
										SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
										HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
										multiple = 0;
										foreach (SizeCodeProfile scp in scl)
										{
											if (hcb.SizeIsInColor(scp.Key))
											{
												if (multiple == 0)
												{
													multiple = hcb.GetSizeBin(scp.Key).SizeMultiple;
												}
												else
												{
													multiple = MIDMath.GreatestCommonDivisor(multiple, hcb.GetSizeBin(scp.Key).SizeMultiple);
												}
											}
										}
										if (multiple == 0)
										{
											multiple = 1;
										}
										break;
									}
									default:
									{
										throw new MIDException(eErrorLevel.severe,
											(int)(eMIDTextCode.msg_al_UnknownComponentType),
											this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
									}
								}
							}
							break;
						}
						default:
						{
							throw new MIDException(eErrorLevel.severe,
								(int)(eMIDTextCode.msg_al_UnknownComponentType),
								this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
						}
					}
					break;
				}
				case (eComponentType.DetailType):
				{
					multiple = this.DetailTypeMultiple;
					break;
				}
				case (eComponentType.GenericType):
				{
					multiple = this.GetSubtotalMultiple(eAllocationSummaryNode.GenericType);
					break;
				}
				case (eComponentType.SpecificColor):
				{
					colorComponent = (AllocationColorOrSizeComponent)aComponent;
					multiple = this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorMultiple;
					break;
				}
				case (eComponentType.SpecificSize):
				{
					throw new MIDException(eErrorLevel.warning,
						(int)eMIDTextCode.msg_al_SizeAllocatedAcrossColorReadOnly,
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SizeAllocatedAcrossColorReadOnly));
				}
				case (eComponentType.SpecificPack):
				{
					packComponent = (AllocationPackComponent)aComponent;
					multiple = 1;
					break;
				}
				case (eComponentType.Total):
				{
					multiple = this.TotalMultiple;	
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.severe,
						(int)(eMIDTextCode.msg_al_UnknownComponentType),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
				}
			}

			int lockTotal = 0;
			int newTotal = aQtyAllocated;
			Index_RID storeIndexRID;
			int qtyAllocated;
			int oldTotal = this.GetStoreListTotalQtyAllocated(aComponent, aStoreList);
			// begin MID Track 4531 AnF Defect 364: Reserve Store Allocation Cannot Be Reduced
			try
			{
				if (this.Transaction.ReserveStore.RID != Include.NoRID)
				{
					this.SetStoreTempLock(aComponent, this.Transaction.ReserveStore, true);
				}
				// end MID Track 4531 AnF Defect 364: Reserve Store Allocation Cannot Be Reduced
				if (newTotal != oldTotal)
				{
					foreach (StoreProfile sp in aStoreList)
					{
						storeIndexRID = StoreIndex(sp.Key);
						if (GetStoreLocked(aComponent, storeIndexRID) ||
							GetStoreTempLock(aComponent, storeIndexRID))
						{
							lockTotal += GetStoreQtyAllocated(aComponent, storeIndexRID);
						}
					}
					if (lockTotal > newTotal)
					{
						throw new MIDException(eErrorLevel.warning,
							(int)(eMIDTextCode.msg_al_LockTotalExceedsNew),
							this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew));
					}
					newTotal -= lockTotal;
					oldTotal -= lockTotal;
                    int minMaxConstraint; // TT#1176 - MD - Jellis - Group Allocation - Size Need not observing inv min max
                    eMIDTextCode statusReasonCode; // TT#1176 - MD - Jellis - Group Allocation - Size Need Not observing inv min max
					foreach (StoreProfile sp in aStoreList)
					{
						storeIndexRID = StoreIndex(sp.Key);
						if (!GetStoreLocked(aComponent, storeIndexRID) &&
							!GetStoreTempLock(aComponent, storeIndexRID))
						{
							if (oldTotal > 0)
							{
								qtyAllocated =
									(int)(
									(((double)GetStoreQtyAllocated(aComponent, storeIndexRID)
									* (double)newTotal)
									/ (double)oldTotal) + 0.5d);
								qtyAllocated = 
									(int)(((double)qtyAllocated
									/ (double)multiple) + 0.5d);
								qtyAllocated = (qtyAllocated * multiple);

                                // begin TT#1176 - MD - Jellis- Group Allocation Size Need not observing inv min max
                                //if (qtyAllocated < GetStoreMinimum(aComponent, storeIndexRID, true))  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken 
                                if (!TryGetStoreMinimum(aComponent, storeIndexRID, true, out minMaxConstraint, out statusReasonCode))
                                {
                                    throw new MIDException(
                                        eErrorLevel.fatal,
                                        (int)statusReasonCode,
                                        SAB.ApplicationServerSession.Audit.GetText(statusReasonCode, false) + " : Source/Method [" + GetType().Name + " / SpreadStoreListTotalQtyAllocated--minimum]");
                                }
                                if (qtyAllocated < minMaxConstraint)
                                    // end TT#1176 - MD - Jellis - Group Allocation Size Need not observing inv min max
								{
									qtyAllocated = 0;
								}
								else
								{
                                    // begin TT#1176 - MD - Jellis - Group Allocation Size Need not observing inv min max
                                    //if (qtyAllocated > GetStoreMaximum(aComponent, storeIndexRID, true)  // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
                                    //    && !GetStoreMayExceedMax(storeIndexRID))
                                    //{
                                    //    qtyAllocated = GetStoreMaximum(aComponent, storeIndexRID, true); // TT#1074 - MD - jellis - Group Allocation Inventory Min Max Broken
                                    //}
                                    if (!TryGetStoreMaximum(aComponent, storeIndexRID, true, out minMaxConstraint, out statusReasonCode))
                                    {
                                        throw new MIDException(
                                            eErrorLevel.fatal,
                                            (int)statusReasonCode,
                                            SAB.ApplicationServerSession.Audit.GetText(statusReasonCode, false) + " : Source/Method [" + GetType().Name + " / SpreadStoreListTotalQtyAllocated--maximum]");
                                    }
                                    if (qtyAllocated > minMaxConstraint
                                        && !GetStoreMayExceedMax(storeIndexRID))
                                    {
                                        qtyAllocated = minMaxConstraint;
                                    }
                                    // end TT#1176 - MD - Jellis - Group Allocation Size Need not observing inv min max
									if (qtyAllocated > GetStorePrimaryMaximum(aComponent, storeIndexRID)
										&& !GetStoreMayExceedPrimaryMaximum(storeIndexRID))
									{
										qtyAllocated = GetStorePrimaryMaximum(aComponent, storeIndexRID);
									}
								}
							}
							else
							{
								qtyAllocated = 0;
							}
							oldTotal -=
								GetStoreQtyAllocated(
								aComponent,
								storeIndexRID);
							if (!SetStoreQtyAllocated(
								aComponent,
								storeIndexRID,
								qtyAllocated,
								distributeChange,
								false))
							{
								success = false;
							}
							//}  // J.Ellis reducing total twice for locked stores!
							newTotal -= 
								GetStoreQtyAllocated
								(aComponent,
								storeIndexRID);
						} // J.Ellis reducing total twice for locked stores
					}
					// begin MID Track 4531 AnF Defect 364: Reserve Store Allocation Cannot Be Reduced
				}
			}
			finally
			{
				if (this.Transaction.ReserveStore.RID != Include.NoRID)
				{
					this.SetStoreTempLock(aComponent, this.Transaction.ReserveStore, false);
				}
			}
			// end MID Track 4531 AnF Defect 364: Reserve Store Allocation Cannot Be Reduced
			return success;
		}
		#endregion SpreadTotalsOfStoreSubtotalsToStores

		#region SpreadStoreQtyAcrossSizes
		/// <summary>
		/// Spreads a change to a store size total (across a group of sizes) to the individual store-size level.
		/// </summary>
		/// <param name="aColorRID">Color RID where the sizes reside</param>
		/// <param name="aSizeCodeList">Size Code Profile List identifying the sizes</param>
		/// <param name="aStore">Index_RID that identifies the store</param>
		/// <param name="aNewTotal">New total</param>
		/// <returns>True: Spread successful; False: Spread not successful</returns>
		private bool SpreadStoreQtyAcrossSizes(int aColorRID, SizeCodeList aSizeCodeList, Index_RID aStore, int aNewTotal)
		{
			int oldTotal = 0;
			int newTotal = aNewTotal;
			int lockTotal = 0;
			HdrColorBin hcb = this.GetSubtotalHdrColorBin(aColorRID);
			ArrayList sizeArray = new ArrayList();
			HdrSizeBin sizeBin;
			foreach (SizeCodeProfile scp in aSizeCodeList)
			{
				if (hcb.SizeIsInColor(scp.Key))
				{
					sizeBin = hcb.GetSizeBin(scp.Key);
					if (this.GetStoreLocked(sizeBin, aStore))
					{
						lockTotal += this.GetStoreQtyAllocated(sizeBin, aStore);
					}
					else
					{
						sizeArray.Add(sizeBin);
						oldTotal += this.GetStoreQtyAllocated(sizeBin, aStore);
					}
				}
			}
			int unitsAllocated;
			int origUnitsAllocated;
			newTotal -= lockTotal;
			if (newTotal <= 0)
			{
				newTotal = 0;
				this.Transaction.SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Information, 
					eMIDTextCode.msg_al_LockTotalExceedsNew,
					this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew, false));
			}
			foreach (HdrSizeBin hsb in sizeArray)
			{
				if (oldTotal > 0)
				{
					origUnitsAllocated = this.GetStoreQtyAllocated(hsb, aStore);
					unitsAllocated = 
						(int)(((double) origUnitsAllocated
						* (double) newTotal
						/ (double) oldTotal)
						+ .5d);
					unitsAllocated =
						(int)(((double)unitsAllocated 
						/ (double) hsb.SizeMultiple)
						+ .5d);
					unitsAllocated = 
						unitsAllocated
						* hsb.SizeMultiple;
					if (unitsAllocated > newTotal)
					{
						unitsAllocated = newTotal;
					}
					oldTotal -= origUnitsAllocated;
				}
				else
				{
					unitsAllocated = 0;
				}
				this.SetStoreQtyAllocated(hsb, aStore, unitsAllocated, eDistributeChange.ToNone, false);
				newTotal -= this.GetStoreQtyAllocated(hsb, aStore);
			}
			return true;
		}
		#endregion SpreadStoreQtyAcrossSizes

        // begin TT#1401 - JEllis - Urban Reservation Stores pt 2
        #region SpreadStoreSubtotalItemToStoreHeaders
        /// <summary>
        /// Spreads a change to a store's subtotal to the headers that make up that subtotal 
        /// </summary>
        /// <param name="aGeneralComponent">The component where the change was made</param>
        /// <param name="aStore">The store RID where the change was made</param>
        /// <param name="aItemQtyAllocated">Item Quantity to spread</param>
        /// <param name="aDistributeChange">How to distribute this change to other components</param>
        /// <param name="aIsManual">True indicates the change was manually keyed by the user.</param>
        /// <returns>True when the spread is successful; false otherwise.</returns>
        private bool SpreadStoreSubtotalItemToHeaders(
            GeneralComponent aGeneralComponent,
            Index_RID aStore,
            int aItemQtyAllocated,
            eDistributeChange aDistributeChange,
            bool aIsManual)
        {
            bool success = true;
            int oldTotal = GetStoreItemQtyAllocated(aGeneralComponent, aStore);
            int newTotal = aItemQtyAllocated;
            int lockTotal = 0;
            int qtyAllocated;
            int oldStoreValue;
            int multiple;
            int maximum;
            GeneralComponent gc;
            AllocationProfileStoreComparer comparer =
                new AllocationProfileStoreComparer(aGeneralComponent, aStore);
            SortedList sl = new SortedList(comparer);
            AllocationColorOrSizeComponent colorComponent;
            AllocationColorOrSizeComponent sizeComponent;
            HdrColorBin hcb;
            if (aGeneralComponent is AllocationColorOrSizeComponent)
            {
                gc = aGeneralComponent;
                if (aGeneralComponent.ComponentType == eComponentType.SpecificColor)
                {
                    colorComponent = (AllocationColorOrSizeComponent)aGeneralComponent;
                    foreach (AllocationProfile ap in this.SubtotalMembers)
                    {
                        if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
                        {
                            if (ap.StyleIntransitUpdated
                                || ap.GetStoreItemTempLock(aGeneralComponent, aStore)
                                || ap.GetStoreLocked(aGeneralComponent, aStore))
                            {
                                lockTotal += ap.GetStoreItemQtyAllocated(aGeneralComponent, aStore);
                            }
                            else
                            {
                                sl.Add(ap, ap);
                            }
                        }
                    }
                }
                else
                {
                    throw new MIDException(eErrorLevel.severe,
                        (int)(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent),
                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent));
                }
            }
            else if (aGeneralComponent is AllocationColorSizeComponent)
            {
                AllocationColorSizeComponent colorSizeComponent = (AllocationColorSizeComponent)aGeneralComponent;
                gc = aGeneralComponent;
                if (colorSizeComponent.ColorComponent.ComponentType == eComponentType.SpecificColor)
                {
                    colorComponent = (AllocationColorOrSizeComponent)colorSizeComponent.ColorComponent;
                    if (colorSizeComponent.SizeComponent.ComponentType == eComponentType.SpecificSize)
                    {
                        sizeComponent = (AllocationColorOrSizeComponent)colorSizeComponent.SizeComponent;
                        foreach (AllocationProfile ap in this.SubtotalMembers)
                        {
                            if (ap.BulkColorIsOnHeader(colorComponent.ColorRID))
                            {
                                hcb = ap.GetHdrColorBin(colorComponent.ColorRID);
                                if (hcb.SizeIsInColor(sizeComponent.SizeRID))
                                {
                                    if (ap.BulkSizeIntransitUpdated
                                        || ap.GetStoreItemTempLock(aGeneralComponent, aStore)
                                        || ap.GetStoreLocked(aGeneralComponent, aStore))
                                    {
                                        lockTotal += ap.GetStoreItemQtyAllocated(aGeneralComponent, aStore);
                                    }
                                    else
                                    {
                                        sl.Add(ap, ap);
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent));
                    }
                }
                else
                {
                    throw new MIDException(eErrorLevel.severe,
                        (int)(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent),
                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent));
                }
            }
            else
            {
                switch (aGeneralComponent.ComponentType)
                {
                    case (eComponentType.SpecificPack):
                        // else if (aGeneralComponent.ComponentType == eComponentType.SpecificPack)
                        {
                            PackHdr pack = this.GetSubtotalPackHdr(((AllocationPackComponent)aGeneralComponent).PackName);
                            // aGeneralComponent is constructed for a subtotal pack
                            // Must set gc to a header pack component
                            gc = new AllocationPackComponent(pack.PackName);
                            foreach (AllocationProfile ap in this.SubtotalMembers)
                            {
                                if (ap.PackIsOnHeader(pack.PackName))
                                {
                                    PackHdr apPack = ap.GetPackHdr(pack.PackName);
                                    if (apPack.PackMultiple == pack.PackMultiple)
                                    {
                                        if (ap.StyleIntransitUpdated
                                            || ap.GetStoreItemTempLock(apPack, aStore)
                                            || ap.GetStoreLocked(apPack, aStore))
                                        {
                                            lockTotal += ap.GetStoreItemQtyAllocated(apPack, aStore);
                                        }
                                        else
                                        {
                                            sl.Add(ap, ap);
                                        }
                                    }
                                }
                            }
                            break;
                        }
                    case (eComponentType.Bulk):
                    case (eComponentType.DetailType):
                    case (eComponentType.Total):
                        //  else
                        // {
                        //if (aGeneralComponent.ComponentType == eComponentType.Bulk ||
                        //	aGeneralComponent.ComponentType == eComponentType.DetailType ||
                        //	aGeneralComponent.ComponentType == eComponentType.Total)
                        {
                            gc = aGeneralComponent;
                            foreach (AllocationProfile ap in this.SubtotalMembers)
                            {
                                if (ap.StyleIntransitUpdated
                                    || ap.GetStoreItemTempLock(aGeneralComponent, aStore)
                                    || ap.GetStoreLocked(aGeneralComponent, aStore))
                                {
                                    lockTotal += ap.GetStoreItemQtyAllocated(aGeneralComponent, aStore);
                                }
                                else
                                {
                                    sl.Add(ap, ap);
                                }
                            }
                            break;
                        }
                    case (eComponentType.AllColors):
                        {
                            gc = aGeneralComponent;
                            foreach (AllocationProfile ap in this.SubtotalMembers)
                            {
                                if (ap.BulkColors.Count > 0)
                                {
                                    if (ap.StyleIntransitUpdated)
                                    {
                                        lockTotal += ap.GetStoreItemQtyAllocated(aGeneralComponent, aStore);
                                    }
                                    else
                                    {
                                        int lockCount = 0;
                                        foreach (HdrColorBin colorBin in ap.BulkColors.Values)
                                        {
                                            if (ap.GetStoreLocked(colorBin, aStore)
                                                || ap.GetStoreItemTempLock(colorBin, aStore))
                                            {
                                                lockCount++;
                                            }
                                        }
                                        if (lockCount == ap.BulkColors.Count)
                                        {
                                            lockTotal += ap.GetStoreItemQtyAllocated(aGeneralComponent, aStore);
                                        }
                                        else
                                        {
                                            sl.Add(ap, ap);
                                        }
                                    }
                                }
                            }
                            break;
                        }
                    default:
                        // else 
                        {
                            throw new MIDException(eErrorLevel.severe,
                                (int)(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent),
                                this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SubtotalQtyAloctdGeneralComponent));
                        }
                }
            }

            if (lockTotal > newTotal)
            {
                throw new MIDException(eErrorLevel.warning,
                    (int)(eMIDTextCode.msg_al_LockTotalExceedsNew),
                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew));

            }

            oldTotal -= lockTotal;
            newTotal -= lockTotal;
            int capacityMaximum; // TT#1074 - MD - Jellis - Group Allocation- Inventory Min/Max broken
            foreach (AllocationProfile ap in sl.Values)
            {
                if (oldTotal > 0)
                {
                    oldStoreValue = ap.GetStoreItemQtyAllocated(gc, aStore);
                    maximum = int.MaxValue;
                    // grade maximum not observed?
                    if (maximum > ap.GetStorePrimaryMaximum(gc, aStore) &&
                        !ap.GetStoreMayExceedPrimaryMaximum(aStore))
                    {
                        maximum = ap.GetStorePrimaryMaximum(gc, aStore);
                    }


                    // begin TT#1074 - MD - Jellis - Group Allocation - Inventory Min / Max broken
                    capacityMaximum = ap.GetStoreCapacityMaximum(gc, aStore, true);
                    if (maximum > capacityMaximum &&
                        !ap.GetStoreMayExceedCapacity(aStore))
                    {
                        maximum = capacityMaximum;
                    }
                    //if (maximum > ap.GetStoreCapacityMaximum(aStore) &&
                    //    !ap.GetStoreMayExceedCapacity(aStore))
                    //{
                    //    maximum = ap.GetStoreCapacityMaximum(aStore); 
                    //}
                    // end TT#1074 - MD - Jellis - Group Allocation - Inventory Min / Max broken

                    if (gc.ComponentType == eComponentType.SpecificPack)
                    {
                        // allocated quantity is number of packs (not units).
                        multiple = 1;
                    }
                    else
                    {
                        multiple = ap.GetMultiple(aGeneralComponent);
                    }
                    maximum = maximum / multiple;
                    maximum = maximum * multiple; // round maximum down to largest multiple.
                    qtyAllocated =
                        (int)((((double)oldStoreValue
                        * (double)newTotal)
                        / (double)oldTotal) + 0.5d);
                    qtyAllocated =
                        (int)(((double)qtyAllocated
                        / (double)multiple) + 0.5d);
                    qtyAllocated =
                        qtyAllocated * multiple;  // round qtyAllocated to nearest multiple;
                    if (qtyAllocated > maximum)
                    {
                        qtyAllocated = maximum;
                    }
                    if (ap.SetStoreItemQtyAllocated(gc, aStore, qtyAllocated, aIsManual)
                        != eAllocationUpdateStatus.Successful)
                    {
                        _errorMsg = String.Format
                            (
                            MIDText.GetText(eMIDTextCode.msg_al_SubtotalSpreadFailed),
                            this.SubtotalName,
                            ap.HeaderID.ToString(CultureInfo.CurrentUICulture),
                            MIDText.GetText((int)gc.ComponentType),
                            aStore.RID.ToString(CultureInfo.CurrentUICulture)
                            );
                        this.SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Severe, _errorMsg, this.GetType().Name);
                        throw new MIDException(eErrorLevel.severe,
                            (int)eMIDTextCode.msg_al_SubtotalSpreadFailed,
                            _errorMsg
                            );
                    }
                    newTotal -= ap.GetStoreItemQtyAllocated(gc, aStore);
                    oldTotal -= oldStoreValue;
                }
                else
                {
                    ap.SetStoreItemQtyAllocated(gc, aStore, 0, aIsManual);
                }
            }
            return success;
        }
        #endregion SpreadStoreSubtotalItemToStoreHeaders

        #region SpreadTotalsOfStoreSubtotalsItemToStores

        // Begin MID Track 3326 Cannot manually key size qty when no secondary size
        /// <summary>
        /// Spreads store All Color Size allocation to color size.
        /// </summary>
        /// <param name="aSizeComponent">Size Component that identifies the sizes</param>
        /// <param name="aStore">Index_RID that identifies the store.</param>
        /// <param name="aNewTotal">New Total</param>
        /// <param name="aDistributeChange">eDistributeChange to indicate how to distribute the change to parents and children.</param>
        /// <param name="aIsManuallyAllocated">True: Spread is result of manual change; False: change is result of auto change.</param>
        internal bool SpreadStoreAllColorSizeItemToColorSize(GeneralComponent aSizeComponent, Index_RID aStore, int aNewTotal, eDistributeChange aDistributeChange, bool aIsManuallyAllocated)
        {
            int colorSizeAllocated;
            int oldTotal = 0;
            int lockTotal = 0;
            ArrayList colorSizes = new ArrayList();
            ArrayList sizeHeader = new ArrayList();
            ArrayList sizeRIDs = new ArrayList();
            switch (aSizeComponent.ComponentType)
            {
                case (eComponentType.AllSizes):
                    {
                        // empty sizeRIDs implies all sizes
                        break;
                    }
                case (eComponentType.SpecificSize):
                    {
                        sizeRIDs.Add(((AllocationColorOrSizeComponent)aSizeComponent).SizeRID);
                        break;
                    }
                case (eComponentType.SpecificSizePrimaryDim):
                    {
                        AllocationColorOrSizeComponent sizeComponent = (AllocationColorOrSizeComponent)aSizeComponent;
                        SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.PrimarySizeDimRID);
                        foreach (SizeCodeProfile scp in scl)
                        {
                            sizeRIDs.Add(scp.Key);
                        }
                        break;
                    }
                case (eComponentType.SpecificSizeSecondaryDim):
                    {
                        AllocationColorOrSizeComponent sizeComponent = (AllocationColorOrSizeComponent)aSizeComponent;
                        SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                        foreach (SizeCodeProfile scp in scl)
                        {
                            sizeRIDs.Add(scp.Key);
                        }
                        break;
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                    }
            }

            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                foreach (HdrColorBin c in ap.BulkColors.Values)
                {
                    if (sizeRIDs.Count > 0)
                    {
                        foreach (int sizeRID in sizeRIDs)
                        {
                            if (c.SizeIsInColor(sizeRID))
                            {
                                HdrSizeBin hsb = c.GetSizeBin(sizeRID);
                                if (GetStoreLocked(hsb, aStore)
                                    || GetStoreItemTempLock(hsb, aStore))
                                {
                                    lockTotal += GetStoreItemQtyAllocated(hsb, aStore);
                                }
                                else
                                {
                                    colorSizes.Add(hsb);
                                    sizeHeader.Add(ap);
                                    oldTotal += GetStoreItemQtyAllocated(hsb, aStore);
                                }
                            }
                        }
                    }
                    else
                    {
                        foreach (HdrSizeBin hsb in c.ColorSizes.Values)  // MID Track 4333 Invalid Cast in Size Review when 2 or more bulk headers selected and All DIM total changed
                        {
                            if (GetStoreLocked(hsb, aStore)
                                || GetStoreItemTempLock(hsb, aStore))
                            {
                                lockTotal += GetStoreItemQtyAllocated(hsb, aStore);
                            }
                            else
                            {
                                colorSizes.Add(hsb);
                                sizeHeader.Add(ap);
                                oldTotal += GetStoreItemQtyAllocated(hsb, aStore);
                            }
                        }
                    }
                }
            }
            if (lockTotal > aNewTotal)
            {
                throw new MIDException(eErrorLevel.warning,
                    (int)(eMIDTextCode.msg_al_LockTotalExceedsNew),
                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew));
            }

            HdrSizeBin[] sortedColorSizes = new HdrSizeBin[colorSizes.Count];
            colorSizes.CopyTo(sortedColorSizes);
            AllocationProfile[] sortedHeaders = new AllocationProfile[sizeHeader.Count];
            sizeHeader.CopyTo(sortedHeaders);
            Array.Sort(sortedColorSizes, sortedHeaders, new StoreHdrSizeBinProcessOrder(aStore.Index));
            int newTotal = aNewTotal - lockTotal;
            HdrSizeBin sizeBin;
            AllocationProfile allocationProfile;

            for (int sortItem = 0; sortItem < sortedColorSizes.Length; sortItem++)
            {
                sizeBin = sortedColorSizes[sortItem];
                allocationProfile = sortedHeaders[sortItem];
                if (oldTotal > 0)
                {
                    colorSizeAllocated =
                        (int)(((double)sizeBin.GetStoreSizeUnitsAllocated(aStore.Index)
                        * (double)newTotal
                        / (double)oldTotal) + 0.5d);
                    colorSizeAllocated =
                        (int)(((double)colorSizeAllocated
                        / (double)sizeBin.SizeMultiple) + 0.5d);
                    colorSizeAllocated = (colorSizeAllocated * sizeBin.SizeMultiple);
                    if (colorSizeAllocated < sizeBin.SizeMinimum)
                    {
                        colorSizeAllocated = 0;
                    }
                    else
                    {
                        if (colorSizeAllocated > sizeBin.GetStoreSizePrimaryMaximum(aStore.Index)
                            && !allocationProfile.GetStoreMayExceedPrimaryMaximum(aStore))
                        {
                            colorSizeAllocated = sizeBin.GetStoreSizePrimaryMaximum(aStore.Index);
                        }
                    }
                }
                else
                {
                    colorSizeAllocated = 0;
                }
                oldTotal -= sizeBin.GetStoreSizeUnitsAllocated(aStore.Index);
                newTotal -= colorSizeAllocated;
                if (aDistributeChange == eDistributeChange.ToAll
                    || aDistributeChange == eDistributeChange.ToChildren)
                {
                    allocationProfile.SetStoreItemQtyAllocated(sizeBin, aStore, colorSizeAllocated,
                        aIsManuallyAllocated);
                }
                else
                {
                    allocationProfile.SetStoreItemQtyAllocated(sizeBin, aStore, colorSizeAllocated,
                        aIsManuallyAllocated);
                }
            }
            return true;
        }


        /// <summary>
        /// Spreads StoreListTotal Item Quantity Allocated to stores in list.
        /// </summary>
        /// <param name="aComponent">Description of the Allocation Component Node</param>
        /// <param name="aStoreList">Profile List of stores for which a total is to be set.</param>
        /// <param name="aItemQtyAllocated">Total Quantity Allocated</param>
        /// <returns>True when update successful; false otherwise</returns>
        internal bool SpreadStoreListTotalItemQtyAllocated(
            GeneralComponent aComponent,
            ProfileList aStoreList,
            int aItemQtyAllocated)
        {
            bool success = false;
            foreach (AllocationProfile ap in this.SubtotalMembers)
            {
                if (!ap.StyleIntransitUpdated)
                {
                    success = true;
                }
            }
            if (success == false)
            {
                return success;
            }
            eDistributeChange distributeChange;
            if (aComponent.ComponentType == eComponentType.SpecificColor // MID Track 3326 cannot manually key size qty when no secondary dimension
                || aComponent.ComponentType == eComponentType.AllColors) // MID Track 3326 cannot manually key size qty when no secondary dimension
            {
                distributeChange = eDistributeChange.ToParent;
            }
            else
            {
                if (aComponent.ComponentType == eComponentType.ColorAndSize)
                {
                    distributeChange = eDistributeChange.ToNone;
                }
                else
                {
                    distributeChange = eDistributeChange.ToAll;
                }
            }
            int multiple = 1;
            Index_RID[] storeIndexRIDs = new Index_RID[aStoreList.Count];
            int s = 0;
            foreach (StoreProfile sp in aStoreList)
            {
                storeIndexRIDs[s] = this.StoreIndex(sp.Key);
                s++;
            }
            AllocationColorOrSizeComponent colorComponent;
            AllocationColorOrSizeComponent sizeComponent;
            AllocationPackComponent packComponent;
            switch (aComponent.ComponentType)
            {
                case (eComponentType.AllColors):
                    {
                        multiple = this.GetSubtotalMultiple(eAllocationSummaryNode.Bulk);
                        break;
                    }
                case (eComponentType.AllGenericPacks):
                    {
                        multiple = this.GetSubtotalMultiple(eAllocationSummaryNode.GenericType);
                        break;
                    }
                case (eComponentType.AllNonGenericPacks):
                    {
                        multiple = this.GetSubtotalMultiple(eAllocationSummaryNode.DetailSubType);
                        break;
                    }
                case (eComponentType.AllPacks):
                    {
                        multiple = this.GetSubtotalMultiple(eAllocationSummaryNode.Total);
                        break;
                    }
                case (eComponentType.AllSizes):
                    {
                        throw new MIDException(eErrorLevel.warning,
                            (int)eMIDTextCode.msg_al_AllSizesAllocatedReadOnly,
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizesAllocatedReadOnly));
                    }
                case (eComponentType.Bulk):
                    {
                        multiple = this.BulkMultiple;
                        break;
                    }
                case (eComponentType.ColorAndSize):
                    {
                        AllocationColorSizeComponent acs = (AllocationColorSizeComponent)aComponent;
                        GeneralComponent color = acs.ColorComponent;
                        GeneralComponent size = acs.SizeComponent;
                        switch (color.ComponentType)
                        {
                            case (eComponentType.AllColors):
                                {
                                    ArrayList sizeRIDs = new ArrayList();

                                    switch (size.ComponentType)
                                    {
                                        case (eComponentType.AllSizes):
                                            {
                                                // empty sizeRIDs implies all sizes
                                                break;
                                            }
                                        case (eComponentType.SpecificSize):
                                            {
                                                sizeRIDs.Add(((AllocationColorOrSizeComponent)size).SizeRID);
                                                break;
                                            }
                                        case (eComponentType.SpecificSizePrimaryDim):
                                            {
                                                AllocationColorOrSizeComponent pSizeComponent = (AllocationColorOrSizeComponent)size;
                                                SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(pSizeComponent.PrimarySizeDimRID);
                                                foreach (SizeCodeProfile scp in scl)
                                                {
                                                    sizeRIDs.Add(scp.Key);
                                                }
                                                break;
                                            }
                                        case (eComponentType.SpecificSizeSecondaryDim):
                                            {
                                                AllocationColorOrSizeComponent sSizeComponent = (AllocationColorOrSizeComponent)size;
                                                SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sSizeComponent.SecondarySizeDimRID);
                                                foreach (SizeCodeProfile scp in scl)
                                                {
                                                    sizeRIDs.Add(scp.Key);
                                                }
                                                break;
                                            }
                                        default:
                                            {
                                                throw new MIDException(eErrorLevel.severe,
                                                    (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                    this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                            }
                                    }
                                    ArrayList oldColorTotalArray = new ArrayList();
                                    ArrayList oldColorLockTotalArray = new ArrayList();
                                    int oldAllColorTotal = 0;
                                    int oldAllColorLockTotal = 0;
                                    ArrayList colorSizeComponentArray = new ArrayList();
                                    ArrayList colorPosition = new ArrayList();
                                    ArrayList correspondingAP = new ArrayList();
                                    int i = 0;
                                    foreach (AllocationProfile ap in this.SubtotalMembers)
                                    {
                                        foreach (HdrColorBin hcb in ap.BulkColors.Values)
                                        {
                                            AllocationColorSizeComponent colorSizeComponent = new AllocationColorSizeComponent(
                                                new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, hcb.ColorCodeRID),
                                                size);
                                            colorSizeComponentArray.Add(colorSizeComponent);
                                            int oldColorTotal = 0;
                                            int oldColorLockTotal = 0;
                                            if (sizeRIDs.Count > 0)
                                            {
                                                foreach (int sizeRID in sizeRIDs)
                                                {
                                                    if (hcb.SizeIsInColor(sizeRID))
                                                    {
                                                        HdrSizeBin hsb = hcb.GetSizeBin(sizeRID);
                                                        foreach (Index_RID strIndexRID in storeIndexRIDs)
                                                        {
                                                            oldColorTotal += ap.GetStoreItemQtyAllocated(
                                                                hsb,
                                                                strIndexRID);
                                                            if (ap.GetStoreLocked(hsb, strIndexRID)
                                                                || ap.GetStoreItemTempLock(hsb, strIndexRID))
                                                            {
                                                                oldColorLockTotal += ap.GetStoreItemQtyAllocated(hsb, strIndexRID);
                                                            }
                                                        }

                                                    }
                                                }
                                            }
                                            else
                                            {
                                                foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                                                {
                                                    foreach (Index_RID strIndexRID in storeIndexRIDs)
                                                    {
                                                        oldColorTotal += ap.GetStoreItemQtyAllocated(
                                                            hsb,
                                                            strIndexRID);
                                                        if (ap.GetStoreLocked(hsb, strIndexRID)
                                                            || ap.GetStoreItemTempLock(hsb, strIndexRID))
                                                        {
                                                            oldColorLockTotal += ap.GetStoreItemQtyAllocated(hsb, strIndexRID);
                                                        }
                                                    }
                                                }
                                            }
                                            oldColorTotalArray.Add(oldColorTotal);
                                            oldColorLockTotalArray.Add(oldColorLockTotal);
                                            oldAllColorTotal += oldColorTotal;
                                            oldAllColorLockTotal += oldColorLockTotal;
                                            correspondingAP.Add(ap);
                                            colorPosition.Add(i);
                                            i++;
                                        }
                                    }
                                    int newAllColorTotal = 0;
                                    if (oldAllColorLockTotal <= aItemQtyAllocated)
                                    {
                                        newAllColorTotal = aItemQtyAllocated - oldAllColorLockTotal;
                                    }
                                    else
                                    {
                                        throw new MIDException(eErrorLevel.warning,
                                            (int)(eMIDTextCode.msg_al_LockTotalExceedsNew),
                                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew));
                                    }
                                    int[] oldColorTotalFixedArray = new int[oldColorTotalArray.Count];
                                    int[] colorPositionFixedArray = new int[oldColorTotalArray.Count];
                                    oldColorTotalArray.CopyTo(oldColorTotalFixedArray);
                                    colorPosition.CopyTo(colorPositionFixedArray);
                                    Array.Sort(oldColorTotalFixedArray, colorPositionFixedArray);
                                    int colorNewTotal;
                                    for (int sortPosition = 0; sortPosition < oldColorTotalFixedArray.Length; sortPosition++)
                                    {
                                        colorNewTotal = 0;
                                        i = colorPositionFixedArray[sortPosition];
                                        if (oldAllColorTotal > oldAllColorLockTotal)
                                        {
                                            colorNewTotal =
                                                ((int)oldColorTotalArray[sortPosition] - (int)oldColorLockTotalArray[i])
                                                * newAllColorTotal
                                                / (oldAllColorTotal - oldAllColorLockTotal);
                                        }
                                        ((AllocationProfile)correspondingAP[i]).SpreadStoreListTotalQtyAllocated((AllocationColorSizeComponent)colorSizeComponentArray[i], aStoreList, colorNewTotal + (int)oldColorLockTotalArray[i]);
                                        oldAllColorTotal -= (int)oldColorTotalArray[sortPosition];
                                        oldAllColorLockTotal -= (int)oldColorLockTotalArray[i];
                                        newAllColorTotal -= colorNewTotal;
                                    }
                                    return true;
                                }
                            case (eComponentType.SpecificColor):
                                {
                                    colorComponent = (AllocationColorOrSizeComponent)color; 
                                    if (this.BulkColorIsOnSubtotal(colorComponent.ColorRID))
                                    {
                                        switch (size.ComponentType)
                                        {
                                            case (eComponentType.AllSizes):
                                                {
                                                    multiple = GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorMultiple;
                                                    break;
                                                }
                                            case (eComponentType.SpecificSize):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                    if (this.GetSubtotalHdrColorBin(colorComponent.ColorRID).SizeIsInColor(sizeComponent.SizeRID))
                                                    {
                                                        multiple = this.GetSubtotalHdrColorBin(colorComponent.ColorRID).GetSizeBin(sizeComponent.SizeRID).SizeMultiple;
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizePrimaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size; 
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeByPrimaryDim(sizeComponent.PrimarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    multiple = 0;
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            if (multiple == 0)
                                                            {
                                                                multiple = hcb.GetSizeBin(scp.Key).SizeMultiple;
                                                            }
                                                            else
                                                            {
                                                                multiple = MIDMath.GreatestCommonDivisor(multiple, hcb.GetSizeBin(scp.Key).SizeMultiple);
                                                            }
                                                        }
                                                    }
                                                    if (multiple == 0)
                                                    {
                                                        multiple = 1;
                                                    }
                                                    break;
                                                }
                                            case (eComponentType.SpecificSizeSecondaryDim):
                                                {
                                                    sizeComponent = (AllocationColorOrSizeComponent)size;  
                                                    SizeCodeList scl = this.Transaction.GetSizeCodeBySecondaryDim(sizeComponent.SecondarySizeDimRID);
                                                    HdrColorBin hcb = this.GetSubtotalHdrColorBin(colorComponent.ColorRID);
                                                    multiple = 0;
                                                    foreach (SizeCodeProfile scp in scl)
                                                    {
                                                        if (hcb.SizeIsInColor(scp.Key))
                                                        {
                                                            if (multiple == 0)
                                                            {
                                                                multiple = hcb.GetSizeBin(scp.Key).SizeMultiple;
                                                            }
                                                            else
                                                            {
                                                                multiple = MIDMath.GreatestCommonDivisor(multiple, hcb.GetSizeBin(scp.Key).SizeMultiple);
                                                            }
                                                        }
                                                    }
                                                    if (multiple == 0)
                                                    {
                                                        multiple = 1;
                                                    }
                                                    break;
                                                }
                                            default:
                                                {
                                                    throw new MIDException(eErrorLevel.severe,
                                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                                }
                                        }
                                    }
                                    break;
                                }
                            default:
                                {
                                    throw new MIDException(eErrorLevel.severe,
                                        (int)(eMIDTextCode.msg_al_UnknownComponentType),
                                        this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                                }
                        }
                        break;
                    }
                case (eComponentType.DetailType):
                    {
                        multiple = this.DetailTypeMultiple;
                        break;
                    }
                case (eComponentType.GenericType):
                    {
                        multiple = this.GetSubtotalMultiple(eAllocationSummaryNode.GenericType);
                        break;
                    }
                case (eComponentType.SpecificColor):
                    {
                        colorComponent = (AllocationColorOrSizeComponent)aComponent;
                        multiple = this.GetSubtotalHdrColorBin(colorComponent.ColorRID).ColorMultiple;
                        break;
                    }
                case (eComponentType.SpecificSize):
                    {
                        throw new MIDException(eErrorLevel.warning,
                            (int)eMIDTextCode.msg_al_SizeAllocatedAcrossColorReadOnly,
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SizeAllocatedAcrossColorReadOnly));
                    }
                case (eComponentType.SpecificPack):
                    {
                        packComponent = (AllocationPackComponent)aComponent;
                        multiple = 1;
                        break;
                    }
                case (eComponentType.Total):
                    {
                        multiple = this.TotalMultiple;
                        break;
                    }
                default:
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)(eMIDTextCode.msg_al_UnknownComponentType),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_UnknownComponentType));
                    }
            }

            int lockTotal = 0;
            int newTotal = aItemQtyAllocated;
            Index_RID storeIndexRID;
            int qtyAllocated;
            int oldTotal = this.GetStoreListTotalQtyAllocated(aComponent, aStoreList);
            eMIDTextCode statusReasonCode; // TT#1176 - MD - Jellis - Group Allocation - Size Need not observing inv min max
            int minMaxConstraint; // TT#1176 - MD - Jellis - Group Allocation - Size Need not observing inv min max
            // begin MID Track 4531 AnF Defect 364: Reserve Store Allocation Cannot Be Reduced
            try
            {
                if (this.Transaction.ReserveStore.RID != Include.NoRID)
                {
                    this.SetStoreItemTempLock(aComponent, this.Transaction.ReserveStore, true);
                }
                // end MID Track 4531 AnF Defect 364: Reserve Store Allocation Cannot Be Reduced
                if (newTotal != oldTotal)
                {
                    foreach (StoreProfile sp in aStoreList)
                    {
                        storeIndexRID = StoreIndex(sp.Key);
                        if (GetStoreLocked(aComponent, storeIndexRID) ||
                            GetStoreItemTempLock(aComponent, storeIndexRID))
                        {
                            lockTotal += GetStoreItemQtyAllocated(aComponent, storeIndexRID);
                        }
                    }
                    if (lockTotal > newTotal)
                    {
                        throw new MIDException(eErrorLevel.warning,
                            (int)(eMIDTextCode.msg_al_LockTotalExceedsNew),
                            this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew));
                    }
                    newTotal -= lockTotal;
                    oldTotal -= lockTotal;
                    foreach (StoreProfile sp in aStoreList)
                    {
                        storeIndexRID = StoreIndex(sp.Key);
                        if (!GetStoreLocked(aComponent, storeIndexRID) &&
                            !GetStoreItemTempLock(aComponent, storeIndexRID))
                        {
                            if (oldTotal > 0)
                            {
                                qtyAllocated =
                                    (int)(
                                    (((double)GetStoreItemQtyAllocated(aComponent, storeIndexRID)
                                    * (double)newTotal)
                                    / (double)oldTotal) + 0.5d);
                                qtyAllocated =
                                    (int)(((double)qtyAllocated
                                    / (double)multiple) + 0.5d);
                                qtyAllocated = (qtyAllocated * multiple);

                                // begin TT#1176 - MD - Jellis - Group Allocation - Size Need Not Observing inv min max
                                //if (qtyAllocated < GetStoreMinimum(aComponent, storeIndexRID, true))  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
                                if (!TryGetStoreMinimum(aComponent, storeIndexRID, true, out minMaxConstraint, out statusReasonCode))
                                {
                                    throw new MIDException(
                                        eErrorLevel.fatal,
                                        (int)statusReasonCode,
                                        SAB.ApplicationServerSession.Audit.GetText(statusReasonCode, false) + " : Source/Method [" + GetType().Name + " / SpreadStoreListTotalItemQtyAllocated--minimum]");
                                }
                                if (qtyAllocated < minMaxConstraint)
                                    // end TT#1176 - MD - Jellis - Group Allocation - Size Need Not observing inv min max
                                {
                                    qtyAllocated = 0;
                                }
                                else
                                {
                                    // begin TT#1176 - MD - Jellis - Group Allocation Size Need not observing inv min max
                                    //if (qtyAllocated > GetStoreMaximum(aComponent, storeIndexRID, true)  // TT#1074 - MD - Jellis - Group Allocation Inventory Min Max Broken
                                    //    && !GetStoreMayExceedMax(storeIndexRID))
                                    //{
                                    //    qtyAllocated = GetStoreMaximum(aComponent, storeIndexRID, true); // TT#1074 - MD - Jellis- Group Allocation Inventory Min Max Broken
                                    //}
                                    if (!TryGetStoreMaximum(aComponent, storeIndexRID, true, out minMaxConstraint, out statusReasonCode))
                                    {
                                        throw new MIDException(
                                            eErrorLevel.fatal,
                                            (int)statusReasonCode,
                                            SAB.ApplicationServerSession.Audit.GetText(statusReasonCode, false) + " : Source/Method [" + GetType().Name + " / SpreadStoreListTotalItemQtyAllocated--maximum]");

                                    }
                                    if (qtyAllocated > minMaxConstraint)
                                    {
                                        qtyAllocated = minMaxConstraint;
                                    }
                                    // end TT#1176 - MD - Jellis - Group Allocaiton Size Need not observing inv min max
                                    if (qtyAllocated > GetStorePrimaryMaximum(aComponent, storeIndexRID)
                                        && !GetStoreMayExceedPrimaryMaximum(storeIndexRID))
                                    {
                                        qtyAllocated = GetStorePrimaryMaximum(aComponent, storeIndexRID);
                                    }
                                }
                            }
                            else
                            {
                                qtyAllocated = 0;
                            }
                            oldTotal -=
                                GetStoreItemQtyAllocated(
                                aComponent,
                                storeIndexRID);
                            if (!SetStoreItemQtyAllocated(
                                aComponent,
                                storeIndexRID,
                                qtyAllocated,
                                distributeChange,
                                false))
                            {
                                success = false;
                            }
                            newTotal -=
                                GetStoreItemQtyAllocated
                                (aComponent,
                                storeIndexRID);
                        } 
                    }
                }
            }
            finally
            {
                if (this.Transaction.ReserveStore.RID != Include.NoRID)
                {
                    this.SetStoreItemTempLock(aComponent, this.Transaction.ReserveStore, false);
                }
            }
            // end MID Track 4531 AnF Defect 364: Reserve Store Allocation Cannot Be Reduced
            return success;
        }
        #endregion SpreadTotalsOfStoreSubtotalsItemToStores

        #region SpreadStoreItemQtyAcrossSizes
        /// <summary>
        /// Spreads a change to a store size total (across a group of sizes) to the individual store-size level.
        /// </summary>
        /// <param name="aColorRID">Color RID where the sizes reside</param>
        /// <param name="aSizeCodeList">Size Code Profile List identifying the sizes</param>
        /// <param name="aStore">Index_RID that identifies the store</param>
        /// <param name="aNewTotal">New total</param>
        /// <returns>True: Spread successful; False: Spread not successful</returns>
        private bool SpreadStoreItemQtyAcrossSizes(int aColorRID, SizeCodeList aSizeCodeList, Index_RID aStore, int aNewTotal)
        {
            int oldTotal = 0;
            int newTotal = aNewTotal;
            int lockTotal = 0;
            HdrColorBin hcb = this.GetSubtotalHdrColorBin(aColorRID);
            ArrayList sizeArray = new ArrayList();
            HdrSizeBin sizeBin;
            foreach (SizeCodeProfile scp in aSizeCodeList)
            {
                if (hcb.SizeIsInColor(scp.Key))
                {
                    sizeBin = hcb.GetSizeBin(scp.Key);
                    if (this.GetStoreLocked(sizeBin, aStore))
                    {
                        lockTotal += this.GetStoreItemQtyAllocated(sizeBin, aStore);
                    }
                    else
                    {
                        sizeArray.Add(sizeBin);
                        oldTotal += this.GetStoreItemQtyAllocated(sizeBin, aStore);
                    }
                }
            }
            int unitsAllocated;
            int origUnitsAllocated;
            newTotal -= lockTotal;
            if (newTotal <= 0)
            {
                newTotal = 0;
                this.Transaction.SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Information,
                    eMIDTextCode.msg_al_LockTotalExceedsNew,
                    this.Transaction.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_LockTotalExceedsNew, false));
            }
            foreach (HdrSizeBin hsb in sizeArray)
            {
                if (oldTotal > 0)
                {
                    origUnitsAllocated = this.GetStoreItemQtyAllocated(hsb, aStore);
                    unitsAllocated =
                        (int)(((double)origUnitsAllocated
                        * (double)newTotal
                        / (double)oldTotal)
                        + .5d);
                    unitsAllocated =
                        (int)(((double)unitsAllocated
                        / (double)hsb.SizeMultiple)
                        + .5d);
                    unitsAllocated =
                        unitsAllocated
                        * hsb.SizeMultiple;
                    if (unitsAllocated > newTotal)
                    {
                        unitsAllocated = newTotal;
                    }
                    oldTotal -= origUnitsAllocated;
                }
                else
                {
                    unitsAllocated = 0;
                }
                this.SetStoreItemQtyAllocated(hsb, aStore, unitsAllocated, eDistributeChange.ToNone, false);
                newTotal -= this.GetStoreItemQtyAllocated(hsb, aStore);
            }
            return true;
        }
        #endregion SpreadStoreItemQtyAcrossSizes
        // end TT#1401 - JEllis - Urban Reservation Stores pt 2
		#endregion Spreads
		
		#region AdjustForCapacity
		// belongs in AllocationProfile or better yet in master allocation profilelist?
		/// <summary>
		/// Adjusts a desired allocation quantity to be consistent with the capacity maximum
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aAllocationSummaryNode">Node where the allocation is to be applied.</param>
		/// <param name="aStore">Index_RID that describes the store.</param>
		/// <param name="aQtyAllocated">Desired quantity allocated</param>
		/// <returns>Adjusted quantity allocated</returns>
		public int AdjustForCapacity (
			AllocationProfile aAllocationProfile,
			eAllocationSummaryNode aAllocationSummaryNode, 
			Index_RID aStore, 
			int aQtyAllocated)
		{
			int unitsAllocated = aQtyAllocated;
			int desiredTotalAllocated;
			int alreadyAllocated;
			int capacityMaximum; 

			switch (aAllocationSummaryNode)
			{
				case (eAllocationSummaryNode.Total):
				{
					alreadyAllocated = 
						aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.Total, aStore);
                    capacityMaximum =                                                                                   // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken 
                        aAllocationProfile.GetStoreCapacityMaximum(new GeneralComponent(eComponentType.Total), aStore, true) // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
                        - alreadyAllocated;                                                                            // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
                    break;
				}
				case(eAllocationSummaryNode.Type):
				{
					alreadyAllocated = 
						aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.Type, aStore);
                    capacityMaximum =                                                                                   // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken 
                        aAllocationProfile.GetStoreCapacityMaximum(new GeneralComponent(eComponentType.Total), aStore, true)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken 
                        - alreadyAllocated; // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
                    break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					alreadyAllocated = 
						aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore);   // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken (unrelated issue)
                    capacityMaximum =                                                                                   // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken 
                        aAllocationProfile.GetStoreCapacityMaximum(new GeneralComponent(eComponentType.GenericType), aStore, true)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken 
                        - alreadyAllocated; // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken                    
                    break;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					alreadyAllocated = 
						aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, aStore); // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken (unrelated issue)
                    capacityMaximum =                                                                                   // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken 
                        aAllocationProfile.GetStoreCapacityMaximum(new GeneralComponent(eComponentType.DetailType), aStore, true) // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
                        - alreadyAllocated; // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken            
                    break;
				}
				case(eAllocationSummaryNode.DetailSubType):
                    //  begin TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
                    //if (BulkIsDetail)
                    //{
                    //    capacityMaximum =
                    //        capacityMaximum
                    //        - aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore);
                    //}
                    //else
                    //{
                    //    capacityMaximum = 
                    //        capacityMaximum
                    //        - aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore)
                    //        - aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.Bulk, aStore);
                    //}
                    // end TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
					alreadyAllocated = 
						aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore);
                    capacityMaximum =                                                                                   // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken 
                        aAllocationProfile.GetStoreCapacityMaximum(new GeneralComponent(eComponentType.DetailSubType), aStore, true) // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
                        - alreadyAllocated; // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken      
					break;
				case(eAllocationSummaryNode.BulkColorTotal):
				{
                    // begin TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
                    //if (BulkIsDetail)
                    //{
                    //    capacityMaximum =
                    //        capacityMaximum
                    //        - aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore)
                    //        - (aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore)
                    //        - aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.Bulk, aStore));
                    //}
                    //else
                    //{
                    //    capacityMaximum = 
                    //        capacityMaximum
                    //        - aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore)
                    //        - aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, aStore);
                    //}
                    // end TT#1074 - MD - Jellis - Group ALlocation - Inventory Min Max Broken
					alreadyAllocated = 
						aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.BulkColorTotal, aStore);
                    capacityMaximum =                                                                                   // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken 
                        aAllocationProfile.GetStoreCapacityMaximum(new GeneralComponent(eComponentType.Bulk), aStore, true) // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
                        - alreadyAllocated; // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken      
					break;
				}
				case(eAllocationSummaryNode.Bulk):
				{
                    // begin TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max Broken
                    //if (BulkIsDetail)
                    //{
                    //    capacityMaximum =
                    //        capacityMaximum
                    //        - aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore);
                    //    alreadyAllocated = 
                    //        aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, aStore);
                    //}
                    //else
                    //{
                    //    alreadyAllocated = 
                    //        aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.Type, aStore);
                    //}
                    alreadyAllocated =
                        aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.Bulk, aStore);
                    capacityMaximum =   
                        aAllocationProfile.GetStoreCapacityMaximum(new GeneralComponent(eComponentType.Bulk), aStore.Index, true) 
                        - alreadyAllocated; 
                    // end TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.fatal,
						(int)(eMIDTextCode.msg_UnknownAllocationComponent),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownAllocationComponent));
				}
			}
			if (capacityMaximum < 0)
			{
				capacityMaximum = 0;
			}
			desiredTotalAllocated =
				alreadyAllocated
				+ unitsAllocated;
			if ((desiredTotalAllocated > capacityMaximum) 
				&& !aAllocationProfile.GetStoreMayExceedCapacity(aStore))
			{
				if (alreadyAllocated > capacityMaximum)
				{
					unitsAllocated = 0;
				}
				else
				{
					unitsAllocated =
						capacityMaximum
						- alreadyAllocated;
				}
			}
			return unitsAllocated;
		}

		/// <summary>
		/// Adjusts a desired allocation quantity to be consistent with the capacity maximum
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aPackName">Pack name of the pack where the allocation is to be applied.</param>
		/// <param name="aStore">Index_RID that describes the store.</param>
		/// <param name="aQtyAllocated">Desired quantity allocated</param>
		/// <returns>Adjusted quantity allocated</returns>
		public int AdjustForCapacity (
			AllocationProfile aAllocationProfile,
			string aPackName,
			Index_RID aStore, 
			int aQtyAllocated)
		{
			PackHdr aPack = aAllocationProfile.GetPackHdr(aPackName);
			if (aPack.GenericPack)
			{
				return (AdjustForCapacity(
					aAllocationProfile, 
					eAllocationSummaryNode.GenericType,
					aStore,
					aQtyAllocated * aPack.PackMultiple))
					/ aPack.PackMultiple;
			}
			else
			{
				return AdjustForCapacity(
					aAllocationProfile,
					eAllocationSummaryNode.DetailSubType,
					aStore,
					aQtyAllocated * aPack.PackMultiple)
					/ aPack.PackMultiple;
			}
		}

		/// <summary>
		/// Adjusts a desired allocation quantity to be consistent with the capacity maximum
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aColorCodeRID">RID of the color where the allocation is to be applied.</param>
		/// <param name="aStore">Index_RID that describes the store.</param>
		/// <param name="aQtyAllocated">Desired quantity allocated</param>
		/// <returns>Adjusted quantity allocated</returns>
		public int AdjustForCapacity (
			AllocationProfile aAllocationProfile,
			int aColorCodeRID,
			Index_RID aStore, 
			int aQtyAllocated)
		{
			return (AdjustForCapacity(
				aAllocationProfile, 
				eAllocationSummaryNode.BulkColorTotal,
				aStore,
				aQtyAllocated));
		}

		/// <summary>
		/// Adjusts a desired allocation quantity to be consistent with the capacity maximum
		/// </summary>
		/// <param name="aAllocationProfile">Allocation Profile</param>
		/// <param name="aColorCodeRID">RID of the color where the size resides</param>
		/// <param name="aSizeKey">RID of the size where the allocation is to be applied</param>
		/// <param name="aStore">Index_RID that describes the store.</param>
		/// <param name="aQtyAllocated">Desired quantity allocated</param>
		/// <returns>Adjusted quantity allocated</returns>
		public int AdjustForCapacity (
			AllocationProfile aAllocationProfile,
			int aColorCodeRID,
			int aSizeKey,
			Index_RID aStore, 
			int aQtyAllocated)
		{
			HdrSizeBin aSize = aAllocationProfile.GetHdrColorBin(aColorCodeRID).GetSizeBin(aSizeKey);
			int unitsAllocated = aQtyAllocated;
			int desiredTotalAllocated;
			int alreadyAllocated;
            // begin TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
            //int capacityMaximum =
            //    aAllocationProfile.GetStoreCapacityMaximum(aStore)
            //    - aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.GenericType, aStore);
 
            //if (aAllocationProfile.BulkIsDetail)
            //{
            //    capacityMaximum -=
            //        aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.DetailSubType, aStore)
            //        - aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.Bulk, aStore);
            //}
            //else
            //{
            //    capacityMaximum -=
            //        aAllocationProfile.GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, aStore);
            //}
            //foreach (HdrColorBin hcb in aAllocationProfile.BulkColors.Values)
            //{
            //    if (hcb.ColorCodeRID != aColorCodeRID)
            //    {
            //        capacityMaximum -=
            //            aAllocationProfile.GetStoreQtyAllocated(aColorCodeRID, aStore);
            //    }
            //}
            //if (capacityMaximum < 0)
            //{
            //    capacityMaximum = 0;
            //}
            //alreadyAllocated = 
            //    aAllocationProfile.GetHdrColorBin(aColorCodeRID).GetStoreColorTotalSizeAllocated(aStore.Index);
            alreadyAllocated =
                aAllocationProfile.GetStoreQtyAllocated(aSize, aStore);
            int capacityMaximum =
                aAllocationProfile.GetStoreCapacityMaximum(
                    new AllocationColorSizeComponent(
                        new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aSize.Color.ColorCodeRID),
                        new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, aSize.SizeCodeRID)),
                    aStore,
                    true)
                - alreadyAllocated;
            // end TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken

			desiredTotalAllocated =
				alreadyAllocated
				+ unitsAllocated;
			if ((desiredTotalAllocated > capacityMaximum) 
				&& !aAllocationProfile.GetStoreMayExceedCapacity(aStore))
			{
				if (alreadyAllocated > capacityMaximum)
				{
					unitsAllocated = 0;
				}
				else
				{
					unitsAllocated =
						capacityMaximum
						- alreadyAllocated;
				}
			}
			return unitsAllocated;
		}
		#endregion AdjustForCapacity

		#region GetComponentMultiple
//		public int GetComponentMultiple(
//			AllocationProfile aAllocationProfile,
//			GeneralComponent aComponent)
//		{
//			int multiple;
//			switch (aAllocationSummaryNode)
//			{
//				case(eAllocationSummaryNode.Total):
//				{
//					multiple = aAllocationProfile.AllocationMultiple;
//					break;
//				}
//				case(eAllocationSummaryNode.Type):
//				{	 
//					multiple = aAllocationProfile.AllocationMultiple;
//					break;
//				}
//				case(eAllocationSummaryNode.GenericType):
//				{
//					multiple = aAllocationProfile.GenericMultiple;
//					break;
//				}
//				case(eAllocationSummaryNode.DetailSubType):
//				{
//					multiple = aAllocationProfile.DetailTypeMultiple;
//					break;
//				}
//				case(eAllocationSummaryNode.DetailType):
//				{
//					multiple = aAllocationProfile.DetailTypeMultiple;
//					break;
//				}
//				case(eAllocationSummaryNode.BulkColorTotal):
//				{
//					multiple = aAllocationProfile.BulkMultiple;
//					break;
//				}
//				case(eAllocationSummaryNode.Bulk):
//				{
//					multiple = aAllocationProfile.BulkMultiple;
//					break;
//				}
//				default:
//				{
//					throw new MIDException(eErrorLevel.fatal,
//						(int)(eMIDTextCode.msg_UnknownAllocationComponent),
//						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownAllocationComponent));
//				}
//			}
//			return multiple;
//		}
		#endregion GetComponentMultiple

		#region GetSubtotalMultiple
		public int GetSubtotalMultiple(eAllocationSummaryNode aAllocationSummaryNode)
		{
			int multiple;
			switch (aAllocationSummaryNode)
			{
				case(eAllocationSummaryNode.Total):
				{
					multiple = this.TotalMultiple;
					break;
				}
				case(eAllocationSummaryNode.Type):
				{	 
					multiple = this.TotalMultiple;
					break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					multiple = this.GenericTypeMultiple;
					break;
				}
				case(eAllocationSummaryNode.DetailSubType):
				{
					multiple = this.DetailTypeMultiple;
					break;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					multiple = this.DetailTypeMultiple;
					break;
				}
				case(eAllocationSummaryNode.BulkColorTotal):
				{
					multiple = this.BulkMultiple;
					break;
				}
				case(eAllocationSummaryNode.Bulk):
				{
					multiple = this.BulkMultiple;
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.fatal,
						(int)(eMIDTextCode.msg_UnknownAllocationComponent),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownAllocationComponent));
				}
			}
			return multiple;
		}
		#endregion GetSubtotalMultiple

		#region GetAllocationMultiple
		public int GetAllocationMultiple(
			AllocationProfile aAllocationProfile,
			eAllocationSummaryNode aAllocationSummaryNode)
		{
			int multiple;
			switch (aAllocationSummaryNode)
			{
				case(eAllocationSummaryNode.Total):
				{
					multiple = aAllocationProfile.AllocationMultiple;
					break;
				}
				case(eAllocationSummaryNode.Type):
				{	 
					multiple = aAllocationProfile.AllocationMultiple;
					break;
				}
				case(eAllocationSummaryNode.GenericType):
				{
					multiple = aAllocationProfile.GenericMultiple;
					break;
				}
				case(eAllocationSummaryNode.DetailSubType):
				{
					multiple = aAllocationProfile.DetailTypeMultiple;
					break;
				}
				case(eAllocationSummaryNode.DetailType):
				{
					multiple = aAllocationProfile.DetailTypeMultiple;
					break;
				}
				case(eAllocationSummaryNode.BulkColorTotal):
				{
					multiple = aAllocationProfile.BulkMultiple;
					break;
				}
				case(eAllocationSummaryNode.Bulk):
				{
					multiple = aAllocationProfile.BulkMultiple;
					break;
				}
				default:
				{
					throw new MIDException(eErrorLevel.fatal,
						(int)(eMIDTextCode.msg_UnknownAllocationComponent),
						this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_UnknownAllocationComponent));
				}
			}
			return multiple;
		}
		#endregion GetAllocationMultiple

		#region AddAllocationProfile
		/// <summary>
		/// Adds an allocation profile to the subtotal.
		/// </summary>
		/// <param name="aAllocationProfile">The allocation profile to add</param>
		public void  AddAllocationToSubtotal (AllocationProfile aAllocationProfile)
		{
            // begin TT#981 - MD - Jellis Argument Out of Range Error
            //// Begin #TT2 - RMatelic - Assortment Planning
            //if (aAllocationProfile.HeaderType == eHeaderType.Assortment)
            //{
            //    return;
            //}   
            //// End TT#2
            // end TT#981 - MD - Jellis - Argument Out of Range Error
			//			Index_RID StoreIndexRID;
			if (_allocationProfileList.Count == 0)
			{
				BulkIsDetail = aAllocationProfile.BulkIsDetail;
			}
			if (BulkIsDetail != aAllocationProfile.BulkIsDetail)
			{
                // BEGIN MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
				this.Transaction.SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Warning,
					eMIDTextCode.msg_al_SelectedHeadersMustTreatBulkSame,
                    "[" + aAllocationProfile.HeaderID + "] " + this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SelectedHeadersMustTreatBulkSame,false), // MID Track 5778 Scheduler 'Run Now' feature gets error in audit
					this.GetType().Name);
//				throw new MIDException(eErrorLevel.warning,
//					(int)(eMIDTextCode.msg_al_SelectedHeadersMustTreatBulkSame),
//					this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_SelectedHeadersMustTreatBulkSame));
			    // END MID Track #2412 Cannot Open Sku or Size Review with multiple headers with color
			}
			//			if (aAllocationProfile.SubtotalProfile != null)
			//			{
			//				RemoveAllocationFromSubtotal (aAllocationProfile);
			//			}
			if (aAllocationProfile.SubtotalExists(this.SubtotalName))
			{
				// Skip adding this subtotal to the profile!
				//				throw new MIDException(eErrorLevel.warning,
				//					(int)(eMIDTextCode.msg_al_DuplicateSubtotalsNotAllowed),
				//					this.SAB.ApplicationServerSession.Audit.GetText(eMIDTextCode.msg_al_DuplicateSubtotalsNotAllowed));

			}
			else
			{
				aAllocationProfile.AddSubtotal(this);
				// Begin MID Multi-Header stodd
				// Only add Alloc Profile, if it's not already in list
                if (!_allocationProfileList.Contains(aAllocationProfile.Key))
                // begin TT#1154 - MD - Jellis - Group Allocation Style Review No Stores
                {
                    aAllocationProfile.AppSessionTransaction.ResetAnalysisSettings();
                    // end TT#1154 - MD - Jellis - Group Allocation Style Review No Stores
                    _allocationProfileList.Add(aAllocationProfile);
                    // Clear list to rebuild
                    _headersForStoreQtyAllocatedNotIntransit = null;  // TT#2126-MD - JSmith - After REDO Need and Need % changes.  Expected it to be the same as before the REDO.
                }   // TT#1154 - MD - Jellis- Group Allocation Style Review No Stores
				// End MID Multi_header
                _buildSubtotal = true;                                             // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                _buildItemSubtotals = true; // TT#967 - MD - Jellis - Group Allocation - VSW in total section zero when viewing multiple headers in Style View
                //List<AllocationProfile> apList = new List<AllocationProfile>();  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                //apList.Add(aAllocationProfile);                                  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                //BuildSubtotal(apList);                                           // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
			}
		}
		private void BuildSubtotal()  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
		{
            if (_buildingSubtotals)
            {
                throw new Exception("999999: Unexpected loop back to 'BuildSubtotal()' in " + GetType().Name);
            }
            // begin TT#1185 - MD - Jellis - Group Allocation - Style Review not showing all eligible stores 
            if (_construct)
            {
                Constructor();
                _construct = false;
            }
            // end TT#1185 - MD - Jellis - Group Allocation - Style Review not showing all eligible stores 
			_buildSubtotal = false; // MID Change j.ellis Delay subtotal build until request for info.
            InitializeAllocationTotals(); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 31
            // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28H
            // removed unnecessary comments
            Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
            try
            {
                _buildingSubtotals = true; // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                foreach (AllocationProfile ap in _allocationProfileList)
                {
                    // begin TT#1042 - MD - Jellis - Qty Allocated Cannot Be Negative part 2
                    //// Begin #TT2 - RMatelic - Assortment Planning
                    //if (ap.HeaderType == eHeaderType.Assortment)
                    //{
                    //    continue;
                    //}
            		// End TT#2
                    // end TT#1042 - MD - Jellis - Qty Allocated Cannot Be Negative part 2
                    //ap.ResetTempLocks(false);  // TT#3297 - MD - Jellis - Temp Locks Broken
                    ap.SuspendSettingTempLocks(true); // TT#3297 - MD - Jellis - Temp Locks Broken
                    this.SetTotalUnitsToAllocate(
                        this.TotalUnitsToAllocate
                        + ap.TotalUnitsToAllocate);
                    this.SetGenericTypeUnitsToAllocate(
                        this.GenericTypeUnitsToAllocate
                        + ap.GenericUnitsToAllocate);
                    this.SetDetailTypeUnitsToAllocate(
                        this.DetailTypeUnitsToAllocate
                        + ap.DetailTypeUnitsToAllocate);
                    this.SetBulkUnitsToAllocate(
                        this.BulkUnitsToAllocate
                        + ap.BulkUnitsToAllocate);
                    foreach (Index_RID StoreIndexRID in index_RID_Array)
                    {
                        this.SetStoreQtyAllocated(
                            eAllocationSummaryNode.Total,
                            StoreIndexRID,
                            (this.GetStoreQtyAllocated(eAllocationSummaryNode.Total, StoreIndexRID)
                            + ap.GetStoreQtyAllocated(eAllocationSummaryNode.Total, StoreIndexRID)),
                            eDistributeChange.ToNone,
                            false);
                        this.SetStoreQtyAllocated(
                            eAllocationSummaryNode.DetailType,
                            StoreIndexRID,
                            (this.GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, StoreIndexRID)
                            + ap.GetStoreQtyAllocated(eAllocationSummaryNode.DetailType, StoreIndexRID)),
                            eDistributeChange.ToNone,
                            false);
                        this.SetStoreQtyAllocated(
                            eAllocationSummaryNode.Bulk,
                            StoreIndexRID,
                            (this.GetStoreQtyAllocated(eAllocationSummaryNode.Bulk, StoreIndexRID)
                            + ap.GetStoreQtyAllocated(eAllocationSummaryNode.Bulk, StoreIndexRID)),
                            eDistributeChange.ToNone,
                            false);
                    }
                    foreach (PackHdr ph in ap.Packs.Values)
                    {
                        AddPackToSubtotal(ap, ph);
                    }
                    foreach (HdrColorBin hcb in ap.BulkColors.Values)
                    {
                        AddBulkColorToSubtotal(ap, hcb);
                    }
                    if (!_buildMinMax)
                    {
                        BuildMinMax(ap);
                    }
                }
                // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 30
                _buildSubtotal = false; // MID Change j.ellis Delay subtotal build until request for info.
            }
            finally
            {
                foreach (AllocationProfile ap in _allocationProfileList)
                {
                    //ap.ResetTempLocks(false);        // TT#3297 - MD - Jellis - Temp Locks Broken 
                    ap.SuspendSettingTempLocks(false); // TT#3297 - MD - Jellis - Temp Locks Broken
                }
                _buildingSubtotals = false; // TT#1401 - JEllis - Virtual Store Warehouse pt 28F
            }
        }
        private void CalculateItemSubtotals()
        {
            // begin TT#2344 - JEllis - AnF VSW Subtotals Broken for Store Item
            if (_buildingItemSubtotals)
            {
                return;
            }
            // end TT#2344 - JEllis - AnF VSW Subtotals Broken for Store Item
            Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
            HdrColorBin subtotalColor;
            HdrSizeBin subtotalSize;
            try     // TT#2344 - JEllis - AnF VSW Subtotals Broken for STore Item
            {       // TT#2344 - JEllis - AnF VSW Subtotals Broken for Store Item
                _buildingItemSubtotals = true; // TT#2344 - JEllis - AnF VSW Subtotals Broken for Store Item  
                foreach (Index_RID StoreIndexRID in index_RID_Array)
                {
                    _subtotalTotal[StoreIndexRID.Index].ItemQtyAllocated = 0;
                    _subtotalGenericType[StoreIndexRID.Index].ItemQtyAllocated = 0;
                    _subtotalDetailType[StoreIndexRID.Index].ItemQtyAllocated = 0;
                    _subtotalBulk[StoreIndexRID.Index].ItemQtyAllocated = 0;
                    foreach (PackHdr subtotalPack in _subtotalPacks.Values)
                    {
                        subtotalPack.SetStoreItemPacksAllocated(StoreIndexRID.Index, 0);
                    }
                    foreach (HdrColorBin hcb in _bulkColors.Values)
                    {
                        hcb.SetStoreItemUnitsAllocated(StoreIndexRID.Index, 0);
                        hcb.SetStoreColorTotalSizeItemAllocated(StoreIndexRID.Index, 0);
                        foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                        {
                            hsb.SetStoreSizeItemUnitsAllocated(StoreIndexRID.Index, 0);
                        }
                    }
                    foreach (AllocationProfile ap in _allocationProfileList)
                    {
                        SetStoreItemQtyAllocated(
                            eAllocationSummaryNode.Total,
                            StoreIndexRID,
                            _subtotalTotal[StoreIndexRID.Index].ItemQtyAllocated
                            + ap.GetStoreItemQtyAllocated(eAllocationSummaryNode.Total, StoreIndexRID),
                            eDistributeChange.ToNone,
                            false);
                        SetStoreItemQtyAllocated(
                            eAllocationSummaryNode.DetailType,
                            StoreIndexRID,
                            _subtotalDetailType[StoreIndexRID.Index].ItemQtyAllocated
                            + ap.GetStoreItemQtyAllocated(eAllocationSummaryNode.DetailType, StoreIndexRID),
                            eDistributeChange.ToNone,
                            false);
                        SetStoreItemQtyAllocated(
                            eAllocationSummaryNode.Bulk,
                            StoreIndexRID,
                            _subtotalBulk[StoreIndexRID.Index].ItemQtyAllocated
                            + ap.GetStoreItemQtyAllocated(eAllocationSummaryNode.Bulk, StoreIndexRID),
                            eDistributeChange.ToNone,
                            false);
                        foreach (PackHdr ph in ap.Packs.Values)
                        {
                            PackHdr subtotalPack = GetSubtotalPackHdr(ph.SubtotalPackName);
                            SetStoreItemQtyAllocated(
                                subtotalPack,
                                StoreIndexRID,
                                subtotalPack.GetStoreItemPacksAllocated(StoreIndexRID.Index)
                                + ap.GetStoreItemQtyAllocated(ph, StoreIndexRID),
                                eDistributeChange.ToNone,
                                false);
                        }
                        foreach (HdrColorBin hcb in ap.BulkColors.Values)
                        {
                            if (BulkColorIsOnSubtotal(hcb.ColorCodeRID))
                            {
                                subtotalColor = GetSubtotalHdrColorBin(hcb.ColorCodeRID);
                                SetStoreItemQtyAllocated(
                                    subtotalColor,
                                    StoreIndexRID,
                                    subtotalColor.GetStoreItemUnitsAllocated(StoreIndexRID.Index)
                                    + ap.GetStoreItemQtyAllocated(hcb, StoreIndexRID),
                                    eDistributeChange.ToNone,
                                    false);
                                foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
                                {
                                    subtotalSize = GetSubtotalHdrSizeBin(subtotalColor, hsb.SizeCodeRID);
                                    SetStoreItemQtyAllocated(
                                        subtotalSize,
                                        StoreIndexRID,
                                        subtotalSize.GetStoreSizeItemUnitsAllocated(StoreIndexRID.Index)
                                        + ap.GetStoreItemQtyAllocated(hsb, StoreIndexRID),
                                        eDistributeChange.ToNone,
                                        false);
                                }
                            }
                        }
                    }
                }
                _buildItemSubtotals = false;
                // begin TT#2344 - JEllis - AnF VSW Subtotal Store Item Broken
            } 
            finally
            {
                _buildingItemSubtotals = false;
            }
            // end TT#2344 - JEllis - AnF VSW Subtotal Store Item Broken
            //end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 30
		}
		/// <summary>
		/// Adds a pack from an allocation profile to this subtotal.
		/// </summary>
		/// <param name="aAllocationProfilePack">The AllocationProfile Pack to add</param>
		public void AddPackToSubtotal(AllocationProfile aAllocationProfile, PackHdr aAllocationProfilePack)
		{
			PackHdr subtotalPack;
			PackHdr ph = aAllocationProfilePack;
			if (ph.SubtotalPackName == null)
			{
				ph.SubtotalPackName = Transaction.GetSubtotalPackID(ph);
			}
			string subtotalPackKey = ph.SubtotalPackName;
			if (_subtotalPacks == null)
			{
				_subtotalPacks = new Hashtable();
			}
			if (!PackIsOnSubtotal(subtotalPackKey))
			{
				subtotalPack = new PackHdr(subtotalPackKey);
				subtotalPack.SetPackName(ph.PackName);
				ph.CopyPackContentTo(subtotalPack);
				subtotalPack.SubtotalPackName = subtotalPackKey;
				subtotalPack.SetStoreDimension(this.StoreDimension, true);
				_subtotalPacks.Add(subtotalPackKey, subtotalPack);
				if (subtotalPack.GenericPack)
				{
					_genericPacks.Add(subtotalPack, subtotalPack);
				}
				else
				{
					_nonGenericPacks.Add(subtotalPack, subtotalPack);
				}
			}
			else
			{
				subtotalPack = (PackHdr)_subtotalPacks[subtotalPackKey];
				subtotalPack.SetPacksToAllocate(
					subtotalPack.PacksToAllocate
					+ ph.PacksToAllocate);
			}
			Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
			foreach (Index_RID StoreIndexRID in index_RID_Array)
			{
				SetStoreQtyAllocated(
                    GetSubtotalPackHdr(ph.SubtotalPackName),
					StoreIndexRID,
					(GetStoreQtyAllocated(ph.SubtotalPackName, StoreIndexRID)
					+ aAllocationProfile.GetStoreQtyAllocated(ph, StoreIndexRID)),
					eDistributeChange.ToNone,
                    false);   // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                    //false,  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28f
                    //true);  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
			}
		}
        /// <summary>
        /// Adds the Pack "item" values to the subtotal
        /// </summary>
        /// <param name="aAllocationProfile">AllocationProfile</param>
        /// <param name="ph">Pack from the AllocationProfile</param>
        public void AddPackToSubtotalItem(AllocationProfile aAllocationProfile, PackHdr ph)
        {
   			Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
            foreach (Index_RID StoreIndexRID in index_RID_Array)
            {
                SetStoreItemQtyAllocated(
                GetSubtotalPackHdr(ph.SubtotalPackName),
                StoreIndexRID,
                this.GetStoreItemQtyAllocated(ph.SubtotalPackName, StoreIndexRID)
                + aAllocationProfile.GetStoreItemQtyAllocated(ph, StoreIndexRID),
                eDistributeChange.ToNone,
                false); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                //false, // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                //true); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
            }
        }
		/// <summary>
		/// Adds bulk color from allocation profile to this subtotal
		/// </summary>
		/// <param name="aAllocationProfile">AllocaitonProfile to which the color belongs</param>
		/// <param name="aAllocationProfileBulkColor">AllocationProfile bulk color to add</param>
		public void AddBulkColorToSubtotal(AllocationProfile aAllocationProfile, HdrColorBin aAllocationProfileBulkColor)
		{
			HdrColorBin subtotalColor;
			HdrColorBin hcb = aAllocationProfileBulkColor;
//			bool newSubtotalColor = false;
			if (!BulkColorIsOnSubtotal(hcb.ColorCodeRID))
			{
//				newSubtotalColor = true;
				subtotalColor = new HdrColorBin();
				subtotalColor.SetColorCodeRID(hcb.ColorCodeRID);
				subtotalColor.SetStoreDimension(this.StoreDimension, true);
				BulkColors.Add(hcb.ColorCodeRID, subtotalColor);
			}
			else
			{
				subtotalColor = GetSubtotalHdrColorBin(hcb.ColorCodeRID);
			}
			this.SetColorUnitsToAllocate(
				subtotalColor,
				subtotalColor.ColorUnitsToAllocate
				+ hcb.ColorUnitsToAllocate);
			if (aAllocationProfile.WorkUpBulkSizeBuy)
			{
				if (aAllocationProfile.SizeGroupRID == Include.NoRID)
				{
					throw new MIDException(eErrorLevel.severe,
						(int)eMIDTextCode.msg_al_SizeGroupRequiredForWorkUpSizeBuy,
						string.Format(MIDText.GetText(eMIDTextCode.msg_al_SizeGroupRequiredForWorkUpSizeBuy), aAllocationProfile.HeaderID));
				}
				SizeGroupProfile sgp = new SizeGroupProfile(aAllocationProfile.SizeGroupRID);
				foreach (SizeCodeProfile scp in sgp.SizeCodeList)
				{
					if (!hcb.ColorSizes.Contains(scp.Key))
					{
						aAllocationProfile.AddBulkSizeToColor(hcb, scp.Key,0,0);
					}
				}
			}
			foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
			{
				this.AddSizeToSubtotalColor (aAllocationProfile, subtotalColor, hsb);
			}


			Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
			foreach (Index_RID StoreIndexRID in index_RID_Array)
			{

                SetStoreQtyAllocated(
                    subtotalColor,
                    StoreIndexRID,
                    (GetStoreQtyAllocated(subtotalColor, StoreIndexRID)
                    + aAllocationProfile.GetStoreQtyAllocated(hcb, StoreIndexRID)),
                    eDistributeChange.ToNone,
                    false);  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                    //false, // TT#1401 - JEllis - Urban Virtual Store warehouse pt 28F
                    //true); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
			}
			_capacityNodes = null;                
		}
		/// <summary>
		/// Adds a bulk size from an AllocationProfile to this subtotal
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile to which bulk size belongs</param>
		/// <param name="aSubtotalColor">Subtotal Color to which the bulk size is to be added</param>
		/// <param name="aAllocationProfileSize">HdrSizeBin</param>
		public void AddSizeToSubtotalColor(AllocationProfile aAllocationProfile, HdrColorBin aSubtotalColor, HdrSizeBin aAllocationProfileSize)
		{			
			HdrSizeBin subtotalSize;
			HdrSizeBin hsb = aAllocationProfileSize;
			HdrColorBin hcb = aAllocationProfileSize.Color;
            if (!aSubtotalColor.SizeIsInColor(hsb.SizeCodeRID)) // Assortment: color/size changes
			{
//				newSubtotalSize = true;
				subtotalSize = new HdrSizeBin(hcb);
                subtotalSize.SetSizeCodeRID(hsb.SizeCodeRID); // Assortment: color/size changes
				subtotalSize.SetStoreDimension(this.StoreDimension, true);
          		// Begin TT#1454-MD - stodd - Asst-Contents tab Add a Place holder color to an Assortment ID on contents tab and the quantity goes to zero for the line. 
                if (!aSubtotalColor.SizeIsInColor(subtotalSize.SizeCodeRID))
                {
                    aSubtotalColor.ColorSizes.Add(subtotalSize.SizeCodeRID, subtotalSize); // Assortment: color/size changes
                }
				// End TT#1454-MD - stodd - Asst-Contents tab Add a Place holder color to an Assortment ID on contents tab and the quantity goes to zero for the line. 
                if (!_sizeList.Contains(hsb.SizeCodeRID)) // Assortment: color/size changes
				{
                    _sizeList.Add(this.Transaction.GetSizeCodeProfile(hsb.SizeCodeRID)); // Assortment: color/size changes
				}
			}
			else
			{
                subtotalSize = GetSubtotalHdrSizeBin(aSubtotalColor, hsb.SizeCodeRID); // Assortment: color/size changes
			}
			aSubtotalColor.SetSizeUnitsToAllocate(
				subtotalSize,
                (aSubtotalColor.GetSizeUnitsToAllocate(hsb.SizeCodeRID) // Assortment: color/size changes
                + hcb.GetSizeUnitsToAllocate(hsb.SizeCodeRID))); // Assortment: color/size changes


			Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
			foreach (Index_RID StoreIndexRID in index_RID_Array)
			{
	
				SetStoreQtyAllocated(
					subtotalSize,
					StoreIndexRID,
					(GetStoreQtyAllocated(subtotalSize, StoreIndexRID)
					+ aAllocationProfile.GetStoreQtyAllocated(hsb, StoreIndexRID)),
					eDistributeChange.ToNone,
                    false);  // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
                //false, // TT#1401 - JEllis - Urban Virtual Store warehouse pt 28F
                //true); // TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28F
			}
		}
		#endregion AddAllocationProfile

		// BEGIN MID Change j.ellis Delay Grades Till Needed
		#region BuildMinMax
		private void BuildMinMax()
		{
			foreach (AllocationProfile ap in this.SubtotalMembers)
			{
				BuildMinMax (ap);
			}
		}
		private void BuildMinMax(AllocationProfile aAllocationProfile)
		{
			int maxExpandRoom;
			int apStoreMaximum;

			Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
			foreach (Index_RID StoreIndexRID in index_RID_Array)
			{
				if (_buildMinMax)
				{
					_buildMinMax = false;  // MID Track #2798Cannot modify store total allocation when multiple headers selected
					//=============Total=======================//
					this.SetStoreMinimum(
						eAllocationSummaryNode.Total,
						StoreIndexRID,
						aAllocationProfile.GetStoreMinimum(
                        eAllocationSummaryNode.Total, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken

					//=============GenericType=======================//
					this.SetStoreMinimum(
						eAllocationSummaryNode.GenericType,
						StoreIndexRID,
						aAllocationProfile.GetStoreMinimum(
                        eAllocationSummaryNode.GenericType, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken

					//=============DetailType=======================//
					this.SetStoreMinimum(
						eAllocationSummaryNode.DetailType,
						StoreIndexRID,
						aAllocationProfile.GetStoreMinimum(
                        eAllocationSummaryNode.DetailType, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken

					//=============Bulk=======================//
					this.SetStoreMinimum(
						eAllocationSummaryNode.Bulk,
						StoreIndexRID,
						aAllocationProfile.GetStoreMinimum(
                        eAllocationSummaryNode.Bulk, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
				}
				else
				{
					//==================Total=======================//
					if (aAllocationProfile.GetStoreMinimum(
						eAllocationSummaryNode.Total, StoreIndexRID, false)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
						< this.GetStoreMinimum(
                        eAllocationSummaryNode.Total, StoreIndexRID, false))  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					{
						this.SetStoreMinimum(
							eAllocationSummaryNode.Total,
							StoreIndexRID,
							aAllocationProfile.GetStoreMinimum(
                            eAllocationSummaryNode.Total, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					}

					//==================GenericType=======================//
					if (aAllocationProfile.GetStoreMinimum(
						eAllocationSummaryNode.GenericType, StoreIndexRID, false)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
						< this.GetStoreMinimum(
						eAllocationSummaryNode.GenericType, StoreIndexRID, false))  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					{
						this.SetStoreMinimum(
							eAllocationSummaryNode.GenericType,
							StoreIndexRID,
							aAllocationProfile.GetStoreMinimum(
							eAllocationSummaryNode.GenericType, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					}

					//==================DetailType=======================//
					if (aAllocationProfile.GetStoreMinimum(
                        eAllocationSummaryNode.DetailType, StoreIndexRID, false)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
						< this.GetStoreMinimum(
                        eAllocationSummaryNode.DetailType, StoreIndexRID, false))  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					{
						this.SetStoreMinimum(
							eAllocationSummaryNode.DetailType,
							StoreIndexRID,
							aAllocationProfile.GetStoreMinimum(
                            eAllocationSummaryNode.DetailType, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					}

					//==================Bulk=======================//
					if (aAllocationProfile.GetStoreMinimum(
                        eAllocationSummaryNode.Bulk, StoreIndexRID, false)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
						< this.GetStoreMinimum(
                        eAllocationSummaryNode.Bulk, StoreIndexRID, false))  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					{
						this.SetStoreMinimum(
							eAllocationSummaryNode.Bulk,
							StoreIndexRID,
							aAllocationProfile.GetStoreMinimum(
                            eAllocationSummaryNode.Bulk, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					}
				}
				//==================Total=======================//
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum 
					- this.GetStoreMaximum(eAllocationSummaryNode.Total, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
				if (maxExpandRoom > 0)
				{
                    apStoreMaximum = aAllocationProfile.GetStoreMaximum(eAllocationSummaryNode.Total, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						this.SetStoreMaximum(
							eAllocationSummaryNode.Total,
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						this.SetStoreMaximum(
							eAllocationSummaryNode.Total,
							StoreIndexRID, 
							(this.GetStoreMaximum(eAllocationSummaryNode.Total,StoreIndexRID, false)  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
							+ aAllocationProfile.GetStoreMaximum(eAllocationSummaryNode.Total,StoreIndexRID, false)));  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					}
				}
				maxExpandRoom =
					this._subtotalTotal[0].LargestMaximum
					- this.GetStorePrimaryMaximum(eAllocationSummaryNode.Total,StoreIndexRID);
				if (maxExpandRoom > 0)
				{
					apStoreMaximum = aAllocationProfile.GetStorePrimaryMaximum(eAllocationSummaryNode.Total, StoreIndexRID);
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						this.SetStorePrimaryMaximum(
							eAllocationSummaryNode.Total,
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						this.SetStorePrimaryMaximum(
							eAllocationSummaryNode.Total,
							StoreIndexRID,
							(this.GetStorePrimaryMaximum(eAllocationSummaryNode.Total,StoreIndexRID)
							+ aAllocationProfile.GetStorePrimaryMaximum(eAllocationSummaryNode.Total,StoreIndexRID)));
					}
				}

				//==================GenericType=======================//
				maxExpandRoom =
					this._subtotalTotal[0].LargestMaximum
                    - this.GetStoreMaximum(eAllocationSummaryNode.GenericType, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
				if (maxExpandRoom > 0)
				{
                    apStoreMaximum = aAllocationProfile.GetStoreMaximum(eAllocationSummaryNode.GenericType, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						this.SetStoreMaximum(
							eAllocationSummaryNode.GenericType,
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						this.SetStoreMaximum(
							eAllocationSummaryNode.GenericType,
							StoreIndexRID, 
							(this.GetStoreMaximum(eAllocationSummaryNode.GenericType,StoreIndexRID, false)  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
							+ aAllocationProfile.GetStoreMaximum(eAllocationSummaryNode.GenericType,StoreIndexRID, false)));  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					}
				}
				maxExpandRoom =
					this._subtotalTotal[0].LargestMaximum
					- this.GetStorePrimaryMaximum(eAllocationSummaryNode.GenericType,StoreIndexRID);
				if (maxExpandRoom > 0)
				{
					apStoreMaximum = aAllocationProfile.GetStorePrimaryMaximum(eAllocationSummaryNode.GenericType, StoreIndexRID);
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						this.SetStorePrimaryMaximum(
							eAllocationSummaryNode.GenericType,
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						this.SetStorePrimaryMaximum(
							eAllocationSummaryNode.GenericType,
							StoreIndexRID,
							(this.GetStorePrimaryMaximum(
							eAllocationSummaryNode.GenericType,
							StoreIndexRID)
							+ aAllocationProfile.GetStorePrimaryMaximum(
							eAllocationSummaryNode.GenericType,
							StoreIndexRID)));
					}
				}
				//==================DetailType=======================//
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum
                    - this.GetStoreMaximum(eAllocationSummaryNode.DetailType, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken 
				if (maxExpandRoom > 0)
				{
                    apStoreMaximum = aAllocationProfile.GetStoreMaximum(eAllocationSummaryNode.DetailType, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						this.SetStoreMaximum(
							eAllocationSummaryNode.DetailType,
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						this.SetStoreMaximum(
							eAllocationSummaryNode.DetailType,
							StoreIndexRID, 
							(this.GetStoreMaximum(eAllocationSummaryNode.DetailType,StoreIndexRID, false)  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
							+ aAllocationProfile.GetStoreMaximum(eAllocationSummaryNode.DetailType,StoreIndexRID, false)));  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					}
				}
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum 
					- this.GetStorePrimaryMaximum(eAllocationSummaryNode.DetailType, StoreIndexRID); 
				if (maxExpandRoom > 0)
				{
					apStoreMaximum = aAllocationProfile.GetStorePrimaryMaximum(eAllocationSummaryNode.DetailType, StoreIndexRID);
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						this.SetStorePrimaryMaximum(
							eAllocationSummaryNode.DetailType,
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						this.SetStorePrimaryMaximum(
							eAllocationSummaryNode.DetailType,
							StoreIndexRID,
							(this.GetStorePrimaryMaximum(eAllocationSummaryNode.DetailType,	StoreIndexRID)
							+ aAllocationProfile.GetStorePrimaryMaximum(eAllocationSummaryNode.DetailType,StoreIndexRID)));
					}
				}

				//==================Bulk=======================//
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum
                    - this.GetStoreMaximum(eAllocationSummaryNode.Bulk, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken 
				if (maxExpandRoom > 0)
				{
                    apStoreMaximum = aAllocationProfile.GetStoreMaximum(eAllocationSummaryNode.Bulk, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						this.SetStoreMaximum(
							eAllocationSummaryNode.Bulk,
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						this.SetStoreMaximum(
							eAllocationSummaryNode.Bulk,
							StoreIndexRID, 
							(this.GetStoreMaximum(eAllocationSummaryNode.Bulk,StoreIndexRID, false)  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
							+ aAllocationProfile.GetStoreMaximum(eAllocationSummaryNode.Bulk,StoreIndexRID, false)));  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					}
				}
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum 
					- this.GetStorePrimaryMaximum(eAllocationSummaryNode.Bulk, StoreIndexRID); 
				if (maxExpandRoom > 0)
				{
					apStoreMaximum = aAllocationProfile.GetStorePrimaryMaximum(eAllocationSummaryNode.Bulk, StoreIndexRID);
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						this.SetStorePrimaryMaximum(
							eAllocationSummaryNode.Bulk,
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						this.SetStorePrimaryMaximum(
							eAllocationSummaryNode.Bulk,
							StoreIndexRID,
							(this.GetStorePrimaryMaximum(eAllocationSummaryNode.Bulk,StoreIndexRID)
							+ aAllocationProfile.GetStorePrimaryMaximum(eAllocationSummaryNode.Bulk,StoreIndexRID)));
					}
				}
			}
			foreach (PackHdr ph in aAllocationProfile.Packs.Values)
			{
				BuildPackMinMax(aAllocationProfile, ph);
			}
			foreach (HdrColorBin hcb in aAllocationProfile.BulkColors.Values)
			{
				BuildBulkColorMinMax(aAllocationProfile, hcb);
			}
//			_buildMinMax = false;  // MID Track #2798 Cannot modify store total allocation when multiple headers selected
		}
		/// <summary>
		/// Builds pack min/max criteria for this subtotal.
		/// </summary>
		/// <param name="aAllocationProfilePack">The AllocationProfile Pack to add</param>
		public void BuildPackMinMax(AllocationProfile aAllocationProfile, PackHdr aAllocationProfilePack)
		{
			PackHdr subtotalPack;
			PackHdr ph = aAllocationProfilePack;
			string subtotalPackKey = ph.SubtotalPackName;
			if (!PackIsOnSubtotal(subtotalPackKey))
			{
				throw new MIDException(eErrorLevel.fatal,
					(int)(eMIDTextCode.msg_al_PackNotDefinedOnSubtotal),
					MIDText.GetText(eMIDTextCode.msg_al_PackNotDefinedOnSubtotal));
			}
			subtotalPack = (PackHdr)_subtotalPacks[subtotalPackKey];

			int maxExpandRoom;
			int apStoreMaximum;

			Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
			foreach (Index_RID StoreIndexRID in index_RID_Array)
			{
				if (_buildMinMax)
				{
					SetStoreMinimum(subtotalPack, StoreIndexRID,
                        aAllocationProfile.GetStoreMinimum(ph, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
				}
				else
				{
                    if (aAllocationProfile.GetStoreMinimum(ph, StoreIndexRID, false)   // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
                        < GetStoreMinimum(subtotalPack, StoreIndexRID, false))  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					{
						SetStoreMinimum(
							subtotalPack, 
							StoreIndexRID,
                            aAllocationProfile.GetStoreMinimum(ph, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					}
				}
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum
                    - this.GetStoreMaximum(subtotalPack, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
				if (maxExpandRoom > 0)
				{
                    apStoreMaximum = aAllocationProfile.GetStoreMaximum(ph, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						SetStoreMaximum(
							subtotalPack,
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						SetStoreMaximum(
							subtotalPack,
							StoreIndexRID, 
							(GetStoreMaximum(subtotalPack, StoreIndexRID, false)  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
							+ aAllocationProfile.GetStoreMaximum(ph, StoreIndexRID, false)));  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					}
				}
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum 
					- this.GetStorePrimaryMaximum(subtotalPack, StoreIndexRID); 
				if (maxExpandRoom > 0)
				{
					apStoreMaximum = aAllocationProfile.GetStorePrimaryMaximum(ph, StoreIndexRID);
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						SetStorePrimaryMaximum(
							subtotalPack,
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						SetStorePrimaryMaximum(
							subtotalPack,
							StoreIndexRID,
							(GetStorePrimaryMaximum(subtotalPack, StoreIndexRID)
							+ aAllocationProfile.GetStorePrimaryMaximum(ph, StoreIndexRID)));
					}
				}
			}
		}
		/// <summary>
		/// Builds bulk color min/max criteria for this subtotal.
		/// </summary>
		/// <param name="aAllocationProfile">AllocaitonProfile to which the color belongs</param>
		/// <param name="aAllocationProfileBulkColor">AllocationProfile bulk color to add</param>
		public void BuildBulkColorMinMax(AllocationProfile aAllocationProfile, HdrColorBin aAllocationProfileBulkColor)
		{
			HdrColorBin subtotalColor;
			HdrColorBin hcb = aAllocationProfileBulkColor;
            // begin TT#1166 - MD - Jellis - Color not in bulk OR no stores in size analysis
            //  NOTE: the error thrown here is thrown by GetSubtotalHdrColorBin if not found
            //if (!BulkColorIsOnSubtotal(hcb.ColorCodeRID))
            //{
            //    throw new MIDException(eErrorLevel.fatal,
            //        (int)(eMIDTextCode.msg_ColorNotDefinedInBulk),
            //        MIDText.GetText(eMIDTextCode.msg_ColorNotDefinedInBulk));
            //}
            // end TT#1166 - MD - Jellis - Color not in bulk or no stores in size analysis
			subtotalColor = GetSubtotalHdrColorBin(hcb.ColorCodeRID);

			foreach (HdrSizeBin hsb in hcb.ColorSizes.Values)
			{
				this.BuildSizeMinMax (aAllocationProfile, subtotalColor, hsb);
			}
			int maxExpandRoom;
			int apStoreMaximum;
			Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
			foreach (Index_RID StoreIndexRID in index_RID_Array)
			{
				if (_buildMinMax)
				{
					SetStoreMinimum(
						subtotalColor,
						StoreIndexRID,
                        aAllocationProfile.GetStoreMinimum(hcb, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
				}
				else
				{
                    if (aAllocationProfile.GetStoreMinimum(hcb, StoreIndexRID, false)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
                        < GetStoreMinimum(subtotalColor, StoreIndexRID, false))  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					{
						SetStoreMinimum(subtotalColor, StoreIndexRID,
                            GetStoreMinimum(hcb, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					}
				}
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum
                    - this.GetStoreMaximum(subtotalColor, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken 
				if (maxExpandRoom > 0)
				{
                    apStoreMaximum = aAllocationProfile.GetStoreMaximum(hcb, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						SetStoreMaximum(
							subtotalColor, 
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						SetStoreMaximum(
							subtotalColor,
							StoreIndexRID, 
							(GetStoreMaximum(subtotalColor, StoreIndexRID, false)  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
							+ aAllocationProfile.GetStoreMaximum(hcb, StoreIndexRID, false)));  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					}
				}
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum 
					- this.GetStorePrimaryMaximum(subtotalColor, StoreIndexRID); 
				if (maxExpandRoom > 0)
				{
					apStoreMaximum = aAllocationProfile.GetStorePrimaryMaximum(hcb, StoreIndexRID);
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						SetStorePrimaryMaximum(
							subtotalColor, 
							StoreIndexRID,
							this._subtotalTotal[0].LargestMaximum);
					}
					else
					{
						SetStorePrimaryMaximum(
							subtotalColor,
							StoreIndexRID,
							(GetStorePrimaryMaximum(subtotalColor, StoreIndexRID)
							+ aAllocationProfile.GetStorePrimaryMaximum(hcb, StoreIndexRID)));
					}
				}
			}
		}
		/// <summary>
		/// Builds bulk size Min/Max criteria for this subtotal
		/// </summary>
		/// <param name="aAllocationProfile">AllocationProfile to which bulk size belongs</param>
		/// <param name="aSubtotalColor">Subtotal Color to which the bulk size is to be added</param>
		/// <param name="aAllocationProfileSize">HdrSizeBin</param>
		public void BuildSizeMinMax(AllocationProfile aAllocationProfile, HdrColorBin aSubtotalColor, HdrSizeBin aAllocationProfileSize)
		{			
			HdrSizeBin subtotalSize;
			HdrSizeBin hsb = aAllocationProfileSize;
			HdrColorBin hcb = aAllocationProfileSize.Color;
            if (!aSubtotalColor.SizeIsInColor(hsb.SizeCodeRID)) // Assortment: color/size changes
			{
				throw new MIDException(eErrorLevel.fatal,
					(int)(eMIDTextCode.msg_SizeNotDefinedInBulkColor),
					MIDText.GetText(eMIDTextCode.msg_SizeNotDefinedInBulkColor));
			}
            subtotalSize = GetSubtotalHdrSizeBin(aSubtotalColor, hsb.SizeCodeRID); // Assortment: color/size changes
			int apStoreMaximum;
			int maxExpandRoom;
			Index_RID[] index_RID_Array = this.Transaction.StoreIndexRIDArray();
			foreach (Index_RID StoreIndexRID in index_RID_Array)
			{
				if (_buildMinMax)
				{
					SetStoreMinimum(
						subtotalSize,
						StoreIndexRID,
                        aAllocationProfile.GetStoreMinimum(hsb, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
				}
				else
				{
                    if (aAllocationProfile.GetStoreMinimum(hsb, StoreIndexRID, false)  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
                        < GetStoreMinimum(subtotalSize, StoreIndexRID, false))  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					{
						SetStoreMinimum(subtotalSize, StoreIndexRID,
                            GetStoreMinimum(hsb, StoreIndexRID, false));  // TT#1074 - MD - Jellis - Group Allocation - Inventory Min Max broken
					}
				}
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum
                    - this.GetStoreMaximum(subtotalSize, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken 
				if (maxExpandRoom > 0)
				{
                    apStoreMaximum = aAllocationProfile.GetStoreMaximum(hsb, StoreIndexRID, false);  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						SetStoreMaximum (subtotalSize, StoreIndexRID, subtotalSize.SizeLargestMaximum);
					}
					else
					{
						SetStoreMaximum(
							subtotalSize,
							StoreIndexRID, 
							(GetStoreMaximum(subtotalSize, StoreIndexRID, false)  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
							+ aAllocationProfile.GetStoreMaximum(hsb, StoreIndexRID, false)));  // TT#1074 - MD - jellis - Group ALlocation Inventory Min Max Broken
					}
				}
				maxExpandRoom = 
					this._subtotalTotal[0].LargestMaximum 
					- this.GetStorePrimaryMaximum(subtotalSize, StoreIndexRID); 
				if (maxExpandRoom > 0)
				{
					apStoreMaximum = aAllocationProfile.GetStorePrimaryMaximum(hsb, StoreIndexRID);
					if (apStoreMaximum == this._subtotalTotal[0].LargestMaximum ||
						apStoreMaximum >= maxExpandRoom)
					{
						SetStorePrimaryMaximum(
							aSubtotalColor,
							subtotalSize, 
							StoreIndexRID, 
							subtotalSize.SizeLargestMaximum);
					}
					else
					{
						SetStorePrimaryMaximum(
							aSubtotalColor,
							subtotalSize,
							StoreIndexRID,
							(GetStorePrimaryMaximum(subtotalSize, StoreIndexRID)
							+ aAllocationProfile.GetStorePrimaryMaximum(hsb, StoreIndexRID)));
					}
				}								
			}
		}
		#endregion BuildMinMax
		// END MID Change j.ellis Delay Grades Till Needed
		#region RemoveAllocationProfile
		/// <summary>
		/// Removes an allocation profile from the subtotal
		/// </summary>
		/// <param name="aAllocationProfile">The allocation profile to remove</param>
		public void RemoveAllocationFromSubtotal (AllocationProfile aAllocationProfile)
		{
			RemoveAllocationFromSubtotalAction(aAllocationProfile);
//			this.RebuildSubtotal();
            //this._buildSubtotal = true; // MID Change j.ellis delay subtotal build till info requested // TT#1154 - MD - Jellis - Group ALlocation Style Review No Stores
		}
		private void RemoveAllocationFromSubtotalAction (AllocationProfile aAllocationProfile)
		{
			if (this.SubtotalMembers.Contains(aAllocationProfile.Key))
			{
				this.SubtotalMembers.Remove(aAllocationProfile);
				aAllocationProfile.RemoveSubtotal(this);
			}
            _construct = true; // TT#1185 - MD - Jellis - Group Allocation - Style Review not showing all eligible stores 
            _capacityNodes = null;
            this._buildSubtotal = true; // MID Change j.ellis delay subtotal build till info requested // TT#1154 - MD - Jellis - Group ALlocation Style Review No Stores
            _buildItemSubtotals = true; // TT#967 - MD - Jellis - Group Allocation - VSW in total section zero when viewing multiple headers in Style View // TT#1154 - MD - Jellis - Group ALlocation Style Review No Stores
            Transaction.ResetAnalysisSettings();  // TT#1154 - MD - Jellis - Group Allocation Style Review No Stores
            _lastSubtotalColorBin = null;  // TT#1166 - Color not in bulk OR no stores in Size Analysis
            _lastSubtotalSizeBin = null;   // TT#1166 - Color not in bulk OR no stores in Size Analysis

        }
		public void RemoveAllSubtotalMembers()
		{
			AllocationProfile[] al = new AllocationProfile[this.SubtotalMembers.Count]; 
			this.SubtotalMembers.ArrayList.CopyTo(al);
			foreach (AllocationProfile ap in al)
			{
				this.RemoveAllocationFromSubtotalAction(ap);
			}
			//			this.RebuildSubtotal();
            //this._buildSubtotal = true; // MID Change j.ellis delay subtotal build till info requested // TT#1154 - MD - Jellis - Group ALlocation Style Review No Stores
            //_buildItemSubtotals = true; // TT#967 - MD - Jellis - Group Allocation - VSW in total section zero when viewing multiple headers in Style View // TT#1154 - MD - Jellis - Group ALlocation Style Review No Stores
		}
		#endregion RemoveAllocationProfile
		#endregion Methods

        //Begin tt#321 - JSmith - Velocity Interactive-> severe error when layering
        ////Begin tt#316 - Rebuild of subtotals needed to display the Allocation % of Totals on the Velocity Matrix - apicchetti
        //public void RebuildSubtotalsNeeded()
        //{
        //    RebuildSubtotal();
        //}
        ////End tt#316 - Rebuild of subtotals needed to display the Allocation % of Totals on the Velocity Matrix - apicchetti
        //End tt#321
	}

    
	#endregion AllocationSubtotalProfile
}
