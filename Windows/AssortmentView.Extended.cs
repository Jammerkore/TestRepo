using System;
using System.Drawing;
using System.Drawing.Printing;
using System.Globalization;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Windows.Forms;
using C1.Win.C1FlexGrid;
using System.Data;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Configuration;
using System.Threading;
using System.Text;
using Infragistics.Win;
using Infragistics.Win.UltraWinGrid;
using Infragistics.Win.UltraWinMaskedEdit;
using Infragistics.Win.UltraWinToolbars;

using MIDRetail.Business;
using MIDRetail.Business.Allocation;
using MIDRetail.Common;
using MIDRetail.DataCommon;
using MIDRetail.Data;
using MIDRetail.Windows.Controls;

namespace MIDRetail.Windows
{
    partial class AssortmentView
    {
        #region Variable Declarations
      
        private KeyEventArgs _gridKeyEvent = null;

        //private DataSet _dsCopySizes;
        private DataSet _dsAsrtSizes;
        private DataSet _dsDetails;
        private DataSet _dsDetailsSaved;
        private DataSet _dsProductCharacteristics;
        private DataTable _anchorNodes;
        private DataTable _assortments;
        private DataTable _assortmentsSaved;
        private DataTable _dtHeader;
        private DataTable _dtBulkColor;
        private DataTable _dtPack;
        private DataTable _dtPackColor;
        private DataTable _dtStyleNodeChars;
        private DataTable _dtColorNodeChars;
        private DataTable _dtGradeQtyRemainder;      // TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0 
        private DataTable _placeHolders;
        private DataTable _placeHoldersSaved;

        private AllocationProfileList _allocProfileList;
        private ColorBrowser _frmColorBrowser;
        private GetMethods _getMethods;
        private HeaderCharGroupProfileList _headerCharGroupProfileList;
        private HierarchyLevelProfile _hlpStyle;
        private HierarchyLevelProfile _hlpProduct;
        private HierarchyMaintenance _hierMaint;
        private HierarchyNodeProfile _nodeDataHashLastValue;
        private HierarchyProfile _mainHp;
        private PlaceholderComponentLinks _phCompLinks;
        private ProductCharProfileList _productCharProfileList;
        private SizeGroupProfile _sizeGroupHashLastValue;

        private FunctionSecurityProfile _allocationNonInterfacedHeadersSecurity;
        private FunctionSecurityProfile _allocationInterfacedHeadersSecurity;
        private FunctionSecurityProfile _assortmentSecurity;
        // Begin TT#2014-MD - JSmith - Assortment Security 
        private FunctionSecurityProfile _userViewSecurity;
        private FunctionSecurityProfile _globalViewSecurity;
        // End TT#2014-MD - JSmith - Assortment Security 

        private UltraGrid _rClickGrid = null;
        private UltraGridColumn _gridCol;
        private UltraGridBand _gridBand;

        private UltraGridRow _colorSelectRow = null;
        private UltraGridRow _firstNewRow = null;
        private UltraGridRow _asrtHdrRow;
        private UltraGridRow _rClickRow = null;
        private UltraGridRow _rClickRowChar = null;

		//BEGIN TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
        private UltraGridRow _dropRow = null;
        private UltraGridCell _dropCell = null;
		//END TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color

        private UltraGridCell _invalidCell = null;
        private ValueList _assortmentValueList;
        private ValueList _headerIntransitValueList;
        private ValueList _headerShipStatusValueList;
        private ValueList _headerStatusValueList;
        private ValueList _headerTypeValueList;
        private ValueList _packTypeValueList;
        private ValueList _placeHolderValueList;
        private ValueList _sizeGroupValueList;

        private ArrayList _deletedAsrtBands = new ArrayList();
        private ArrayList _deletedHeaderRows = new ArrayList();
        private ArrayList _deletedPlaceholderPacks = new ArrayList();
        private ArrayList _placeholdersIntransit = new ArrayList();
        private ArrayList _removedAsrtHeaders = new ArrayList();
        private ArrayList _selectedComponentList = new ArrayList();

		// BEGIN TT#371-MD - stodd -  Velocity Interactive on Assortment
        //private ArrayList _selectedHeaderKeyList = new ArrayList();
		private SelectedHeaderList _selectedHeaderList = new SelectedHeaderList(eProfileType.SelectedHeader);
		// END TT#371-MD - stodd -  Velocity Interactive on Assortment

        private Hashtable _addedColorSizeHash = new Hashtable();
        private Hashtable _assortmentGroups = new Hashtable();
        private Hashtable _charValueListsHash;
        private Hashtable _colorsForStyle = new Hashtable();
        private Hashtable _colorNodesForStyle = new Hashtable();
        private Hashtable _deletedAssortmentStyles = new Hashtable();
        private Hashtable _deletedPhComponents = new Hashtable();
        private Hashtable _deletedPlaceholderStyles = new Hashtable();
        private Hashtable _addedHeaders = new Hashtable();
        //private Hashtable _methodHash = new Hashtable(); //TT#1313-MD -jsobek -Header Filters -performance
        private Hashtable _nodeAncestorList = new Hashtable();
        private Hashtable _nodeCharacteristics = new Hashtable();
        private Hashtable _nodeDataHash = new Hashtable();
        private Hashtable _placeHolderColor = new Hashtable();
        private Hashtable _placeHolderColorIds = new Hashtable();
        private Hashtable _placeHolderAndHeaders = new Hashtable();
        private Hashtable _productCharValueLists = new Hashtable();
        private Hashtable _sizeGroupHash = new Hashtable();
        private Hashtable _workflowNameHash = new Hashtable();

        private bool _addingSizes = false;
        private bool _addingHeaderToAssortment;
        private bool _addingMTColorRow = false;
        private bool _addingPlaceholder = false;
        private bool _applyInheritance = false;
        private bool _asrtHdrRowFound = true;
        private bool _buildDetailsGrid = true;
        private bool _buildProductCharsGrid = true;
        private bool _canAddHeader = false;
        private bool _canDeleteHeader = false;
        private bool _characteristicsChanged = false;
        private bool _deleteKeyPressed = false;
        private bool _expandAllContent = true;
        private bool _expandAllProductChar = true;
		private bool _expandAllAssortment = true;	// TT#1538 - expand/collapse button on matrix grid
        private bool _fromCellButton = false;
        private bool _fromRightClick = false;
        private bool _fromSaveAs = false;
        private bool _headerAdded = false;
        private bool _headerPacksAdded = false;     // TT#2 - RMatelic - Assortment Planning-allocating header packs not totaling correctly
        private bool _inEditMode = false;
        private bool _rebuildSizes = false;
        private bool _removingHeaderFromAssortment;
        private bool _replacingSizes = false;
        private bool _rowDeleted = false;
        private bool _sizesAutoAdded = false;
        private bool _skipAnchorEdit = false;
        private bool _skipBeforeCellUpdate = false;
        private bool _skipEdit = false;
        private bool _skipHeaderEdit = false;
        private bool _skipProductEdit = false;
        private bool _skipRowUpdate = false;
        private bool _skipStyleEdit = false;
        private bool _bindingGrid = false;   // TT#2073-MD - JSmith - Asst Velocity when select alloate receive mssg Pack is not defined on the Subtotal

        private string _dupSizeNameSeparator;
        private string _errors;
        private string _lblCollapseAll;
        private string _lblColor;
        private string _lblColumnChooser;
        private string _lblDeleteRow;
        private string _lblDescription;
        private string _lblExpandAll;
        private string _lblHierarchyNode;
        private string _lblHeaderNotes;
        private string _lblNone;
        private string _lblPlaceholder;
        private string _lblQuantity;
        private string _lblStyleSKU;
        private string _noSizeDimensionLbl;
        private string _txtInheritedFrom;

        // Begin TT#1498-MD- RMatelic - ASST - MU% not calcing on the fly for the Detail section
        private string _lblUnitRetail;
        private string _lblUnitCost;
        // End TT#1498-MD

        private int _charStyleNodeColCount;
        private int _charColorNodeColCount;
		// Begin TT#1227 - stodd
		// First key is Assortment Rid, then last placeholder seq
		private Dictionary<int, int> _lastAsrtPlaceholderSortSeq;
		// Keys are Assortment Rid and placeholder seq, value is last header seq
		private MID2DimIntDictionary _lastAsrtHeaderSortSeq;
        //private int _lastAsrtPlaceholderSortSeq;
		//private Dictionary<int, int> _lastAsrtHeaderSortSeq;
		//private int _lastAsrtHeaderSortSeq;
		// End TT#1227 - stodd
        private int _lastMultiSortSeq;
        private int _maxBandDepth = 6;
        private int _nodeDataHashLastKey = 0;
        private int _nonCharColCount = 0;
        private int _sizeGroupHashLastKey = 0;
		// BEGIN TT#1806 - stodd - new placeholders not displaying in correct order
		private List<UltraGridRow> _addedRowList = new List<UltraGridRow>();
		// END TT#1806 - stodd - new placeholders not displaying in correct order
		// BEGIN TT#530-MD - stodd -  Columns not correct on matrix tab
		private bool _asrtTypeChanged = false;
		// END TT#530-MD - stodd -  Columns not correct on matrix tab
		private bool _rebuildWafers = false;
		//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
		List<PlaceholderNewColorInfo> _placeholderNewColorList;
        List<PlaceholderNewColorInfo> _placeholderNewPlaceholderColorList; // TT#2019-MD - JSmith  - Receive system argument exception when adding a Detail Pack Header to a Placeholder.
        List<PlaceholderNewPackInfo> _placeholderNewGenericPackList;  // TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
		private UltraGridRow _hdrColorRow = null;	// TT#854 - MD - stodd - enqueue error 
		private AssortmentProfile _assortmentProfile;	// TT#952 - MD - Add Matrix to Group Allocation - 
        private bool _skipStyleSave = false; // TT#1503-MD - RMatelic - ASST - Header not being attached to placeholder when drag/dropped from Allocation Workspace
        private bool _isColorChanging = false;	// TT#1562-MD - stodd - Type in a color over a PH color go to add the Bulk size and receive a warning "color not defined for bulk.

		
		/// <summary>
		/// This holds the new colors added to a placeholder due to a header being dropped on it.
		/// The units are the units that will be allocated to the color.
		/// </summary>
		internal struct PlaceholderNewColorInfo
		{
			public int PlaceholderColorRid;
			public int PlaceholderColorUnits;
			public int Multiple;	// TT#600-MD - stodd
            public bool AddedFromPack;  // TT#2047-MD - JSmith - Remove a header from a PH and PH Qty increases greater than the header plus the residual Ph values.
		}
		//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder

        // Begin TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
        /// <summary>
        /// This holds the new packs added to a placeholder due to a header being dropped on it.
        /// The units are the units that will be allocated to the pack.
        /// </summary>
        internal struct PlaceholderNewPackInfo
        {
            public string PlaceholderPackName;
            public int PlaceholderPackUnits;
            public int Multiple;	
        }
        // End TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.

        #endregion

        #region Enums
        public enum eBalanceAction
        {
            RowAdded,
            RowDeleted,
            ValueChanged
        }

        public enum eSecurityType
        {
            View,
            Update
        }
        #endregion

        #region Initialize & Load Content Grid 
        private void InitializeContentTabData()
        {
            try
            {
                _allocationNonInterfacedHeadersSecurity = _sab.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AllocationHeadersNonInterfaced);
                _allocationInterfacedHeadersSecurity = _sab.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AllocationHeadersInterfaced);
				
				// Begin TT#952 - MD - Add Matrix to Group Allocation - 
				if (IsGroupAllocation)
				{
					_assortmentSecurity = _sab.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.GroupAllocationReview);
				}
				else
				{
                _assortmentSecurity = _sab.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.Assortment);
				}
				// End TT#952 - MD - Add Matrix to Group Allocation - 

                _mainHp = _sab.HierarchyServerSession.GetMainHierarchyData();
                _hierMaint = new HierarchyMaintenance(_sab);
                _headerCharGroupProfileList = _sab.HeaderServerSession.GetHeaderCharGroups();
                _getMethods = new GetMethods(_sab);

                // get hierarchy profiles for style and product (parent of style)
                _hlpStyle = null;
                _hlpProduct = null;
                for (int level = 1; level <= _mainHp.HierarchyLevels.Count; level++)
                {
                    _hlpProduct = _hlpStyle;
                    _hlpStyle = (HierarchyLevelProfile)_mainHp.HierarchyLevels[level];
                    if (_hlpStyle.LevelType == eHierarchyLevelType.Style)
                    {
                        break;
                    }
                }
                if (_hlpStyle == null)
                {
                    _hlpStyle = new HierarchyLevelProfile(0);
                    _hlpStyle.LevelID = "Style";
                }
                if (_hlpProduct == null)
                {
                    _hlpProduct = new HierarchyLevelProfile(1);
                    _hlpProduct.LevelID = "Product";
                }

                SetText();

				// BEGIN TT#488-MD - Stodd - Group Allocation
                //this.btnExpandCollapse.Text = _lblCollapseAll;
                //this.btnExpandCollapse.Enabled = false;
				// END TT#488-MD - Stodd - Group Allocation

            }
            catch
            {
                throw;
            }
        }

        private void SetText()
        {
            try
            {
                _dupSizeNameSeparator = MIDText.GetTextOnly((int)eMIDTextCode.lbl_DupSizeNameSeparator);
                _lblCollapseAll = MIDText.GetTextOnly(eMIDTextCode.lbl_CollapseAll);
                _lblColor = MIDText.GetTextOnly((int)eMIDTextCode.lbl_Color);
                _lblExpandAll = MIDText.GetTextOnly(eMIDTextCode.lbl_ExpandAll);
                _lblColumnChooser = MIDText.GetTextOnly(eMIDTextCode.lbl_ColumnChooser);
                _lblDeleteRow = MIDText.GetTextOnly(eMIDTextCode.lbl_DeleteRow);
                _lblDescription = MIDText.GetTextOnly(eMIDTextCode.lbl_Description);
                _lblHeaderNotes = MIDText.GetTextOnly(eMIDTextCode.lbl_HeaderNotes);
                _lblHierarchyNode = MIDText.GetTextOnly(eMIDTextCode.lbl_HierarchyNode);
                _lblNone = MIDText.GetTextOnly(eMIDTextCode.lbl_None);
                _lblQuantity = MIDText.GetTextOnly(eMIDTextCode.lbl_Quantity);
                _lblStyleSKU = MIDText.GetTextOnly((int)eAssortmentComponentVariables.Placeholder);
                _noSizeDimensionLbl = MIDText.GetTextOnly((int)eMIDTextCode.lbl_NoSecondarySize);
                _txtInheritedFrom = MIDText.GetTextOnly(eMIDTextCode.lbl_Inherited_From);

                cmsInsert.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Insert);
                cmsInsertPhStyle.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_PhStyleName);
                cmsInsertPack.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Pack);
                cmsInsertPackColor.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_PackColor);
                cmsInsertPackSize.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_PackSize);
                cmsInsertBulkColor.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_BulkColor);
                cmsInsertBulkSize.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_BulkSize);
                cmsInsertMTColorRow.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_EmptyRow);
                cmsChooseColor.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_ColorBrowser);
                cmsRemove.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Remove);

				// BEGIN TT#732-MD - Stodd - add radio button
				midToolbarRadioButton1.Button1.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Attribute);
				midToolbarRadioButton1.Button2.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Store_Grades);
				// END TT#732-MD - Stodd - add radio button
				
				// Begin TT#952 - MD - Add Matrix to Group Allocation - 
				// FROM GA STODD
				midToolbarRadioButton2.Button1.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Group);
				midToolbarRadioButton2.Button2.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Headers);

                midToolbarRadioButton2.ForeColor = ((UltraToolbar)ultraToolbarsManager1.Toolbars[0]).ToolbarsManager.Appearance.ForeColor;
                midToolbarRadioButton2.BackColor = ((UltraToolbar)ultraToolbarsManager1.Toolbars[0]).ToolbarsManager.Appearance.BackColor;
				// Begin TT#952 - MD - Add Matrix to Group Allocation - 

                // Begin TT#1498-MD- RMatelic - ASST - MU% not calcing on the fly for the Detail section
                _lblUnitRetail = MIDText.GetTextOnly((int)eAssortmentTotalVariables.UnitRetail);
                _lblUnitCost = MIDText.GetTextOnly((int)eAssortmentTotalVariables.UnitCost);
                // End TT#1498-MD

            }
            catch
            {
                throw;
            }
        }

		//BEGIN TT#665-MD - stodd - asst with placeholder and placeholder colors when input avg units in the matrix units not spread evenly to placeholder colors.
        public bool LoadContentGrid()
		{
			bool didBuild = false;
            try
            {
                if (_buildDetailsGrid)
                {
                    // Begin TT#1545-MD - RMatelic - Asst - Run Size Proportiona and receive Action Failed.  Select OK and the process runs as expected.  MY Activity mssg Action (Size Proportional) cannot be performed for a header (Demo Script PHStyle1-8) when Workup Total Buy. 
                    SelectedHeaderList selHeaderList = null;
                    if (_selectedHeaderList != null && _selectedHeaderList.Count > 0)
                    {
                        selHeaderList = new SelectedHeaderList(eProfileType.SelectedHeader);
                        foreach (SelectedHeaderProfile shp in _selectedHeaderList)
                        {
                            selHeaderList.Add(shp);
                        }
                    }
                    // End TT#1545-MD 
                    BuildDataSets();
                    LoadHeaders();
                    LoadGridValueLists();
                    BindDetailsGrid();
                    // Begin TT#1547-MD - RMatelic - ASST - Content Tab - User selects the content tab to be collapse for PH and headers.  If they run a method or action the content tab is then uncollapsed.  PH and Headers should remain collapsed until user decides to expand it
                    //ExpandCollapseGrid(true);
                    ExpandCollapseGrid(_expandAllContent);
                    // End TT#1547-MD
                    SetEditMode();
                    // Assign a CreationFilter to the grid. 
                    // The CreationFilter will trap the ColumnChooserButtonUIElement in the grid
                    // and set the tooltip information. 
                    this.ugDetails.CreationFilter = new ToolTipItemCreationFilter();
                    MarkFirstHeaderInGroupAllocation();		// TT#1130 - md - stodd - mark first header - 
                    _buildDetailsGrid = false;
					didBuild = true;
                    // Begin TT#1545-MD - RMatelic - Asst - Run Size Proportiona and receive Action Failed.  Select OK and the process runs as expected.  MY Activity mssg Action (Size Proportional) cannot be performed for a header (Demo Script PHStyle1-8) when Workup Total Buy. 
                    if (selHeaderList != null)
                    {
                        _selectedHeaderList.Clear();
                        foreach (SelectedHeaderProfile shp in selHeaderList)
                        {
                            _selectedHeaderList.Add(shp);
                        }
                        ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                        foreach (SelectedHeaderProfile shp in _selectedHeaderList)
                        {
                            IEnumerable enumerator = ugDetails.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
                            foreach (UltraGridRow row in enumerator)
                            {
                                if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == shp.Key)
                                {
                                    row.Selected = true;
                                    break;
                                }
                            }
                        }
                        ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                        DetermineMasterProfileList(true);
                        this.ultraToolbarsManager1.Tools["btnProcessAlloc"].SharedProps.Enabled = (ugDetails.Selected.Rows.Count > 0) ? true : false;
                    }
                    // End TT#1545-MD
                }
                else if (_currentTabPage.Name == "tabContent")
                {
                    ExpandCollapseGrid(_expandAllContent);
                    didBuild = true; //TT#1227 - MD- DOConnell - Get a spread lock error when trying to remove a color from a placeholder
                }    
                //SetExpandCollapseButtonText();	// TT#488-MD - Stodd - Group Allocation
				return didBuild;
            }
            catch
            {
                throw;
            }
        }
		//END TT#665-MD - stodd - asst with placeholder and placeholder colors when input avg units in the matrix units not spread evenly to placeholder colors.
        #endregion

		// Begin TT#1130 - md - stodd - mark first header - 
        /// <summary>
        /// Gets the first header from the assortmentMember list and 
        /// marks it on the grid. This is the header the group allocation header uses 
        /// for it's default info, such as style.
        /// </summary>
        private void MarkFirstHeaderInGroupAllocation()
        {
            if (IsGroupAllocation)
            {
                int firstHeaderRid = GetFirstHeaderInGroupAllocation();
                foreach (UltraGridRow uRow in ugDetails.Rows)
                {
                    int hdrKey = int.Parse(uRow.Cells["KeyH"].Value.ToString());
                    if (hdrKey == firstHeaderRid)
                    {
                        uRow.Cells["FirstHeaderInd"].Appearance.Image = MIDGraphics.GetImage(MIDGraphics.msgOKImage);
                        uRow.Cells["FirstHeaderInd"].ToolTipText = "First/Control Header";
                        //toolTip1.SetToolTip(uRow.Cells["FirstHeaderInd"], "First Header");
                    }
                }
            }
        }
		// End TT#1130 - md - stodd - mark first header - 

        #region Build Content Grid DataSet data
        private void BuildDataSets()
        {
            _dtHeader = MIDEnvironment.CreateDataTable("Header");

            _colorsForStyle.Clear();
            _nodeDataHash.Clear();
            _nodeDataHashLastKey = 0;
            _sizeGroupHashLastKey = 0;

            try
            {	
                // Assortment
                _assortments = MIDEnvironment.CreateDataTable("Assortments");
                _assortments.Columns.Add("AsrtRID", System.Type.GetType("System.Int32"));
                _assortments.Columns.Add("AssortmentID");
                // BEGIN Track #5835 stodd assortment
                // Add Key
                DataColumn[] myPrimaryKeyColumns = new DataColumn[1];
                myPrimaryKeyColumns[0] = _assortments.Columns["AsrtRID"];
                _assortments.PrimaryKey = myPrimaryKeyColumns;
                // END Track #5835 stodd assortment

                // Placeholders
                _placeHolders = MIDEnvironment.CreateDataTable("PlaceHolders");
                _placeHolders.Columns.Add("PlaceHolderRID", System.Type.GetType("System.Int32"));
                _placeHolders.Columns.Add("PlaceHolderID");

                // AnchorNodes
                _anchorNodes = MIDEnvironment.CreateDataTable("AnchorNodes");
                _anchorNodes.Columns.Add("PhStyleRID", System.Type.GetType("System.Int32"));
                _anchorNodes.Columns.Add("PhOldAnchorRID", System.Type.GetType("System.Int32"));
                _anchorNodes.Columns.Add("PhNewAnchorRID", System.Type.GetType("System.Int32"));
                _anchorNodes.PrimaryKey = new DataColumn[] { _anchorNodes.Columns["PhStyleRID"] };

                _dtHeader.Columns.Add("FirstHeaderInd");	// TT#1130 - md - stodd - mark first header - 
                _dtHeader.Columns.Add("KeyH", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("KeyP", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("KeyC", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("HeaderID");

                _dtHeader.Columns.Add("HdrGroupRID", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("AsrtRID", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("PlaceHolderRID", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("FunctionSecurity");

                _dtHeader.Columns.Add("Type", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("Date", System.Type.GetType("System.DateTime"));
                _dtHeader.Columns.Add("Status", System.Type.GetType("System.Int32"));

                _dtHeader.Columns.Add("AnchorHnRID", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("AnchorNode");
                _dtHeader.Columns.Add("ProductRID", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("Product");
                _dtHeader.Columns.Add("StyleHnRID", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("Style");

                _dtHeader.Columns.Add("StyleSecurity", System.Type.GetType("System.Int32"));

                _dtHeader.Columns.Add("Description");
                _dtHeader.Columns.Add("HdrQuantity", System.Type.GetType("System.Int32"));

                _dtHeader.Columns.Add("Balance", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("AllocatedUnits", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("UnitRetail", System.Type.GetType("System.Double"));
                _dtHeader.Columns.Add("UnitCost", System.Type.GetType("System.Double"));
                _dtHeader.Columns.Add("SizeGroup", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("Multiple", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("PO");
                _dtHeader.Columns.Add("Vendor");
                _dtHeader.Columns.Add("Workflow");
                _dtHeader.Columns.Add("APIWorkflow");
                _dtHeader.Columns.Add("DC");

                _dtHeader.Columns.Add("Intransit", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("ShipStatus", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("Release", System.Type.GetType("System.String"));

                _dtHeader.Columns.Add("Notes");
                _dtHeader.Columns.Add("Interfaced", System.Type.GetType("System.Boolean"));
                _dtHeader.Columns.Add("ChildTotal", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("MultiSortSeq", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("Master");
                
                _dtHeader.Columns.Add("OrigAllocatedUnits", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("RsvAllocatedUnits", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("AsrtType", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("AsrtPlaceholderSortSeq", System.Type.GetType("System.Int32"));	// TT#1227 - stodd
                _dtHeader.Columns.Add("CharUpdated", System.Type.GetType("System.Boolean"));
				// Begin TT#1227 - stodd 
				_dtHeader.Columns.Add("AsrtHeaderSortSeq", System.Type.GetType("System.Int32"));
				// End TT#1227 - stodd 
               
                // Begin TT#1442 - RMatelic - Error processing General Allocation Method on Assortment>>> unrelated
                _dtHeader.Columns.Add("AsrtRIDSortCol", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("PlaceHolderRIDSortCol", System.Type.GetType("System.Int32"));
                // End TT#1442

                // save column count before characteristics are added for characteristic processing 
                _nonCharColCount = _dtHeader.Columns.Count;

                foreach (HeaderCharGroupProfile hcgp in _headerCharGroupProfileList)
                {
                    _dtHeader.Columns.Add(hcgp.ID);
                    _dtHeader.Columns[hcgp.ID].ExtendedProperties.Add("IsChar", hcgp);

                    if (hcgp.ListInd)   // uses a drop down list
                    {
                        _dtHeader.Columns[hcgp.ID].DataType = System.Type.GetType("System.Int32");
                    }
                    else
                    {
                        switch (hcgp.Type)
                        {
                            case eHeaderCharType.date:
                                _dtHeader.Columns[hcgp.ID].DataType = System.Type.GetType("System.DateTime");
                                break;

                            case eHeaderCharType.number:
                            case eHeaderCharType.dollar:
                                _dtHeader.Columns[hcgp.ID].DataType = System.Type.GetType("System.Double");
                                break;
                        }
                    }
                }

                Header headerData = new Header();
                _dtHeader.Columns["HeaderID"].MaxLength = headerData.GetColumnSize("HEADER", "HDR_ID");

                // header defaults and constraints
                _dtHeader.Columns["HeaderID"].AllowDBNull = false;
                _dtHeader.Columns["HeaderID"].Unique = true;
                _dtHeader.Columns["Product"].AllowDBNull = true;            // allow nulls because of Assortment
                _dtHeader.Columns["Description"].AllowDBNull = true;        // allow nulls because of Assortment
                _dtHeader.Columns["HdrGroupRID"].AllowDBNull = true;
                _dtHeader.Columns["AsrtRID"].AllowDBNull = true;
                _dtHeader.Columns["PlaceHolderRID"].AllowDBNull = true;
                _dtHeader.Columns["MultiSortSeq"].AllowDBNull = true;
                _dtHeader.Columns["AsrtPlaceholderSortSeq"].AllowDBNull = true;	// TT#1227 - stodd
                _dtHeader.Columns["KeyH"].DefaultValue = 0;
                _dtHeader.Columns["KeyP"].DefaultValue = 0;
                _dtHeader.Columns["KeyC"].DefaultValue = 0;
                _dtHeader.Columns["Type"].DefaultValue = (int)eHeaderType.Receipt;
                _dtHeader.Columns["Date"].DefaultValue = DateTime.Today;
                _dtHeader.Columns["Multiple"].DefaultValue = Include.DefaultUnitMultiple;
                _dtHeader.Columns["SizeGroup"].DefaultValue = Include.UndefinedSizeGroupRID;
                _dtHeader.Columns["Release"].DefaultValue = String.Empty;
                _dtHeader.Columns["Interfaced"].DefaultValue = false;
                _dtHeader.Columns["Master"].DefaultValue = String.Empty;
                _dtHeader.Columns["CharUpdated"].DefaultValue = false;
                _dtHeader.PrimaryKey = new DataColumn[] { _dtHeader.Columns["KeyH"] };

                _dsDetails = MIDEnvironment.CreateDataSet();

                _dsDetails.Tables.Add(_dtHeader);
                //ds.Relations.Add("Placeholder", ds.Tables["Header"].Columns["KeyH"], ds.Tables["Header"].Columns["AsrtRID"], false);

                // _bindSourceHeader = new BindingSource(ds, "Header");

                AddComponentTables();

                // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                _dtGradeQtyRemainder = MIDEnvironment.CreateDataTable("GradeQtyRemainder");
                _dtGradeQtyRemainder.Columns.Add("StoreGroupLevelKey", System.Type.GetType("System.Int32"));
                _dtGradeQtyRemainder.Columns.Add("StoreGradeKey", System.Type.GetType("System.Int32"));
                _dtGradeQtyRemainder.Columns.Add("LevelGradeTotalQty", System.Type.GetType("System.Int32"));
                _dtGradeQtyRemainder.Columns.Add("LevelGradeColorQty", System.Type.GetType("System.Int32"));
                _dtGradeQtyRemainder.Columns.Add("Remainder", System.Type.GetType("System.Int32"));
                _dtGradeQtyRemainder.Columns.Add("GradeStoreList", System.Type.GetType("System.Object"));
                // End TT#1282 
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        private void AddComponentTables()
        {
            try
            {
                // pack definition
                _dtPack = MIDEnvironment.CreateDataTable("Pack");

                _dtPack.Columns.Add("KeyH", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("KeyP", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("KeyC", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("Pack");
                _dtPack.Columns.Add("PackType", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("TotalPacks", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("QuantityPerPack", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("TotalQuantity", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("AssociatedPackRID", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("Sequence", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("Balance", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("ChildTotal", System.Type.GetType("System.Int32"));

                // pack defaults and constraints
                _dtPack.Columns["Pack"].AllowDBNull = false;
                _dtPack.Columns["KeyP"].DefaultValue = 0;
                _dtPack.Columns["KeyC"].DefaultValue = 0;
                _dtPack.Columns["PackType"].DefaultValue = (int)eAllocationType.GenericType;
                _dtPack.Columns["TotalPacks"].DefaultValue = 0;		// TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                _dtPack.Columns["QuantityPerPack"].DefaultValue = 1;
                _dtPack.Columns["TotalQuantity"].DefaultValue = 1;

                _dtPack.PrimaryKey = new DataColumn[] {_dtPack.Columns["KeyH"], 
													  _dtPack.Columns["Pack"]};
                Header headerData = new Header();
                _dtPack.Columns["Pack"].MaxLength = headerData.GetColumnSize("HEADER_PACK", "HDR_PACK_NAME"); 
                _dsDetails.Tables.Add(_dtPack);

                // pack color definition
                _dtPackColor = MIDEnvironment.CreateDataTable("PackColor");

                _dtPackColor.Columns.Add("KeyH", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("KeyP", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("KeyC", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("ColorCodeRID", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("PackColor");
                _dtPackColor.Columns.Add("Description");
                _dtPackColor.Columns.Add("QuantityPerPack", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("Sequence", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("Name");
                _dtPackColor.Columns.Add("Balance", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("ChildTotal", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("IsNewColor", System.Type.GetType("System.Boolean"));
                _dtPackColor.Columns.Add("IsVirtual", System.Type.GetType("System.Boolean"));

                // pack color defaults and constraints
                _dtPackColor.Columns["PackColor"].AllowDBNull = false;
                _dtPackColor.Columns["QuantityPerPack"].DefaultValue = 1;
                _dtPackColor.Columns["IsNewColor"].DefaultValue = false;
                _dtPackColor.Columns["IsVirtual"].DefaultValue = false;

                _dtPackColor.PrimaryKey = new DataColumn[] {_dtPackColor.Columns["KeyH"],  
                                                            _dtPackColor.Columns["KeyP"],
                                                            _dtPackColor.Columns["ColorCodeRID"]};
                _dsDetails.Tables.Add(_dtPackColor);

                // bulk color definition
                _dtBulkColor = MIDEnvironment.CreateDataTable("BulkColor");

                _dtBulkColor.Columns.Add("KeyH", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("KeyP", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("KeyC", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("ColorCodeRID", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("BulkColor");
                _dtBulkColor.Columns.Add("Description");
                _dtBulkColor.Columns.Add("Quantity", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("Sequence", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("Name");
                _dtBulkColor.Columns.Add("AsrtBCRID", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("Balance", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("ChildTotal", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("IsNewColor", System.Type.GetType("System.Boolean"));
                _dtBulkColor.Columns.Add("IsVirtual", System.Type.GetType("System.Boolean"));

                // bulk color defaults and constraints
                _dtBulkColor.Columns["KeyP"].DefaultValue = 0;
                _dtBulkColor.Columns["Quantity"].DefaultValue = 0;
                _dtBulkColor.Columns["ChildTotal"].DefaultValue = 0;
                _dtBulkColor.Columns["IsNewColor"].DefaultValue = false;
                _dtBulkColor.Columns["IsVirtual"].DefaultValue = false;

                _dtBulkColor.PrimaryKey = new DataColumn[] {_dtBulkColor.Columns["KeyH"], 
                                                            _dtBulkColor.Columns["ColorCodeRID"]};
                _dsDetails.Tables.Add(_dtBulkColor);

                _dsDetails.Relations.Add("Pack", _dsDetails.Tables["Header"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyH"]);

                _dsDetails.Relations.Add("PackColor", new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                    new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"] }, true);

                _dsDetails.Relations.Add("BulkColor", _dsDetails.Tables["Header"].Columns["KeyH"], _dsDetails.Tables["BulkColor"].Columns["KeyH"]);

                _dsDetails.AcceptChanges();
            }
            catch
            {
                throw;
            }
        }

        private void LoadHeaders()
        {
            try
            {
                _lastMultiSortSeq = 0;
                //_lastAsrtPlaceholderSortSeq = 0;	// TT#1227 - stodd
				//_lastAsrtHeaderSortSeq = 0;

                //_allocProfileList = new AllocationProfileList(eProfileType.Allocation);
				// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                //_allocProfileList = (AllocationProfileList)_transaction.GetMasterProfileList(eProfileType.Allocation);
				_allocProfileList = (AllocationProfileList)_transaction.GetMasterProfileList(eProfileType.AssortmentMember);
				// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
          
                foreach (AllocationHeaderProfile allocHeaderProfile in _headerList)
                {
                    if (allocHeaderProfile.HeaderType == eHeaderType.Assortment ||
                        allocHeaderProfile.HeaderType == eHeaderType.Placeholder)
                    {
                        LoadHeader(allocHeaderProfile.Key);
                    }
                    else if (allocHeaderProfile.AsrtRID > 0)
                    {
                        LoadHeader(allocHeaderProfile.Key);
                    }
                }
                _dsDetails.AcceptChanges();

            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void LoadHeader(int aHdrRID)
        {
            try
            {
                int headerType, headerStatus, intransitStatus, shipStatus;
                object groupRID, asrtRID, phRID, multiSortSeq, asrtPlaceholderSortSeq, asrtHeaderSortSeq;	// TT#1227 stodd

                HierarchyNodeSecurityProfile securityNode;
                eSecurityType styleSecurity;

                //WorkflowBaseData workflowData = new WorkflowBaseData(); //TT#1313-MD -jsobek -Header Filters -performance
                eSecurityLevel securityLevel = eSecurityLevel.Allow;
                string releaseDate = string.Empty;
                string headerDay = string.Empty;
                Header headerData = new Header();  // Track #5835

                bool canView, canUpdate;

                //Begin TT#2016 - DOConnell - Adding a characteristic to an assortment. Drag and drop FALL11 and get the System Argument Exception error.
                //AllocationHeaderProfile ahp = _sab.HeaderServerSession.GetHeaderData(aHdrRID, true, true);

                AllocationHeaderProfile ahp = _sab.HeaderServerSession.GetHeaderData(aHdrRID, true, true, true);
                //End TT#2016 - DOConnell - Adding a characteristic to an assortment. Drag and drop FALL11 and get the System Argument Exception error.
                AllocationProfile ap; // = new AllocationProfile(_transaction, ahp.HeaderID, aHdrRID, _sab.ClientServerSession);

                if (!_allocProfileList.Contains(ahp.Key))
                {
                    ap = new AllocationProfile(_transaction, ahp.HeaderID, aHdrRID, _sab.ClientServerSession);
                    ap.AsrtRID = GetAssortmentProfile().AsrtRID;   // TT#2077-MD - JSmith - Asst_after process Velocity Interactive_ go to Velocity Store Detail_ Qty Allocated column is populated with the allocation although the user did not select the Allocate button.
                    _allocProfileList.Add(ap);
                    ap.LoadStores();	// TT#4389 - stodd - Drag/Drop a header in to a GA, which is not the same plan level of the Lead header and receive a System Null Reference Exception.
                }
                else
                {
                    ap = GetAllocationProfile(ahp.Key);
                }
               
                if (!_headerList.Contains(ahp.Key))
                {
                    _headerList.Add(ahp);
                }

				if (!_asrtCubeGroup.Transaction.AllocationCriteria.HeaderList.Contains(ap.Key))
				{
					//AllocationProfile ap = new AllocationProfile(_sab, ahp, _sab.ClientServerSession);
					_asrtCubeGroup.Transaction.AllocationCriteria.HeaderList.Add(ap);
				}
				// Begin TT#2 - stodd
				else
				{
					AllocationProfile allocAp = (AllocationProfile)_asrtCubeGroup.Transaction.AllocationCriteria.HeaderList.FindKey(ap.Key);
					if (allocAp.HeaderType == eHeaderType.Assortment)
					{
						AssortmentProfile asp = (AssortmentProfile)allocAp;
						// Begin TT#952 - MD - stodd - add matrix to Group Allocation Review
                        if (asp.AssortmentSummaryProfile == null)
                        {
                            asp.BuildAssortmentSummary();
                        }
                        else
                        {
                            asp.AssortmentSummaryProfile.RereadStoreSummaryData();
                            asp.AssortmentSummaryProfile.BuildSummary(_lastStoreGroupValue);
                            //asp.GetSummaryInformation(_asrtCubeGroup, _currStoreGroupLevelProfile.Key);
                        }
						// End TT#952 - MD - stodd - add matrix to Group Allocation Review
					}
				}
				// End TT#2

                headerType = Convert.ToInt32(ahp.HeaderType, CultureInfo.CurrentUICulture);
                headerStatus = Convert.ToInt32(ahp.HeaderAllocationStatus, CultureInfo.CurrentUICulture);
                intransitStatus = Convert.ToInt32(ahp.HeaderIntransitStatus, CultureInfo.CurrentUICulture);
                shipStatus = Convert.ToInt32(ahp.HeaderShipStatus, CultureInfo.CurrentUICulture);
                canView = false;
                canUpdate = false;

                switch ((eHeaderType)headerType)
                {
                    case eHeaderType.Assortment:
                    //case eHeaderType.Placeholder:
                        canUpdate = _assortReviewContentSecurity.AllowUpdate;
                        canView = _assortReviewContentSecurity.AllowView;
                        break;

                    default:
                        securityNode = _sab.ClientServerSession.GetMyUserNodeSecurityAssignment(ahp.StyleHnRID, (int)eSecurityTypes.Allocation);
                        canUpdate = securityNode.AllowUpdate;
                        canView = securityNode.AllowView;
                        break;
                }
                if (canUpdate || canView)
                {
                    if (canUpdate)
                    {
                        styleSecurity = eSecurityType.Update;
                    }
                    else
                    {
                        styleSecurity = eSecurityType.View;
                    }

                    // check for size group in hash; if not found read it
                    SizeGroupProfile sgp = (SizeGroupProfile)_sizeGroupHash[ahp.SizeGroupRID];
                    if (sgp == null)
                    {
                        sgp = new SizeGroupProfile(ahp.SizeGroupRID);
                        _sizeGroupHash.Add(ahp.SizeGroupRID, sgp);
                    }
                    string workflowMethodStr = string.Empty;
                    // check for workflow name in hash; if not found read it
                    if (ahp.WorkflowRID > Include.UndefinedWorkflowRID)
                    {
                        workflowMethodStr = (string)_workflowNameHash[ahp.WorkflowRID];
                        if (workflowMethodStr == null)
                        {
                            workflowMethodStr = ahp.WorkflowName; // workflowData.GetWorkflowName(ahp.WorkflowRID); //TT#1313-MD -jsobek -Header Filters -performance
                            _workflowNameHash.Add(ahp.WorkflowRID, workflowMethodStr);
                        }
                    }
                    else if (ahp.MethodRID > Include.UndefinedMethodRID)
                    {
                        // check for method in hash; if not found read it
                        //ApplicationBaseMethod abm = (ApplicationBaseMethod)_methodHash[ahp.MethodRID];
                        //if (abm == null)
                        //{
                        //    abm = (ApplicationBaseMethod)_getMethods.GetUnknownMethod(ahp.MethodRID, false);
                        //    _methodHash.Add(ahp.MethodRID, abm);
                        //}
                        workflowMethodStr = ahp.HeaderMethodName; // abm.Name; //TT#1313-MD -jsobek -Header Filters -performance
                    }

                    string APIworkflowMethodStr = string.Empty;
                    // check for workflow name in hash; if not found read it
                    if (ahp.API_WorkflowRID > Include.UndefinedWorkflowRID)
                    {
                        APIworkflowMethodStr = (string)_workflowNameHash[ahp.API_WorkflowRID];
                        if (APIworkflowMethodStr == null)
                        {
                            APIworkflowMethodStr = ahp.APIWorkflowName; // workflowData.GetWorkflowName(ahp.API_WorkflowRID); //TT#1313-MD -jsobek -Header Filters -performance
                            _workflowNameHash.Add(ahp.API_WorkflowRID, APIworkflowMethodStr);
                        }
                    }

                    int masterRID = Include.NoRID;
                    int subordRID = Include.NoRID;

                    string masterID = String.Empty;
                    string subordID = String.Empty;
                    string msgMasterSubord = String.Empty;

                    subordRID = ahp.SubordinateRID;
                    if (subordRID != Include.NoRID)
                    {
                        subordID = ahp.SubordinateID;
                        if (subordID != null && subordID != string.Empty)
                        {
                            msgMasterSubord = ahp.HeaderID + " / " + subordID;
                        }
                    }
                    else
                    {
                        masterRID = ahp.MasterRID;
                        if (masterRID != Include.NoRID)
                        {
                            masterID = ahp.MasterID;
                            if (masterID != null && masterID != string.Empty)
                            {
                                msgMasterSubord = masterID + " / " + ahp.HeaderID;
                            }
                        }
                    }

                    if (ahp.ReleaseDate == Include.UndefinedDate)
                    {
                        releaseDate = string.Empty;
                    }
                    else
                    {
                        releaseDate = ahp.ReleaseDate.ToShortDateString();
                    }

                    //use first parent ID if multiple parents
                    string parentID = string.Empty;
                    //int parentRID = 0;
					int parentRID = 1;
					
                    HierarchyNodeProfile hnp_style = this.GetNodeData(ahp.StyleHnRID);
                    //if (ahp.StyleHnRID != 1)  // TT#991 - MD - Jellis - GA - Last Header Removed from Group gets Foreign Key Error
                    if (ahp.StyleHnRID > 1)     // TT#991 - MD - Jellis - GA - Last Header Removed from Group gets Foreign Key Error
                    {
						parentRID = Convert.ToInt32(hnp_style.Parents[0], CultureInfo.CurrentUICulture);
					}

                    HierarchyNodeProfile hnpProduct = this.GetNodeData(parentRID);
                    parentID = hnpProduct.LevelText;

                    // BEGIN Track #5835 stodd assortment
                    if (ahp.AsrtRID != Include.NoRID)
                    {
                        AddToAssortments(ahp.AsrtRID, headerData);
                    }
                    // END Track #5835 stodd assortment

                    
                    switch (headerType)
                    {
                        case (int)eHeaderType.Assortment:
                            AddToAssortments(ahp.Key, headerData);
                            break;

                        case (int)eHeaderType.Placeholder:
                            if (hnp_style.IsVirtual && hnp_style.Purpose == ePurpose.Placeholder )
                            {
                                _placeHolders.Rows.Add(new object[] { ahp.Key, ahp.HeaderID });
                            }
                            else
                            {
                                _placeHolders.Rows.Add(new object[] { ahp.Key, hnp_style.LevelText });
                            }
                            break;

                    }

                    // MultiHeader
                    if (ahp.HeaderGroupRID == Include.UndefinedHeaderGroupRID)
                        if (ahp.MultiHeader)
                        {
                            groupRID = ahp.Key;
                            multiSortSeq = 0;
                        }
                        else
                        {
                            groupRID = System.DBNull.Value;
                            multiSortSeq = System.DBNull.Value;
                        }
                    else
                    {
                        groupRID = ahp.HeaderGroupRID;
                        _lastMultiSortSeq++;
                        multiSortSeq = _lastMultiSortSeq;
                    }

                    phRID = System.DBNull.Value;
                    asrtRID = System.DBNull.Value;
					asrtPlaceholderSortSeq = System.DBNull.Value;	// TT#1227 - stodd
					asrtHeaderSortSeq = System.DBNull.Value;
                    if (headerType == (int)eHeaderType.Assortment)
                    {
                        asrtRID = ahp.Key;
						asrtPlaceholderSortSeq = 0;	// TT#1227 - stodd
						asrtHeaderSortSeq = 0;	// TT#1227 - stodd
                    }
                    else if (headerType == (int)eHeaderType.Placeholder)
                    {
                        phRID = ahp.Key;
                        asrtRID = ahp.AsrtRID;
						// Begin TT#1227 - stodd - placeholder sort seq
						asrtPlaceholderSortSeq = ahp.AsrtPlaceholderSeq;	// TT#1227 - stodd
						asrtHeaderSortSeq = ahp.AsrtHeaderSeq;
						UpdateLastPlaceholderSeq((int)asrtRID, asrtPlaceholderSortSeq);
						// End TT#1227 - stodd - placeholder sort seq
                    }
                    else if (ahp.AsrtRID != Include.NoRID)  // headers attached to an assortment
                    {
                        asrtRID = ahp.AsrtRID;
						// Begin TT#1227 - stodd - placeholder sort seq
                        //_lastAsrtSortSeq++;
                        //asrtSortSeq = _lastAsrtSortSeq;
						asrtPlaceholderSortSeq = ahp.AsrtPlaceholderSeq;	// TT#1227 - stodd
						asrtHeaderSortSeq = ahp.AsrtHeaderSeq;
						//UpdateLastPlaceholderSeq(asrtPlaceholderSortSeq);
						UpdateLastHeaderSeq((int)asrtRID, asrtPlaceholderSortSeq, asrtHeaderSortSeq);
						// End TT#1227 - stodd - placeholder sort seq
                        if (ahp.PlaceHolderRID != Include.NoRID)
                        {
                            phRID = ahp.PlaceHolderRID;
                        }
                    }

                    object anchorHnRID = System.DBNull.Value;
                    string anchorNode = null;
                    //if (headerType == (int)eHeaderType.Assortment || headerType == (int)eHeaderType.Placeholder)
                    //{
                    //    HierarchyNodeProfile anchorHnp = _hierMaint.GetAnchorNode(ahp.StyleHnRID);
                    //    if (anchorHnp.Key != Include.NoRID)
                    //    {
                    //        anchorHnRID = anchorHnp.Key;
                    //        anchorNode = anchorHnp.LevelText;
                    //    }
                    //}
                    if (headerType == (int)eHeaderType.Assortment || headerType == (int)eHeaderType.Placeholder)
                    {
                        AssortmentProfile asp;
                        if (headerType == (int)eHeaderType.Assortment)
                        {
                            asp = (AssortmentProfile)ap;
                        }
                        else
                        {
                            asp = (AssortmentProfile)_allocProfileList.FindKey(ahp.AsrtRID);
                        }
                        HierarchyNodeProfile anchorHnp = this.GetNodeData(asp.AssortmentAnchorNodeRid);
                        if (anchorHnp.Key != Include.NoRID)
                        {
                            anchorHnRID = anchorHnp.Key;
                            anchorNode = anchorHnp.LevelText;
                        }
                    }

                    // Begin TT#1178 - RMatelic - Placeholder Styles do not match Placeholder ID's - need consistency
                    string styleDisplay;
                    if (hnp_style.IsVirtual && hnp_style.Purpose == ePurpose.Placeholder)
                    {
                        styleDisplay = ahp.HeaderID;
                    }
                    else
                    {
                        styleDisplay = hnp_style.LevelText;
                    }
                    // End TT#1178

                    string firstHeaderInd = string.Empty;	// TT#1130 - md - stodd - mark first header - 

                    int totalUnitsAllocated = TotalUnitsAllocated(ap);	// TT#1575-MD - stodd - Group Allocation Content tab units allocated should always match the total units from the Matrix screen.  

                    DataRow headerRow;
                    headerRow = _dtHeader.Rows.Add(new object[] 
									//BEGIN TT#573-MD - stodd -  Header not fully allocated after drag unto placeholder  
                                      { firstHeaderInd, ap.Key, Include.NoRID, Include.NoRID, ap.HeaderID, groupRID, 	// TT#1130 - md - stodd - mark first header - 
                                        asrtRID, phRID, (int)securityLevel, headerType, ap.HeaderDay,
                                        headerStatus, anchorHnRID, anchorNode, parentRID, parentID, ap.StyleHnRID, 
                                        // Begin TT#1178 - RMatelic - Placeholder Styles do not match Placeholder ID's - need consistency
                                        //hnp_style.LevelText,
                                        styleDisplay,
                                        // End TT#1178 
                                        (int)styleSecurity, ahp.HeaderDescription,
                                        //ahp.TotalUnitsToAllocate, System.DBNull.Value, ahp.AllocatedUnits, ahp.UnitRetail, ahp.UnitCost,
										// Begin TT#1575-MD - stodd - Group Allocation Content tab units allocated should always match the total units from the Matrix screen.  
										//ap.TotalUnitsToAllocate, System.DBNull.Value, ap.TotalUnitsAllocated, ap.UnitRetail, ap.UnitCost,
                                        ap.TotalUnitsToAllocate, System.DBNull.Value, totalUnitsAllocated, ap.UnitRetail, ap.UnitCost,
										// End TT#1575-MD - stodd - Group Allocation Content tab units allocated should always match the total units from the Matrix screen.  
                                        ap.SizeGroupRID, ahp.AllocationMultipleDsply, ap.PurchaseOrder, ap.Vendor, // MID Track 5761 Allocation Multiple not saved on DB 
                                        workflowMethodStr, APIworkflowMethodStr, ap.DistributionCenter, 
                                        intransitStatus, shipStatus, releaseDate, ap.AllocationNotes,
                                        ap.IsInterfaced, 0, multiSortSeq, msgMasterSubord, 
                                         ap.OrigAllocatedUnits, 
                                        ap.RsvAllocatedUnits, ap.AsrtType, asrtPlaceholderSortSeq, false, asrtHeaderSortSeq, asrtRID, phRID });	// TT#1227 - stodd
                                                                                                           // RMatelic -  last 2 columns are for sorting
									//BEGIN TT#573-MD - stodd -  Header not fully allocated after drag unto placeholder  

                    AddCharacteristicsToHeader(headerRow, ahp.Characteristics);

                    // Begin TT#940 - MD - Opening a group allocation fails with a constraint exception
                    // The content grid is not expecting the Assortment/Group Allocation header to have components--it doesn't use or need them.
                    if (ap.HeaderType != eHeaderType.Assortment)
                    {
                        AddComponents(ahp.Key, ref headerRow);
                    }
                    // End TT#940 - MD - Opening a group allocation fails with a constraint exception
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		// Begin TT#1575-MD - stodd - Group Allocation Content tab units allocated should always match the total units from the Matrix screen.  
        /// <summary>
        /// Computes the total units allocated based upon the packs and bulk
        /// to match the matrix total units when headers are out of balance
        /// or detail where size need hasn't been run.
        /// </summary>
        /// <param name="ap"></param>
        private int TotalUnitsAllocated(AllocationProfile ap)
        {
            // Begin TT#2058-MD - JSmith - Allocated units is not populated when the PH is created and in the status All In Balance.
            //int BulkAndPackAllocated = 0;
            //if (CreateAndAddHeaders)
            //{
            //    BulkAndPackAllocated = ap.TotalUnitsAllocated;
            //}
            //else
            //{
            //    if (ap.Packs != null && ap.Packs.Count > 0)
            //    {
            //        foreach (PackHdr aPack in ap.Packs.Values)
            //        {
            //            BulkAndPackAllocated += aPack.UnitsAllocated;
            //        }
            //    }
            //    if (ap.BulkColors != null && ap.BulkColors.Count > 0)
            //    {
            //        foreach (HdrColorBin aColor in ap.BulkColors.Values)
            //        {
            //            BulkAndPackAllocated += aColor.ColorUnitsAllocated;
            //        }
            //    }
            //}
            //return BulkAndPackAllocated;
            return ap.AllocatedUnits;
            // End TT#2058-MD - JSmith - Allocated units is not populated when the PH is created and in the status All In Balance.
        }
		// End TT#1575-MD - stodd - Group Allocation Content tab units allocated should always match the total units from the Matrix screen.  

		// Begin TT#1130 - md - stodd - mark first header - 
        private int GetFirstHeaderInGroupAllocation()
        {
            int firstHeaderRid = Include.NoRID;
            ProfileList ampl = _transaction.GetMasterProfileList(eProfileType.AssortmentMember);
            foreach (AllocationProfile ap in ampl.ArrayList)
            {
                if (ap.HeaderType == eHeaderType.Assortment || ap.HeaderType == eHeaderType.Placeholder)
                {
                    continue;
                }
                firstHeaderRid = ap.Key;
                break;
            }
            return firstHeaderRid;
        }
		// End TT#1130 - md - stodd - mark first header - 

        // Begin TT#1110 - md - stodd - style wrong on GA header - 
        ////Begin TT#957 - MD - stodd - "Errors Found" message when clicking on header - 
        //// Begin TT#957 - MD - stodd - "Errors Found" message when clicking on header -
        ///// <summary>
        ///// Updates the assortment product and style nodes with the nodes from the first header in the assortment.
        ///// This is used for Group Allocation only.
        ///// </summary>
        ///// <param name="asrtRow"></param>
        //private void UpdateAssortmentNodesFromFirstHeader(UltraGridRow asrtRow)
        //{
        //    if (GetAssortmentType() == eAssortmentType.GroupAllocation)
        //    {
        //        if (asrtRow.Cells["Product"].Value == DBNull.Value || asrtRow.Cells["Style"].Value == DBNull.Value)
        //        {

        //            int asrtRid = int.Parse(asrtRow.Cells["AsrtRid"].Value.ToString());
        //            UltraGridRow hdrRow = GetFirstHeaderRowInAssortment(asrtRow);
        //            if (hdrRow != null)
        //            {
        //                // Grab the values from the first header
        //                int productRid = int.Parse(hdrRow.Cells["ProductRid"].Value.ToString());
        //                string product = hdrRow.Cells["Product"].Value.ToString();
        //                int styleRid = int.Parse(hdrRow.Cells["StyleHnRid"].Value.ToString());
        //                string style = hdrRow.Cells["Style"].Value.ToString();
        //                // update the assortment header
        //                _skipProductEdit = true;
        //                _skipStyleEdit = true;
        //                asrtRow.Cells["ProductRID"].Value = productRid;
        //                asrtRow.Cells["Product"].Value = product;
        //                asrtRow.Cells["StyleHnRID"].Value = styleRid;
        //                asrtRow.Cells["Style"].Value = style;
        //            }
        //        }
        //    }
        //}
        //// End TT#957 - MD - stodd - "Errors Found" message when clicking on header -
        // End TT#1110 - md - stodd - style wrong on GA header - 

		// Begin TT#1227 - stodd
		private void UpdateLastPlaceholderSeq(int asrtRid, object newSeq)
		{
			try
			{
				if (_lastAsrtPlaceholderSortSeq == null)
					_lastAsrtPlaceholderSortSeq = new Dictionary<int, int>();
				if (_lastAsrtPlaceholderSortSeq.ContainsKey(asrtRid))
				{
					if ((int)newSeq > _lastAsrtPlaceholderSortSeq[asrtRid])
					{
						_lastAsrtPlaceholderSortSeq[asrtRid] = (int)newSeq;
					}
				}
				else
				{
					_lastAsrtPlaceholderSortSeq.Add(asrtRid, (int)newSeq);
				}
			}
			catch
			{
				throw;
			}
		}

		private void UpdateLastHeaderSeq(int asrtRid, object placeholderSeq, object newSeq)
		{
			try
			{
				if (_lastAsrtHeaderSortSeq == null)
					_lastAsrtHeaderSortSeq = new MID2DimIntDictionary();

				if (_lastAsrtHeaderSortSeq.ContainsKey(asrtRid, (int)placeholderSeq))
				{
					if ((int)newSeq > (int)_lastAsrtHeaderSortSeq[asrtRid, (int)placeholderSeq])
					{
						_lastAsrtHeaderSortSeq[asrtRid, (int)placeholderSeq] = (int)newSeq;
					}

				}
				else
				{
					_lastAsrtHeaderSortSeq[asrtRid, (int)placeholderSeq] = (int)newSeq;
				}
			}
			catch
			{
				throw;
			}
		}
		private int IncreaseLastPlaceholderSeq(int asrtRid)
		{
			try
			{
				if (_lastAsrtPlaceholderSortSeq == null)
					_lastAsrtPlaceholderSortSeq = new Dictionary<int, int>();
				int newSeq = 0;
				if (_lastAsrtPlaceholderSortSeq.ContainsKey(asrtRid))
				{
					_lastAsrtPlaceholderSortSeq[asrtRid]++;
					newSeq = _lastAsrtPlaceholderSortSeq[asrtRid];
				}
				else
				{
					_lastAsrtPlaceholderSortSeq.Add(asrtRid, 1);
					newSeq = 1;
				}
				return newSeq;
			}
			catch
			{
				throw;
			}
		}
		private int IncreaseLastHeaderSeq(int asrtRid, object placeholderSeq)
		{
			try
			{
				if (_lastAsrtHeaderSortSeq == null)
					_lastAsrtHeaderSortSeq = new MID2DimIntDictionary();
				int newSeq = 0;

				if (_lastAsrtHeaderSortSeq.ContainsKey(asrtRid, (int)placeholderSeq))
				{
					newSeq = (int)_lastAsrtHeaderSortSeq[asrtRid, (int)placeholderSeq];
					_lastAsrtHeaderSortSeq[asrtRid, (int)placeholderSeq] = ++newSeq;
				}
				else
				{
					newSeq = 1;
					_lastAsrtHeaderSortSeq[asrtRid, (int)placeholderSeq] = newSeq;
				}

				return newSeq;
			}
			catch
			{
				throw;
			}
		}
		// End TT#1227 - stodd

        private AllocationProfile GetAllocationProfile(int aHeaderRID)
        {
            try
            {
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(aHeaderRID);
                return ap;
            }
            catch
            {
                throw;
            }
        }


		// Begin TT#1053 - MD - stodd - removing/adding headers to GA - 
        private AssortmentProfile GetAssortmentProfile()
        {
            AssortmentProfile asp = null;
            try
            {
                AllocationProfileList apl = (AllocationProfileList)_transaction.GetMasterProfileList(eProfileType.AssortmentMember);
                foreach (AllocationProfile ap in apl.ArrayList)
                {
                    if (ap.HeaderType == eHeaderType.Assortment)
                    {
                        asp = (AssortmentProfile)ap;
                        break;
                    }
                }
                return asp;
            }
            catch
            {
                throw;
            }
        }
		// End TT#1053 - MD - stodd - removing/adding headers to GA - 


        private void AddComponents(int aHdrRID, ref DataRow aHeaderRow)
        {
            try
            {
                int headerTotal = 0;
                AllocationProfile ap = GetAllocationProfile(aHdrRID);
                HierarchyNodeProfile hnp_style = _sab.HierarchyServerSession.GetNodeData(aHdrRID, false);
               
                // begin TT#488 - MD - Jellis - Group Allocation
                // Begin TT#4988 - BVaughan - Performance
                #if DEBUG
                if ((ap is AssortmentProfile && !ap.isAssortmentProfile) || (!(ap is AssortmentProfile) && ap.isAssortmentProfile))
                {
                    throw new Exception("Object does not match AssortmentProfile in AddComponents()");
                }
                #endif
                //if (!(ap is AssortmentProfile))
                if (!(ap.isAssortmentProfile))
                // End TT#4988 - BVaughan - Performance
                {
                    // end TT#488 - MD - Jellis - Gorup Allocation
                    if (ap.Packs != null && ap.Packs.Count > 0)
                    {
                        int packType;
                        foreach (PackHdr aPack in ap.Packs.Values)
                        {
                            if (aPack.GenericPack)
                                packType = (int)eAllocationType.GenericType;
                            else
                                packType = (int)eAllocationType.DetailType;

                        headerTotal += (aPack.PacksToAllocate * aPack.PackMultiple);
                        DataRow packRow = _dtPack.Rows.Add(new object[] { ap.HeaderRID, aPack.PackRID, Include.NoRID,
                                                          aPack.PackName, packType, aPack.PacksToAllocate,
                                                          aPack.PackMultiple, aPack.UnitsToAllocate, 
                                                          aPack.AssociatedPackRID, aPack.Sequence});
                        int colorTotal = 0;
                        bool hasDummyColor = false;

                        if (aPack.PackColors != null && aPack.PackColors.Count > 0)
                        {
                            foreach (PackColorSize packColor in aPack.PackColors.Values)
                            {
                                DataRow colorRow = null;
                                ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(packColor.ColorCodeRID);
                                
                                string packColorDescription = string.Empty;
                                string colorID = string.Empty;

                                if (ccp.VirtualInd)
                                {
                                    colorID = packColor.ColorName;
									// Begin TT#795-MD - stodd - Build Packs not working on a Placeholder in an assortment.
                                    if (colorID == null)
                                    {
                                        colorID = ccp.ColorCodeID;
                                    }
                                    packColorDescription = packColor.ColorDescription;
                                    if (packColorDescription == null)
                                    {
                                        packColorDescription = GetColorDescription(hnp_style, ccp);
                                    }
									// End TT#795-MD - stodd - Build Packs not working on a Placeholder in an assortment.
                                }
                                else
                                {
                                    colorID = ccp.ColorCodeID;
                                    packColorDescription = GetColorDescription(hnp_style, ccp);
                                }
                                if (packColor.ColorCodeRID != Include.DummyColorRID)
                                {
                                    colorTotal += packColor.ColorUnitsInPack;
                                    colorRow = _dtPackColor.Rows.Add(new object[] { ap.HeaderRID, aPack.PackRID,
                                                                  packColor.HdrPCRID, packColor.ColorCodeRID, 
                                                                  colorID, packColorDescription, 
                                                                  packColor.ColorUnitsInPack, packColor.ColorSequenceInPack, packColor.ColorName });
                                }
                                if (ccp.VirtualInd)
                                {
                                    colorRow["IsVirtual"] = true;
                                }
                                if (_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                                {
                                    if (packColor.ColorSizes != null && packColor.ColorSizes.Count > 0)
                                    {
                                        string namePrefix = packColor.ColorCodeRID == Include.DummyColorRID ? "PackSize" : "PackColorSize";
                                        string sizeTableName = namePrefix
                                            + "~" + ap.Key.ToString(CultureInfo.CurrentUICulture)
                                            + "~" + aPack.PackRID.ToString(CultureInfo.CurrentUICulture)
                                            + "~" + packColor.HdrPCRID.ToString(CultureInfo.CurrentUICulture);
                                        int sizeTotal = 0;

                                        DataTable dtSizes = FormatPackSizeTable(packColor, ap.SizeGroupRID, ap.HeaderRID, aPack.PackRID, packColor.HdrPCRID, ccp.ColorCodeID, sizeTableName, ref sizeTotal);
                                        if (dtSizes != null)
                                        {
                                            ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, false);  // TT#1483-MD - RMatelic - Asst - when attaching a header receive mssg Unable to determine where to add row:please select a valid row before adding a new row.  Select OK get null reference exception
                                            _dsDetails.Tables.Add(dtSizes);
                                            if (packColor.ColorCodeRID == Include.DummyColorRID)
                                            {
                                                _dsDetails.Relations.Add(sizeTableName,
                                                    new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                                                    new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyP"] }, true);
                                                hasDummyColor = true;
                                                packRow["ChildTotal"] = sizeTotal;
                                                packRow["Balance"] = Convert.ToInt32(packRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - sizeTotal;

                                            }
                                            else
                                            {
                                                _dsDetails.Relations.Add(sizeTableName,
                                                    new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"], _dsDetails.Tables["PackColor"].Columns["KeyC"] },
                                                    new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyP"], _dsDetails.Tables[sizeTableName].Columns["KeyC"] }, true);
                                                colorRow["ChildTotal"] = sizeTotal;
                                                colorRow["Balance"] = Convert.ToInt32(colorRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - sizeTotal;

                                            }
                                            ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, true);  // TT#1483-MD - RMatelic - Asst - when attaching a header receive mssg Unable to determine where to add row:please select a valid row before adding a new row.  Select OK get null reference exception
                                        }
                                    }
                                }
                            }

                            if (aPack.PackColors != null && aPack.PackColors.Count > 0
                                && !hasDummyColor)
                            {
                                packRow["ChildTotal"] = colorTotal;
                                packRow["Balance"] = Convert.ToInt32(packRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - colorTotal;
                            }
                        }
                    }
                }
			   	} // TT#488 - MD - Jellis _ group Allocation
                if (ap.BulkColors != null && ap.BulkColors.Count > 0)
                {
                    foreach (HdrColorBin aColor in ap.BulkColors.Values)
                    {
                        ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(aColor.ColorCodeRID);

                        string colorID = string.Empty;
                        string description = string.Empty;

                        if (ccp.VirtualInd)
                        {
                            colorID = aColor.ColorName;
                            description = aColor.ColorDescription;
                        }
                        else
                        {
                            colorID = ccp.ColorCodeID;
                            description = GetColorDescription(hnp_style, ccp);
                        }
                        headerTotal += aColor.ColorUnitsToAllocate;
                        DataRow colorRow = _dtBulkColor.Rows.Add(new object[] { ap.HeaderRID, Include.NoRID, 
                                                   aColor.HdrBCRID, aColor.ColorCodeRID, colorID, 
                                                   description, aColor.ColorUnitsToAllocate,
                                                   aColor.ColorSequence, aColor.ColorName, aColor.AsrtBCRID });

                        if (ccp.VirtualInd)
                        {
                            colorRow["IsVirtual"] = true;
                        }
                        if (_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                        {
                            if (aColor.ColorSizes != null && aColor.ColorSizes.Count > 0)
                            {
                                string sizeTableName = "BulkSize"
                                    + "~" + ap.HeaderRID.ToString(CultureInfo.CurrentUICulture)
                                    + "~" + aColor.HdrBCRID.ToString(CultureInfo.CurrentUICulture);

                                int sizeTotal = 0;
                                DataTable dtSizes = FormatBulkSizeTable(aColor, ap.SizeGroupRID, ap.HeaderRID, aColor.HdrBCRID, ccp.ColorCodeID, sizeTableName, ref sizeTotal);

                                if (dtSizes != null)
                                {
                                    colorRow["ChildTotal"] = sizeTotal;
                                    colorRow["Balance"] = Convert.ToInt32(colorRow["Quantity"], CultureInfo.CurrentUICulture) - sizeTotal;
                                    ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, false);  // TT#1483-MD - RMatelic - Asst - when attaching a header receive mssg Unable to determine where to add row:please select a valid row before adding a new row.  Select OK get null reference exception
                                    _dsDetails.Tables.Add(dtSizes);
                                    _dsDetails.Relations.Add(sizeTableName,
                                    new DataColumn[] { _dsDetails.Tables["BulkColor"].Columns["KeyH"], _dsDetails.Tables["BulkColor"].Columns["KeyC"] },
                                    new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyC"] }, true);
                                    ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, true);   // TT#1483-MD - RMatelic - Asst - when attaching a header receive mssg Unable to determine where to add row:please select a valid row before adding a new row.  Select OK get null reference exception
                                }
                            }
                        }
                    }
                }
                if ((ap.Packs != null && ap.Packs.Count > 0) ||
                    (ap.BulkColors != null && ap.BulkColors.Count > 0))
                {
                    aHeaderRow["ChildTotal"] = headerTotal;
                    aHeaderRow["Balance"] = Convert.ToInt32(aHeaderRow["HdrQuantity"], CultureInfo.CurrentUICulture) - headerTotal;
                }
                
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		//BEGIN TT#665-MD - stodd - asst with placeholder and placeholder colors when input avg units in the matrix units not spread evenly to placeholder colors.
		/// <summary>
		/// This updates the content grid with any changes caused by changes to the matrix grid.
		/// </summary>
		private void UpdateContentGrid()
		{
			try
			{
				// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
				//AllocationProfileList apl = (AllocationProfileList)_transaction.GetMasterProfileList(eProfileType.Allocation);
				AllocationProfileList apl = (AllocationProfileList)_transaction.GetMasterProfileList(eProfileType.AssortmentMember);
				// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
				foreach (AllocationProfile ahp in apl)
				{
					// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
					//AllocationProfile ap = _transaction.GetAllocationProfile(ahp.Key);
					AllocationProfile ap = _transaction.GetAssortmentMemberProfile(ahp.Key);
					// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
					if (ap != null && ap.HeaderType != eHeaderType.Assortment)
					{
						// Header Status
						UpdateStatusColumn(ap.Key, ap.GetHeaderAllocationStatus(true));

						// Total
						UpdateQuantityFromAssortmentGrid(ap.Key, int.MaxValue, int.MaxValue, ap.TotalUnitsAllocated);
						// Packs
						if (ap.Packs != null && ap.Packs.Count > 0)
						{
							foreach (PackHdr aPack in ap.Packs.Values)
							{
								UpdateQuantityFromAssortmentGrid(ap.Key, aPack.PackRID, int.MaxValue, aPack.UnitsAllocated);
								if (aPack.PackColors != null && aPack.PackColors.Count > 0)
								{
									foreach (PackColorSize packColor in aPack.PackColors.Values)
									{
										UpdateQuantityFromAssortmentGrid(ap.Key, aPack.PackRID, packColor.ColorCodeRID, packColor.ColorUnitsInPack);
									}
								}
							}
						}

						// Colors
						if (ap.BulkColors != null && ap.BulkColors.Count > 0)
						{
							foreach (HdrColorBin aColor in ap.BulkColors.Values)
							{
								UpdateQuantityFromAssortmentGrid(ap.Key, int.MaxValue, aColor.ColorCodeRID, aColor.ColorUnitsAllocated);
							}
						}
					}
				}
                LoadContentGrid(); //TT#791 - MD - DOConnell - Assortment -> Content Tab-> does not stay collapsed after selected
			}
			catch (Exception ex)
			{
				HandleException(ex);
			}
		}
		//END TT#665-MD - stodd - asst with placeholder and placeholder colors when input avg units in the matrix units not spread evenly to placeholder colors.
		
        private string GetColorDescription(HierarchyNodeProfile hnp_style, ColorCodeProfile ccp)
        {
            int colorHnRID = Include.NoRID;
            string colorDescription = null;
            Hashtable colorHash = null;
            try
            {
                if (_colorsForStyle.ContainsKey(hnp_style.Key))
                {
                    colorHash = (Hashtable)_colorsForStyle[hnp_style.Key];
                    if (colorHash.ContainsKey(ccp.Key))
                    {
                        colorDescription = colorHash[ccp.Key].ToString();
                    }
                    else
                    {
                        if (_sab.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
                        {
                            HierarchyNodeProfile hnp_color = _sab.HierarchyServerSession.GetNodeData(colorHnRID, false);
                            colorDescription = hnp_color.NodeDescription;
                        }
                        else
                        {
                            colorDescription = ccp.ColorCodeName;
                        }
                        colorHash.Add(ccp.Key, colorDescription);
                    }
                }
                else
                {
                    colorHash = new Hashtable();
                    _colorsForStyle.Add(hnp_style.Key, colorHash);
                    colorDescription = GetColorDescription(hnp_style, ccp);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            return colorDescription;
        }

        private void AddToAssortments(int asrtRid, Header headerData)
        {
            if (asrtRid != Include.NoRID)
            {
                if (!_assortments.Rows.Contains(asrtRid))
                {
                    DataTable dt = headerData.GetHeader(asrtRid);
                    if (dt.Rows.Count > 0)
                    {
                        DataRow aRow = dt.Rows[0];
                        string id = aRow["HDR_ID"].ToString();
                        _assortments.Rows.Add(new object[] { asrtRid, id });
                    }
                }
            }
        }
      
        private void AddCharacteristicsToHeader(DataRow aHeaderRow, HeaderCharProfileList aCharList)
        {
            try
            {
                for (int i = _nonCharColCount; i < _dtHeader.Columns.Count; i++)
                {
                    DataColumn col = (DataColumn)_dtHeader.Columns[i];
                    if (col.ExtendedProperties.ContainsKey("IsChar"))
                    {
                        HeaderCharGroupProfile hcgp = (HeaderCharGroupProfile)col.ExtendedProperties["IsChar"];
                        HeaderCharProfile hcp = (HeaderCharProfile)aCharList.FindKey(hcgp.Key);

                        aHeaderRow[col.ColumnName] = System.DBNull.Value;
                        if (hcp.Text != null)
                        {
                            if (hcgp.ListInd) // uses a drop down list
                            {
                                aHeaderRow[col.ColumnName] = hcp.CharRID;        
                            }
                            else
                            {
                                aHeaderRow[col.ColumnName] = hcp.Text;
                                // need to save the char RID for update routine
                                string charString = string.Empty;
                                if (hcp.HeaderCharType == eHeaderCharType.date)
                                {
                                    charString = hcgp.Key.ToString() + "~" + hcp.DateValue.ToString();
                                }
                                else
                                {
                                    charString = hcgp.Key.ToString() + "~" + hcp.Text;
                                }
                                if (!col.ExtendedProperties.ContainsKey(charString))
                                {
                                    col.ExtendedProperties.Add(charString, hcp.CharRID);
                                }
                            }  
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }


        private HierarchyNodeProfile GetNodeData(int aHnRID)
        {
            try
            {
                if (_nodeDataHashLastKey != aHnRID)
                {
                    _nodeDataHashLastKey = aHnRID;
                    if (_nodeDataHash == null)
                    {
                        _nodeDataHash = new Hashtable();
                    }
                    if (_nodeDataHash.Contains(aHnRID))
                    {
                        _nodeDataHashLastValue = (HierarchyNodeProfile)_nodeDataHash[aHnRID];
                    }
                    else
                    {
                        _nodeDataHashLastValue = _sab.HierarchyServerSession.GetNodeData(aHnRID, false);
                        _nodeDataHash.Add(aHnRID, _nodeDataHashLastValue);
                    }
                }
                return _nodeDataHashLastValue;
            }
            catch
            {
                throw;
            }
        }

        private void LoadGridValueLists()
        {
            try
            {
                // Assortments
                _assortmentValueList = new ValueList();
                _assortmentValueList.Key = "AssortmentID";

                foreach (DataRow dr in _assortments.Rows)
                {
                    _assortmentValueList.ValueListItems.Add(Convert.ToInt32(dr["AsrtRID"], CultureInfo.CurrentUICulture), dr["AssortmentID"].ToString());
                }

                // PlaceHolders
                _placeHolderValueList = new ValueList();
                _placeHolderValueList.Key = "PlaceHolderID";

                foreach (DataRow dr in _placeHolders.Rows)
                {
                    _placeHolderValueList.ValueListItems.Add(Convert.ToInt32(dr["PlaceHolderRID"], CultureInfo.CurrentUICulture), dr["PlaceHolderID"].ToString());
                }

                // Header Type
                _headerTypeValueList = LoadMIDTextValueList("HeaderType", eMIDTextType.eHeaderType, eMIDTextOrderBy.TextCode);
                if (!_sab.ClientServerSession.GlobalOptions.AppConfig.AssortmentInstalled)
                {
                    bool phRemoved = false, asrtRemoved = false;
                    for (int i = _headerTypeValueList.ValueListItems.Count - 1; i >= 0; i--)
                    {
                        ValueListItem vli = _headerTypeValueList.ValueListItems[i];
                        int value = Convert.ToInt32(vli.DataValue, CultureInfo.CurrentUICulture);
                        if (value == Convert.ToInt32(eHeaderType.Assortment, CultureInfo.CurrentUICulture))
                        {
                            _headerTypeValueList.ValueListItems.Remove(vli);
                            asrtRemoved = true;
                        }
                        else if (value == Convert.ToInt32(eHeaderType.Placeholder, CultureInfo.CurrentUICulture))
                        {
                            _headerTypeValueList.ValueListItems.Remove(vli);
                            phRemoved = true;
                        }
                        if (asrtRemoved && phRemoved)
                        {
                            break;
                        }
                    }
                }

                // Header Status
                _headerStatusValueList = LoadMIDTextValueList("Status", eMIDTextType.eHeaderAllocationStatus, eMIDTextOrderBy.TextCode);

                // Header Intransit
                _headerIntransitValueList = LoadMIDTextValueList("Intransit", eMIDTextType.eHeaderIntransitStatus, eMIDTextOrderBy.TextCode);

                // Header Ship Status
                _headerShipStatusValueList = LoadMIDTextValueList("ShipStatus", eMIDTextType.eHeaderShipStatus, eMIDTextOrderBy.TextCode);

                // Size Groups
                if (_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                {
                    _sizeGroupValueList = new ValueList();
                    _sizeGroupValueList.Key = "SizeGroup";
                    SizeGroupList sgl = new SizeGroupList(eProfileType.SizeGroup);
                    //sgl.LoadAll(true);
                    sgl.LoadAll(IncludeUndefinedGroup: true, doReadSizeCodeListFromDatabase: false); //TT#1313-MD -jsobek -Header Filters -performance
                    foreach (SizeGroupProfile sgp in sgl.ArrayList)
                    {
                        _sizeGroupValueList.ValueListItems.Add(sgp.Key, sgp.SizeGroupName);
                    }
                }

                // Pack Type
                _packTypeValueList = LoadMIDTextValueList("PackType", eMIDTextType.ePackType, eMIDTextOrderBy.TextCode);

                // Characteristics
                _charValueListsHash = new Hashtable();

                foreach (HeaderCharGroupProfile hcgp in _headerCharGroupProfileList)
                {
                    if (hcgp.Characteristics.Count > 0)
                    {
                        ValueList charValueList = new ValueList();
                        charValueList.Key = hcgp.ID;
                        charValueList.ValueListItems.Add(Include.NoRID, Include.NoneText);
                        foreach (HeaderCharInfo hci in hcgp.Characteristics.Values)
                        {
                            string value = GetCharacteristicValue(hci, hcgp.Type);
                            charValueList.ValueListItems.Add(hci.RID, value);
                        }
                        _charValueListsHash.Add(hcgp.ID, charValueList);
                    }
                }

            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private ValueList LoadMIDTextValueList(string aKey, eMIDTextType aMIDTextType, eMIDTextOrderBy aMIDTextOrderBy)
        {
            ValueList valueList = new ValueList();
            valueList.Key = aKey;
            try
            {
                DataTable dataTable = MIDText.GetTextType(aMIDTextType, aMIDTextOrderBy);

                foreach (DataRow dr in dataTable.Rows)
                {
                    valueList.ValueListItems.Add(Convert.ToInt32(dr["TEXT_CODE"], CultureInfo.CurrentUICulture), dr["TEXT_VALUE"].ToString());
                    if (Convert.ToInt32(dr["TEXT_CODE"], CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                    {
                        _lblPlaceholder = dr["TEXT_VALUE"].ToString();
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }

            return valueList;
        }

        private string GetCharacteristicValue(HeaderCharInfo aCharInfo, eHeaderCharType aCharType)
        {
            string value = null;
            try
            {
                switch (aCharType)
                {
                    case eHeaderCharType.text:
                        value = aCharInfo.TextValue;
                        break;

                    case eHeaderCharType.dollar:
                        value = Convert.ToString(aCharInfo.DollarValue, CultureInfo.CurrentUICulture);
                        break;

                    case eHeaderCharType.number:
                        value = Convert.ToString(aCharInfo.NumberValue, CultureInfo.CurrentUICulture);
                        break;

                    case eHeaderCharType.date:
                        value = Convert.ToString(aCharInfo.DateValue, CultureInfo.CurrentUICulture);
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }

            return value;
        }


        #endregion

        #region Create Size Tables
        private DataTable FormatBulkSizeTable(HdrColorBin aColor, int aSizeGroupRID, int headerRID, int colorRID, string aColorCodeID, string tableName, ref int sizeTotal)
        {
            ArrayList sizeID = new ArrayList();
            SortedList primarySL = new SortedList();
            ArrayList secondaryAL = new ArrayList();
            Hashtable bothHash = new Hashtable();
            SortedList sortedList = new SortedList();
            SizeGroupProfile sgp = null;
            sizeTotal = 0;

            AllocationProfile ap = GetAllocationProfile(headerRID);
            SizeCodeList scl = null;
            // is there a size group?
            if (aSizeGroupRID > Include.UndefinedSizeGroupRID)
            {
                // load existing group
                sgp = GetSizeGroup(aSizeGroupRID);
                scl = sgp.SizeCodeList;

                LoadSizeArraysFromGroup(scl, ref sizeID, ref primarySL, ref secondaryAL);

                if (aColor != null)
                {
                    foreach (HdrSizeBin aSize in aColor.ColorSizes.Values)
                    {
                        sortedList.Add(aSize.SizeSequence, aSize);
                    }
                    foreach (HdrSizeBin aSize in sortedList.Values)
                    {
                        if (scl.Contains(aSize.SizeKey))
                        {
                            SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(aSize.SizeKey);
                            if (!bothHash.ContainsKey(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID))
                            {
                                bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                            }
                            else
                            {
                                throw new MIDException(eErrorLevel.severe, 0, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                            }
                        }
                    }
                    foreach (HdrSizeBin aSize in sortedList.Values)
                    {
                        SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(aSize.SizeKey);
                        if (scp == null)
                        {
                            if (!ap.Placeholder)
                            {
                                scp = _sab.HierarchyServerSession.GetSizeCodeProfile(aSize.SizeKey);
                                if (scp.Key == Include.NoRID)
                                {
                                    throw new MIDException(eErrorLevel.severe, 0, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_CantRetrieveSizeCode) + " " + aSize.SizeKey.ToString(CultureInfo.CurrentUICulture));
                                }
                                MessageBox.Show(string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeNotInGroup), scp.SizeCodeName, scp.SizeCodeID, sgp.SizeGroupName));
                                return null;
                            }
                            else
                            {
                                AddSizesNotInGroup(aSize.SizeKey, ref scp, ref sizeID, ref primarySL, ref secondaryAL, bothHash);
                            }
                        }
                        else
                        {
                            continue;
                        }
                        if (!bothHash.ContainsKey(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID))
                        {
                            bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                        }
                        else
                        {	
                            string newPrimaryBoth = scp.SizeCodePrimary + _dupSizeNameSeparator + scp.SizeCodeID;
                            if (!bothHash.ContainsKey(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID))
                            {
                                bothHash.Add(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID, aSize);
                            }
                            else
                            {
                                throw new MIDException(eErrorLevel.severe, 0, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                            }
                        }  
                    }
                }
            }
            else
            {	// no size group  display in SEQ sequence
                foreach (HdrSizeBin aSize in aColor.ColorSizes.Values)
                {
                    sortedList.Add(aSize.SizeSequence, aSize);
                }
                scl = new SizeCodeList(eProfileType.SizeCode);
                foreach (HdrSizeBin aSize in sortedList.Values)
                {
                    SizeCodeProfile scp = _sab.HierarchyServerSession.GetSizeCodeProfile(aSize.SizeKey);
                    if (scp.Key == Include.NoRID)
                    {
                        throw new MIDException(eErrorLevel.severe, 0,
                            string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeRetrieveError), aSize.SizeKey.ToString(CultureInfo.CurrentUICulture)));
                    }
                    scl.Add(scp);   
                    LoadSizeArraysFromHeader(aSize.SizeKey, ref sizeID, ref primarySL, ref secondaryAL);
                   
                    if (!bothHash.ContainsKey(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID))
                    {
                        bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                    }
                    else
                    {
                        AddSizesNotInGroup(aSize.SizeKey, ref scp, ref sizeID, ref primarySL, ref secondaryAL, bothHash);
                        string newPrimaryBoth = scp.SizeCodePrimary + _dupSizeNameSeparator + scp.SizeCodeID;
                        if (!bothHash.ContainsKey(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID))
                        {
                            bothHash.Add(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID, aSize);
                        }
                        else
                        {
                            throw new MIDException(eErrorLevel.severe, 0, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                        }
                    }   
                }
            }

            if (_addingSizes)
            {
                UpdateColorSizeHash(ap.StyleHnRID, aColorCodeID, sizeID);
            }

            DataTable dtSizes = InitializeSizeTable(tableName, primarySL);
            BuildSizeTableFromArrays(ref dtSizes, false, scl, headerRID, Include.NoRID, colorRID, secondaryAL, bothHash, ref sizeTotal);





            return (dtSizes);
        }

        private DataTable FormatPackSizeTable(PackColorSize aColor, int sizeGroupRID, int headerRID, int packRID, int colorRID, string aColorCodeID, string tableName, ref int sizeTotal)
        {
            System.Collections.ArrayList sizeID = new ArrayList();
            System.Collections.SortedList primarySL = new SortedList();
            System.Collections.ArrayList secondaryAL = new ArrayList();
            System.Collections.Hashtable bothHash = new Hashtable();
            SizeGroupProfile sgp = null;
            sizeTotal = 0;

            AllocationProfile ap = GetAllocationProfile(headerRID);
            SizeCodeList scl = null;
            // is there a size group?
            if (sizeGroupRID > Include.UndefinedSizeGroupRID)
            {
                // load existing group
                sgp = GetSizeGroup(sizeGroupRID);
                scl = sgp.SizeCodeList;

                LoadSizeArraysFromGroup(scl, ref sizeID, ref primarySL, ref secondaryAL);

                if (aColor != null)
                {
                    foreach (PackContentBin aSize in aColor.ColorSizes.Values)
                    {
                        if (scl.Contains(aSize.ContentCodeRID))
                        {
                            SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(aSize.ContentCodeRID);
                            if (!bothHash.ContainsKey(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID))
                            {
                                bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                            }
                            else
                            {
                                throw new MIDException(eErrorLevel.severe, 0, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                            }
                        }
                    }
                    foreach (PackContentBin aSize in aColor.ColorSizes.Values)
                    {
                        // make sure this size is in the group
                        SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(aSize.ContentCodeRID);
                        if (scp == null)
                        {
                            if (!ap.Placeholder)
                            {
                                scp = _sab.HierarchyServerSession.GetSizeCodeProfile(aSize.ContentCodeRID);
                                if (scp.Key == Include.NoRID)
                                {
                                    throw new MIDException(eErrorLevel.severe, 0,
                                          string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeRetrieveError), aSize.ContentCodeRID.ToString(CultureInfo.CurrentUICulture)));
                                }
                                MessageBox.Show(string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeNotInGroup), scp.SizeCodeName, scp.SizeCodeID, sgp.SizeGroupName));
                                return null;
                            }
                            else
                            {
                                AddSizesNotInGroup(aSize.ContentCodeRID, ref scp, ref sizeID, ref primarySL, ref secondaryAL, bothHash);
                            }
                        }
                        if (!bothHash.ContainsKey(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID))
                        {
                            bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                        }
                        else
                        {
                            string newPrimaryBoth = scp.SizeCodePrimary + _dupSizeNameSeparator + scp.SizeCodeID;
                            if (!bothHash.ContainsKey(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID))
                            {
                                bothHash.Add(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID, aSize);
                            }
                            else
                            {
                                throw new MIDException(eErrorLevel.severe, 0, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                            }
                        }  
                    }
                }
            }
            else
            {	// no size group
                SortedList sl = new SortedList();
                foreach(PackContentBin aSize in aColor.ColorSizes.Values)
                {
                    sl.Add(aSize.Sequence, aSize);
                }

                foreach(PackContentBin aSize in sl.Values)
                {
                    SizeCodeProfile scp = _sab.HierarchyServerSession.GetSizeCodeProfile(aSize.ContentCodeRID);
                    if (scp.Key == Include.NoRID)
                    {
                        throw new MIDException(eErrorLevel.severe, 0,
                            string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeRetrieveError), aSize.ContentCodeRID.ToString(CultureInfo.CurrentUICulture)));
                    }
                    LoadSizeArraysFromHeader(aSize.ContentCodeRID, ref sizeID, ref primarySL, ref secondaryAL);

                    if (!bothHash.ContainsKey(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID))
                    {
                        bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                    }
                    else
                    {
                        // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                        string newPrimaryBoth = scp.SizeCodePrimary + _dupSizeNameSeparator + scp.SizeCodeID;
                        if (!bothHash.ContainsKey(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID))
                        {
                            bothHash.Add(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID, aSize);
                        }
                        else
                        {
                            throw new MIDException(eErrorLevel.severe, 0, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                        }
                    }
                }
            }

            if (_addingSizes)
            {
                UpdateColorSizeHash(ap.StyleHnRID, aColorCodeID, sizeID);
            }
            DataTable dtSizes = InitializeSizeTable(tableName, primarySL);
            BuildSizeTableFromArrays(ref dtSizes, true, scl, headerRID, packRID, colorRID, secondaryAL, bothHash, ref sizeTotal);
            return (dtSizes);
        }

        private void UpdateColorSizeHash(int aStyleHnRID, string aColorCodeID, ArrayList aSizeID)
        {
            try
            {
                ArrayList colorSizeAL;
                Hashtable styleColorHash;
                string addSizeID;
                for (int i = 0; i < aSizeID.Count; i++)
                {
                    addSizeID = Convert.ToString(aSizeID[i], CultureInfo.CurrentUICulture);
                    if (!_addedColorSizeHash.ContainsKey(aStyleHnRID))
                    {
                        styleColorHash = new Hashtable();
                        colorSizeAL = new ArrayList();
                        colorSizeAL.Add(addSizeID);
                        styleColorHash.Add(aColorCodeID, colorSizeAL);
                        _addedColorSizeHash.Add(aStyleHnRID, styleColorHash);
                    }
                    else
                    {
                        styleColorHash = (Hashtable)_addedColorSizeHash[aStyleHnRID];
                        if (!styleColorHash.ContainsKey(aColorCodeID))
                        {
                            colorSizeAL = new ArrayList();
                            colorSizeAL.Add(addSizeID);
                            styleColorHash.Add(aColorCodeID, colorSizeAL);
                        }
                        else
                        {
                            colorSizeAL = (ArrayList)styleColorHash[aColorCodeID];
                            if (!colorSizeAL.Contains(addSizeID))
                            {
                                colorSizeAL.Add(addSizeID);
                            }
                        }
                    }
                }
                _addingSizes = false;
            }
            catch
            {
                throw;
            }
        }

        private DataTable InitializeSizeTable(string aTableName, SortedList aPrimarySL)
        {
            try
            {
                DataTable dtSizes = MIDEnvironment.CreateDataTable(aTableName);
                dtSizes.Columns.Add("KeyH", System.Type.GetType("System.Int32"));
                dtSizes.Columns.Add("KeyP", System.Type.GetType("System.Int32"));
                dtSizes.Columns.Add("KeyC", System.Type.GetType("System.Int32"));
                dtSizes.Columns.Add("SecondaryRID", System.Type.GetType("System.Int32"));
                dtSizes.Columns.Add("Secondary");
                dtSizes.Columns.Add(" - ");
                dtSizes.Columns.Add("TotalQuantity", System.Type.GetType("System.Int32"));

                foreach (int seq in aPrimarySL.Keys)
                {
                    string[] sizeParts = aPrimarySL[seq].ToString().Split(new char[] { '~' });
                    string colName = sizeParts[0];
                    int primaryRID = Convert.ToInt32(sizeParts[1], CultureInfo.CurrentUICulture);
                    if (dtSizes.Columns.Contains(colName))
                    {
                        colName += _dupSizeNameSeparator + Convert.ToString(sizeParts[2], CultureInfo.CurrentUICulture);
                    }
                    dtSizes.Columns.Add(colName);
                    dtSizes.Columns[colName].DataType = System.Type.GetType("System.Int32");
                    dtSizes.Columns[colName].ExtendedProperties.Add("PrimaryRID", primaryRID);
                }
                return dtSizes;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return null;
            }
        }

        private void BuildSizeTableFromArrays(ref DataTable dtSizes, bool aPackSizes, SizeCodeList aSizeCodeList, int aHeaderRID, int aPackRID, int aColorRID, ArrayList aSecondaryAL, Hashtable aBothHash, ref int aSizeTotal)
        {
            try
            {
                foreach (string secondary in aSecondaryAL)
                {
                    string[] secondaryParts = secondary.ToString().Split(new char[] { '~' });
                    string secondaryName = secondaryParts[0];
                    int secondaryRID = Convert.ToInt32(secondaryParts[1], CultureInfo.CurrentUICulture);
                    int total = 0;
                    DataRow dRow = dtSizes.NewRow();
                    dRow["KeyH"] = aHeaderRID;
                    dRow["KeyP"] = aPackRID;
                    dRow["KeyC"] = aColorRID;
                    dRow["SecondaryRID"] = secondaryRID;
                    dRow["Secondary"] = secondaryName;

                    if (secondaryName == Include.NoSecondarySize || secondaryName.Trim() == string.Empty || secondaryName.Trim() == _noSizeDimensionLbl)
                    {
                        dRow[" - "] = _lblQuantity;
                    }
                    else
                    {
                        dRow[" - "] = secondaryName;
                    }

                    dRow["TotalQuantity"] = 0;

                    for (int i = 7; i < dtSizes.Columns.Count; i++)
                    {
                        DataColumn dCol = dtSizes.Columns[i];
                        string primary = dCol.ColumnName;

                        if (aBothHash.Contains(primary + "~" + secondaryRID))
                        {
                            if (aPackSizes)
                            {
                                total += ((PackContentBin)aBothHash[primary + "~" + secondaryRID]).ContentUnits;
                                dRow[dCol] = ((PackContentBin)aBothHash[primary + "~" + secondaryRID]).ContentUnits;
                                dCol.ExtendedProperties.Add(primary + "~" + secondaryRID, ((PackContentBin)aBothHash[primary + "~" + secondaryRID]).ContentCodeRID);
                            }
                            else
                            {
                                total += ((HdrSizeBin)aBothHash[primary + "~" + secondaryRID]).SizeUnitsToAllocate;
                                dRow[dCol] = ((HdrSizeBin)aBothHash[primary + "~" + secondaryRID]).SizeUnitsToAllocate;
                                dCol.ExtendedProperties.Add(primary + "~" + secondaryRID, ((HdrSizeBin)aBothHash[primary + "~" + secondaryRID]).SizeKey);
                            }
                        }
                        else
                        {
                            dRow[dCol] = 0;
                            if (aSizeCodeList == null)
                            {
                                //SizeGroup sizeData = new SizeGroup();
                                //DataTable dtGetSize = sizeData.GetSizeForPrimarySecondary(primary, secondary);
                                //if (dtGetSize != null && dtGetSize.Rows.Count > 0)
                                //{
                                //    DataRow row = dtGetSize.Rows[0];
                                //    dCol.ExtendedProperties.Add(primary + "~" + secondary, row["SIZE_CODE_RID"]);
                                //}
                                //else
                                //{
                                //    dtGetSize = sizeData.GetSizeForPrimarySecondary(primary, Include.NoSecondarySize);
                                //    if (dtGetSize != null && dtGetSize.Rows.Count > 0)
                                //    {
                                //        DataRow row = dtGetSize.Rows[0];
                                //        dCol.ExtendedProperties.Add(primary + "~" + secondary, row["SIZE_CODE_RID"]);
                                //    }
                                //}
                            }
                            else
                            {
                                SizeCodeProfile scp = null;
                                bool foundSize = false;
                                for (int j = 0; j < aSizeCodeList.ArrayList.Count; j++)
                                {
                                    scp = (SizeCodeProfile)aSizeCodeList.ArrayList[j];
                                    if (scp.SizeCodePrimary == primary && scp.SizeCodeSecondaryRID == secondaryRID)
                                    {
                                        dCol.ExtendedProperties.Add(primary + "~" + secondaryRID, scp.Key);
                                        foundSize = true;
                                        break;
                                    }
                                }
                                if (scp == null || !foundSize)
                                {
                                    SizeGroup sizeData = new SizeGroup();
                                    DataTable dtGetSize = sizeData.GetSizeForPrimarySecondary(primary, secondaryName);
                                    if (dtGetSize != null && dtGetSize.Rows.Count > 0)
                                    {
                                        DataRow row = dtGetSize.Rows[0];
                                        dCol.ExtendedProperties.Add(primary + "~" + secondaryRID, row["SIZE_CODE_RID"]);
                                        foundSize = true;
                                    }
                                    else
                                    {
                                        dtGetSize = sizeData.GetSizeForPrimarySecondary(primary, Include.NoSecondarySize);
                                        if (dtGetSize != null && dtGetSize.Rows.Count > 0)
                                        {
                                            DataRow row = dtGetSize.Rows[0];
                                            dCol.ExtendedProperties.Add(primary + "~" + secondaryRID, row["SIZE_CODE_RID"]);
                                            foundSize = true;
                                        }
                                    }
                                    if (!foundSize)
                                    {
                                        dCol.ExtendedProperties.Add(primary + "~" + secondaryRID, Include.NoRID);
                                    }
                                }
                            }
                        }
                    }
                    dRow["TotalQuantity"] = total;
                    aSizeTotal += total;
                    dtSizes.Rows.Add(dRow);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        private void LoadSizeArraysFromGroup(SizeCodeList aScl, ref ArrayList aSizeID, ref SortedList aPrimarySL, ref ArrayList aSecondaryAL)
        {
            try
            {
                foreach(SizeCodeProfile scp in aScl.ArrayList)
                {
                    if (scp.Key == Include.NoRID)
                    {
                        throw new MIDException(eErrorLevel.severe,
                            (int)eMIDTextCode.msg_CantRetrieveSizeCode,
                            MIDText.GetText(eMIDTextCode.msg_CantRetrieveSizeCode));
                    }

                    if (!aSizeID.Contains(scp.SizeCodeID))
                    {
                        aSizeID.Add(scp.SizeCodeID);		// SizeCodeID is used by the hierarachy QuickAdd
                    }
                    if (!aPrimarySL.ContainsValue(scp.SizeCodePrimary + "~" + scp.SizeCodePrimaryRID))
                    {
                        aPrimarySL.Add(scp.PrimarySequence, scp.SizeCodePrimary + "~" + scp.SizeCodePrimaryRID);
                    }
                    if (!aSecondaryAL.Contains(scp.SizeCodeSecondary + "~" + scp.SizeCodeSecondaryRID))
                    {
                        aSecondaryAL.Add(scp.SizeCodeSecondary + "~" + scp.SizeCodeSecondaryRID);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private SizeGroupProfile GetSizeGroup(int aSizeGroupRID)
        {
            if (_sizeGroupHashLastKey != aSizeGroupRID)
            {
                _sizeGroupHashLastKey = aSizeGroupRID;
                if (_sizeGroupHash == null)
                {
                    _sizeGroupHash = new Hashtable();
                }
                if (_sizeGroupHash.Contains(aSizeGroupRID))
                {
                    _sizeGroupHashLastValue = (SizeGroupProfile)_sizeGroupHash[aSizeGroupRID];
                }
                else
                {
                    _sizeGroupHashLastValue = new SizeGroupProfile(aSizeGroupRID);
                    _sizeGroupHash.Add(aSizeGroupRID, _sizeGroupHashLastValue);
                }
            }
            return _sizeGroupHashLastValue;
        }

        private void AddSizesNotInGroup(int aSizeKey, ref SizeCodeProfile aScp, ref ArrayList aSizeID, ref SortedList aPrimarySL, ref ArrayList aSecondaryAL, Hashtable aBothHash)
        {
            try
            {
                aScp = _sab.HierarchyServerSession.GetSizeCodeProfile(aSizeKey);
                if (aScp.Key == Include.NoRID)
                {
                    throw new MIDException(eErrorLevel.severe, 0,
                            string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeRetrieveError), aSizeKey.ToString(CultureInfo.CurrentUICulture)));
                }
                if (!aSizeID.Contains(aScp.SizeCodeID))
                {
                    aSizeID.Add(aScp.SizeCodeID);
                }

                // scp.PrimarySequnce is not valid here so increment the count
                int seq = aPrimarySL.Count;
                if (!aPrimarySL.ContainsValue(aScp.SizeCodePrimary + "~" + aScp.SizeCodePrimaryRID))
                {
                    seq++;
                    aPrimarySL.Add(seq, aScp.SizeCodePrimary + "~" + aScp.SizeCodePrimaryRID);
                }
                else if (aBothHash.Contains(aScp.SizeCodePrimary + "~" + aScp.SizeCodeSecondaryRID))
                {
                    if (!aPrimarySL.ContainsValue(aScp.SizeCodePrimary + "~" + aScp.SizeCodePrimaryRID + "~" + aScp.SizeCodeID))
                    {
                        seq++;
                        aPrimarySL.Add(seq, aScp.SizeCodePrimary + "~" + aScp.SizeCodePrimaryRID + "~" + aScp.SizeCodeID);
                    }
                }
              
                if (!aSecondaryAL.Contains(aScp.SizeCodeSecondary + "~" + aScp.SizeCodeSecondaryRID))
                {
                    aSecondaryAL.Add(aScp.SizeCodeSecondary + "~" + aScp.SizeCodeSecondaryRID);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void LoadSizeArraysFromHeader(int aSizeKey, ref ArrayList aSizeID, ref SortedList aPrimarySL, ref ArrayList aSecondaryAL)
        {
            try
            {
                SizeCodeProfile scp = _sab.HierarchyServerSession.GetSizeCodeProfile(aSizeKey);
                if (scp.Key == Include.NoRID)
                {
                    throw new MIDException(eErrorLevel.severe, 0,
                            string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeRetrieveError), aSizeKey.ToString(CultureInfo.CurrentUICulture)));
                }
                if (!aSizeID.Contains(scp.SizeCodeID))
                {
                    aSizeID.Add(scp.SizeCodeID);
                }
                // scp.PrimarySequnce is not valid here so increment the count
                int seq = aPrimarySL.Count;
                if (!aPrimarySL.ContainsValue(scp.SizeCodePrimary + "~" + scp.SizeCodePrimaryRID))
                {
                    seq++;
                    aPrimarySL.Add(seq, scp.SizeCodePrimary + "~" + scp.SizeCodePrimaryRID);
                }
                if (!aSecondaryAL.Contains(scp.SizeCodeSecondary + "~" + scp.SizeCodeSecondaryRID))
                {
                    aSecondaryAL.Add(scp.SizeCodeSecondary + "~" + scp.SizeCodeSecondaryRID);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool SaveAddedColorsSizes()
        {
            HierarchyMaintenance hierMaint = new HierarchyMaintenance(_sab);
            HierarchyNodeProfile hnpStyle;
            EditMsgs editMsg = new EditMsgs();
            ArrayList colorSizeAL;
            Hashtable styleColorHash;
            int sizeNodeRID = Include.NoRID;
            bool processOK = true;
            try
            {
                foreach (int styleRID in _addedColorSizeHash.Keys)
                {
                    hnpStyle = _sab.HierarchyServerSession.GetNodeData(styleRID);
                    if (hnpStyle.Key > 0)
                    {
                        int colorNodeRID = Include.NoRID;

                        styleColorHash = (Hashtable)_addedColorSizeHash[styleRID];
                        foreach (string colorCodeID in styleColorHash.Keys)
                        {    // add color to style if it somehow does not exist
                            if (!_sab.HierarchyServerSession.ColorExistsForStyle(hnpStyle.HomeHierarchyRID, hnpStyle.Key, colorCodeID, ref colorNodeRID))
                            {
                                colorNodeRID = hierMaint.QuickAdd(ref editMsg, hnpStyle.Key, colorCodeID);
                                if (editMsg.ErrorFound)
                                {
                                    DisplayMessages.Show(editMsg, _sab, _windowName);
                                    processOK = false;
                                    break;
                                }
                            }
                            colorSizeAL = (ArrayList)styleColorHash[colorCodeID];
                            foreach (string sizeID in colorSizeAL)
                            {
                                sizeNodeRID = hierMaint.QuickAdd(ref editMsg, colorNodeRID, sizeID);
                                if (editMsg.ErrorFound)
                                {
                                    DisplayMessages.Show(editMsg, _sab, _windowName);
                                    processOK = false;
                                    break;
                                }
                            }
                            if (!processOK)
                            {
                                break;
                            }
                        }
                    }
                    if (!processOK)
                    {
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
            return processOK;
        }

        #endregion

        #region Set Edit Mode
        private void SetEditMode()
        {
            try
            {
                
               
                _assortmentsSaved = null;
                if (_assortments.Rows.Count > 0)
                {
                    _assortmentsSaved = _assortments.Copy();
                }
                _placeHoldersSaved = null;
                if (_placeHolders.Rows.Count > 0)
                {
                    _placeHoldersSaved = _placeHolders.Copy();
                }

                _anchorNodes.Clear();
                _removedAsrtHeaders.Clear();

                // Begin TT#3823 - RMatelic - GA Header selection is confusing
                //ugDetails.DisplayLayout.Override.CellClickAction = Infragistics.Win.UltraWinGrid.CellClickAction.EditAndSelectText;
                // Begin  TT#1259-MD - stodd - Change headers selection in assortment to match header selection in group allocation. That is, clicking anywhere in the row, selects the row.
                //if (IsAssortment)
                //{
                //    ugDetails.DisplayLayout.Override.CellClickAction = Infragistics.Win.UltraWinGrid.CellClickAction.EditAndSelectText;
                //}
                // End  TT#1259-MD - stodd - Change headers selection in assortment to match header selection in group allocation. That is, clicking anywhere in the row, selects the row.
                // End TT#3823
 
                _inEditMode = true;

                SetEditActivation();

                if (ugDetails.Rows.Count == 0)
                {
                    _dsDetails.Clear();
                    BindDetailsGrid();
                }
                else
                {
                    if (ugDetails.Selected.Rows.Count > 0)
                    {
                        ugDetails.ActiveRow = ugDetails.Selected.Rows[0];
                    }
                    else
                    {
                        for (int i = 0; i < ugDetails.Rows.Count; i++)
                        {
                            if (!ugDetails.Rows[i].Hidden)
                            {
                                ugDetails.ActiveRow = ugDetails.Rows[i];
                                break;
                            }
                        }
                    }
                    ugDetails.ActiveCell = null;
                    // Begin TT#441-MD - RMatelic - Placeholder fields are not editable  >>> unrelated; HeaderID appeared to be editable but was not  
                    //if (ugDetails.ActiveRow != null)
                    //{
                    //    for (int i = 3; i < ugDetails.ActiveRow.Cells.Count; i++)
                    //    {
                    //        UltraGridCell cell = ugDetails.ActiveRow.Cells[i];
                    //        if (!cell.Column.Hidden && cell.Column.CellActivation == Activation.AllowEdit)
                    //        {
                    //            ugDetails.ActiveCell = cell;
                    //            break;
                    //        }
                    //    }
                    //}
                    // End TT#441-MD
                    ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                }

                _deletedHeaderRows.Clear();
                _addedColorSizeHash.Clear();

                //cmsSave.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Button_Save);
                //cmsCancel.Visible = true;
                //btnRestoreLayout.Enabled = false;
                
                //_inEditMode = true;

                //SetFileSaveMenuItem(true);      // MID Track #5501 - File>Save not implemented
            }
            catch
            {
                throw;
            }
        }

        private void SetEditActivation()
        {
            try
            {
                foreach (UltraGridRow uRow in ugDetails.Rows)
                {
                    SetEditActivation(uRow);
                }
            }
            catch
            {
                throw;
            }
        }

        private void SetEditActivation(UltraGridRow aRow)
        {
            bool allowUpdate = false;
            //bool allocationStarted;
            //bool workUpTotalBuy;
            int styleRID;
            AllocationProfile ap = null;
            try
            {
                ap = GetAllocationProfile(Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));

                eHeaderAllocationStatus headerStatus = (eHeaderAllocationStatus)Convert.ToInt32(aRow.Cells["Status"].Value, CultureInfo.CurrentUICulture);
                eHeaderType headerType = (eHeaderType)Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                //allocationStarted = ap.AllocationStarted;
                //workUpTotalBuy = ap.WorkUpTotalBuy;

                aRow.Activation = Activation.AllowEdit;
                aRow.Cells["HeaderID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;

                // Begin TT#441-MD - RMatelic - Placeholder fields are not editable  >>> GA Placeholders are hidden
                //if (headerType == eHeaderType.Assortment)
                if (headerType == eHeaderType.Assortment || aRow.Hidden)
                // End TT#441-MD
                {
                    return; // Assortment rows are not displayed
                }
                if (headerType == eHeaderType.Placeholder)
                {
                    allowUpdate = AllowPlaceholderUpdate(aRow);
                }

                if (headerType == eHeaderType.Placeholder)
                {
                    // Begin TT#441-MD - RMatelic - Placeholder fields are not editable  >>> next line is a duplcate of above so comment out
                    //allowUpdate = AllowPlaceholderUpdate(aRow);
                    // End TT#441-MD
                    aRow.Cells["FirstHeaderInd"].Activation = Activation.NoEdit;	// TT#1130 - md - stodd - mark first header - 
                    aRow.Cells["HeaderID"].Activation = Activation.NoEdit;
                    // Don't display the Placeholder HeaderID value
                    aRow.Cells["HeaderID"].Appearance.ForeColor = aRow.Band.Layout.Override.FixedCellAppearance.BackColor;
                    aRow.Cells["HeaderID"].SelectedAppearance.BackColor = aRow.Band.Layout.Override.FixedCellAppearance.BackColor;
					// BEGIN TT#775-MD - Stodd - Header ID field is populated with Placeholder ID when selected
                    //aRow.Cells["HeaderID"].SelectedAppearance.ForeColor = aRow.Band.Layout.Override.FixedCellAppearance.BackColor;

					aRow.Cells["HeaderID"].SelectedAppearance.ForeColor = Color.Transparent;
					aRow.Cells["HeaderID"].ActiveAppearance.ForeColor = Color.Transparent;
					// END TT#775-MD - Stodd - Header ID field is populated with Placeholder ID when selected


                    aRow.Cells["HeaderID"].CellDisplayStyle = CellDisplayStyle.PlainText;
                    aRow.Cells["Type"].Activation = Activation.NoEdit;
                    aRow.Cells["Date"].Activation = Activation.NoEdit;
                    aRow.Cells["AnchorNode"].Activation = Activation.NoEdit;

                    if (allowUpdate)
                    {
                        // Begin TT#441-MD - RMatelic - Placeholder fields are not editable
                        ugDetails.DisplayLayout.Override.CellClickAction = Infragistics.Win.UltraWinGrid.CellClickAction.EditAndSelectText;
                        // End TT#441-MD 
                        SetNotesCellButton(aRow, true);
                        //styleRID = Convert.ToInt32(aRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                        //HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(styleRID);
                        //if (hnp.IsVirtual)
                        //{
                        //    aRow.Cells["Product"].Activation = Activation.AllowEdit;
                        //    aRow.Cells["Style"].Activation = Activation.AllowEdit;
                        //}
                        //else
                        if (HeaderAttachedToPlaceHolder(aRow))
                        {
                            aRow.Cells["Product"].Activation = Activation.NoEdit;
                            aRow.Cells["Style"].Activation = Activation.NoEdit;
                        }
                        else
                        {
                            aRow.Cells["Product"].Activation = Activation.AllowEdit;
                            aRow.Cells["Style"].Activation = Activation.AllowEdit;
                        }
                        aRow.Cells["Description"].Activation = Activation.AllowEdit;
                        //aRow.Cells["HdrQuantity"].Activation = Activation.AllowEdit;   
                        // Begin  TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
                        //aRow.Cells["UnitRetail"].Activation = Activation.AllowEdit;
                        //aRow.Cells["UnitCost"].Activation = Activation.AllowEdit;
                        SetCellActivation(aRow);
                        // End TT#1498-MD
                        aRow.Cells["SizeGroup"].Activation = Activation.AllowEdit;
                        aRow.Cells["UnitRetail"].Activation = Activation.AllowEdit;  // TT#1975-MD - AGallagher  - Content Tab - Unit Retail and Cost are not editable
                        aRow.Cells["UnitCost"].Activation = Activation.AllowEdit;    // TT#1975-MD - AGallagher  - Content Tab - Unit Retail and Cost are not editable
                        aRow.Cells["Multiple"].Activation = Activation.AllowEdit;
                        aRow.Cells["PO"].Activation = Activation.AllowEdit;
                        aRow.Cells["Vendor"].Activation = Activation.AllowEdit;
                        aRow.Cells["Workflow"].Activation = Activation.NoEdit;
                        aRow.Cells["DC"].Activation = Activation.AllowEdit;
                    }
                    else
                    {
                        //aRow.Cells["HeaderID"].Appearance.ForeColor = aRow.Cells["HeaderID"].Appearance.ForeColorDisabled;
                        //aRow.Cells["AnchorNode"].Activation = Activation.NoEdit;
                        SetNotesCellButton(aRow, false);
                        aRow.Cells["Product"].Activation = Activation.NoEdit;
                        aRow.Cells["Style"].Activation = Activation.NoEdit;
                        aRow.Cells["Description"].Activation = Activation.NoEdit;
                        //aRow.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                        aRow.Cells["UnitRetail"].Activation = Activation.NoEdit;
                        aRow.Cells["UnitCost"].Activation = Activation.NoEdit;
                        aRow.Cells["SizeGroup"].Activation = Activation.NoEdit;
                        aRow.Cells["Multiple"].Activation = Activation.NoEdit;
                        aRow.Cells["PO"].Activation = Activation.NoEdit;
                        aRow.Cells["Vendor"].Activation = Activation.NoEdit;
                        aRow.Cells["Workflow"].Activation = Activation.NoEdit;
                        aRow.Cells["DC"].Activation = Activation.NoEdit;
                    }
                }
                else    // non-placeholder
                {
                    aRow.Cells["FirstHeaderInd"].Activation = Activation.NoEdit;	// TT#1130 - md - stodd - mark first header - 
                    aRow.Cells["HeaderID"].Activation = Activation.ActivateOnly;
                    aRow.Cells["HeaderID"].Appearance.ForeColor = aRow.Cells["HeaderID"].Appearance.ForeColorDisabled;
                    SetNotesCellButton(aRow, false);
                    // Begin TT#1083 - MD - stodd - fields are editable - 
                    aRow.Cells["Status"].Activation = Activation.NoEdit;
                    aRow.Cells["AsrtRID"].Activation = Activation.NoEdit;
                    aRow.Cells["Balance"].Activation = Activation.NoEdit;
                    aRow.Cells["AllocatedUnits"].Activation = Activation.NoEdit;
                    // End TT#1083 - MD - stodd - fields are editable - 
                    aRow.Cells["Type"].Activation = Activation.NoEdit;
                    aRow.Cells["Date"].Activation = Activation.NoEdit;
                    aRow.Cells["AnchorNode"].Activation = Activation.NoEdit;
                    aRow.Cells["Product"].Activation = Activation.NoEdit;
                    aRow.Cells["Style"].Activation = Activation.NoEdit;
                    aRow.Cells["Description"].Activation = Activation.NoEdit;
                    aRow.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                    aRow.Cells["UnitRetail"].Activation = Activation.NoEdit;
                    aRow.Cells["UnitCost"].Activation = Activation.NoEdit;
                    aRow.Cells["SizeGroup"].Activation = Activation.NoEdit;
                    aRow.Cells["Multiple"].Activation = Activation.NoEdit;
                    aRow.Cells["PO"].Activation = Activation.NoEdit;
                    aRow.Cells["Vendor"].Activation = Activation.NoEdit;
                    aRow.Cells["Workflow"].Activation = Activation.NoEdit;
                    aRow.Cells["APIWorkflow"].Activation = Activation.NoEdit;
                    aRow.Cells["DC"].Activation = Activation.NoEdit;
                    // Begin TT#1083 - MD - stodd - fields are editable - 
                    aRow.Cells["Intransit"].Activation = Activation.NoEdit;
                    aRow.Cells["ShipStatus"].Activation = Activation.NoEdit;
                    aRow.Cells["Release"].Activation = Activation.NoEdit;
                    aRow.Cells["ChildTotal"].Activation = Activation.NoEdit;
                    aRow.Cells["Master"].Activation = Activation.NoEdit;
                    aRow.Cells["OrigAllocatedUnits"].Activation = Activation.NoEdit;
                    aRow.Cells["RsvAllocatedUnits"].Activation = Activation.NoEdit;
                    // End TT#1083 - MD - stodd - fields are editable - 
                }

                foreach (UltraGridColumn col in aRow.Band.Columns)
                {
                    if (col.Tag != null && col.Tag.GetType() == typeof(HeaderCharGroupProfile))
                    {
                        HeaderCharGroupProfile hcgp = (HeaderCharGroupProfile)col.Tag;
                        if (hcgp.ProtectInd || !_allocationNonInterfacedHeadersSecurity.AllowUpdate || IsGroupAllocation)   // TT#1083 - MD - stodd - fields are editable - 
                        {
                            aRow.Cells[hcgp.ID].Activation = Activation.NoEdit;
                        }
                        else
                        {
                            // Begin TT#441-MD - RMatelic - Placeholder fields are not editable >>> this applies to both headers and placeholders
                            aRow.Cells[hcgp.ID].Column.CellClickAction = CellClickAction.EditAndSelectText;
                            // End TT#441-MD
                            aRow.Cells[hcgp.ID].Activation = Activation.AllowEdit;
                        }
                    }
                }

                if (aRow.HasChild())
                {
                    UltraGridRow childRow = aRow.GetChild(ChildRow.First);
                    while (childRow != null)
                    {
                        SetChildRowActivation(childRow, allowUpdate);
                        childRow = childRow.GetSibling(SiblingRow.Next, true);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }


        // Begin  TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
        private void SetCellActivation()
        {
            try
            {
                
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (headerType == eHeaderType.Assortment || row.Hidden)
                    {
                        continue;
                    }
                    else if (headerType == eHeaderType.Placeholder)
                    {
                        bool allowUpdate = AllowPlaceholderUpdate(row);
                        if (allowUpdate)
                        {
                            SetCellActivation(row);
                        }
                    }
                }

            }
            catch
            {
                throw;
            }
        }
        private void SetCellActivation(UltraGridRow aRow)
        {
            try
            {
                int unitRetailCol = 0;
                int unitCostCol = 0;
                List<int> unitRetailColList = new List<int>();
                List<int> unitCostColList = new List<int>();
                if (isColumnOnTotalGrid(_lblUnitRetail, ref unitRetailCol) && isColumnOnDetailGrid(_lblUnitRetail, ref unitRetailColList))
                {
                    aRow.Cells["UnitRetail"].Activation = Activation.AllowEdit;
                }
                else
                {
                    aRow.Cells["UnitRetail"].Activation = Activation.NoEdit;
                }
                if (isColumnOnTotalGrid(_lblUnitCost, ref unitCostCol) && isColumnOnDetailGrid(_lblUnitCost, ref unitCostColList))
                {
                    aRow.Cells["UnitCost"].Activation = Activation.AllowEdit;
                }
                else
                {
                    aRow.Cells["UnitCost"].Activation = Activation.NoEdit;
                }
            }
            catch
            {
                throw;
            }

        }        
        // End TT#1498-MD
        private void SetChildRowActivation(UltraGridRow aRow, bool aAllowUpdate)
        {
            string bandKey = aRow.Band.Key;
            string[] bandKeyParts = bandKey.Split(new char[] { '~' });
            try
            {
                aRow.Activation = Activation.AllowEdit;
                switch (bandKeyParts[0])
                {
                    case "Pack":
                        SetPackRowActivation(aRow, aAllowUpdate);
                        break;

                    case "PackColor":
                        SetPackColorRowActivation(aRow, aAllowUpdate);
                        break;

                    case "BulkColor":
                        SetBulkColorRowActivation(aRow, aAllowUpdate);
                        break;

                    case "BulkSize":
                    case "PackSize":
                    case "PackColorSize":
                        SetSizeRowActivation(aRow, aAllowUpdate);
                        break;

                    default:
                        break;
                }

                if (aRow.HasChild(false))
                {
                    UltraGridRow cRow = aRow.GetChild(ChildRow.First);
                    while (cRow != null)
                    {
                        SetChildRowActivation(cRow, aAllowUpdate);
                        cRow = cRow.GetSibling(SiblingRow.Next, true, false);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetPackRowActivation(UltraGridRow aRow, bool aAllowUpdate)
        {
            try
            {
                if (aAllowUpdate)
                {
                    aRow.Cells["Pack"].Activation = Activation.AllowEdit;
                    aRow.Cells["PackType"].Activation = Activation.AllowEdit;                    
                }
                else
                {
                    aRow.Cells["Pack"].Activation = Activation.NoEdit;
                    aRow.Cells["PackType"].Activation = Activation.NoEdit;
                }
                aRow.Cells["TotalPacks"].Activation = Activation.NoEdit;        // always disallow quantity change
                aRow.Cells["QuantityPerPack"].Activation = Activation.NoEdit;
                aRow.Cells["Balance"].Activation = Activation.NoEdit;  // TT#1083 - MD - stodd - fields are editable - 
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetPackColorRowActivation(UltraGridRow aRow, bool aAllowUpdate)
        {
            try
            {
                if (aAllowUpdate)
                {
                    aRow.Cells["PackColor"].Activation = Activation.AllowEdit;
                    aRow.Cells["PackColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                    aRow.Cells["Description"].Activation = Activation.AllowEdit;
                }
                else
                {
                    aRow.Cells["PackColor"].Activation = Activation.NoEdit;
                    aRow.Cells["Description"].Activation = Activation.NoEdit;
                }
                aRow.Cells["QuantityPerPack"].Activation = Activation.NoEdit; // always disallow quantity change
                aRow.Cells["Balance"].Activation = Activation.NoEdit;  // TT#1083 - MD - stodd - fields are editable - 
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetBulkColorRowActivation(UltraGridRow aRow, bool aAllowUpdate)
        {
            try
            {
                if (aAllowUpdate)
                {
                    aRow.Cells["BulkColor"].Activation = Activation.AllowEdit;
                    aRow.Cells["BulkColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                    aRow.Cells["Description"].Activation = Activation.AllowEdit;
                }
                else
                {
                    aRow.Cells["BulkColor"].Activation = Activation.NoEdit;
                    aRow.Cells["Description"].Activation = Activation.NoEdit;
                }
                aRow.Cells["Quantity"].Activation = Activation.NoEdit;  // always disallow quantity change
                aRow.Cells["Balance"].Activation = Activation.NoEdit;  // TT#1083 - MD - stodd - fields are editable - 
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetSizeRowActivation(UltraGridRow aRow, bool aAllowUpdate)
        {
            try
            {
                for (int i = 7; i < aRow.Cells.Count; i++)
                {
                    if (!aAllowUpdate)
                    {
                        aRow.Cells[i].Activation = Activation.NoEdit;
                    }
                    else if (Convert.ToInt32(aRow.Cells[i].Tag, CultureInfo.CurrentUICulture) == Include.NoRID)
                    {
                        aRow.Cells[i].Activation = Activation.Disabled;
                    }
                    else
                    {
                        aRow.Cells[i].Activation = Activation.AllowEdit;  
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool AllowPlaceholderUpdate(UltraGridRow aRow)
        {
            bool allowHeaderUpdate = false;
            try
            {
				// Begin TT#997 - MD - stodd - Enqueue check in group allocation requests a single hdr, but checks them all
                int hdrRid = Convert.ToInt32(aRow.Cells["KeyH"].Value);
				// BEGIN Stodd - 4.0 to 4.1 Manual merge
                //if (_assortmentSecurity.IsReadOnly || !_transaction.HeadersEnqueued)
				string enqMessage = string.Empty;
				//BEGIN TT#9-MD - DOConnell - Cannot drag and drop header into assortment
                AllocationHeaderProfileList allocProfileList = (AllocationHeaderProfileList)_transaction.GetMasterProfileList(eProfileType.AllocationHeader);
                AllocationHeaderProfile ahp = (AllocationHeaderProfile)allocProfileList.FindKey(hdrRid);
                //AllocationHeaderProfileList ahpl = new AllocationHeaderProfileList(eProfileType.AllocationHeader);
                List<int> hdrKeyList = new List<int>();
                if (ahp != null)
                {
                    //ahpl.Add(ahp);
                    hdrKeyList.Add(ahp.Key);
                }

                if (ahp == null && hdrRid > Include.NoRID)     // TT#1005 - md - stodd New placeholder's have a hdrRid of -1
                {
                    allowHeaderUpdate = false;
                }
                // Begin TT#441-MD - RMatelic - Placeholder fields are not editable >>> unrelated; wrong security level was being checked
                //else if (_assortmentSecurity.IsReadOnly || !_transaction.AreHeadersEnqueued(hdrKeyList))
                else if (_assortReviewContentSecurity.IsReadOnly  || !_transaction.AreHeadersEnqueued(hdrKeyList))
                // End TT#441-MD
                //else if (_assortmentSecurity.IsReadOnly || !_transaction.AreHeadersEnqueued(allocProfileList))
				// End TT#997 - MD - stodd - Enqueue check in group allocation requests a single hdr, but checks them all
				//if (_assortmentSecurity.IsReadOnly || !_transaction.EnqueueSelectedHeaders(out enqMessage))
                {
                    allowHeaderUpdate = false;
                }
				// END Stodd - 4.0 to 4.1 Manual merge
				//END TT#9-MD - DOConnell - Cannot drag and drop header into assortment 
                //else if (Convert.ToInt32(aRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.ReleaseApproved ||
                //    Convert.ToInt32(aRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.Released ||
                //   (aRow.Cells["Intransit"].Value != DBNull.Value &&
                //      Convert.ToInt32(aRow.Cells["Intransit"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderIntransitStatus.NotIntransit))
                else if (Convert.ToInt32(aRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.ReleaseApproved ||
                         Convert.ToInt32(aRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.Released)
               
                // TODO: Add ChargeCommitted
                {
                    allowHeaderUpdate = false;
                }
                else
                {
                    if (Convert.ToBoolean(aRow.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture))
                    {
                        if (_sab.ClientServerSession.GlobalOptions.ProtectInterfacedHeadersInd)
                        {
                            allowHeaderUpdate = false;
                        }
                        else
                        {
                            allowHeaderUpdate = _allocationInterfacedHeadersSecurity.AllowUpdate;
                        }
                    }
                    else	// not Interfaced
                    {
                        allowHeaderUpdate = _allocationNonInterfacedHeadersSecurity.AllowUpdate;
                    }
                }
                return allowHeaderUpdate;
            }
            catch
            {
                throw;
            }
        }

        #endregion

        #region Validation Methods

        private bool PackNameEntered(UltraGridRow aRow)
        {
            UltraGridCell cell = aRow.Cells["Pack"];
            string errorMessage = string.Empty;
            try
            {
                if (!RequiredFieldEntered(cell, ref errorMessage))
                {
                    MessageBox.Show(errorMessage, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return false;
                }
                else
                    return true;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private int GetAnchorNodeKey(string anchorID)
        {
            try
            {
                string errorMessage1 = string.Format
                    (MIDText.GetText(eMIDTextCode.msg_MustBeCorrectLevel),
                    _lblHierarchyNode);

                string errorMessage2 = string.Format
                    (MIDText.GetText(eMIDTextCode.msg_Data1NotValidData2),
                    anchorID, _lblHierarchyNode);

                if (anchorID.Trim() == string.Empty)
                {
                    MessageBox.Show(errorMessage1, this.Text);
                    return -1;
                }
                HierarchyNodeProfile anchorHnp = _sab.HierarchyServerSession.GetNodeData(anchorID);
                if (anchorHnp.Key == -1)
                {
                    string errorMessage3 = errorMessage2 + Environment.NewLine + errorMessage1;
                    MessageBox.Show(errorMessage3, this.Text);
                    return -1;
                }

                if (anchorHnp.HomeHierarchyLevel >= _hlpStyle.Level)
                {
                    string errorMessage3 = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_InvalideAnchorNodeLevel);
                    MessageBox.Show(errorMessage3, this.Text);
                    return -1;
                }
                return anchorHnp.Key;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return -1;
            }
        }

        private bool ValidAssortmentLink(UltraGridRow aRow, int aPhAnchorKey)
        {
            bool isValidLink = false;
            try
            {   //TODO must ancestorally link to assortment row anchor node 
                int asrtAnchorKey = Include.NoRID;
                int asrtRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (row.Cells["AsrtRID"].Value != DBNull.Value
                     && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == asrtRID)
                    {
                        asrtAnchorKey = Convert.ToInt32(row.Cells["AnchorHnRID"].Value, CultureInfo.CurrentUICulture);
                        break;
                    }
                }
                HierarchyNodeProfile anchorHnp = this.GetNodeData(aPhAnchorKey);
                NodeAncestorList nal = _sab.HierarchyServerSession.GetNodeAncestorList(aPhAnchorKey, anchorHnp.HomeHierarchyRID);
                if (nal.Contains(asrtAnchorKey))
                {
                    isValidLink = true;
                }
                else
                {
                    string errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AsrtNodePhNodeNotLinked);
                    MessageBox.Show(errorMessage, this.Text);
                    isValidLink = false;
                }
            }
            catch
            {
                throw;
            }
            return isValidLink;
        }

        private int GetProductIdKey(string productID)
        {
            try
            {
                string errorMessage1 = string.Format
                    (MIDText.GetText(eMIDTextCode.msg_MustBeCorrectLevel),
                    _hlpProduct.LevelID);

                string errorMessage2 = string.Format
                    (MIDText.GetText(eMIDTextCode.msg_Data1NotValidData2),
                    productID, _hlpProduct.LevelID);

                if (productID.Trim() == string.Empty)
                {
                    MessageBox.Show(errorMessage1, this.Text);
                    return -1;
                }
                HierarchyNodeProfile styleParentHnp = _sab.HierarchyServerSession.GetNodeData(productID);
                if (styleParentHnp.Key == -1)
                {
                    string errorMessage3 = errorMessage2 + Environment.NewLine + errorMessage1;
                    MessageBox.Show(errorMessage3, this.Text);
                    return -1;
                }

                int styleParentHomeHierarchyRID = styleParentHnp.HomeHierarchyRID;
                HierarchyProfile hp = _sab.HierarchyServerSession.GetHierarchyData(styleParentHomeHierarchyRID);

                HierarchyLevelProfile hlp = (HierarchyLevelProfile)hp.HierarchyLevels[styleParentHnp.HomeHierarchyLevel + 1];
                if (hlp.LevelType != eHierarchyLevelType.Style)
                {
                    string errorMessage3 = errorMessage2 + Environment.NewLine + errorMessage1;
                    MessageBox.Show(errorMessage3, this.Text);
                    return -1;
                }
                return styleParentHnp.Key;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return -1;
            }
        }

        private bool AllDataValid()
        {
            bool dataIsValid = true;
            EditMsgs editMessages = new EditMsgs();
            try
            {
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    ValidRow(row, ref editMessages);
                }
                if (editMessages.EditMessages.Count > 0)
                {
                    _errors = null;
                    for (int i = 0; i < editMessages.EditMessages.Count; i++)
                    {
                        EditMsgs.Message emm = (EditMsgs.Message)editMessages.EditMessages[i];
                        AddErrorMessage(emm);
                    }
                    //EAB.Explorer.DisplayWorkspacePane();    // MID Track #5501 - add 'nag' message
                    MessageBox.Show(_errors, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    dataIsValid = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                dataIsValid = false;
            }
            return dataIsValid;
        }

        private bool ValidRow(UltraGridRow aRow, ref EditMsgs em)
        {
            bool dataIsValid;
            try
            {
                dataIsValid = ValidateSpecificFields(aRow, ref em);

                if (dataIsValid)
                {
                    if (aRow.HasChild())
                    {
                        UltraGridRow childRow = aRow.GetChild(ChildRow.First);
                        while (childRow != null)
                        {
                            dataIsValid = ValidRow(childRow, ref em);
                            if (!dataIsValid)
                            {
                                childRow.ExpandAncestors();
                                break;
                            }
                            childRow = childRow.GetSibling(SiblingRow.Next, true);
                        }
                    }
                }
                else
                {
                    aRow.ExpandAncestors();
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                dataIsValid = false;
            }
            return dataIsValid;
        }

        private bool ValidateSpecificFields(UltraGridRow aRow, ref EditMsgs em)
        {
            bool fieldsValid = true;
            string errorMessage = string.Empty;
            UltraGridCell gridCell;
            try
            {
                switch (aRow.Band.Key)
                {
                    case "Header":
                        //case "Placeholder":
                        gridCell = aRow.Cells["HeaderID"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        else if (!ValidHeaderID(gridCell, ref errorMessage, null))
                        {
                            fieldsValid = false;
                        }

                        gridCell = aRow.Cells["Product"];
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["Style"];
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        if (Convert.ToInt32(gridCell.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Assortment)
                        {
                            gridCell = aRow.Cells["Description"];
                            errorMessage = string.Empty;
                            if (!RequiredFieldEntered(gridCell, ref errorMessage))
                            {
                                fieldsValid = false;
                            }
                        }
                        gridCell = aRow.Cells["Multiple"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        else if (!ValidMultiple(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }

                        //if (!fieldsValid)
                        //{
                        //    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_ErrorsFoundReviewCorrect);
                        //    em.AddMsg(eMIDMessageLevel.Edit, errorMessage, this.ToString());
                        //}
                        break;

                    case "Pack":
                        gridCell = aRow.Cells["Pack"];
                        string packName = aRow.Cells["Pack"].Value.ToString();
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        else if (!ValidPackName(gridCell, packName, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["QuantityPerPack"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        break;
                    case "BulkColor":
                        gridCell = aRow.Cells["BulkColor"];
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        else if (!ValidBulkColor(gridCell, aRow.Cells["BulkColor"].Value.ToString(), ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["Description"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["Quantity"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        break;
                    case "PackColor":
                        gridCell = aRow.Cells["PackColor"];
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        else if (!ValidPackColor(gridCell, aRow.Cells["PackColor"].Value.ToString(), ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["QuantityPerPack"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        break;

                }
                if (!fieldsValid)
                {
                    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_ErrorsFoundReviewCorrect);
                    em.AddMsg(eMIDMessageLevel.Edit, errorMessage, this.ToString());
                }
                return fieldsValid;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool RequiredFieldEntered(UltraGridCell gridCell, ref string errorMessage)
        {
            bool errorFound = false;
            try
            {
                if (gridCell.Text.Trim().Length == 0)
                {	// cell is empty
                    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_FieldIsRequired);
                    errorFound = true;
                }
                if (errorFound)
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool ValidHeaderID(UltraGridCell aGridCell, ref string errorMessage, string aNewValue)
        {
            bool errorFound = false;
            try
            {
                string headerID;
                if (aNewValue != null)
                {
                    headerID = aNewValue.Trim();
                }
                else
                {
                    headerID = aGridCell.Row.Cells["HeaderID"].Value.ToString().Trim();
                }
                int hdrRID = Convert.ToInt32(aGridCell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                // Header ID cannot be used as file name because it contains invalid characters
                if (headerID != null
                    && headerID != string.Empty
                    && !MIDMath.ValidFileName(headerID))
                {
                    ugDetails.ActiveCell = aGridCell;
                    errorMessage = string.Format(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_HeaderNameInvalid), headerID, Include.HeaderNameExcludedCharacters);
                    errorFound = true;
                }
                else
                {
                    //foreach (AssortmentProfile asp in _allocProfileList)
                    foreach (AllocationProfile ap in _allocProfileList)
                    {   
                        if (ap.HeaderID != null && ap.HeaderID.ToUpper().Trim() == headerID.ToUpper() && ap.Key != hdrRID)
                        {
                            ugDetails.ActiveCell = aGridCell;
                            errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicateHeaderIdNotAllowed);
                            errorFound = true;
                            break;
                        }
                    }
                    if (!errorFound)
                    {
                        Header hd = new Header();
                        if (hd.DuplicateHeaderExists(headerID, hdrRID))
                        {
                            ugDetails.ActiveCell = aGridCell;
                            errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicateHeaderIdNotAllowed);
                            errorFound = true;
                        }
                    }
                }
                if (errorFound)
                {
                    SetErrorImage(aGridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(aGridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void SetErrorImage(UltraGridCell gridCell, bool showError, ref string errorMessage)
        {
            if (showError)
            {
                gridCell.Appearance.Image = ErrorImage;
                gridCell.Tag = errorMessage;
            }
            else
            {
                gridCell.Appearance.Image = null;
                gridCell.Tag = null;
            }
        }

        private bool ValidCharDate(ref BeforeCellUpdateEventArgs e, ref string errorMessage)
        {
            bool errorFound = false;

            if (e.NewValue == System.DBNull.Value || e.Cell.ValueList != null)
            {
                SetErrorImage(e.Cell, errorFound, ref errorMessage);
                return !errorFound;
            }

            try
            {
                Convert.ToDateTime(e.NewValue);
            }
            catch (Exception)
            {
                errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DateValuesOnly);
                errorFound = true;
            }

            SetErrorImage(e.Cell, errorFound, ref errorMessage);
            return !errorFound;
        }

        private bool ValidCharNumber(ref BeforeCellUpdateEventArgs e, ref string errorMessage)
        {
            bool errorFound = false;

            if (e.NewValue == System.DBNull.Value || e.Cell.ValueList != null)
            {
                SetErrorImage(e.Cell, errorFound, ref errorMessage);
                return !errorFound;
            }

            try
            {
                Convert.ToDouble(e.NewValue);
            }
            catch (Exception)
            {
                errorFound = true;
                errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_NumericValuesOnly);
            }

            SetErrorImage(e.Cell, errorFound, ref errorMessage);
            return !errorFound;
        }

        private bool ValidStyle(UltraGridCell gridCell, string aStyleID, ref string errorMessage)
        {
            bool validStyle = true, errorFound = false;
            string styleID, productID;
            int productKey;
            try
            {
                styleID = aStyleID.Trim();
                HierarchyNodeProfile styleHnp = _sab.HierarchyServerSession.GetNodeData(styleID);
                if (styleHnp.Key == -1)
                {
                    // Begin TT#1324 - RMatelic - When adding a new Style, the description does not update.
                    //errorMessage = string.Format(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LevelNotFoundAddQuestion),
                    //                             _hlpStyle.LevelID, styleID);
                    //DialogResult ret = MessageBox.Show(errorMessage, string.Empty, MessageBoxButtons.YesNo,
                    //                   MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
                               
                    errorMessage = string.Format(MIDText.GetTextOnly(eMIDTextCode.msg_LevelNotFoundAddQuestion),
                                                      _hlpStyle.LevelID,string.Empty);
                    NameDescriptionDialog descDialog = new NameDescriptionDialog(_windowName, errorMessage, _hlpStyle.LevelID, _lblDescription, styleID, styleID);
                    descDialog.StartPosition = FormStartPosition.CenterParent;
                    DialogResult ret = descDialog.ShowDialog();
                    //if (ret == DialogResult.No)
                    if (ret != DialogResult.Yes)
                    // End TT#1324
                    {
                        validStyle = false;
                    }
                    else
                    {
                        productID = gridCell.Row.Cells["Product"].Value.ToString();
                        productKey = 0;
                        if (productID == null || productID == string.Empty)
                        {
                            productKey = GetProductIdKey(productID); // this will force an error message
                        }
                        else if (gridCell.Row.Cells["ProductRID"].Value != System.DBNull.Value)
                        {
                            productKey = Convert.ToInt32(gridCell.Row.Cells["ProductRID"].Value, CultureInfo.CurrentUICulture);
                        }

                        if (productKey > 0)
                        {
                            EditMsgs em = new EditMsgs();
                            // BEGIN MID Track #5565 - add style error 
                            HierarchyMaintenance hm = new HierarchyMaintenance(_sab);
                           
                            // Begin TT#1324 - RMatelic - When adding a new Style, the description does not update.
                            //hm.QuickAdd(ref em, productKey, styleID);
                            // END MID Track #5565

                            hm.QuickAdd(ref em, productKey, styleID, descDialog.TextValue2);
                            // End TT#1324

                            if (em.ErrorFound)
                            {
                                DisplayMessages.Show(em, _sab, _windowName);
                                validStyle = false;
                                errorFound = true;
                            }
                            // Begin TT#2002-MD - JSmith - Adding a new style that does not exist in the hierarchy.  Does not add to the hierarchy until the asst is closed and a Tools Refresh is done.  Should it add on the fly?
                            else
                            {
                                _eab.MerchandiseExplorer.IRefresh();
                            }
                            // End TT#2002-MD - JSmith - Adding a new style that does not exist in the hierarchy.  Does not add to the hierarchy until the asst is closed and a Tools Refresh is done.  Should it add on the fly?
                        }
                    }
                    descDialog.Dispose();   // TT#1324 - RMatelic - When adding a new Style, the description does not update.
                }
                else if (styleHnp.LevelType != eHierarchyLevelType.Style)
                {
                    errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_Data1NotValidData2),
                                                 styleID, _hlpStyle.LevelID);
                    MessageBox.Show(errorMessage, this.Text);
                    validStyle = false;
                    errorFound = true;
                }

                else if (Convert.ToInt32(gridCell.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                {
                    validStyle = ValidPlaceholderStyle(gridCell.Row, styleHnp.Key, ref errorMessage);
                    errorFound = !validStyle;
                }

                SetErrorImage(gridCell, errorFound, ref errorMessage);

                return validStyle;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool ValidPlaceholderStyle(UltraGridRow aRow, int aStyleHnRID, ref string errorMessage)
        {
            bool validStyle = true;
            try
            {
                int asrtRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                int phHdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (row.Cells["AsrtRID"].Value != DBNull.Value
                     && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == asrtRID
                     && Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder
                     && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != phHdrRID
                     && Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture) == aStyleHnRID)
                    {
                        errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_as_DupPhStylesNotAllowed),
                                                      _lblPlaceholder + " " + _hlpStyle.LevelID);
                        validStyle = false;
                        MessageBox.Show(errorMessage, this.Text);
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
            return validStyle;
        }

        private bool ValidMultiple(UltraGridCell gridCell, ref string errorMessage)
        {
            bool errorFound = false;
            try
            {
                int multiple = Convert.ToInt32(gridCell.Value, CultureInfo.CurrentUICulture);
                if (multiple < 1)
                {
                    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_MultipleCannotBeLessThan1);
                    errorFound = true;
                }
                if (errorFound)
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool ValidPackName(UltraGridCell gridCell, string aPackName, ref string errorMessage)
        {
            bool errorFound = false;
            try
            {
                UltraGridRow row = gridCell.Row.GetSibling(SiblingRow.First, false);

                while (row != null)
                {
                    string packName = Convert.ToString(row.Cells["Pack"].Value, CultureInfo.CurrentUICulture);
                    if (row != gridCell.Row && packName.ToUpper().Trim() == aPackName.ToUpper().Trim())
                    {
                        errorFound = true;
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next, false);
                }
                if (errorFound)
                {
                    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicatePackNameNotAllowed);
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool ValidBulkColor(UltraGridCell gridCell, string aColorName, ref string errorMessage)
        {
            bool errorFound = false;
            try
            {
                UltraGridRow row = gridCell.Row.GetSibling(SiblingRow.First, false);
                while (row != null)
                {
                    // BEGIN MID Track #6127 - ComponentOne Case Insensitve issue: prohibit duplicate name regardless of case
                    string bulkColor = Convert.ToString(row.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture);
                    //if (row != gridCell.Row &&
                    //     Convert.ToString(row.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture) == aColorName)
                    if (row != gridCell.Row && bulkColor.ToUpper().Trim() == aColorName.ToUpper().Trim())
                    // END MID Track #6127
                    {
                        errorFound = true;
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next, false);
                }
                if (errorFound)
                {
                    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_DuplicateBulkColorNotAllowed);
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool ValidPackColor(UltraGridCell gridCell, string aPackColor, ref string errorMessage)
        {
            bool errorFound = false;
            try
            {
                UltraGridRow row = gridCell.Row.GetSibling(SiblingRow.First, false);
                while (row != null)
                {
                    // BEGIN MID Track #6127 - ComponentOne Case Insensitve issue: prohibit duplicate name regardless of case
                    //if (row != gridCell.Row &&
                    //    Convert.ToString(row.Cells["PackColor"].Value, CultureInfo.CurrentUICulture) == aPackColor)
                    string packColor = Convert.ToString(row.Cells["PackColor"].Value, CultureInfo.CurrentUICulture);
                    if (row != gridCell.Row && packColor.ToUpper().Trim() == aPackColor.ToUpper().Trim())
                    // END MID Track #6127
                    {
                        errorFound = true;
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next, false);
                }
                if (errorFound)
                {
                    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_DuplicateColorInPackNotAllowed);
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private string AddErrorMessage(EditMsgs.Message emm)
        {
            string error = null;
            try
            {
                if (emm.code != 0)
                {
                    error = _sab.ClientServerSession.Audit.GetText(emm.code);
                }
                else
                {
                    error = emm.msg;
                }
                _errors += Environment.NewLine + "     " + error;
                return error;
            }
            catch (Exception exception)
            {
                HandleException(exception);
                error = exception.Message;
                return error;
            }
        }

        #endregion

        #region Button Events & Methods
		// BEGIN TT#488-MD - Stodd - Group Allocation
        private void ExpandCollapse_Click(bool expand)
        {
            switch (_currentTabPage.Name)
            {
                case "tabContent":
					// BEGIN TT#553-MD - stodd - Size View null reference from attr set
					ExpandCollapseGrid(expand, true);
					// END TT#553-MD - stodd - Size View null reference from attr set
                    break;

                case "tabProductChar":
					ExpandCollapseGrid(expand);
                    break;

				// BEGIN TT#1538 - stodd - expand/collaspe button
				case "tabAssortment":
					ExpandCollapseAssortmentGrid(expand);
					break;
				// END TT#1538 - stodd - expand/collaspe button
            }
        }
		// END TT#488-MD - Stodd - Group Allocation

		// BEGIN TT#553-MD - stodd - Size View null reference from attr set
		private void ExpandCollapseGrid(bool aExpand)
		{
			ExpandCollapseGrid(aExpand, false);
		}
		// END TT#553-MD - stodd - Size View null reference from attr set

		// BEGIN TT#553-MD - stodd - Size View null reference from attr set
        private void ExpandCollapseGrid(bool aExpand, bool fromButtonPress)
	  	// END TT#553-MD - stodd - Size View null reference from attr set
        {
            try
            {
                switch (_currentTabPage.Name)
                {
                    case "tabContent":
                        if (aExpand)
                        {
							//BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy  
							bool alreadyExpanded = IsContentGridAlreadyExpanded(ugDetails.Rows[0]);

							// BEGIN TT#553-MD - stodd - Size View null reference from attr set
							if (!alreadyExpanded || fromButtonPress)
							// END TT#553-MD - stodd - Size View null reference from attr set
							{
								foreach (UltraGridRow row in ugDetails.Rows)
								{
									row.ExpandAll();
								}
							}
							//END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy  
							// BEGIN TT#488-MD - Stodd - Group Allocation
                            //this.btnExpandCollapse.Text = _lblCollapseAll;
                            //_expandAllContent = true;
							// END TT#488-MD - Stodd - Group Allocation
                        }
                        else
                        {
							// BEGIN TT#553-MD - stodd - Size View null reference from attr set
							bool alreadyExpanded = IsContentGridAlreadyExpanded(ugDetails.Rows[0]);

							if (fromButtonPress)
							{
								foreach (UltraGridRow row in ugDetails.Rows)
								{
									row.CollapseAll();
								}
							}
							// END TT#553-MD - stodd - Size View null reference from attr set
							// BEGIN TT#488-MD - Stodd - Group Allocation
                            //this.btnExpandCollapse.Text = _lblExpandAll;
                            //_expandAllContent = false;
							// END TT#488-MD - Stodd - Group Allocation
                        }
                        break;

                     case "tabProductChar":
                        if (aExpand)
                        {
                            foreach (UltraGridRow row in ugCharacteristics.Rows)
                            {
                                row.ExpandAll();
                            }
							// BEGIN TT#488-MD - Stodd - Group Allocation
                            //this.btnExpandCollapse.Text = _lblCollapseAll;
                            //_expandAllProductChar = true;
							// END TT#488-MD - Stodd - Group Allocation
                        }
                        else
                        {
                            foreach (UltraGridRow row in ugCharacteristics.Rows)
                            {
                                row.CollapseAll();
                            }
							// BEGIN TT#488-MD - Stodd - Group Allocation
                            //this.btnExpandCollapse.Text = _lblExpandAll;
                            //_expandAllProductChar = false;
							// END TT#488-MD - Stodd - Group Allocation
                        }
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		//BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy  
		private bool IsContentGridAlreadyExpanded(UltraGridRow aRow)
		{
			bool isExpanded = false;
			if (aRow.Expanded)
			{
				isExpanded = true;
			}
			else
			{
				if (aRow.HasChild())
				{
					UltraGridRow childRow = aRow.GetChild(ChildRow.First);
					while (childRow != null)
					{
						isExpanded = IsContentGridAlreadyExpanded(childRow);
						if (isExpanded)
						{
							break;
						}
						else
						{
							childRow = childRow.GetSibling(SiblingRow.Next, true);
						}
					}
				}
			}
			return isExpanded;
		}
		//END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy  

		// BEGIN TT#1538 - stodd - expand/collaspe button
		private void ExpandCollapseAssortmentGrid(bool aExpand)
		{
			try
			{
				foreach (C1.Win.C1FlexGrid.Row row in g4.Rows)
				{
					if (row.Node != null)
					{
						if (aExpand)
						{
							row.Node.Expanded = true;
							_expandAllAssortment = true;
							//this.btnExpandCollapse.Text = _lblCollapseAll;	// TT#488-MD - Stodd - Group Allocation
						}
						else
						{
							row.Node.Expanded = false;
							_expandAllAssortment = false;
							//this.btnExpandCollapse.Text = _lblExpandAll;		// TT#488-MD - Stodd - Group Allocation
						}
					}
				}
			}
			catch (Exception ex)
			{
				HandleException(ex);
			}
		}
		// END TT#1538 - stodd - expand/collaspe button

		// BEGIN TT#488-MD - Stodd - Group Allocation
		//private void SetExpandCollapseButtonText()
		//{
		//    switch (_currentTabPage.Name)
		//    {
		//        case "tabContent":
		//            this.btnExpandCollapse.Text = _expandAllContent ? _lblCollapseAll : _lblExpandAll;
		//            break;

		//        case "tabProductChar":
		//            this.btnExpandCollapse.Text = _expandAllProductChar ? _lblCollapseAll : _lblExpandAll;
		//            break;

		//        // BEGIN TT#1538 - stodd - expand/collaspe button
		//        case "tabAssortment":
		//            this.btnExpandCollapse.Text = _expandAllAssortment ? _lblCollapseAll : _lblExpandAll;
		//            break;
		//        // END TT#1538 - stodd - expand/collaspe button
		//    }
		//}    
		// END TT#488-MD - Stodd - Group Allocationn
		#endregion

		#region Display Context Menu Options
		private void cmsContentGrid_Opening(object sender, CancelEventArgs e)
        {
            _errors = null; // TT#1221 - RMatelic - Color Browser Errors in Assortment Review
            try
            {
				// BEGIN Stodd - 4.0 to 4.1 Manual merge
				string enqMessage = string.Empty;

                // BEGIN TT#67-MD - stodd - Context Menu not displaying on content tab
                AllocationHeaderProfileList allocProfileList = (AllocationHeaderProfileList)_transaction.GetMasterProfileList(eProfileType.AllocationHeader);
                if (_assortReviewContentSecurity.IsReadOnly || !_transaction.AreHeadersEnqueued(allocProfileList))
                //if (_assortReviewContentSecurity.IsReadOnly || !_transaction.EnqueueSelectedHeaders(out enqMessage))
                // END TT#67-MD - stodd 
                //if (_assortReviewContentSecurity.IsReadOnly || !_transaction.HeadersEnqueued)
				// END Stodd - 4.0 to 4.1 Manual merge
                {
                    e.Cancel = true;
                    return;
                }

				// Begin TT#1135-md - stodd - "Insert" in context menu - 
                if (IsGroupAllocation)
                {
                    cmsInsert.Visible = false;
                }
				// End TT#1135-md - stodd - "Insert" in context menu - 

                if (_rClickRow == null)
                {
                    if (ugDetails.Selected.Rows.Count > 0)
                    {
                        _rClickRow = ugDetails.Selected.Rows[0];
                    }
                    //else
                    //{
                    //    for (int i = 0; i < ugDetails.Rows.Count; i++)
                    //    {
                    //        if (!ugDetails.Rows[i].Hidden)
                    //        {
                    //            _rClickRow = ugDetails.Rows[i];
                    //            break;
                    //        }
                    //    }
                    //}
                }
                if (_rClickRow != null)
                {
					//BEGIN TT#200 - MD - DOConnell - Deleting a blank color on a placeholder and then adding a new color generates a null reference exception
                    //BEGIN TT#361 - MD - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message “Object cannot be cast from DBNull to other types.”
                    if (ugDetails.Selected.Rows.Count > 0)
                    {
                        if (Convert.ToInt32(_rClickRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != Convert.ToInt32(ugDetails.Selected.Rows[0].Cells["KeyH"].Value, CultureInfo.CurrentUICulture))
                        {
                            _rClickRow = ugDetails.Selected.Rows[0];
                        }
                        //END TT#200 - MD - DOConnell - Deleting a blank color on a placeholder and then adding a new color generates a null reference exception
                        if (HeaderMaintainable(_rClickRow))
                        {
                            SetMaintainableHeaderMenu();
                        }
                        else
                        {
                            SetNonMaintainableHeaderMenu();
                        }
                        // Begin TT#1221 -  RMatelic - Color Browser Errors in Assortment Review
                        if (_errors != null)
                        {
                            e.Cancel = true;
                            return;
                        }
                        // End TT#1221
                    }
                    //END TT#361 - MD - DOConnell
					// Begin TT#1135-md - stodd - "Insert" in context menu - 
                    else
                    {
                        cmsRemove.Enabled = false;
                    }
					// End TT#1135-md - stodd - "Insert" in context menu - 
                }
                else
                {
                    cmsRemove.Enabled = false;
                    if (_assortments.Rows.Count == 1)
                    {
                        DataRow dr = (DataRow)_assortments.Rows[0];
                        AllocationProfile ap = GetAllocationProfile((int)dr["AsrtRID"]);
                        if ((eAssortmentType)ap.AsrtType == eAssortmentType.PostReceipt || (eAssortmentType)ap.AsrtType == eAssortmentType.GroupAllocation)
                        {
                            cmsInsert.Visible = false;
                            cmsInsertPhStyle.Visible = false;
                        }
                        else
                        {
                            cmsInsert.Visible = true;
                            cmsInsertPhStyle.Visible = true;
                        }
                    }
                    else
                    {
                        cmsInsert.Visible = false;
                        cmsInsertPhStyle.Visible = false;
                    }
                    cmsInsertPack.Visible = false;
                    cmsInsertPackColor.Visible = false;
                    cmsInsertPackSize.Visible = false;
                    cmsInsertBulkColor.Visible = false;
                    cmsInsertBulkSize.Visible = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool HeaderMaintainable(UltraGridRow aRow)
        {
            try
            {
                UltraGridRow headerRow = aRow;

                while (headerRow.Band.Key != "Header")
                {
                    headerRow = headerRow.ParentRow;
                }

                SetCanDeleteSwitch(headerRow);
                SetCanAddSwitch(headerRow);

                return SetCanUpdateSwitch(headerRow);
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void SetCanDeleteSwitch(UltraGridRow aHeaderRow)
        {
            try
            {
                _canDeleteHeader = true;

                if (!CanDeleteInterfacedNonInterfaced(aHeaderRow))
                {
                    _canDeleteHeader = false;
                    return;
                }

                eHeaderAllocationStatus headerStatus = (eHeaderAllocationStatus)Convert.ToInt32(aHeaderRow.Cells["Status"].Value, CultureInfo.CurrentUICulture);
                if (headerStatus == eHeaderAllocationStatus.InUseByMultiHeader)
                {
                    _canDeleteHeader = false;
                    return;
                }
                int key = Convert.ToInt32(aHeaderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
            
                AllocationProfile ap = GetAllocationProfile(key);
                if (ap != null)
                {
                    if (ap.Assortment)
                    {
                        _canDeleteHeader = false;
                    }
                    else if (ap.Placeholder)    
                    {
                        if (!AllowPlaceholderUpdate(aHeaderRow))
                        {
                            _canDeleteHeader = false;
                        }
                        else if (!_assortReviewContentSecurity.AllowDelete)
                        {
                            _canDeleteHeader = false;
                        }
						//BEGIN TT#200 - MD - DOConnell - Deleting a blank color on a placeholder and then adding a new color generates a null reference exception
                        else if (PhColorAttachedToHeaderColor(aHeaderRow, ap))
                        {
                            _canDeleteHeader = false;
                        }
						//END TT#200 - MD - DOConnell - Deleting a blank color on a placeholder and then adding a new color generates a null reference exception
                    }
                    else if (aHeaderRow.Cells["AsrtRID"].Value != DBNull.Value)
                    {
                        foreach (UltraGridCell cell in aHeaderRow.Cells)
                        {
                            Debug.WriteLine(cell.Column.ToString() + " " + cell.Value);
                        }
                        _canDeleteHeader = false;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private bool CanDeleteInterfacedNonInterfaced(UltraGridRow aHeaderRow)
        {
            bool canDelete = true;
            try
            {
                if (Convert.ToBoolean(aHeaderRow.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture))
                {
                    if (_sab.ClientServerSession.GlobalOptions.ProtectInterfacedHeadersInd)
                    {
                        canDelete = false;
                    }
                    else
                    {
                        canDelete = _allocationInterfacedHeadersSecurity.AllowDelete;
                    }
                }
                else	// not Interfaced   
                {
                    canDelete = _allocationNonInterfacedHeadersSecurity.AllowDelete;
                }
            }
            catch
            {
                throw;
            }
            return canDelete;
        }

        private void SetCanAddSwitch(UltraGridRow aHeaderRow)
        {
            try
            {
                _canAddHeader = true;
                if (!_allocationNonInterfacedHeadersSecurity.AllowUpdate)
                {
                    _canAddHeader = false;
                }
                else if (aHeaderRow.Cells["AsrtRID"].Value != DBNull.Value)
                {
                    int headerType = Convert.ToInt32(aHeaderRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (headerType != (int)eHeaderType.Assortment && headerType != (int)eHeaderType.Placeholder)
                    {
                        _canAddHeader = false;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private bool SetCanUpdateSwitch(UltraGridRow aHeaderRow)
        {
            bool canUpdate = true;
            try
            {
                if (aHeaderRow.Cells["AsrtRID"].Value != DBNull.Value)
                {
                    int headerType = Convert.ToInt32(aHeaderRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (headerType != (int)eHeaderType.Placeholder)
                    {   // real headers in an Assortment
                        canUpdate = false;
                    }
                }
                //else if (aHeaderRow.Cells["StyleSecurity"].Value != System.DBNull.Value)
                //{
                //    eSecurityType styleSecurity = (eSecurityType)Convert.ToInt32(aHeaderRow.Cells["StyleSecurity"].Value, CultureInfo.CurrentUICulture);
                //    if (styleSecurity == eSecurityType.View)
                //    {
                //        canUpdate = false;    //TODO:  not sure if this is correct
                //    }
                //}

                if (canUpdate)
                {
                    int key = Convert.ToInt32(aHeaderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    AllocationProfile ap = GetAllocationProfile(key);
                    if (ap != null)
                    {
                        if (!AllowPlaceholderUpdate(aHeaderRow)) 
                        {
                            canUpdate = false;
                        }
                        else
                        {
                            canUpdate = CanUpdateInterfacedNonInterfaced(aHeaderRow);
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
            return canUpdate;
        }

        private bool CanUpdateInterfacedNonInterfaced(UltraGridRow aHeaderRow)
        {
            bool canUpdate = true;
            try
            {
                if (Convert.ToBoolean(aHeaderRow.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture))
                {
                    if (_sab.ClientServerSession.GlobalOptions.ProtectInterfacedHeadersInd)
                    {
                        canUpdate = false;
                    }
                    else
                    {
                        canUpdate = _allocationInterfacedHeadersSecurity.AllowUpdate;
                    }
                }
                else	// not Interfaced  
                {
                    canUpdate = _allocationNonInterfacedHeadersSecurity.AllowUpdate;
                }
            }
            catch
            {
                throw;
            }
            return canUpdate;
        }

        private void SetNonMaintainableHeaderMenu()
        {
            try
            {
                cmsInsert.Visible = false;
                SetOtherNonMaintainableHeaderMenuOptions();
               
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetOtherNonMaintainableHeaderMenuOptions()
        {
            try
            {
                if (_rClickRow.Band.Key == "Header")
                {
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(_rClickRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);

                    switch (headerType)
                    {
                        case eHeaderType.Assortment:
                            break;

                        case eHeaderType.Placeholder:
                            if (_assortReviewContentSecurity.AllowUpdate) //TODO: may need to qualify further
                            {
                                cmsRemove.Enabled = true;
                            }
                            else
                            {
                                cmsRemove.Enabled = false;
                            }
                            break;

                        default:
                            if (_assortReviewContentSecurity.AllowUpdate) //TODO: may need to qualify further
                            {
                                cmsRemove.Enabled = true;
                            }
                            break;
                    }
                }
                else
                {
                    cmsRemove.Enabled = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool OkToRemoveRows(UltraGridRow aRow)
        {
            int asrtRID;
            try
            {
                if (this.ugDetails.Selected.Rows.Count == 0)
                {
                    return false;
                }
                asrtRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);

                _asrtHdrRowFound = false;
                _asrtHdrRow = null;
                GetHeaderRow(ugDetails.GetRow(ChildRow.First), asrtRID);

                if (_asrtHdrRow == null || _asrtHdrRow.Selected)
                {
                    return false;
                }

                if (!HeaderMaintainable(_asrtHdrRow))
                {
                    return false;
                }

                Header hd = new Header();
                DataTable dtChildren = hd.GetHeaderGroupChildren(asrtRID);

                if (this.ugDetails.Selected.Rows.Count >= dtChildren.Rows.Count)
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void GetHeaderRow(UltraGridRow aRow, int aAsrtRID)
        {
            try
            {
                UltraGridRow gRow = aRow;
                while (gRow != null && !_asrtHdrRowFound)
                {
                    if (gRow.IsGroupByRow)
                    {
                        GetHeaderRow(gRow.GetChild(ChildRow.First), aAsrtRID);
                        if (_asrtHdrRowFound)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (gRow.Band.Key == "Header" && (int)gRow.Cells["KeyH"].Value == aAsrtRID)
                        {
                            _asrtHdrRowFound = true;
                            _asrtHdrRow = gRow;
                            break;
                        }
                    }
                    gRow = gRow.GetSibling(SiblingRow.Next, true, false);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetMaintainableHeaderMenu()
        {
            try
            {
                //cmsDelete.Enabled = cmsDelete.Visible = _canDeleteHeader;
                bool isInterfaced = HeaderIsInterfaced();
                string[] bandKeyParts = _rClickRow.Band.Key.Split(new char[] { '~' });

                switch (bandKeyParts[0])
                {
                    case "Header":
                        SetHeaderContextMenu();
                        break;

                    case "Pack":
                        SetPackContextMenu();
                        break;

                    case "PackColor":
                        SetPackColorContextMenu();
                        break;

                    case "BulkColor":
                        SetBulkColorContextMenu();
                        break;

                    case "BulkSize":
                    case "PackColorSize":
                    case "PackSize":
                        SetSizeContextMenu(bandKeyParts[0]);
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool HeaderIsInterfaced()
        {
            try
            {
                UltraGridRow headerRow = _rClickRow;

                while (headerRow.Band.Key != "Header")
                {
                    headerRow = headerRow.ParentRow;
                }
                return Convert.ToBoolean(headerRow.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture);
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void SetHeaderContextMenu()
        {
            bool canAddTo = false, canAddPlaceholder = false;
            EditMsgs em = new EditMsgs();
            try
            {
                if (_rClickRow.Cells["HeaderID"].Appearance.Image != null && _rClickRow.Cells["HeaderID"].Tag != null)
                {
                    return;
                }
                if (!ValidateSpecificFields(_rClickRow, ref em))
                {
                    if (em.EditMessages.Count > 0)
                    {
                        _errors = null;
                        for (int i = 0; i < em.EditMessages.Count; i++)
                        {
                            EditMsgs.Message emm = (EditMsgs.Message)em.EditMessages[i];
                            AddErrorMessage(emm);
                        }
                        MessageBox.Show(_errors, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    return;
                }
                cmsInsert.Visible = true;
                // BEGIN TT#2018-MD - AGallaghre - Pack is not available for selction when managing components.
                //cmsInsertPack.Visible = false;
                cmsInsertPack.Visible = true;
                // END TT#2018-MD - AGallaghre - Pack is not available for selction when managing components.
                cmsInsertPackColor.Visible = false;
                cmsInsertPackSize.Visible = false;
                cmsInsertBulkSize.Visible = false;

                _fromRightClick = true;

                string colValue = Convert.ToString(_rClickRow.Cells["HeaderID"].Value).Trim();
                if (colValue != string.Empty)
                {
                    foreach (UltraGridRow row in ugDetails.Rows)
                    {
                        if (RowDataChanged(row))
                            return;
                    }

                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(_rClickRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    switch (headerType)
                    {
                        case eHeaderType.Assortment:
                            cmsRemove.Enabled = false;
                            CheckAddSwitches(ref canAddTo, ref canAddPlaceholder);
                            if (canAddPlaceholder)
                            {
                                cmsInsertPhStyle.Visible = true;
                                cmsInsertPhStyle.Enabled = true;
                            }
                            else
                            {
                                cmsInsert.Visible = false;
                            }
                            cmsInsertBulkColor.Visible = false;
                            cmsInsertPack.Visible = false;
                            break;

                        case eHeaderType.Placeholder:
                            if (_assortReviewContentSecurity.AllowUpdate)
                            {
                                cmsInsertPhStyle.Visible = true;
                                cmsInsertPhStyle.Enabled = true;
                                if (HeaderAttachedToPlaceHolder(_rClickRow))
                                {
                                    cmsRemove.Enabled = false;
                                }
                                else
                                {
                                    cmsRemove.Enabled = true;
                                }
                            }
                            cmsInsertBulkColor.Visible = true;
                            //cmsInsertPack.Visible = true;
                            break;

                        default:
                            cmsInsert.Visible = false;
                            if (_assortReviewContentSecurity.AllowUpdate)
                            {
                                cmsRemove.Enabled = true;
                            }
                            else
                            {
                                cmsRemove.Enabled = false;
                            }
                            break;
                    }
                }
                else
                {
                    cmsInsert.Visible = false;
                }
            }
            catch
            {
                throw;
            }
        }

        private void CheckAddSwitches(ref bool aCanAddTo, ref bool aCanAddPlaceholder)
        {
            try
            {
                aCanAddTo = true;

                eAssortmentType asrtType = (eAssortmentType)Convert.ToInt32(_rClickRow.Cells["AsrtType"].Value, CultureInfo.CurrentUICulture);
                aCanAddPlaceholder = (asrtType == eAssortmentType.PreReceipt) ? true : false;
            }
            catch
            {
                throw;
            }
        }

        private void SetPackContextMenu()
        {
            try
            {
                _fromRightClick = true;
                string colValue = Convert.ToString(_rClickRow.Cells["Pack"].Value).Trim();
                if (colValue != string.Empty)
                {
                    //cmsInsert.Visible = true;
                    cmsInsert.Visible = false;
                    cmsInsertBulkColor.Visible = false;
                    cmsInsertBulkSize.Visible = false;

                    if (Convert.ToInt32(_rClickRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Placeholder)
                    {
                        cmsInsert.Visible = false;
                        cmsRemove.Enabled = false;
                    }
                    else
                    {
                        //cmsInsertPack.Visible = true;
                        SetPackContextMenuAdds();
                        if (_rClickRow.Cells["AssociatedPackRID"].Value != System.DBNull.Value &&
                            Convert.ToInt32(_rClickRow.Cells["AssociatedPackRID"].Value, CultureInfo.CurrentUICulture) > 0)
                        {
                            cmsRemove.Enabled = false;
                        }
                        else
                        {
                            cmsRemove.Enabled = true;
                        }
                    }
                }
                else
                {
                    cmsInsert.Visible = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetPackContextMenuAdds()
        {
            try
            {
                cmsInsertPhStyle.Visible = false;
                //if (Convert.ToInt32(_rClickRow.Cells["PackType"].Value, CultureInfo.CurrentUICulture) == (int)eAllocationType.DetailType)
                //{
                //    if (_rClickRow.HasChild(false))
                //    {
                //        UltraGridRow childRow = _rClickRow.GetChild(ChildRow.First);
                //        if (childRow.Band.Key == "PackColor" || childRow.Band.Key.StartsWith("PackSize"))
                //        {
                //            cmsInsertPackColor.Visible = true;
                //            cmsInsertPackSize.Visible = false;
                //        }
                //        else
                //        {
                //            cmsInsertPackColor.Visible = false;
                //            cmsInsertPackSize.Visible = true;
                //        }
                //    }
                //    else
                //    {
                //        cmsInsertPackColor.Visible = true;
                //        cmsInsertPackSize.Visible = true;
                //    }
                //}
                //else
                //{
                //    cmsInsertPackColor.Visible = true;
                //    cmsInsertPackSize.Visible = _rClickRow.HasChild(false) ? false : true;
                //}
                cmsInsertPack.Visible = false;
                cmsInsertPackColor.Visible = false;
                cmsInsertPackSize.Visible = false;
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetPackColorContextMenu()
        {
            try
            {
                cmsInsertPhStyle.Visible = false;
                _fromRightClick = true;
                string colValue = Convert.ToString(_rClickRow.Cells["PackColor"].Value).Trim();
                if (colValue != string.Empty)
                {
                    cmsInsert.Visible = true;
                    cmsInsertBulkColor.Visible = false;
                    cmsInsertBulkSize.Visible = false;

                    if (Convert.ToInt32(_rClickRow.ParentRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Placeholder)
                    {
                        cmsInsert.Visible = false;
                    }
                    else
                    {
                        cmsInsertPack.Visible = true;
                        cmsInsertPackColor.Visible = true;
                        cmsInsertPackSize.Visible = _rClickRow.HasChild() ? false : true;
                    }
                }
                else
                {
                    cmsInsert.Visible = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetBulkColorContextMenu()
        {
            try
            {
                cmsInsertPhStyle.Visible = false;
                _fromRightClick = true;
                string colValue = Convert.ToString(_rClickRow.Cells["BulkColor"].Value).Trim();
                if (colValue != string.Empty)
                {
                    cmsInsert.Visible = true;
                    cmsInsertPack.Visible = false;
                    cmsInsertPackColor.Visible = false;
                    cmsInsertPackSize.Visible = false;
                    if (Convert.ToInt32(_rClickRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Placeholder)
                    {
                        cmsInsert.Visible = false;
                    }
                    else
                    {
                        cmsInsertBulkColor.Visible = true;
                        cmsInsertBulkSize.Visible = _rClickRow.HasChild() ? false : true;
                        if (HeaderColorAttachedToPhColor(_rClickRow))
                        {
                            cmsRemove.Enabled = false;
                        }
                        else
                        {
                            cmsRemove.Enabled = true;
                        }
                    }
                }
                else
                {
                    cmsInsert.Visible = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool HeaderAttachedToPlaceHolder(UltraGridRow aPhRow)
        {
            bool rowFound = false;
            try
            {
                UltraGridColumn phKeyHColumn = aPhRow.Band.Columns["KeyH"];
                int phRID = Convert.ToInt32(aPhRow.GetCellValue(phKeyHColumn), CultureInfo.CurrentUICulture);
                
                IEnumerable enumerator = aPhRow.Band.GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Assortment ||
                        Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                    {
                        continue;
                    }
                    else if (row.Cells["PlaceHolderRID"].Value != DBNull.Value &&
                             Convert.ToInt32(row.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == phRID)
                    {
                        rowFound = true;
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
            return rowFound;
        }

        private bool HeaderColorAttachedToPhColor(UltraGridRow aPhColorRow)
        {
            bool rowFound = false;
            try
            {               
                UltraGridColumn phKeyHColumn = aPhColorRow.Band.Columns["KeyH"];
                UltraGridColumn phKeyCColumn = aPhColorRow.Band.Columns["KeyC"];
                int phRID = Convert.ToInt32(aPhColorRow.GetCellValue(phKeyHColumn), CultureInfo.CurrentUICulture);
                int phBCRID = Convert.ToInt32(aPhColorRow.GetCellValue(phKeyCColumn), CultureInfo.CurrentUICulture);
                
                IEnumerable enumerator = aPhColorRow.Band.GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    if (Convert.ToInt32(row.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Placeholder
                      && Convert.ToInt32(row.ParentRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == phRID
                      && Convert.ToInt32(row.Cells["AsrtBCRID"].Value, CultureInfo.CurrentUICulture) == phBCRID)
                    {
                        rowFound = true;
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
            return rowFound;
        }

        //BEGIN TT#200 - MD - DOConnell - Deleting a blank color on a placeholder and then adding a new color generates a null reference exception
        private bool PhColorAttachedToHeaderColor(UltraGridRow aPhColorRow, AllocationProfile ap)
        {
            bool rowFound = false;
            UltraGridRow headerRow = null; //TT#690 - MD - DOConnell - Right Click on Size Row in an Assortment and receive Argument Exception Error
            try
            {
                UltraGridColumn phKeyHColumn = aPhColorRow.Band.Columns["KeyH"];
                int phRID = Convert.ToInt32(aPhColorRow.GetCellValue(phKeyHColumn), CultureInfo.CurrentUICulture);

                foreach (UltraGridRow row in ugDetails.Selected.Rows)
                {
					//BEGIN TT#690 - MD - DOConnell - Right Click on Size Row in an Assortment and receive Argument Exception Error
                    headerRow = row;
                    while (headerRow.Band.Key != "Header")
                    {
                        headerRow = headerRow.ParentRow;
                    }
					//BEGIN TT#361 - MD - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message “Object cannot be cast from DBNull to other types.”
                    //if (row.ParentRow != null)
                    if (headerRow != null)
                    {
                        //if (Convert.ToInt32(row.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder &&
                        //    Convert.ToInt32(row.ParentRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == phRID)
                        if (Convert.ToInt32(headerRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder &&
                            Convert.ToInt32(headerRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == phRID)
                        {
                            if (HeaderAttachedToPlaceHolder(headerRow))
					 //END TT#690 - MD - DOConnell - Right Click on Size Row in an Assortment and receive Argument Exception Error
                            {
							//Begin TT#722 - MD - DOConnell - Right clicking on a header with multiple child levels that is not selected generates a Key Not found error
                                if (row.Band.Key == "BulkColor")
                                {
                                if (HeaderColorAttachedToPhColor(row))
                                {
                                    rowFound = true;
                                    break;
                                    }
							//END TT#722 - MD - DOConnell - Right clicking on a header with multiple child levels that is not selected generates a Key Not found error
                                }
                            }
                        }
                    }
					//END TT#361 - MD - DOConnell 
                }
            }
            catch
            {
                throw;
            }
            return rowFound;
        }
        //END TT#200 - MD - DOConnell - Deleting a blank color on a placeholder and then adding a new color generates a null reference exception

        private void SetSizeContextMenu(string aBandKey)
        {
            try
            {
                _fromRightClick = true; //TT#690 - MD - DOConnell - Right Click on a Size Row in Assortment and recieve an Argument Exception Error.
                cmsInsert.Visible = false;
                UltraGridRow parentRow = _rClickRow.ParentRow;
                UltraGridRow headerRow = _rClickRow.ParentRow;
                while (headerRow.Band.Key != "Header")
                {
                    headerRow = headerRow.ParentRow;
                }
                
                if (Convert.ToInt32(headerRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                {
                    switch (aBandKey)
                    {
                        case "BulkSize":
                            if (HeaderColorAttachedToPhColor(parentRow))
                            {
                                cmsRemove.Enabled = false;
                            }
                            else
                            {
                                cmsRemove.Enabled = true;
                            }
                            break;

                        case "PackSize":
                            if (_rClickRow.ParentRow.Cells["AssociatedPackRID"].Value != System.DBNull.Value &&
                                 Convert.ToInt32(_rClickRow.ParentRow.Cells["AssociatedPackRID"].Value, CultureInfo.CurrentUICulture) > 0)
                            {
                                cmsRemove.Enabled = false;
                            }
                            else
                            {
                                cmsRemove.Enabled = true;
                            }
                            break;
                    }
                }    
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool RowDataChanged(UltraGridRow aRow)
        {
            try
            {
                if (aRow.HasChild())
                {
                    foreach (UltraGridChildBand childBand in aRow.ChildBands)
                    {
                        foreach (UltraGridRow childRow in childBand.Rows)
                        {
                            if (childRow.DataChanged)
                                childRow.Update();
                            if (childRow.HasChild())
                            {
                                RowDataChanged(childRow);
                            }
                        }
                    }
                }
                if (aRow.DataChanged)
                {
                    aRow.Update();
                }
                return false;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }
        #endregion
      
        #region ContextMenu Events and Methods
        private void cmsInsertPhStyle_DropDownOpened(object sender, EventArgs e)
        {
            cmsInsertPhTextBox.TextBox.Text = "1";    // sets default value
        }

        private void cmsInsertPhStyle_DropDownOpening(object sender, EventArgs e)
        {
            cmsInsertPhTextBox.TextBox.Focus();
        }

        private void cmsInsertPhTextBox_DoubleClick(object sender, EventArgs e)
        {
            AddNewPlaceholders(sender);
        }

        private void cmsInsertPhTextBox_KeyUp(object sender, KeyEventArgs e)
        {
            try
            {
                if (e.KeyCode == Keys.Enter)
                {
                    AddNewPlaceholders(sender);
                }
            }
            catch
            {
                throw;
            }
        }

        private void AddNewPlaceholders(object sender)
        {
            try
            {
                ToolStripTextBox tstb = (ToolStripTextBox)sender;
                int phCount = 0;
                string phCountStr, errorMessage;

                phCountStr = tstb.Text.Trim();
                if (MIDMath.IsPositiveNumber(phCountStr))
                {
                    phCount = Convert.ToInt32(phCountStr, CultureInfo.CurrentUICulture);
                    if (phCount > 0 && OkToAddPlaceholders())
                    {
                        AddPlaceholders(phCount, Include.NoRID);
                    }
                }
                else
                {
                    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_pl_InvalidValueFormat);
                    MessageBox.Show(errorMessage, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
            catch
            {
                throw;
            }
        }

        private bool OkToAddPlaceholders()
        {
            bool okToAdd = true;
            try
            {
                //if (!RowActive())
                //{
                //    okToAdd = false;
                //}
                //else
                //{
                //    while (ugDetails.ActiveRow.Band.Key != "Header")
                //    {
                //        ugDetails.ActiveRow = ugDetails.ActiveRow.ParentRow;
                //    }
                //    eHeaderType headerType = (eHeaderType)Convert.ToInt32(ugDetails.ActiveRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                //    if (headerType != eHeaderType.Assortment)
                //    {
                //        okToAdd = false;
                //    }
                //    else
                //    {
                        EditMsgs em = new EditMsgs();
                        if (!ValidateSpecificFields(ugDetails.ActiveRow, ref em))
                        {
                            if (em.EditMessages.Count > 0)
                            {
                                _errors = null;
                                for (int i = 0; i < em.EditMessages.Count; i++)
                                {
                                    EditMsgs.Message emm = (EditMsgs.Message)em.EditMessages[i];
                                    AddErrorMessage(emm);
                                }
                                MessageBox.Show(_errors, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            }
                            okToAdd = false;
                        }
                //    }
                //}
            }
            catch
            {
                throw;
            }
            return okToAdd;
        }

        private void AddPlaceholders(int aReqPhCount, int aStyleHnRID)
        {
            bool isFirstHeader = false;
            try
            {
                if (cmsContentInsert.Visible)  // context menus don't AutoClose when there's a TextBox 
                {
                    cmsContentInsert.Close();
                    cmsContentGrid.Close();
                }
                Cursor.Current = Cursors.WaitCursor;
                int curPhCount = 0;

                ugDetails.BeginUpdate();
                ugDetails.SuspendRowSynchronization();

                // get Assortment row data
                UltraGridRow asrtRow = null;
                int asrtRid = -1;
                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Assortment) 
                    {
                        asrtRow = row;
                        break;
                    }     
                    row = row.GetSibling(SiblingRow.Next, false);
                }
				// BEGIN TT#2152 - stodd - new highlighted row not in selected list 
                //ugDetails.ActiveRow = asrtRow;
				// END TT#2152 - stodd - new highlighted row not in selected list 

				// ASRT/GA MERGE
				if (IsGroupAllocation)
					{
					isFirstHeader = IsFirstHeader(asrtRid);
					if (isFirstHeader)
					{
						asrtRow.Cells["AnchorHnRID"].Value = aStyleHnRID;
					}
				}

                string asrtID = Convert.ToString(asrtRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                int asrtHdrRID = Convert.ToInt32(asrtRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                // begin TT#955 - MD - Jellis - Dup Color Error on Drag Drop Header into Group
                //int anchorRID = Convert.ToInt32(asrtRow.Cells["AnchorHnRID"].Value, CultureInfo.CurrentUICulture);
                int anchorRID;
                if (Convert.IsDBNull(asrtRow.Cells["AnchorHnRID"].Value))
                {
                    anchorRID = aStyleHnRID;
                }
                else
                {
                    anchorRID = Convert.ToInt32(asrtRow.Cells["AnchorHnRID"].Value, CultureInfo.CurrentUICulture);
                }
                // end TT#955 - MD - Jellis - Dup Color Error on Drag Drop Header into Group

                row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (row != asrtRow && row.Cells["AsrtRID"].Value != DBNull.Value)
                    {
                        int asrtRID = Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                        if (asrtRID == asrtHdrRID && Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                        {
                            curPhCount++;
                        }
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }

				// BEGIN TT#1806 - stodd - new placeholders not displaying in correct order
				_addedRowList.Clear();
				// END TT#1806 - stodd - new placeholders not displaying in correct order
                if (aStyleHnRID == Include.NoRID)
                {
                    HierarchyNodeList hierNodeList = _hierMaint.GetPlaceholderStyles(anchorRID, aReqPhCount, curPhCount, asrtHdrRID);

                    for (int i = 0; i < aReqPhCount; i++)
                    {
                        AddPlaceholderStyle((HierarchyNodeProfile)hierNodeList[i], asrtHdrRID);
                    }
                }
                else
                {
                    HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(aStyleHnRID);
                    AddPlaceholderStyle(hnp, asrtHdrRID);
                }

                this.ugDetails.UpdateData();
            }
            catch (Exception ex)
            {
                MIDException MIDExc = new MIDException(eErrorLevel.information, 0, ex.Message);
                HandleMIDException(MIDExc);
            }
            finally
            {
				// BEGIN TT#2152 - stodd - new highlighted row not in selected list 
				//if (this.ugDetails.ActiveRow != null)
				//{
				//    //this.ugDetails.ActiveRow.RefreshSortPosition();
				//    this.ugDetails.ActiveRow.Selected = true;
				//}
				// END TT#2152 - stodd - new highlighted row not in selected list 

                if (!_addingHeaderToAssortment)
                {
                    //SaveAndUpdateAssortmentTab(); 
                    OnAssortmentSaveHeaderData(null);	// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                    SaveAndUpdateAssortmentTab(); //TT#1225 - MD - DOConnell - Placeholders do not show up on matrix screen when added on the content screen
                }

				// BEGIN TT#376-MD - stodd - Update Enqueue logic
				if (!_enqueueHeaderError)
				{
					// BEGIN TT#1806 - stodd - new placeholders not displaying in correct order
					foreach (UltraGridRow newRow in _addedRowList)
					{
						ugDetails.ActiveRow = newRow;
						ugDetails.ActiveRow.RefreshSortPosition();
					}
					// END TT#1806 - stodd - new placeholders not displaying in correct order
					this.ugDetails.ResumeRowSynchronization();
					this.ugDetails.EndUpdate();
					if (!_addingHeaderToAssortment)
					{
						Cursor.Current = Cursors.Default;
					}
				}
				else
				{
					Cursor.Current = Cursors.Default;
				}
				// END TT#376-MD - stodd - Update Enqueue logic
            }
        }

        private void AddPlaceholderStyle(HierarchyNodeProfile aHnp, int aAsrtRID)
        {
            try
            {
                _addingPlaceholder = true;
                UltraGridRow row = AddHeaderRow();     // new row becomes the active row
				ugDetails.ActiveRow = row;

                _addingPlaceholder = false;
                
                _skipStyleEdit = true;
                // Begin TT#1178 - RMatelic - Placeholder Styles do not match Placeholder ID's - need consistency
                //this.ugDetails.ActiveRow.Cells["Style"].Value = aHnp.LevelText;
                string phHeaderID = DeterminePlaceholderID(aAsrtRID);
                if (aHnp.IsVirtual && aHnp.Purpose == ePurpose.Placeholder)
                {
                    this.ugDetails.ActiveRow.Cells["Style"].Value = phHeaderID;
                }
                else
                {
                    this.ugDetails.ActiveRow.Cells["Style"].Value = aHnp.LevelText;
                }
                // End TT#1178
                this.ugDetails.ActiveRow.Cells["StyleHnRID"].Value = aHnp.Key;
                this.ugDetails.ActiveRow.Cells["Description"].Value = aHnp.NodeDescription;

                HierarchyNodeProfile productHnp = _sab.HierarchyServerSession.GetNodeData(aHnp.HomeHierarchyParentRID);

                _skipProductEdit = true;
                this.ugDetails.ActiveRow.Cells["ProductRID"].Value = productHnp.Key;
                this.ugDetails.ActiveRow.Cells["Product"].Value = productHnp.LevelText;
                this.ugDetails.ActiveRow.Cells["StyleSecurity"].Value = (int)eSecurityType.Update;

                AssortmentProfile asp = (AssortmentProfile)_allocProfileList.FindKey(aAsrtRID);
                HierarchyNodeProfile anchorHnp = this.GetNodeData(asp.AssortmentAnchorNodeRid);
                if (anchorHnp.Key != Include.NoRID)
                {
                    _skipAnchorEdit = true;
                    this.ugDetails.ActiveRow.Cells["AnchorHnRID"].Value = anchorHnp.Key;
                    this.ugDetails.ActiveRow.Cells["AnchorNode"].Value = anchorHnp.LevelText;
                }

                //string replaceChar = " ";
                //string phHeaderID = aHnp.NodeID.Replace(@"\", replaceChar);
                //string phHeaderID = DeterminePlaceholderID(aAsrtRID);

                this.ugDetails.ActiveRow.Cells["HeaderID"].Appearance.ForeColor = this.ugDetails.ActiveRow.Band.Layout.Override.FixedCellAppearance.BackColor;
                this.ugDetails.ActiveRow.Cells["HeaderID"].Value = phHeaderID;
                
                this.ugDetails.ActiveRow.Cells["AsrtRID"].Value = aAsrtRID;
                this.ugDetails.ActiveRow.Cells["AsrtRIDSortCol"].Value = aAsrtRID;
                this.ugDetails.ActiveRow.Cells["Type"].Value = (int)eHeaderType.Placeholder;

                int hdrRID = Convert.ToInt32(this.ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                this.ugDetails.ActiveRow.Cells["PlaceHolderRID"].Value = hdrRID;
                this.ugDetails.ActiveRow.Cells["PlaceHolderRIDSortCol"].Value = hdrRID;
				// Begin TT#1227 - stodd
				int newSeq = IncreaseLastPlaceholderSeq(aAsrtRID);
				this.ugDetails.ActiveRow.Cells["AsrtPlaceholderSortSeq"].Value = newSeq;	// TT#1227 - stodd
				this.ugDetails.ActiveRow.Cells["AsrtHeaderSortSeq"].Value = 0;	// TT#1227 - stodd
				// End TT#1227 - stodd

                this.ugDetails.ActiveRow.Cells["ChildTotal"].Value = 0;
                this.ugDetails.ActiveRow.Cells["HdrQuantity"].Value = 0;

				// BEGIN TT#1806 - stodd - new placeholders not displaying in correct order
				_addedRowList.Add(this.ugDetails.ActiveRow);
                //this.ugDetails.ActiveRow.RefreshSortPosition();
				// END TT#1806 - stodd - new placeholders not displaying in correct order

                // add new rid and ID to ValueList
                // Begin TT#1227 - RMatelic - Placeholders s/b sorted by a sequence number; unrelated to issue
                //_placeHolders.Rows.Add(new object[] { hdrRID, phHeaderID });
                if (aHnp.IsVirtual && aHnp.Purpose == ePurpose.Placeholder)
                {
                    _placeHolders.Rows.Add(new object[] { hdrRID, phHeaderID });
                }
                else
                {
                    _placeHolders.Rows.Add(new object[] { hdrRID, aHnp.LevelText });
                }
                // End TT#1227

                ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Clear();
                foreach (DataRow dr in _placeHolders.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Add(Convert.ToInt32(dr["PlaceHolderRID"], CultureInfo.CurrentUICulture), dr["PlaceHolderID"].ToString());
                }
                SetEditActivation(this.ugDetails.ActiveRow);
            }
            catch
            {
                throw;
            }
        }

        //private void AddToAssortmentTab(UltraGridRow aRow)
        //{
        //    NodeCharProfileList charProfList;
        //    NodeCharProfile charProf;
        //    eHeaderType headerType;
        //    string hashKey;
        //    try
        //    {
        //        UltraGridRow headerRow = aRow;

        //        while (headerRow.Band.Key != "Header")
        //        {
        //            headerRow = headerRow.ParentRow;
        //        }
        //        UltraGridColumn asrtRIDColumn = headerRow.Band.Columns["AsrtRID"];
        //        AssortmentProfile asp = (AssortmentProfile)_allocProfileList.FindKey(Convert.ToInt32(headerRow.GetCellValue(asrtRIDColumn), CultureInfo.CurrentUICulture));
        //        //int asrtRID = Convert.ToInt32(headerRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
        //        //AssortmentProfile asp = (AssortmentProfile)_allocProfileList.FindKey(asrtRID);
       
        //        UltraGridColumn keyHColumn = aRow.Band.Columns["KeyH"];
        //        AssortmentProfile ap = (AssortmentProfile)_allocProfileList.FindKey(Convert.ToInt32(aRow.GetCellValue(keyHColumn), CultureInfo.CurrentUICulture));
        //        headerType = ap.HeaderType;

        //        //DataTable dtComponents = _asrtCubeGroup.GetAssortmentComponents();
        //        AllocationSummaryComponentVariables summaryComponentVars = new AllocationSummaryComponentVariables();
        //        summaryComponentVars.Initialize();
        //        DataTable dtHdrComponents = AllocationProfile.CreateAllocationComponentTable(summaryComponentVars);
        //        AssortmentViewComponentVariables vars = (AssortmentViewComponentVariables)_asrtCubeGroup.AssortmentComponentVariables;
              
        //        ap.GetAllocationComponents(_asrtCubeGroup, dtHdrComponents);
               
        //        Hashtable packHash = new Hashtable();
        //        Hashtable packColorHash = new Hashtable(); 

        //        //AssortmentProfile.PackColorHashEntry packHashEntry;
        //        //AssortmentProfile.PackColorHashEntry packColorHashEntry;
                
                
        //        object[] rowParms = new object[_dtHeaders.Columns.Count];
        //        int i;

        //        if (headerType == eHeaderType.Placeholder)
        //        {
        //            for (int j = _dtHeaders.Rows.Count - 1; j >= 0; j--)
        //            {
        //                DataRow row = _dtHeaders.Rows[j];
                  
        //                if (ap.Key == Convert.ToInt32(row["PLACEHOLDER_RID"], CultureInfo.CurrentUICulture) &&
        //                    Convert.ToInt32(row["HEADER_RID"], CultureInfo.CurrentUICulture) == int.MaxValue)
        //                {
        //                    _dtHeaders.Rows.Remove(row);
        //                }
        //            }
        //            _dtHeaders.AcceptChanges();

        //            foreach (DataRow hdrRow in dtHdrComponents.Rows)
        //            {
        //                i = 0;
        //                rowParms[i++] = false;
        //                rowParms[i++] = true;

        //                foreach (AssortmentComponentVariableProfile varProf in vars.VariableProfileList)
        //                {
        //                    if (varProf.Key == vars.Assortment.Key)
        //                    {
        //                        rowParms[i++] = asp.Key;
        //                        rowParms[i++] = asp.HeaderID;
        //                        rowParms[i++] = DBNull.Value;
        //                    }
        //                    else if (varProf.Key == vars.Placeholder.Key)
        //                    {
        //                        rowParms[i++] = hdrRow[vars.HeaderID.RIDColumnName];
        //                        rowParms[i++] = hdrRow[vars.HeaderID.TextColumnName];
        //                        rowParms[i++] = DBNull.Value;
        //                    }
        //                    else if (varProf.Key == vars.HeaderID.Key)
        //                    {
        //                        rowParms[i++] = int.MaxValue;
        //                        rowParms[i++] = MIDText.GetTextOnly(eMIDTextCode.msg_as_PlaceholderBalance);
        //                        rowParms[i++] = DBNull.Value;
        //                    }
        //                    else if (varProf.Key >= (int)eAssortmentComponentVariables.Characteristic)
        //                    {
        //                        charProfList = SAB.HierarchyServerSession.GetProductCharacteristics(ap.StyleHnRID);
        //                        charProf = (NodeCharProfile)charProfList.FindKey(varProf.Key - (int)eAssortmentComponentVariables.Characteristic);

        //                        if (charProf != null)
        //                        {
        //                            rowParms[i++] = charProf.ProductCharValueRID;
        //                            rowParms[i++] = charProf.ProductCharValue;
        //                            rowParms[i++] = DBNull.Value;
        //                        }
        //                        else
        //                        {
        //                            rowParms[i++] = int.MaxValue;
        //                            rowParms[i++] = DBNull.Value;
        //                            rowParms[i++] = DBNull.Value;
        //                        }
        //                    }
        //                    else if (varProf.Key == vars.Pack.Key)
        //                    {
        //                        rowParms[i++] = hdrRow[varProf.RIDColumnName];
        //                        rowParms[i++] = hdrRow[varProf.TextColumnName];
        //                        rowParms[i++] = Convert.ToString(hdrRow[varProf.TextColumnName]) + " (" + Convert.ToString(hdrRow[vars.HeaderID.TextColumnName]) + ")";
        //                    }
        //                    else
        //                    {
        //                        rowParms[i++] = hdrRow[varProf.RIDColumnName];
        //                        rowParms[i++] = hdrRow[varProf.TextColumnName];
        //                        rowParms[i++] = DBNull.Value;
        //                    }
        //                }
        //                _dtHeaders.Rows.Add(rowParms);
        //                //hashKey = Convert.ToString(hdrRow[vars.HeaderID.TextColumnName]) + Convert.ToString(hdrRow[vars.Pack.TextColumnName]);
        //                //packHash[hashKey] = new asp.PackColorHashEntry(
        //                //    Convert.ToInt32(hdrRow[vars.Pack.RIDColumnName]),
        //                //    Convert.ToString(hdrRow[vars.Pack.TextColumnName]),
        //                //    Convert.ToString(hdrRow[vars.Pack.TextColumnName]) + " (" + Convert.ToString(hdrRow[vars.HeaderID.TextColumnName]) + ")");

        //                //hashKey = Convert.ToString(hdrRow[vars.HeaderID.TextColumnName]) + Convert.ToString(hdrRow[vars.Pack.TextColumnName]) + Convert.ToString(hdrRow[vars.Color.TextColumnName]);
        //                //packColorHash[hashKey] = new PackColorHashEntry(
        //                //    Convert.ToInt32(hdrRow[vars.Color.RIDColumnName]),
        //                //    Convert.ToString(hdrRow[vars.Color.TextColumnName]),
        //                //    String.Empty);
        //            }
        //        }
        //        else
        //        {
        //            foreach (DataRow hdrRow in dtHdrComponents.Rows)
        //            {
                         
        //                //plchldrProf = AppSessionTransaction.GetAllocationProfile(Convert.ToInt32(assrtRow["PLACEHOLDER_RID"]));
        //                AssortmentProfile plchldrProf = (AssortmentProfile)_allocProfileList.FindKey(ap.PlaceHolderRID);
        //                i = 0;
        //                rowParms[i++] = false;
        //                rowParms[i++] = false;

        //                foreach (AssortmentComponentVariableProfile varProf in vars.VariableProfileList)
        //                {
        //                    if (varProf.Key == vars.Assortment.Key)
        //                    {
        //                        rowParms[i++] = asp.Key;
        //                        rowParms[i++] = asp.HeaderID;
        //                        rowParms[i++] = DBNull.Value;
        //                    }
        //                    else if (varProf.Key == vars.Placeholder.Key)
        //                    {
        //                        rowParms[i++] = plchldrProf.Key;
        //                        rowParms[i++] = plchldrProf.HeaderID;
        //                        rowParms[i++] = DBNull.Value;
        //                    }
        //                    else if (varProf.Key >= (int)eAssortmentComponentVariables.Characteristic)
        //                    {
        //                        charProfList = SAB.HierarchyServerSession.GetProductCharacteristics(ap.StyleHnRID);
        //                        charProf = (NodeCharProfile)charProfList.FindKey(varProf.Key - (int)eAssortmentComponentVariables.Characteristic);

        //                        if (charProf != null)
        //                        {
        //                            rowParms[i++] = charProf.ProductCharValueRID;
        //                            rowParms[i++] = charProf.ProductCharValue;
        //                            rowParms[i++] = DBNull.Value;
        //                        }
        //                        else
        //                        {
        //                            rowParms[i++] = int.MaxValue;
        //                            rowParms[i++] = DBNull.Value;
        //                            rowParms[i++] = DBNull.Value;
        //                        }
        //                    }
        //                    else if (varProf.Key == vars.Pack.Key)
        //                    {
        //                        rowParms[i++] = hdrRow[varProf.RIDColumnName];
        //                        rowParms[i++] = hdrRow[varProf.TextColumnName];
        //                        rowParms[i++] = Convert.ToString(hdrRow[varProf.TextColumnName]) + " (" + plchldrProf.HeaderID + ")";
        //                    }
        //                    else
        //                    {
        //                        rowParms[i++] = hdrRow[varProf.RIDColumnName];
        //                        rowParms[i++] = hdrRow[varProf.TextColumnName];
        //                        rowParms[i++] = DBNull.Value;
        //                    }
        //                }

        //                _dtHeaders.Rows.Add(rowParms);

        //                //hashKey = plchldrProf.HeaderID + Convert.ToString(hdrRow[vars.Pack.TextColumnName]);
        //                //packHashEntry = (PackColorHashEntry)packHash[hashKey];

        //                //if (packHashEntry == null)
        //                //{
        //                //    packHashEntry = new PackColorHashEntry(
        //                //        Convert.ToInt32(hdrRow[vars.Pack.RIDColumnName]),
        //                //        Convert.ToString(hdrRow[vars.Pack.TextColumnName]),
        //                //        Convert.ToString(hdrRow[vars.Pack.TextColumnName]) + " (" + plchldrProf.HeaderID + ")");
        //                //    packHash[hashKey] = packHashEntry;
        //                //}

        //                //hashKey = plchldrProf.HeaderID + packHashEntry.ID + Convert.ToString(hdrRow[vars.Color.TextColumnName]);
        //                //packColorHashEntry = (PackColorHashEntry)packColorHash[hashKey];

        //                //if (packColorHashEntry == null)
        //                //{
        //                //    packColorHashEntry = new PackColorHashEntry(
        //                //        Convert.ToInt32(hdrRow[vars.Color.RIDColumnName]),
        //                //        Convert.ToString(hdrRow[vars.Color.TextColumnName]),
        //                //        string.Empty);
        //                //    packHash[hashKey] = packColorHashEntry;

        //                //    i = 0;
        //                //    rowParms = new object[aComponentTable.Columns.Count];
        //                //    rowParms[i++] = true;
        //                //    rowParms[i++] = true;

        //                //    foreach (AssortmentComponentVariableProfile varProf in vars.VariableProfileList)
        //                //    {
        //                //        if (varProf.Key == vars.Assortment.Key)
        //                //        {
        //                //            rowParms[i++] = asp.Key;
        //                //            rowParms[i++] = asp.HeaderID;
        //                //            rowParms[i++] = DBNull.Value;
        //                //        }
        //                //        else if (varProf.Key == vars.Placeholder.Key)
        //                //        {
        //                //            rowParms[i++] = plchldrProf.Key;
        //                //            rowParms[i++] = plchldrProf.HeaderID;
        //                //            rowParms[i++] = DBNull.Value;
        //                //        }
        //                //        else if (varProf.Key == vars.HeaderID.Key)
        //                //        {
        //                //            rowParms[i++] = int.MaxValue;
        //                //            rowParms[i++] = MIDText.GetTextOnly(eMIDTextCode.msg_as_PlaceholderBalance);
        //                //            rowParms[i++] = DBNull.Value;
        //                //        }
        //                //        else if (varProf.Key >= (int)eAssortmentComponentVariables.Characteristic)
        //                //        {
        //                //            charProfList = SAB.HierarchyServerSession.GetProductCharacteristics(hdrProf.StyleHnRID);
        //                //            charProf = (NodeCharProfile)charProfList.FindKey(varProf.Key - (int)eAssortmentComponentVariables.Characteristic);

        //                //            if (charProf != null)
        //                //            {
        //                //                rowParms[i++] = charProf.ProductCharValueRID;
        //                //                rowParms[i++] = charProf.ProductCharValue;
        //                //                rowParms[i++] = DBNull.Value;
        //                //            }
        //                //            else
        //                //            {
        //                //                rowParms[i++] = int.MaxValue;
        //                //                rowParms[i++] = DBNull.Value;
        //                //                rowParms[i++] = DBNull.Value;
        //                //            }
        //                //        }
        //                //        else if (varProf.Key == vars.Pack.Key)
        //                //        {
        //                //            rowParms[i++] = packHashEntry.RID;
        //                //            rowParms[i++] = packHashEntry.ID;
        //                //            rowParms[i++] = packHashEntry.AlternateID;
        //                //        }
        //                //        else
        //                //        {
        //                //            rowParms[i++] = hdrRow[varProf.RIDColumnName];
        //                //            rowParms[i++] = hdrRow[varProf.TextColumnName];
        //                //            rowParms[i++] = DBNull.Value;
        //                //        }
        //                //    }

        //                     //_dtHeaders.Rows.Add(rowParms);
        //                //}

        //                //aPackColorXRef.AddXRefIdEntry(
        //                //    plchldrProf.Key,
        //                //    packHashEntry.RID,
        //                //    packColorHashEntry.RID,
        //                //    Convert.ToInt32(hdrRow[vars.HeaderID.RIDColumnName]),
        //                //    Convert.ToInt32(hdrRow[vars.Pack.RIDColumnName]),
        //                //    Convert.ToInt32(hdrRow[vars.Color.RIDColumnName]));
        //                //}
                       
        //            }
        //        }
        //    }
        //    catch
        //    {
        //        throw;
        //    }
        //}  
 
        private string DeterminePlaceholderID(int aAsrtRID)
        {
            ArrayList placeholderList = new ArrayList();
            string phHeaderID = string.Empty;
            try
            {
                string lblPhStyle = MIDText.GetTextOnly(eMIDTextCode.lbl_PhStyle);
               
                AllocationProfile ap = GetAllocationProfile(aAsrtRID);
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (row.Cells["AsrtRID"].Value != DBNull.Value
                     && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == aAsrtRID 
                     && Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                    {
                        string phHdrID = Convert.ToString(row.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                        if (!placeholderList.Contains(phHdrID))
                        {
                            placeholderList.Add(phHdrID);
                        }    
                    }
                }
                int placeholderCount = placeholderList.Count;
                placeholderCount++;
                phHeaderID = ap.HeaderID + " " + lblPhStyle + " " + placeholderCount.ToString(CultureInfo.CurrentUICulture);
                while (placeholderList.Contains(phHeaderID))
                {
                    placeholderCount++;
                    phHeaderID = ap.HeaderID + " " + lblPhStyle + " " + placeholderCount.ToString(CultureInfo.CurrentUICulture);
                }
                return phHeaderID; 
            }
            catch
            {

                throw;
            }
        }

        private UltraGridRow AddHeaderRow()
        {
            try
            {
                UltraGridRow row = this.ugDetails.DisplayLayout.Bands["Header"].AddNew();
                this.ugDetails.ActiveRow = row;
                this.ugDetails.ActiveRow.Cells["HeaderID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                //this.ugDetails.ActiveCell = this.ugDetails.ActiveRow.Cells["HeaderID"];
                this.ugDetails.ActiveRow.Cells["StyleSecurity"].Value = (int)eSecurityType.Update;
                this.ugDetails.ActiveRow.Cells["Status"].Value = (int)eHeaderAllocationStatus.ReceivedInBalance;
                this.ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                _headerAdded = true;
				return row;
            }
            catch
            {
                throw;
            }
        }

        private void cmsInsertMTColorRow_Click(object sender, EventArgs e)
        {
            try
            {
                switch (_rClickRow.Band.Key)
                {
                    case "Header":
                    case "BulkColor":
                        _addingMTColorRow = true;
                        AddBulkColorRow();
                        break;

                    case "Pack":
                    case "PackColor":
                        ugDetails.ActiveRow = _rClickRow;
                        _addingMTColorRow = true;
                        AddPackColorRow();
                        break;

                }
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private void cmsChooseColor_Click(object sender, EventArgs e)
        {
            try
            {
                ArrayList colorRIDs = new ArrayList();
                bool allowPlaceHolders = false;
                _fromCellButton = false;
                _colorSelectRow = _rClickRow;

                if (ugDetails.Selected.Rows.Count == 0)
                {
                    _colorSelectRow.Selected = true;
                }
                foreach (UltraGridRow selectedRow in ugDetails.Selected.Rows)
                {
                    UltraGridRow selRow = selectedRow;
                    while (selRow.Band.Key != "Header")
                    {
                        selRow = selRow.ParentRow;
                    }
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (headerType == eHeaderType.Assortment || headerType == eHeaderType.Placeholder)
                    {
                        UltraGridRow colorRow = null;
                        allowPlaceHolders = true;

                        switch (selectedRow.Band.Key)
                        {
                            case "Header":
                                if (ugDetails.DisplayLayout.Bands.Exists("BulkColor"))
                                {
                                    colorRow = selectedRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                                }
                                break;

                            case "Pack":
                                if (ugDetails.DisplayLayout.Bands.Exists("PackColor"))
                                {
                                    colorRow = selectedRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                                }
                                break;

                            default:
                                colorRow = selectedRow.GetSibling(SiblingRow.First, false);
                                break;
                        }

                        while (colorRow != null)
                        {
                            int colorCodeRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                            if (Convert.ToBoolean(colorRow.Cells["IsVirtual"].Value, CultureInfo.CurrentUICulture))
                            {
                                if (!colorRIDs.Contains(colorCodeRID))
                                {
                                    colorRIDs.Add(colorCodeRID);
                                }
                            }
                            colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                }
                ChooseColors(allowPlaceHolders, colorRIDs);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void cmsInsertPack_Click(object sender, EventArgs e)
        {
            try
            {
                AddPackRow();
            }
            catch (Exception ex)
            {
                MIDException MIDExc = new MIDException(eErrorLevel.information, 0, ex.Message);
                HandleMIDException(MIDExc);
            }
        }

        private bool AddPackRow()
        {
            bool addOK = true;
            try
            {
                if (!RowActive())
                {
                    addOK = false;
                }
                else
                {
                    while (ugDetails.ActiveRow.Band.Key != "Header")
                    {
                        ugDetails.ActiveRow = ugDetails.ActiveRow.ParentRow;
						// Begin TT#936 - MD - Prevent the saving of empty Group Allocations
						// If an error is encountered goes into loop
                        if (_errors != null)
                        {
                            break;
                        }
						// End TT#936 - MD - Prevent the saving of empty Group Allocations
                    }

                    int hdrRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                    //UltraGridRow row = this.ugDetails.DisplayLayout.Bands["Pack"].AddNew();
                    UltraGridRow row = null;
                    // sometimes AddNew() doesn't work, so add to table
                    if (row == null)
                    {
                        object[] Keys = new object[2];
                        Keys[0] = hdrRID;
                        Keys[1] = string.Empty;
                        DataRow drPack = _dsDetails.Tables["Pack"].Rows.Find(Keys);
                        if (drPack != null)
                        {
                            return false;
                        }
                        DataRow newRow = _dsDetails.Tables["Pack"].NewRow();
                        newRow["KeyH"] = hdrRID;
                        newRow["Pack"] = string.Empty;
                        _dsDetails.Tables["Pack"].Rows.Add(newRow);
                        _dsDetails.Tables["Pack"].AcceptChanges();
                        this.ugDetails.UpdateData();
                        _dsDetails.Tables["Header"].AcceptChanges();
                        row = ugDetails.ActiveRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["Pack"]);
                        while (row != null)
                        {
                            if ((int)row.Cells["KeyP"].Value == 0)
                            {
                                break;
                            }
                            row = row.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                    row.Cells["KeyH"].Value = hdrRID;
                    CalculateBalances(eBalanceAction.RowAdded, row.Cells["QuantityPerPack"]);
                    ugDetails.ActiveRow = row;
                    ugDetails.ActiveCell = row.Cells["Pack"];
                    if (!_addingHeaderToAssortment)
                    {
                        ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                    }
                    _rClickRow = row;
                }
            }
            catch
            {
                addOK = false;
                throw;
            }
            return addOK;
        }



        private void cmsInsertBulkSize_Click(object sender, EventArgs e)
        {
            try
            {
                UltraGridRow bulkColorRow = ugDetails.ActiveRow;

                if (bulkColorRow.Band.Key != "BulkColor")
                {
                    if (_rClickRow.Band.Key == "BulkColor")
                    {
                        bulkColorRow = _rClickRow;
                    }
                    else
                    {
                        return;
                    }
                }

                bulkColorRow.Update();   
                UltraGridRow headerRow = bulkColorRow.ParentRow;

                this.ugDetails.UpdateData();

                string colorID = bulkColorRow.Cells["BulkColor"].Value.ToString();
                int headerRID = Convert.ToInt32(bulkColorRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                int colorRID = Convert.ToInt32(bulkColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                int colorCodeRID = Convert.ToInt32(bulkColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                 
                string sizeTableName = "BulkSize" + "~"
                    + headerRID.ToString(CultureInfo.CurrentUICulture) + "~"
                    + colorRID.ToString(CultureInfo.CurrentUICulture);

                // does it already exist?
                if (_dsDetails.Relations.Contains(sizeTableName))
                {
                    MessageBox.Show(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SizeTableExists));
                    return;
                }

                // get the size group
              
                AllocationProfile ap = GetAllocationProfile(headerRID);
                if (ap.SizeGroupRID == Include.UndefinedSizeGroupRID)
                {
                    MessageBox.Show(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SizeGroupRequired),
                            this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                int sizeTotal = 0;
                _addingSizes = true;
                DataTable dtBulkSize = FormatBulkSizeTable(null, ap.SizeGroupRID, headerRID, colorRID, colorID, sizeTableName, ref sizeTotal);

                if (dtBulkSize != null)
                {
                    // adding a new table to the DataSet fires the InitializeLayout event, but we don't want that here
                    ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, false);
                    // BEGIN MID Track #6026 - WorkUpBuy issues - AfterSelectChange was clearing _selectedHeaderKeyList
                    ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                    // END MID Track #6026 
                    _dsDetails.Tables.Add(dtBulkSize);

                    _dsDetails.Relations.Add(sizeTableName,
                        new DataColumn[] { _dsDetails.Tables["BulkColor"].Columns["KeyH"], _dsDetails.Tables["BulkColor"].Columns["KeyC"] },
                        new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyC"] }, true);

                    _dsDetails.AcceptChanges();
                    // For some reason if a size band is added, deleted & re-added with no Save or Cancel,
                    // 2 bands with the same sizeTableName were created one of which is actually the BulkColor
                    // band columns. This caused subsequent errors because an erroneous band existed
                    // The BindDetailsGrid gets rid of the erroneous extra band
                    BindDetailsGrid();

                    FormatAddedSizesLayout(ugDetails.DisplayLayout.Bands[sizeTableName]);
                    // BEGIN MID Track #6026 - WorkUpBuy issues
                    ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                    // END MID Track #6026 - WorkUpBuy issues
                    ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, true);

                    ugDetails.BeginUpdate();
                    headerRow = bulkColorRow.ParentRow;
                    ugDetails.ActiveRow = headerRow;
                    headerRow.ExpandAll();
                    UltraGridRow row = headerRow.GetChild(ChildRow.First);
                    while (row != null)
                    {
                        int colorRowValue = Convert.ToInt32(row.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                        int bulkColorRowValue = Convert.ToInt32(bulkColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                        if (colorRowValue != bulkColorRowValue)
                        {
                            row.Expanded = false;
                        }
                        row = row.GetSibling(SiblingRow.Next, true, false);
                    }

                    ugDetails.ActiveRow = headerRow;
                    ugDetails.DisplayLayout.RowScrollRegions[0].ScrollRowIntoView(ugDetails.ActiveRow);
                    ugDetails.EndUpdate();

                    if ((eHeaderType)Convert.ToInt32(headerRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == eHeaderType.Placeholder)
                    {
                        UltraGridRow sizeRow = bulkColorRow.GetChild(ChildRow.First);
                        while (sizeRow != null)
                        {
                            for (int j = 7; j < sizeRow.Cells.Count; j++)
                            {
                                int sizeCodeKey = Convert.ToInt32(sizeRow.Cells[j].Tag, CultureInfo.CurrentUICulture);
                                sizeRow.Cells[j].Value = 0;
                                ap.AddBulkSizeToColor(colorCodeRID, sizeCodeKey, 0, -1);
                                sizeRow.Cells[j].Activation = Activation.AllowEdit;
                            }
                            sizeRow = sizeRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                    UltraGridRow lastRow = bulkColorRow.GetChild(ChildRow.Last);
                    ScrollRowIntoView(lastRow);

					SaveAndUpdateAssortmentTab();	// TT#854 - MD - stodd - enqueue error 
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }

        }

        private void ScrollRowIntoView(UltraGridRow aRow)
        {
            try
            {
                this.ugDetails.DisplayLayout.RowScrollRegions[0].ScrollRowIntoView(aRow);
            }
            catch
            {
                throw;
            }
        }

        private void cmsInsertPackSize_Click(object sender, EventArgs e)
        {
            string errorMessage = string.Empty;
            string colorID, sizeTableName, namePrefix, packName;
            int headerRID, packRID, colorRID, sizeTotal, colorCodeRID;
            UltraGridRow headerRow;
            try
            {
                UltraGridRow packColorRow = ugDetails.ActiveRow;
                if (packColorRow.Band.Key != "PackColor" && packColorRow.Band.Key != "Pack")
                {
                    if (_rClickRow.Band.Key == "PackColor" || packColorRow.Band.Key == "Pack")
                    {
                        packColorRow = _rClickRow;
                    }
                    else
                    {
                        return;
                    }
                }
                packColorRow.Update();

                if (packColorRow.Band.Key == "PackColor")
                {
                    headerRow = packColorRow.ParentRow.ParentRow;
                    colorID = packColorRow.Cells["PackColor"].Value.ToString();
                    colorRID = Convert.ToInt32(packColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                    namePrefix = "PackColorSize";
                    packName = packColorRow.ParentRow.Cells["Pack"].Value.ToString();
                    colorCodeRID = Convert.ToInt32(packColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                }
                else
                {
                    headerRow = packColorRow.ParentRow;
                    ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(Include.DummyColorRID);
                    colorID = ccp.ColorCodeID;
                    colorRID = ccp.Key;
                    namePrefix = "PackSize";
                    if (!DummyColorCheckOK(packColorRow))
                    {
                        return;
                    }
                    packName = packColorRow.Cells["Pack"].Value.ToString();
                    colorCodeRID = Include.DummyColorRID;
                }
              
                headerRID = Convert.ToInt32(packColorRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                packRID = Convert.ToInt32(packColorRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                sizeTableName = namePrefix + "~"
                    + headerRID.ToString(CultureInfo.CurrentUICulture) + "~"
                    + packRID.ToString(CultureInfo.CurrentUICulture) + "~"
                    + colorRID.ToString(CultureInfo.CurrentUICulture);

                // does it already exist?
                if (_dsDetails.Relations.Contains(sizeTableName))
                {
                    MessageBox.Show(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SizeTableExists));
                    return;
                }

                // get the size group
               
                AllocationProfile ap = GetAllocationProfile(headerRID);
                if (ap.SizeGroupRID == Include.UndefinedSizeGroupRID)
                {
                    MessageBox.Show(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SizeGroupRequired),
                           _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                sizeTotal = 0;
                _addingSizes = true;
                DataTable dtPackSize = FormatPackSizeTable(null, ap.SizeGroupRID, headerRID, packRID, colorRID, colorID, sizeTableName, ref sizeTotal);

                if (dtPackSize != null)
                {   // adding a new table to the DataSet fires the InitializeLayout event, but we don't want that here
                    ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, false);
                    _dsDetails.Tables.Add(dtPackSize);

                    try
                    {
                        if (colorID == Include.DummyColorID)
                        {
                            _dsDetails.Relations.Add(sizeTableName,
                                new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                                new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyP"] }, true);
                        }
                        else
                        {
                            _dsDetails.Relations.Add(sizeTableName,
                                new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"], _dsDetails.Tables["PackColor"].Columns["KeyC"] },
                                new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyP"], _dsDetails.Tables[sizeTableName].Columns["KeyC"] }, true);
                        }
                        _dsDetails.AcceptChanges();
                        // For some reason if a size band is added, deleted & re-added with no Save or Cancel,
                        // 2 bands with the same sizeTableName were created one of which is actually the BulkcColor
                        // band columns. This caused subsequent errors because an erroneous band existed
                        // The BindDetailsGrid gets rid of the extra band
                        BindDetailsGrid();

                        FormatAddedSizesLayout(ugDetails.DisplayLayout.Bands[sizeTableName]);
                        ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, true);

                        packColorRow.Expanded = true;

                        if ((eHeaderType)Convert.ToInt32(headerRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == eHeaderType.Placeholder)
                        {
                            UltraGridRow sizeRow = packColorRow.GetChild(ChildRow.First);
                            while (sizeRow != null)
                            {
                                for (int j = 7; j < sizeRow.Cells.Count; j++)
                                {
                                    int sizeCodeKey = Convert.ToInt32(sizeRow.Cells[j].Tag, CultureInfo.CurrentUICulture);
                                    sizeRow.Cells[j].Value = 0;
                                    ap.AddSizeToPackColor(packName, colorCodeRID, sizeCodeKey, 0, -1);
                                    sizeRow.Cells[j].Activation = Activation.AllowEdit;
                                }
                                sizeRow = sizeRow.GetSibling(SiblingRow.Next, false, false);
                            }
                        }
                        UltraGridRow lastRow = packColorRow.GetChild(ChildRow.Last);
                        ScrollRowIntoView(lastRow);
                    }
                    catch
                    {
                        throw;
                    }
                }
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }

        }

        private bool DummyColorCheckOK(UltraGridRow aRow)
        {
            ColorCodeProfile ccp;
            EditMsgs em;
            try
            {
                ccp = _sab.HierarchyServerSession.GetColorCodeProfile(Include.DummyColorRID);
                if (ccp.Key == -1)
                {
                    throw new Exception();
                }
              
                AllocationProfile ap = GetAllocationProfile(Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));

                HierarchyNodeProfile styleHnp = _sab.HierarchyServerSession.GetNodeData(ap.StyleHnRID);
                em = new EditMsgs();
                int colorHnRID = _hierMaint.QuickAdd(ref em, styleHnp.Key, ccp.ColorCodeID, ccp.ColorCodeName);
                if (em.ErrorFound)
                {
                    DisplayMessages.Show(em, _sab, _windowName);
                    return false;
                }

                string packName = Convert.ToString(aRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture);

                bool dummyOnPack = false;
                int[] packColorCodeRIDs;

                if (ap.PackIsOnHeader(packName))
                {
                    packColorCodeRIDs = ap.GetPackColorCodeRIDs(packName);
                    if (packColorCodeRIDs.Length > 0)
                    {
                        for (int i = 0; i < packColorCodeRIDs.Length; i++)
                        {
                            if (packColorCodeRIDs[i] == Include.DummyColorRID)
                            {
                                dummyOnPack = true;
                                break;
                            }
                        }
                    }
                }
                
                if (!dummyOnPack)
                {
                    // finally, add it to the header
                    if (!ap.MultiHeader)
                    {
                        ap.AddColorToPack(packName, Include.DummyColorRID, 0, 0);
                    }
                }
                return true;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void cmsRemove_Click(object sender, EventArgs e)
        {
            Cursor.Current = Cursors.WaitCursor;
            UltraGridRow headerRow = null;
            UltraGridRow asrtRow = null;
            eHeaderType headerType;
            bool errorFound = false;
            string errMessage = string.Empty;
            ArrayList removedHeaderRids = new ArrayList();	// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
            try
            {
                Hashtable phWithRemovedHeaders = new Hashtable(); // TT#2 - RMatelic - Assortment Planning - removing multiple headers not updating placeholder correctly
                //Begin  TT#2121 - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message “Object cannot be cast from DBNull to other types.?
				Hashtable removedPHwithExistingHeaders = new Hashtable();
				//End  TT#2121 - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message �“Object cannot be cast from DBNull to other types.?
                //foreach (UltraGridRow row in ugDetails.Rows)
                //{
                //    if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Assortment)
                //    {
                //        if (Convert.ToInt32(row.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance)
                //        {
                //            errorFound = true;
                //            string asrtType = MIDText.GetTextOnly((int)eHeaderType.Assortment);
                //            errMessage = string.Format(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_InvalidAssrtStatus), asrtType);
                //        }
                //        break;
                //    }
                //}
                if (errorFound)
                {
                    MessageBox.Show(errMessage, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                if (_rClickRow != null)
                {
                    _rClickRow.Selected = true;
                }
                 
                // TODO; some rows added to placeholders can be deleted; may need some additional logic
                if (_rClickRow.Band.Key != "Header")
                {
                    headerRow = _rClickRow.ParentRow;
                    while (headerRow.Band.Key != "Header")
                    {
                        headerRow = headerRow.ParentRow;
                    }
                    _deletedPhComponents.Clear();
                    _deletedPlaceholderPacks.Clear();
                    if (Convert.ToInt32(headerRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                    {
                        ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, true);
                        ugDetails.DeleteSelectedRows(); // delete rows and exit
                        return;
                    }
                }
               
                // TODO: these next lines may need to be moved; put here  
                _deletedHeaderRows.Clear();
                _removedAsrtHeaders.Clear();
                //
                _deletedPlaceholderStyles.Clear();
                _deletedAssortmentStyles.Clear();

                ugDetails.BeginUpdate();
                ugDetails.SuspendRowSynchronization();
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, false);

                ArrayList removedHeaders = new ArrayList();
                ArrayList deletedPlaceHolders = new ArrayList();

                int deleteRowCount = 0; // TT#2 - RMatelic - Assortment Planning>> add nag message on Remove Placeholder
                foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                {
                    headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    switch (headerType)
                    {
                        case eHeaderType.Assortment:
                            break;
                        case eHeaderType.Placeholder:
                            if (!OKToDeleteRow(selRow))
                            {
                                errorFound = true;
                                return;
                            }
							// Begin TT#983 - MD - stodd - remove message row count incorrect - 
                            eAssortmentType asrtType = GetAssortmentType();
                            if (asrtType == eAssortmentType.PreReceipt)
                            {
                                deleteRowCount++;  // TT#2 - RMatelic - Assortment Planning>> add nag message on Remove Placeholder
                            }
							// End TT#983 - MD - stodd - remove message row count incorrect - 
                            int phRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            deletedPlaceHolders.Add(selRow);
                            foreach (UltraGridRow row in ugDetails.Rows)
                            {
                                if (row.Cells["PlaceHolderRID"].Value != DBNull.Value
                                    && Convert.ToInt32(row.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == phRID
                                    && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != phRID)
                                {
                                    if (!removedHeaders.Contains(row))
                                    {
                                        removedHeaders.Add(row);
                                        removedHeaderRids.Add(Convert.ToInt32(row.Cells["KeyH"].Value));	// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                                    }
                                    row.Selected = true;
                                }
                            }
                            break;

                        default:
                            if (selRow.Cells["AsrtRID"].Value != DBNull.Value) // TODO may need to further qualify
                            {
                                if (!removedHeaders.Contains(selRow))
                                {
                                    removedHeaders.Add(selRow);
                                    removedHeaderRids.Add(Convert.ToInt32(selRow.Cells["KeyH"].Value));	// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces

                				//Begin TT#2121 - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message �“Object cannot be cast from DBNull to other types.? 
                                }
                                deleteRowCount++;  // TT#2 - RMatelic - Assortment Planning>> add nag message on Remove Placeholder
                                // Begin TT#2 - RMatelic - Assortment Planning - removing multiple headers not updating placeholder correctly
                                int pRID = Convert.ToInt32(selRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture);
                                foreach (UltraGridRow row in ugDetails.Rows)
                                {
                                    if (row.Cells["PlaceHolderRID"].Value != DBNull.Value
                                       && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == pRID
                                        && row.Selected)
                                    {
                                        if (!phWithRemovedHeaders.ContainsKey(pRID))
                                        {
                                            phWithRemovedHeaders.Add(pRID, row);
                                        }
                                        break; 
                                    }
                                    if (row.Cells["PlaceHolderRID"].Value != DBNull.Value
                                        && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == pRID
                                        && !row.Selected)
                                    {
                                        if (!removedPHwithExistingHeaders.ContainsKey(pRID))
                                        {
                                            removedPHwithExistingHeaders.Add(pRID, row);
                                        }
                                        break;
                                    }
                                }
                                // End TT#2
								//}
								//End TT#2121 - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message �“Object cannot be cast from DBNull to other types.? 
                            }
                            break;
                    }
                }

                // Begin TT#2 - RMatelic - Assortment Planning>> add nag message on Remove Placeholder
                if (deleteRowCount > 0)
                {
					// Begin TT#1053 - MD - stodd - removing/adding headers to GA - 
                    DialogResult diagResult = DialogResult.Ignore;
                    AssortmentProfile asp = GetAssortmentProfile();
                    if (asp != null && asp.AllocationStarted && !asp.AllUnitsInReserve && IsGroupAllocation)
                    {
                        errMessage = MIDText.GetTextOnly(eMIDTextCode.msg_al_HeadersCannotBeRemovedFromGroupAllocation);
                        diagResult = _transaction.SAB.MessageCallback.HandleMessage(
                                    errMessage,
                                    "Invalid Header Removal",
                                    System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Asterisk);
                        errorFound = true;
                        return;
                    }

                    string message = string.Format(MIDText.GetTextOnly(eMIDTextCode.msg_DeleteRows), deleteRowCount.ToString());
                    message += Environment.NewLine + MIDText.GetTextOnly((int)eMIDTextCode.msg_ContinueQuestion);
                    diagResult = MessageBox.Show(message, _lblDeleteRow, System.Windows.Forms.MessageBoxButtons.YesNo,
                                              System.Windows.Forms.MessageBoxIcon.Question);
					// End TT#1053 - MD - stodd - removing/adding headers to GA - 
					
                    if (diagResult == System.Windows.Forms.DialogResult.No)
                    {
                        _rowDeleted = false; //TT#722 - MD - DOConnell - Right clicking on a header with multiple child levels that is not selected generates a Key Not found error
                        errorFound = true;
                        return;
                    }
                    else 
                    {
                        _rowDeleted = true; //TT#722 - MD - DOConnell - Right clicking on a header with multiple child levels that is not selected generates a Key Not found error
                        if (deletedPlaceHolders.Count > 0)
                        {
                            foreach (UltraGridRow phRow in deletedPlaceHolders)
                            {
                                int headerRID = Convert.ToInt32(phRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                                int asrtRID = Convert.ToInt32(phRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                                int styleHnRID = Convert.ToInt32(phRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                if (!_deletedHeaderRows.Contains(headerRID))
                                {
                                    _deletedHeaderRows.Add(headerRID);
                                }
                                if (!_deletedPlaceholderStyles.ContainsKey(headerRID))
                                {
                                    _deletedPlaceholderStyles.Add(headerRID, styleHnRID);
                                }
                                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                                while (row != null)
                                {
                                    if (row.Cells["PlaceHolderRID"].Value != DBNull.Value
                                     && Convert.ToInt32(row.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == headerRID
                                     && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != headerRID)
                                    {
                                        ClearChildAssortmentColumns(row);
                                        row.Cells["AsrtRID"].Value = DBNull.Value;
                                        row.Cells["AsrtRIDSortCol"].Value = DBNull.Value;
                                        row.Cells["PlaceHolderRID"].Value = DBNull.Value;
                                        row.Cells["PlaceHolderRIDSortCol"].Value = DBNull.Value;
                                        row.Cells["AsrtPlaceholderSortSeq"].Value = DBNull.Value;	// TT#1227 - stodd
                                    }
                                    row = row.GetSibling(SiblingRow.Next, false, false);
                                }
                                CheckForAssortmentTypeUpdate(asrtRID);
                            }
                        }
                    }
                }
                // End TT#2

                _placeholdersIntransit = new ArrayList(); // TT#2 - RMatelic - Assortment Planning - charge Intransit 
                foreach (UltraGridRow removedRow in removedHeaders)
                {
                    if (!RemoveHeaderFromAssortment(removedRow))
                    {
                        _removingHeaderFromAssortment = false; // TT#2 - RMatelic -Assortment Planning- unnecessary placeholder size group change error message
                        errorFound = true;
                        return;
                    }
                    else 
                    {
                        _removingHeaderFromAssortment = true; // TT#2 - RMatelic -Assortment Planning- unnecessary placeholder size group change error message
                    }

                }
               
                // Begin TT#2 - RMatelic - Assortment Planning - removing multiple headers not updating placeholder correctly
                if (phWithRemovedHeaders.Count > 0)
                {
                    foreach (int phRID in phWithRemovedHeaders.Keys)
                    {
                        UltraGridRow phRow = (UltraGridRow)phWithRemovedHeaders[phRID];
                        phRow.Cells["SizeGroup"].Value = DetermineSizeGroup(phRID);
                    }
                }
                // End TT#2

                foreach (string bandKey in _deletedAsrtBands)    
                {
                    if (_dsDetails.Tables.Contains(bandKey))
                    {
                        _dsDetails.Tables[bandKey].Constraints.Remove(bandKey);
                        _dsDetails.Relations.Remove(bandKey);
                        _dsDetails.Tables.Remove(bandKey);
                    }
                }

                foreach (UltraGridRow removedPHRow in deletedPlaceHolders)
                {
                    removedPHRow.Selected = true;
                    int phRID = Convert.ToInt32(removedPHRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    int phQty = Convert.ToInt32(removedPHRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                    int asrtRID = Convert.ToInt32(removedPHRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                    bool phFound = false;    
                    foreach (UltraGridRow removedRow in removedHeaders)
                    {
                        int hdrPhRID = Convert.ToInt32(removedPHRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture);
                        if (hdrPhRID == phRID)
                        {
                            phFound = true;
                            break;
                        }
                    }
                    if (!phFound)
                    {
                        foreach (UltraGridRow row in ugDetails.Rows)
                        {
                            if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == asrtRID)
                            {
                                int asrtQty = Convert.ToInt32(row.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                                asrtQty -= phQty;
                                row.Cells["HdrQuantity"].Value = asrtQty;
                                break;
                            }
                        }
                    }
                }

                foreach (UltraGridRow removedRow in removedHeaders)
                {
                    removedRow.Selected = true;
                }

                if (ugDetails.Selected.Rows.Count > 0)
                {
                    ArrayList al = new ArrayList();
                    foreach (UltraGridRow row in ugDetails.Selected.Rows)
                    {
                        if (row.Band.Key == "Header")
                        {
                            headerType = (eHeaderType)Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                            int hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            if (headerType == eHeaderType.Placeholder)
                            {
                                if (!_deletedHeaderRows.Contains(hdrRID))
                                {
                                    _deletedHeaderRows.Add(hdrRID);
                                }
                            }
                            else
                            {
                                al.Add(hdrRID);
                            }
                        }
                    }
                    ugDetails.DeleteSelectedRows(false);
                    if (al.Count > 0)
                    {
                        foreach (int hRID in al)
                        {
                            RemoveSizeBands(hRID);
                            // Begin TT#2 - RMatelic - Assortment Planning-charge intransit to headers attached to intransit placeholders
							// BEGIN TT#371-MD - stodd -  Velocity Interactive on Assortment
                            if (_selectedHeaderList.Contains(hRID))
                            {
								SelectedHeaderProfile shp = (SelectedHeaderProfile)_selectedHeaderList.FindKey(hRID);
								_selectedHeaderList.Remove(shp);
                            }
							// END TT#371-MD - stodd -  Velocity Interactive on Assortment
                            // End TT#2
                        }
                    }
                }
                else if (ugDetails.ActiveRow != null)
                {
                    RemoveDetailGridRows(ugDetails.ActiveRow);
                }

                if (ugDetails.Rows.Count == 0)
                {
                    //ResetWorkspace();
                }

                //_dsDetailsSaved = _dsDetails.Copy();

                ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.ExitEditMode, false, false);
            }
            catch (Exception ex)
            {
                errorFound = true;
                MIDException MIDExc = new MIDException(eErrorLevel.information, 0, ex.Message);
                HandleMIDException(MIDExc);
            }
            finally
            {
                if (_rowDeleted) //TT#722 - MD - DOConnell - Right clicking on a header with multiple child levels that is not selected generates a Key Not found error
                {
                    BindDetailsGrid();
                    this.ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, true);
                    this.ugDetails.ResumeRowSynchronization();
                    this.ugDetails.EndUpdate();
                    SetEditActivation();
                    Cursor.Current = Cursors.Default;
                    if (!errorFound)
                    {
                        RemoveRowsFromAssortmentTab();
						// GA MERGE STODD - GA HAS
						//OnAssortmentSaveHeaderData(null);
						
                        CalculateTotalsForWkSpc(); //TT#658 - MD - DOConnell - Assortment Workspace quantity is not updaed on a Post-Receipt Assortment
                        // BEGIN TT#1930 - stodd - argument exception
                        if (ugDetails.Rows.Count > 1 || g4.Rows.Count > 1)	// grids will have one row for the headings
                        {
                            EnableCreatePlaceholderAction(false);
                        }
                        else
                        {
                            EnableCreatePlaceholderAction(true);
                            EnableBalanceAssortmentAction(false);	// TT#1265-MD - stodd - Balance Assortment action gets “Action Successful” but values in grid do not change.
                        }
                        // END TT#1930 - stodd - argument exception
                    }
					// Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                    int[] hdrRidList = new int[removedHeaderRids.Count];
                    hdrRidList = (int[])removedHeaderRids.ToArray(typeof(int));
                    MarkFirstHeaderInGroupAllocation();	// TT#1130 - md - stodd - mark first header - 
                    ReloadUpdatedHeadersInAllocationWorkspace(hdrRidList);
					// End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                } //TT#722 - MD - DOConnell - Right clicking on a header with multiple child levels that is not selected generates a Key Not found error
            }	
        }

        private void RemoveRowsFromAssortmentTab()
        {
            try
            {
                Hashtable delRowsHT = new Hashtable();
                ArrayList rowAL;
                Cursor.Current = Cursors.WaitCursor;

                if (_removedAsrtHeaders.Count > 0)
                {
                    foreach (int hdrRID in _removedAsrtHeaders)
                    {
                        foreach (DataRow row in _dtHeaders.Rows)
                        {
                            if (hdrRID == Convert.ToInt32(row["HEADER_RID"], CultureInfo.CurrentUICulture))
                            {
                                if (!delRowsHT.ContainsKey(hdrRID))
                                {
                                    rowAL = new ArrayList();
                                    rowAL.Add(row);
                                    delRowsHT.Add(hdrRID, rowAL);
                                }
                                else
                                {
                                    rowAL = (ArrayList)delRowsHT[hdrRID];
                                    rowAL.Add(row);
                                }
                            }
                        }
                    }
                }
                if (_deletedHeaderRows.Count > 0)
                {
                    foreach (int hdrRID in _deletedHeaderRows)
                    {
                        foreach (DataRow row in _dtHeaders.Rows)
                        {
                            if (hdrRID == Convert.ToInt32(row["PLACEHOLDER_RID"], CultureInfo.CurrentUICulture) 
                                && Convert.ToInt32(row["HEADER_RID"], CultureInfo.CurrentUICulture) == int.MaxValue) 
                            {
                                if (!delRowsHT.ContainsKey(hdrRID))
                                {
                                    rowAL = new ArrayList();
                                    rowAL.Add(row);
                                    delRowsHT.Add(hdrRID, rowAL);
                                }
                                else
                                {
                                    rowAL = (ArrayList)delRowsHT[hdrRID];
                                    rowAL.Add(row);
                                }
                            }
                        }
                    }
                }

                if (delRowsHT.Count > 0)
                {
                    foreach (int hdrRID in delRowsHT.Keys)
                    {
                        ArrayList al = (ArrayList)delRowsHT[hdrRID];
                        foreach (DataRow delRow in al)
                        {
                            _dtHeaders.Rows.Remove(delRow);
                        }
                        AllocationHeaderProfile ahp = (AllocationHeaderProfile)_headerList.FindKey(hdrRID);
                        if (ahp != null)
                        {
                            _headerList.Remove(ahp);
                        }
                    }
                }

                if (_deletedPhComponents.Count > 0)
                {
                    foreach (int phRID in _deletedPhComponents.Keys)
                    {
                        string selectStr = string.Empty;
                        ArrayList al = (ArrayList)_deletedPhComponents[phRID];
                        foreach (DataRow delRow in al)
                        {
                            int hdrRID = Convert.ToInt32(delRow["HEADER_RID"], CultureInfo.CurrentUICulture);
                            int colorRID = Convert.ToInt32(delRow["COLOR_RID"], CultureInfo.CurrentUICulture);
                            int packRID = Convert.ToInt32(delRow["PACK_RID"], CultureInfo.CurrentUICulture);

                            selectStr = "PLACEHOLDER_RID = " + phRID.ToString() + " and HEADER_RID = " + int.MaxValue.ToString();
                            DataRow[] rows = _dtHeaders.Select(selectStr);
                            if (rows != null && rows.Length > 0)
                            {
                                if (rows.Length > 1)
                                {
                                    _dtHeaders.Rows.Remove(delRow);
                                }
                                else
                                {
                                    if (colorRID != int.MaxValue && hdrRID == int.MaxValue && packRID == int.MaxValue)      // Bulk Color
                                    {
                                        delRow["COLOR_RID"] = int.MaxValue;
                                        delRow["COLOR"] = MIDText.GetTextOnly(eMIDTextCode.lbl_No_Color);
                                    }
                                    else if (colorRID == int.MaxValue && hdrRID == int.MaxValue && packRID != int.MaxValue) // Pack
                                    {
                                        delRow["PACK"] = "Bulk";
                                        delRow["PACK_RID"] = int.MaxValue;
                                        delRow["COLOR"] = MIDText.GetTextOnly(eMIDTextCode.lbl_No_Color);
                                    }
                                    else if (colorRID != int.MaxValue && hdrRID == int.MaxValue && packRID != int.MaxValue) // Pack Color
                                    {
                                        delRow["COLOR_RID"] = int.MaxValue;
                                        delRow["COLOR"] = MIDText.GetTextOnly(eMIDTextCode.lbl_No_Color);
                                        if (_deletedPlaceholderPacks.Contains(packRID))
                                        {
                                            delRow["PACK"] = "Bulk";
                                            delRow["PACK_RID"] = int.MaxValue;
                                        } 
                                    }
                                }
                            }
                            
                        }
                    }
                    _deletedPhComponents.Clear();
                }
                SaveAndUpdateAssortmentTab();
                _removingHeaderFromAssortment = false; // TT#2-Assortment Planning-header quantities zeroing out when other headers removed from assortment
            }
            catch
            {
                throw;
            }
            finally
            {
                Cursor.Current = Cursors.Default;
            }    
        }

        private void RemoveDetailGridRows(UltraGridRow aRow)
        {
            try
            {
                UltraGridRow row = aRow;
                while (row.Band.Key != "Header")
                {
                    row = row.ParentRow;
                }
                int hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                RemoveSizeBands(hdrRID);
                row.Delete(false);
            }
            catch 
            {
                throw;
            }
        }

        private void cmsColSelectrAll_Click(object sender, EventArgs e)
        {
            HideColumns(false);
        }

        private void cmsColClearAll_Click(object sender, EventArgs e)
        {
            HideColumns(true);
        }

        private void HideColumns(bool aHideColumn)
        {
            try
            {
                foreach (UltraGridColumn hdrCol in this.ugDetails.DisplayLayout.Bands["Header"].Columns)
                {
                    if (!hdrCol.IsChaptered && hdrCol.ExcludeFromColumnChooser != ExcludeFromColumnChooser.True)
                    {
                        hdrCol.Hidden = aHideColumn;
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }    
        #endregion

        #region Add Headers to Assortment

		/// <summary>
		/// Adds new components to the Placeholder that exists on the Header.
		/// </summary>
        private void AddHeadersToAssortment()
        {
            bool phIsVirtual = true;
            bool errorFound = false;
            string errMessage = string.Empty;
            int asrtRID = 0;
			int asrtPlaceholderSortSeq = 0;	// Begin TT#1227 - stodd
            int phRID = Include.NoRID, phStyleHnRID = Include.NoRID;
            int phHdrTotal = 0, phChildTotal = 0;
            UltraGridRow asrtRow = null, placeHolderRow = null;
            eHeaderType addToHeaderType = eHeaderType.Assortment, selHeaderType;
            ArrayList addedHeaders = new ArrayList();
            ArrayList selectedRows = new ArrayList();
            Hashtable placeholderHash = new Hashtable();
            _placeHolderAndHeaders = new Hashtable();
            _placeholdersIntransit = new ArrayList();
            int groupAllocProductRid = Include.NoRID;	// TT#1110 - MD - stodd - incorrect style on group allocation header - 
			bool placeholderHasColor = false;		//TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
            try
            {
                if (this.ugDetails.Selected.Rows.Count == 0)
                {
                    if (_rClickRow != null && _rClickRow.Band.Key == "Header")
                    {
                        _rClickRow.Selected = true;
                    }
                    else
                    {
                        errorFound = true;
                        return;
                    }
                }

                if (!ValidAssortmentHeaderSelection(ref addedHeaders))
                {
                    errorFound = true;
                    foreach (UltraGridRow row in addedHeaders)
                    {
                        int addedHdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        RemoveAndDequeueHeader(addedHdrRID);
                    }
					//BEGIN TT#661-MD - stodd - Drag/Drop Header onto Placeholder Style/Color and recieve error 80036: Color not defined for Bulk  
					// Remove the headers from an invlaid drop from the deleted header list. We don't really want to delete tham.
					_deletedHeaderRows.Clear();
					//END TT#661-MD - stodd - Drag/Drop Header onto Placeholder Style/Color and recieve error 80036: Color not defined for Bulk  
                    return;
                }
                Cursor.Current = Cursors.WaitCursor;
                this.ugDetails.BeginUpdate();
                this.ugDetails.SuspendRowSynchronization();

                foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                {
                    selectedRows.Add(selRow);
                    selHeaderType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (selHeaderType == eHeaderType.Assortment || selHeaderType == eHeaderType.Placeholder)
                    {
                        asrtRID = Convert.ToInt32(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
						// Begin TT#1227 - stodd
						if (selRow.Cells["AsrtPlaceholderSortSeq"].Value != DBNull.Value)
						{
							asrtPlaceholderSortSeq = Convert.ToInt32(selRow.Cells["AsrtPlaceholderSortSeq"].Value);
						}
						// End TT#1227 - stodd
                        addToHeaderType = selHeaderType;
                        if (addToHeaderType == eHeaderType.Placeholder)
                        {
                            phRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            phStyleHnRID = Convert.ToInt32(selRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                            HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(phStyleHnRID);
                            phIsVirtual = hnp.IsVirtual;
                            placeHolderRow = selRow;
                            if (!placeholderHash.ContainsKey(phStyleHnRID))
                            {
                                placeholderHash.Add(phStyleHnRID, placeHolderRow);
                            }
							// Find and set grid row that points to assortment
                            foreach (UltraGridRow row in ugDetails.Rows)
                            {
                                if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == asrtRID)
                                {
                                    asrtRow = row;
                                    break;
                                }
                            }
                        }
                        else
                        {
                            asrtRow = selRow;
                            UltraGridRow row = asrtRow.GetSibling(SiblingRow.First, false);
                            while (row != null)
                            {   // load all placeholder rows for this assortment to hashtable                    
                                if (row.Cells["AsrtRID"].Value != DBNull.Value
                                 && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == asrtRID
                                 && Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                                {
                                    phStyleHnRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                    placeholderHash.Add(phStyleHnRID, row);
                                }
                                row = row.GetSibling(SiblingRow.Next, false);
                            }
                            if (placeholderHash.Count == 0)     // no other Rows so make it a PostReceipt Assortment
                            {
                                if (IsGroupAllocation)
                                {
                                    asrtRow.Cells["AsrtType"].Value = (int)eAssortmentType.GroupAllocation;
                                    // BEGIN TT#2148 - stodd - Assortment totals do not include header values
                                    EnableBalanceAssortmentAction(false);
                                    // BEGIN TT#2148 - stodd - Assortment totals do not include header values

                                    if (addedHeaders.Count > 0)
                                    {
                                        UltraGridRow hdrRow = (UltraGridRow)addedHeaders[0];
                                        _assortmentProfile.StyleHnRID = Convert.ToInt32(hdrRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                        groupAllocProductRid = Convert.ToInt32(hdrRow.Cells["ProductRID"].Value);	// TT#1110 - MD - stodd - incorrect style on group allocation header - 
                                    }
                                }
                                else
                                {

                                    asrtRow.Cells["AsrtType"].Value = (int)eAssortmentType.PostReceipt;
                                    // BEGIN TT#2148 - stodd - Assortment totals do not include header values
                                    EnableBalanceAssortmentAction(false);
                                    // BEGIN TT#2148 - stodd - Assortment totals do not include header values
                                }
                            }
                        }
                    }
                }

                //_phCompLinks = new PlaceholderComponentLinks(asrtRID);
                _dsAsrtSizes = MIDEnvironment.CreateDataSet();


				//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
				int addedHeadersTotQty = 0;
				int phHdrTotalQty = 0;
				//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
				//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
				if (addToHeaderType == eHeaderType.Placeholder)
				{
					if (placeHolderRow != null)
					{
						phHdrTotalQty = Convert.ToInt32(placeHolderRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
						if (placeHolderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
						{
							placeholderHasColor = true;
						}
					}
				}
				//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder

				//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
				_placeholderNewColorList = new List<PlaceholderNewColorInfo>();
                _placeholderNewPlaceholderColorList = new List<PlaceholderNewColorInfo>(); // TT#2019-MD - JSmith  - Receive system argument exception when adding a Detail Pack Header to a Placeholder.
                _placeholderNewGenericPackList = new List<PlaceholderNewPackInfo>();  // TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
				int headerIdx = 0;	// TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
				bool doComponentMismatch = true;	// TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                foreach (UltraGridRow row in addedHeaders)
                {
					headerIdx++;
                    int addedHdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    int styleRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
					//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
				//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
					addedHeadersTotQty += Convert.ToInt32(row.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
					//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
                  
                    if (addToHeaderType == eHeaderType.Placeholder)
                    {
                        if (styleRID != phStyleHnRID)
                        {
                            if (!ValidPlaceholderStyle(placeHolderRow, styleRID, ref errMessage))
                            {
                                errorFound = true;
                                RemoveAndDequeueHeader(addedHdrRID);
                                return;
                            }
                            else
                            {
                                HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(styleRID);

								//BEGIN TT#1524 - MD - DOConnell - Track down and correct the Audit Messages with "Unknown" for the module name.
                                //errMessage = string.Format(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PhStyleWillChange),
                                                   //_lblPlaceholder + " " + _hlpStyle.LevelID, hnp.LevelText);

                                errMessage = string.Format(MIDText.GetTextOnly(eMIDTextCode.msg_as_PhStyleWillChange),
                                                    _lblPlaceholder + " " + _hlpStyle.LevelID, hnp.LevelText);
								//END TT#1524 - MD - DOConnell - Track down and correct the Audit Messages with "Unknown" for the module name.
								
                                errMessage += Environment.NewLine + MIDText.GetTextOnly((int)eMIDTextCode.msg_ContinueQuestion);

                                DialogResult diagResult = MessageBox.Show(errMessage, this.Text, System.Windows.Forms.MessageBoxButtons.YesNo,
                                                          System.Windows.Forms.MessageBoxIcon.Question);

                                if (diagResult == System.Windows.Forms.DialogResult.No)
                                {
                                    errorFound = true;
                                    RemoveAndDequeueHeader(addedHdrRID);
                                    return;
                                }

                                //Begin TT#2103 - DOConnell - Created Asst, Drag/Drop header to Placeholder and receive unexpected results for units allocated and quantity
                                //SaveAndUpdateAssortmentTab();		// TT#1410-MD - stodd - Adding a header to a placeholder with placeholder colors(s) defined sometimes gets a "Color not defined for Bulk" error.
                                //End TT#2103 - DOConnell - Created Asst, Drag/Drop header to Placeholder and receive unexpected results for units allocated and quantity
                               
                                _skipStyleSave = true; // TT#1503-MD - RMatelic - ASST - Header not being attached to placeholder when drag/dropped from Allocation Workspace
                                placeHolderRow.Cells["Style"].Value = hnp.NodeID;
                                // Begin TT#1503-MD - RMatelic - ASST - Header not being attached to placeholder when drag/dropped from Allocation Workspace
                                //phStyleHnRID = Convert.ToInt32(placeHolderRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                phStyleHnRID = hnp.Key; 
                                // End TT#1503-MD
                                phIsVirtual = false;
                            }
                        }
                        row.Cells["PlaceHolderRID"].Value = phRID;
                        row.Cells["PlaceHolderRIDSortCol"].Value = phRID;
                    }
                    else if (addToHeaderType == eHeaderType.Assortment)
                    {   // check for matching placeholder style; otherwise, add placeholder
                        if (!placeholderHash.ContainsKey(styleRID))
                        {
                            ugDetails.ActiveRow = asrtRow;
                            AddPlaceholders(1, styleRID);
                            phHdrTotal = 0;
                            phChildTotal = 0;
                            placeHolderRow = ugDetails.ActiveRow;

							// BEGIN TT#621-MD - Stodd - invalid cast exception -- style was set in the AddPlaceholders above.
							//int newPhRid = Convert.ToInt32(placeHolderRow.Cells["PlaceHolderRID"].Value);
							//placeHolderRow.Cells["SizeGroup"].Value = DetermineSizeGroup(newPhRid);
							//HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(styleRID);
                            //placeHolderRow.Cells["Style"].Value = hnp.NodeID;
							// END TT#621-MD - Stodd - invalid cast exception
                            phStyleHnRID = Convert.ToInt32(placeHolderRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                            phIsVirtual = false;
                            placeholderHash.Add(phStyleHnRID, placeHolderRow);
                        }
                        else
                        {
                            placeHolderRow = (UltraGridRow)placeholderHash[styleRID];
							//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
							if (headerIdx == 1)	// only check the first time through. After that the placeholder will most likely have new components added that we don't want to consider.
							{
								phHdrTotalQty = Convert.ToInt32(placeHolderRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
								if (placeHolderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
								{
									placeholderHasColor = true;
								}
							}
							//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                            if (!AllowPlaceholderUpdate(placeHolderRow))
                            {
                                errorFound = true;
                                string asrtType = MIDText.GetTextOnly((int)eHeaderType.Placeholder);
                                errMessage = string.Format(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_InvalidAssrtStatus), asrtType);
                            }
                            else //if (!DuplicateColorCheckOK(row))
                            {
                                DuplicateColorCheckOK(placeHolderRow);  // this is to load the placeholder colors
								if (!DuplicateColorCheckOK(row))        // this checks the header colors against the placeholder colors
								{
									errorFound = true;
									errMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AssortmentDupColorSizeMismatch);
								}
								//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
								else
								{
									//================================================================
									// This check is only done once for ALL of the selected headers.
									//================================================================
                                    //Begin TT#441-MD-DOConnell - not related to 441 but getting error on PostReciept assortment when droping headers
									if (doComponentMismatch && (GetAssortmentType() != eAssortmentType.PostReceipt && GetAssortmentType() != eAssortmentType.GroupAllocation))
                                    //if (doComponentMismatch)
                                    //Begin TT#441-MD-DOConnell - not related to 441 but getting error on PostReciept assortment when droping headers
									{
										List<UltraGridRow> selRowsList = new List<UltraGridRow>();
										foreach (UltraGridRow hdrRow in addedHeaders)
										{
											selRowsList.Add(hdrRow);
										}
										if (IsComponentMismatch(selRowsList, placeHolderRow))
										{
											errorFound = true;
											//BEGIN TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                            //errMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PlaceholderHeaderComponentMismatch);
                                            errMessage = MIDText.GetTextOnly(eMIDTextCode.msg_as_PlaceholderHeaderComponentMismatch);
											//END TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
										}
										doComponentMismatch = false;
									}
								}
								//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                            }
                            if (errorFound)
                            {
                                MessageBox.Show(errMessage, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                RemoveAndDequeueHeader(addedHdrRID);
                                return;
                            }
                        }
                        phRID = Convert.ToInt32(placeHolderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        row.Cells["PlaceHolderRID"].Value = phRID;
                        row.Cells["PlaceHolderRIDSortCol"].Value = phRID;
                        // Begin TT#1227 - RMatelic - Placeholders s/b sorted by a sequence number
                        row.Cells["AsrtRID"].Value = asrtRID;
                        row.Cells["AsrtRIDSortCol"].Value = asrtRID;
                        asrtPlaceholderSortSeq = Convert.ToInt32(placeHolderRow.Cells["AsrtPlaceholderSortSeq"].Value, CultureInfo.CurrentUICulture);
                        row.Cells["AsrtPlaceholderSortSeq"].Value = asrtPlaceholderSortSeq;
						row.Cells["AsrtHeaderSortSeq"].Value = IncreaseLastHeaderSeq(asrtRID, asrtPlaceholderSortSeq);
                        row.RefreshSortPosition();
                        // End TT#1227 
                    }
                    string phID = Convert.ToString(placeHolderRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                    //_phCompLinks.AddPlaceholder(phRID, phID);

                    //ArrayList currentPhColorRIDs = new ArrayList();
                    //if (placeHolderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                    //{
                    //    UltraGridRow phColorRow = placeHolderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                    //    while (phColorRow != null)
                    //    {
                    //        int phColorBCRID = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                    //        currentPhColorRIDs.Add(phColorBCRID);

                    //        AddPlaceholderColorToLinkProfile(phRID, phColorRow);

                    //        phColorRow = phColorRow.GetSibling(SiblingRow.Next, false, false);
                    //    }
                    //}

					//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                    //phHdrTotal = Convert.ToInt32(placeHolderRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                    //phChildTotal = Convert.ToInt32(placeHolderRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
					//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
					
					//========================
					// Check for Intransit
					//========================
					if (IsGroupAllocation)
					{
                        CheckPlaceholderIntransit(phRID);
					}

					//================================
					// Add Components to Placeholder
					//================================
                    AddComponentsToPlaceholder(placeHolderRow, row, phHdrTotalQty < addedHeadersTotQty);

                    //eAssortmentType asrtType = (eAssortmentType)(Convert.ToInt32(asrtRow.Cells["AsrtType"].Value, CultureInfo.CurrentUICulture));
                    //switch (asrtType)
                    //{
                    //    case eAssortmentType.PostReceipt:

                           // asrtHdrTotal -= selRowQty;
                          //  asrtChildTotal -= selRowChildTotal;
					//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
					//phHdrTotal -= Convert.ToInt32(row.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
					//phChildTotal -= Convert.ToInt32(row.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
					//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                            //break;

                        //case eAssortmentType.PreReceipt:

                           // asrtHdrTotal += selRowQty;
                          //  asrtChildTotal += selRowChildTotal;
                            //phHdrTotal -= Convert.ToInt32(row.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                            //phChildTotal -= Convert.ToInt32(row.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                    //        break;
                    //}
                  
                    //if (row.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                    //{
                    //    UltraGridRow colorRow = row.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                    //    while (colorRow != null)
                    //    {
                    //        AddHeaderColorToLinkProfile(phRID, colorRow);
                    //        colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                    //    }
                    //}

                    // Begin TT#2065-MD - JSmith - Total Units when changing Store Attributes is not consistent
                    // Copy blocked cells from placeholder to header
                    if (addToHeaderType == eHeaderType.Placeholder)
                    {
                        if (placeHolderRow != null)
                        {
                            int PHHdrRID = Convert.ToInt32(placeHolderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            foreach (UltraGridRow hRow in addedHeaders)
                            {
                                addedHdrRID = Convert.ToInt32(hRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                                _asrtCubeGroup.CopyBlockedList(PHHdrRID, addedHdrRID);
                            }
                        }
                    }
                    // End TT#2065-MD - JSmith - Total Units when changing Store Attributes is not consistent

                    if (!selectedRows.Contains(placeHolderRow))
                    {
                        selectedRows.Add(placeHolderRow);
                    }

					//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                    //placeHolderRow.Cells["ChildTotal"].Value = phChildTotal >= 0 ? phChildTotal : 0;
                    //placeHolderRow.Cells["HdrQuantity"].Value = phHdrTotal >= 0 ? phHdrTotal : 0;
					//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder

                    // Begin TT#2 - RMatelic - Assortment Planning-allocating header packs not totaling correctly
                    if (_headerPacksAdded)
                    {
                        CheckForColorSpread(placeHolderRow);
                    }
                    // End TT#2


                    //    int hdrColorCount = _phCompLinks.HeaderColorCount(phRID, addedHdrRID);
                    //    int phColorCount = _phCompLinks.PlaceholderColorCount(phRID);

                    //    int diff = hdrColorCount - phColorCount;
                    //    if (diff > 0)   // need more placeholder colors
                    //    {
                    //        _colorSelectRow = placeHolderRow;
                    //        if (_frmColorBrowser != null)
                    //        {
                    //            _frmColorBrowser.Dispose();
                    //        }
                    //        _phColorAutoAdd = true;
                    //        _frmColorBrowser = new ColorBrowser(_sab, currentPhColorRIDs, diff);
                    //        _frmColorBrowser.OnColorBrowserSelectHandler += new ColorBrowser.ColorBrowserSelectEventHandler(form_OnColorBrowserSelectHandler);
                    //        _frmColorBrowser.GetPhColorsAndSetEventHandler();
                    //        _frmColorBrowser.Dispose();
                    //        _phColorAutoAdd = false;
                    //    }

                }

                //Begin TT#957 - MD - stodd - "Errors Found" message when clicking on header - 
				// Begin TT#989 - MD - GA only processes on first header - 
                // Begin TT#1110 - md - stodd - style wrong on GA header - 
				// depending upon the sort order on the grid, this could get the wrong header
                //UpdateAssortmentNodesFromFirstHeader(asrtRow);
                if (IsGroupAllocation && Convert.ToInt32(asrtRow.Cells["StyleHnRid"].Value) == Include.NoRID)
                {
                    _skipStyleEdit = true;
                    asrtRow.Cells["StyleHnRid"].Value = _assortmentProfile.StyleHnRID;
                    HierarchyNodeProfile hnpProduct = this.GetNodeData(_assortmentProfile.StyleHnRID);
                    asrtRow.Cells["Style"].Value = hnpProduct.NodeID;
                    _skipProductEdit = true;
                    asrtRow.Cells["ProductRID"].Value = groupAllocProductRid;
                    hnpProduct = this.GetNodeData(groupAllocProductRid);
                    asrtRow.Cells["Product"].Value = hnpProduct.NodeID;  
                }
				// End TT#1110 - md - stodd - style wrong on GA header - 
				// End TT#989 - MD - GA only processes on first header - 
                //End TT#957 - MD - stodd - "Errors Found" message when clicking on header -


				//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
				//=============================================================================
				// Spread allocation to new colors added due to header added to placeholder.
				// This spread is only done if the placeholder had no colors originally.
				//=============================================================================
				//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
				//if (!placeholderHasColor && _newPHColorRows.Count > 0 && _newPHColorRows.Count == _matchingHdrColorRows.Count)
				//BEGIN TT#666-MD - stodd - Post-Receipt Assortment - last header added is automatically allocated added check for PostReciept
				if (!placeholderHasColor && _placeholderNewColorList != null && _placeholderNewColorList.Count > 0 && 
                    (GetAssortmentType() != eAssortmentType.PostReceipt && GetAssortmentType() != eAssortmentType.GroupAllocation))
				//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
				//END TT#666-MD - stodd - Post-Receipt Assortment - last header added is automatically allocated
				{
					//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
					AllocateColorsOnEmptyPlaceholder(placeHolderRow, addedHeadersTotQty, phHdrTotalQty);
					//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
				}
				//BEGIN TT#676-MD - stodd - Placeholder colors not being created for balance of units when adding more than 1 color to a header.
				else
				{
					//===============================================================================================================================================
					// This handles the situation where a real color took over a placeholder and there will be units left over after the header is allocated.
					// A new placeholder color will be created to hold the leftover units.
					// this section makes sure both of those are allocated.
					//===============================================================================================================================================
					if (_placeholderNewColorList != null && _placeholderNewColorList.Count > 0 && 
                        (GetAssortmentType() != eAssortmentType.PostReceipt && GetAssortmentType() != eAssortmentType.GroupAllocation))
					{
						// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
						//AllocationProfile ap = _transaction.GetAllocationProfile(Convert.ToInt32(placeHolderRow.Cells["KeyH"].Value));
						AllocationProfile ap = _transaction.GetAssortmentMemberProfile(Convert.ToInt32(placeHolderRow.Cells["KeyH"].Value));
						// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member

						for (int c = 0; c < _placeholderNewColorList.Count;c++ )
						{
							PlaceholderNewColorInfo pnci = _placeholderNewColorList[c];
							if (pnci.PlaceholderColorRid == -1)
							{
								ugDetails.ActiveRow = placeHolderRow;
								// BEGIN TT#856 - MD - stodd - total not spread error
								int newColorCodeRid = AddPlaceholderColorToPlaceholder(placeHolderRow);
								//pnci.PlaceholderColorRid = Convert.ToInt32(ugDetails.ActiveRow.Cells["ColorCodeRID"].Value);
								pnci.PlaceholderColorRid = newColorCodeRid;
								// END TT#856 - MD - stodd - total not spread error
							}
							AllocatePlaceholderColor(ap, pnci.PlaceholderColorRid, pnci.PlaceholderColorUnits);
						}
					}
                    // Begin TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
                    else if (_placeholderNewGenericPackList != null && _placeholderNewGenericPackList.Count > 0 && 
                        (GetAssortmentType() != eAssortmentType.PostReceipt && GetAssortmentType() != eAssortmentType.GroupAllocation))
                    {
                        AllocationProfile ap = _transaction.GetAssortmentMemberProfile(Convert.ToInt32(placeHolderRow.Cells["KeyH"].Value));

                        // Allocate new placeholder colors
                        //if (_placeholderNewPlaceholderColorList.Count > 0)
                        //{
                        //    for (int i = 0; i < _placeholderNewPlaceholderColorList.Count; i++)
                        //    {
                        //        PlaceholderNewColorInfo pnci = _placeholderNewPlaceholderColorList[i];
                        //        AllocatePlaceholderColor(ap, pnci.PlaceholderColorRid, phHdrTotalQty - addedHeadersTotQty);
                        //    }
                        //}

                        //for (int c = 0; c < _placeholderNewGenericPackList.Count; c++)
                        //{
                        //    PlaceholderNewPackInfo pnpi = _placeholderNewGenericPackList[c];
                        //    AllocatePlaceholderPack(ap, pnpi.PlaceholderPackName, pnpi.Multiple, pnpi.PlaceholderPackUnits);
                        //}

                        AllocatePlaceholderPack(ap, phHdrTotalQty - addedHeadersTotQty);
                    }
                    // End TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
				}
				//END TT#676-MD - stodd - Placeholder colors not being created for balance of units when adding more than 1 color to a header.
				//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
				_placeholderNewColorList = null;
                _placeholderNewGenericPackList = null;  // TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
				//_newPHColorRows = null;
				//_matchingHdrColorRows = null;
				//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
				//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
                //if (_phCompLinks.HasHeaderColors)
                //{
                //    MatchComponents();
                //}

                AddAssortmentSizeTables();
                if (placeholderHash.Count > 0)
                {
                    foreach (UltraGridRow phRow in placeholderHash.Values)
                    {
                        int placeHolderhRID = Convert.ToInt32(phRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        phRow.Cells["SizeGroup"].Value = DetermineSizeGroup(placeHolderhRID);
                    }    
                }
                
                ugDetails.Selected.Rows.Clear();

                foreach (UltraGridRow row in selectedRows)
                {
                    row.Selected = true;
                }

                for (int i = 0; i < ugDetails.Selected.Rows.Count; i++)
                {
                    UltraGridRow selRow = this.ugDetails.Selected.Rows[i];
                    selHeaderType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    // skip the Assortment row

                    switch (selHeaderType)
                    {
                        case eHeaderType.Assortment:
                            break;

                        case eHeaderType.Placeholder:
                            if (_sizesAutoAdded)
                            {
                                UpdateAddedSizeRows(selRow);
                            }
                            if (_expandAllContent)
                            {
                                selRow.ExpandAll();
                            }
                            break;

                        default:
                            if (selRow.Cells["AsrtRID"].Value != DBNull.Value)
                            {
                                //continue;		// TT#600-MD - stodd - Commented out. This was causing headers dropped in "open" area to not get allocated
                            }
                            else
                            {   // Begin TT#1227 - RMatelic - Placeholders s/b sorted by a sequence number; moved this code up in the method
                                selRow.Cells["AsrtRID"].Value = asrtRID;
                                selRow.Cells["AsrtRIDSortCol"].Value = asrtRID;
                                selRow.Cells["AsrtPlaceholderSortSeq"].Value = asrtPlaceholderSortSeq;	// TT#1227 stodd
                                selRow.Cells["AsrtHeaderSortSeq"].Value = IncreaseLastHeaderSeq(asrtRID, asrtPlaceholderSortSeq);	// TT#1227 stodd
                                // End TT#1227
                                
                                selRow.RefreshSortPosition();
                                if (_expandAllContent)
                                {
                                    selRow.ExpandAll();
                                }
                            }
                            // Begin TT#2 -  RMatelic - Assortment Planning- allocate headers attached to placeholders
                            int headerRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            int placehRID = Convert.ToInt32(selRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture);
                            ArrayList headerList;
                            if (!_placeHolderAndHeaders.ContainsKey(placehRID))
                            {
                                headerList = new ArrayList();
                                headerList.Add(headerRID);
                                _placeHolderAndHeaders.Add(placehRID, headerList);
                            }
                            else
                            {
                                headerList = (ArrayList)_placeHolderAndHeaders[placehRID];
                                if (!headerList.Contains(headerRID))
                                {
                                    headerList.Add(headerRID);
                                }
                            }
                            //AllocateHeaderAndPlaceholderUnits(placehRID, headerRID);
                            // End TT#2
                            break;
                    }
                }
				//BEGIN TT#666-MD - stodd - Post-Receipt Assortment - last header added is automatically allocated added check for PostReciept
                if (_placeHolderAndHeaders.Count > 0 && 
                    (GetAssortmentType() != eAssortmentType.PostReceipt && GetAssortmentType() != eAssortmentType.GroupAllocation))
				//END TT#666-MD - stodd - Post-Receipt Assortment - last header added is automatically allocated
                {
					// Allocates the newly added header & adjusts the placeholder accordingly
                    AllocateHeaderAndPlaceholderUnits(_placeHolderAndHeaders);
                }
                if (_sizesAutoAdded)
                {
                    _sizesAutoAdded = false;
                }
            }
            catch (Exception ex)
            {
                errorFound = true; // TT#1483-MD - RMatelic - Asst - when attaching a header receive mssg Unable to determine where to add row:please select a valid row before adding a new row.  Select OK get null reference exception
                HandleException(ex);
            }
            finally
            {
                SetEditActivation();
                this.ugDetails.ResumeRowSynchronization();
                this.ugDetails.EndUpdate();
                if (!errorFound)
                {
                    SaveAndUpdateAssortmentTab();
					// GA MERGE STODD - GA HAD...
					// OnAssortmentSaveHeaderData(null);
                }
                // Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                //CalculateTotalsForWkSpc(); //TT#658 - MD - DOConnell - Assortment Workspace quantity is not updaed on a Post-Receipt Assortment
                // End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
				//BEGIN TT#579-MD - stodd -  After adding a header to a placeholder, placeholder has a balance value even though its units are all in balance  
				CalculatePlaceholderBalances();
				//END TT#579-MD - stodd -  After adding a header to a placeholder, placeholder has a balance value even though its units are all in balance  
                ReloadUpdatedHeadersInAllocationWorkspace();
				// End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                Cursor.Current = Cursors.Default;
            }
        }

		//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
		/// <summary>
		/// Spreads allocation to new colors added due to header added to placeholder.
		/// **This spread is only done if the placeholder had no colors originally.**
		/// </summary>
		/// <param name="placeHolderRow"></param>
		/// <param name="addedHeadersTotQty"></param>
		/// <param name="phHdrTotalQty"></param>
		private void AllocateColorsOnEmptyPlaceholder(UltraGridRow placeHolderRow, int addedHeadersTotQty, int phHdrTotalQty)
		{
			//======================================================================
			// If the qty totals for all header(s) is less than the placeholder qty,
			// then a placeholder color needs to be added to hold the leftover units.
			//===========================================================================
			int placeholderColorQty = 0;
			if (addedHeadersTotQty < phHdrTotalQty)
			{
                // Begin TT#2019-MD - JSmith  - Receive system argument exception when adding a Detail Pack Header to a Placeholder.
                if (_placeholderNewPlaceholderColorList.Count == 0)
                {
                // End TT#2019-MD - JSmith  - Receive system argument exception when adding a Detail Pack Header to a Placeholder.
				    // BEGIN TT#856 - MD - stodd - total not spread error
                    int newColorCodeRid = AddPlaceholderColorToPlaceholder(placeHolderRow);
                    placeholderColorQty = phHdrTotalQty - addedHeadersTotQty;
                    PlaceholderNewColorInfo pnci = new PlaceholderNewColorInfo();
				    //pnci.PlaceholderColorRid = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value);
                    pnci.PlaceholderColorRid = newColorCodeRid;
				    // END TT#856 - MD - stodd - total not spread error
                    pnci.PlaceholderColorUnits = placeholderColorQty;
                    pnci.Multiple = 1;
                    pnci.AddedFromPack = false;  // TT#2047-MD - JSmith - Remove a header from a PH and PH Qty increases greater than the header plus the residual Ph values.
                    _placeholderNewColorList.Add(pnci);
                // Begin TT#2019-MD - JSmith  - Receive system argument exception when adding a Detail Pack Header to a Placeholder.
                }
                else
                {
                    PlaceholderNewColorInfo pnci;
                    for (int i = 0; i < _placeholderNewPlaceholderColorList.Count; i++)
                    {
                        pnci = _placeholderNewPlaceholderColorList[i];
                        pnci.PlaceholderColorUnits = phHdrTotalQty - addedHeadersTotQty;
                        _placeholderNewColorList.Add(pnci);
                    }
                }
                // End TT#2019-MD - JSmith  - Receive system argument exception when adding a Detail Pack Header to a Placeholder.
			}

			// Placeholder
			int phRID = Convert.ToInt32(placeHolderRow.Cells["KeyH"].Value);
			AllocationProfile ap = GetAllocationProfile(phRID);

			// Set up columns (stores)
			Index_RID storeIndexRID;
			ProfileList aStoreList = _asrtCubeGroup.GetMasterProfileList(eProfileType.Store);
			List<Index_RID> storeIndexRIDArray = new List<Index_RID>(aStoreList.Count);
			for (int s = 0; s < aStoreList.Count; s++)
			{
				StoreProfile sp = (StoreProfile)aStoreList.ArrayList[s];
				if (sp.Key != _transaction.ReserveStore.RID)
				{
					storeIndexRID = this._transaction.StoreIndexRID(sp.Key);
					storeIndexRIDArray.Add(storeIndexRID);
				}
			}

			List<int> aRowTotalList = new List<int>();	// Stores
			List<int> aColTotalList = new List<int>();	// Colors

			// Setup Constraints
			ConstraintBin[,] constraints = null;
            int[,] spreadBulkResults = null;	// TT#1561-MD - stodd - drag/drop a PPK header to a place holder and receive a null reference exception.  Also PH color black has a qty of 57 units why would that happen? 
			bool unitsWereSpread = false;
			MIDException aMIDException;

			//==============
			// BULK First
			//==============
			for (int s = 0; s < storeIndexRIDArray.Count; s++)
			{
				Index_RID storeIndex = storeIndexRIDArray[s];
				aRowTotalList.Add(ap.GetStoreQtyAllocated(eAllocationSummaryNode.Total, storeIndex.RID));
			}

			aColTotalList.Add(phHdrTotalQty);	// Just need a number to respresent Bulk
            _transaction.RuleBasedAllocation.Do_2_DimensionalSpread(aRowTotalList, aColTotalList, constraints, out spreadBulkResults, out unitsWereSpread, out aMIDException, true);  // TT#2049-MD - JSmith - Attached Detail PPK header with Qty less than PH the PH values are not the difference between the Orig PH value and the Header Allocation.

            ap.ResetTempLocks(false);		// TT#1561-MD - stodd - drag/drop a PPK header to a place holder and receive a null reference exception.  Also PH color black has a qty of 57 units why would that happen? 
			for (int s = 0; s < storeIndexRIDArray.Count; s++)
			{
				Index_RID storeIndex = storeIndexRIDArray[s];
				ap.SetStoreQtyAllocated(eAllocationSummaryNode.Bulk, storeIndex.RID, spreadBulkResults[s, 0], eDistributeChange.ToAll, false);	// TT#749-MD - Stodd - Assortment setting manually allocated to true
			}

			//=============================================
			// NOW ALLOCATE NEW COLORS ON PLACEHOLDER
			//=============================================
			aColTotalList.Clear();
			//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
			//for (int r = 0; r < _newPHColorRows.Count; r++)
			for (int r = 0; r < _placeholderNewColorList.Count; r++)
			{
				//UltraGridRow phColorRow = _newPHColorRows[r];
				//UltraGridRow hdrColorRow = _matchingHdrColorRows[r];
				PlaceholderNewColorInfo pnci = _placeholderNewColorList[r];
				int qty = pnci.PlaceholderColorUnits;
				aColTotalList.Add(qty);
			}

			// Begin TT#1561-MD - stodd - drag/drop a PPK header to a place holder and receive a null reference exception.  Also PH color black has a qty of 57 units why would that happen? 
            // Set up constraints to use the color multiple. This is mostly used when pack/colors will be adjusting bulk colors
            //constraints = null;
			// Begin TT#2092-MD - JSmith - Gen PPK & Bulk(no color) Allocation not proportional to original PH allocation.
            //constraints = new ConstraintBin[storeIndexRIDArray.Count, _placeholderNewColorList.Count];
            //for (int r = 0; r < storeIndexRIDArray.Count; r++)
            //{
            //    for (int c = 0; c < _placeholderNewColorList.Count; c++)
            //    {
            //        ConstraintBin cBin = new ConstraintBin(0, 0, int.MaxValue, (uint)_placeholderNewColorList[c].Multiple, false, false);
            //        constraints[r, c] = cBin;
            //    }
            //}

            int col = 0;
            for (int c = 0; c < _placeholderNewGenericPackList.Count; c++)
            {
                PlaceholderNewPackInfo pnpi = _placeholderNewGenericPackList[c];
                aColTotalList.Add(pnpi.PlaceholderPackUnits * pnpi.Multiple);
            }

            constraints = new ConstraintBin[storeIndexRIDArray.Count, _placeholderNewColorList.Count + _placeholderNewGenericPackList.Count];
            for (int r = 0; r < storeIndexRIDArray.Count; r++)
            {
                col = 0;
                for (int c = 0; c < _placeholderNewColorList.Count; c++)
                {
                    ConstraintBin cBin = new ConstraintBin(0, 0, int.MaxValue, (uint)_placeholderNewColorList[c].Multiple, false, false);
                    constraints[r, col] = cBin;
                    col++;
                }
                for (int c = 0; c < _placeholderNewGenericPackList.Count; c++)
                {
                    ConstraintBin cBin = new ConstraintBin(0, 0, int.MaxValue, (uint)_placeholderNewGenericPackList[c].Multiple, false, false);
                    constraints[r, col] = cBin;
                    col++;
                }
            }
			// End TT#2092-MD - JSmith - Gen PPK & Bulk(no color) Allocation not proportional to original PH allocation.

			//int[,] spreadColorResults = new int[_newPHColorRows.Count, 1];
            int[,] spreadColorResults = null;
			// End TT#1561-MD - stodd - drag/drop a PPK header to a place holder and receive a null reference exception.  Also PH color black has a qty of 57 units why would that happen? 
			
			unitsWereSpread = false;
            _transaction.RuleBasedAllocation.Do_2_DimensionalSpread(aRowTotalList, aColTotalList, constraints, out spreadColorResults, out unitsWereSpread, out aMIDException, true);  // TT#2049-MD - JSmith - Attached Detail PPK header with Qty less than PH the PH values are not the difference between the Orig PH value and the Header Allocation.);

			//for (int c = 0; c < _newPHColorRows.Count; c++)
			// Begin TT#2092-MD - JSmith - Gen PPK & Bulk(no color) Allocation not proportional to original PH allocation.
            //for (int c = 0; c < _placeholderNewColorList.Count; c++)
            //{
            //    for (int s = 0; s < storeIndexRIDArray.Count; s++)
            //    {
            //        Index_RID storeIndex = storeIndexRIDArray[s];
            //        // BEGIN TT#856 - MD - stodd - total not spread error
            //        //ap.SetStoreQtyAllocated(eAllocationSummaryNode.Bulk, storeIndex.RID, spreadColorResults[s, c], eDistributeChange.ToAll, false);		// TT#749-MD - Stodd - Assortment setting manually allocated to true
            //        ap.SetStoreQtyAllocated(_placeholderNewColorList[c].PlaceholderColorRid, storeIndex.RID, spreadColorResults[s, c], eDistributeChange.ToAll, false);		// TT#749-MD - Stodd - Assortment setting manually allocated to true
            //        // END TT#856 - MD - stodd - total not spread error
            //    }
            //}

            col = 0;
            for (int c = 0; c < _placeholderNewColorList.Count; c++)
            {
                for (int s = 0; s < storeIndexRIDArray.Count; s++)
                {
                    Index_RID storeIndex = storeIndexRIDArray[s];
                    ap.SetStoreQtyAllocated(_placeholderNewColorList[c].PlaceholderColorRid, storeIndex.RID, spreadColorResults[s, col], eDistributeChange.ToAll, false);
                }
                col++;
            }

            for (int c = 0; c < _placeholderNewGenericPackList.Count; c++)
            {
                for (int s = 0; s < storeIndexRIDArray.Count; s++)
                {
                    Index_RID storeIndex = storeIndexRIDArray[s];
                    ap.SetStoreQtyAllocated(_placeholderNewGenericPackList[c].PlaceholderPackName, storeIndex, spreadColorResults[s, col] / _placeholderNewGenericPackList[c].Multiple, eDistributeChange.ToAll, false);
                }
                col++;
            }
			// Begin TT#2092-MD - JSmith - Gen PPK & Bulk(no color) Allocation not proportional to original PH allocation.
		}
		//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder

        // Begin TT#2 - RMatelic - Assortment Planning-allocating header packs not totaling correctly
        private void CheckForColorSpread(UltraGridRow aPlaceHolderRow)
        {
            try
            {
                int totalColorQty = 0, phHdrQty = 0, colorRowQty = 0;
               
                if (aPlaceHolderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                {
                    phHdrQty = Convert.ToInt32(aPlaceHolderRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);

                    UltraGridRow colorRow = aPlaceHolderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                    while (colorRow != null)
                    {
                        totalColorQty += Convert.ToInt32(colorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
                        colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }
               
                if (totalColorQty > phHdrQty)
                {
                    int totalDiff = totalColorQty - phHdrQty;
                    UltraGridRow colorRow = aPlaceHolderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                    while (colorRow != null)
                    {
                        colorRowQty = Convert.ToInt32(colorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
                       
                        int colorRowDiff =  (int) (((double)totalDiff * (double)(colorRowQty / (double)totalColorQty)) + .5d);
                        totalColorQty -= colorRowQty;
                        totalDiff -= colorRowDiff;
                        colorRowQty -= colorRowDiff;

                        if (colorRowQty < 0)
                        {
                            colorRowQty = 0;
                        }
                        colorRow.Cells["Quantity"].Value = colorRowQty;                           
                 
                        colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }
            }
            catch
            {
                throw;
            }
        }
        // End TT#2

        private int DetermineSizeGroup(int aPhRID)
        {
            int sizeGroupRID = Include.UndefinedSizeGroupRID;
            ArrayList sizeGroups = new ArrayList();
            try
            {
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (row.Cells["PlaceHolderRID"].Value != DBNull.Value
                      //&& Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture)!= (int)eHeaderType.Placeholder  
                      && Convert.ToInt32(row.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == aPhRID)
                    {
                        int sizeGroup = Convert.ToInt32(row.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture);
                        if (sizeGroup != Include.UndefinedSizeGroupRID)
                        {
                            if (!sizeGroups.Contains(sizeGroup))
                            {
                                sizeGroups.Add(sizeGroup);
                            } 
                        }
                    }
                }
                if (sizeGroups.Count > 0)
                {
                    if (sizeGroups.Count == 1)
                    {
                        sizeGroupRID = (int)sizeGroups[0];
                    }
                    else
                    {
                        foreach (int sizeGroup1 in sizeGroups)
                        {
                            bool allSizesFound = true;
                            SizeGroupProfile sgp1 = (SizeGroupProfile)_sizeGroupHash[sizeGroup1];
                            SizeCodeList scl_1 = sgp1.SizeCodeList;
                            foreach (int sizeGroup2 in sizeGroups)
                            {
                                if (sizeGroup2 != sizeGroup1)
                                {
                                    SizeGroupProfile sgp2 = (SizeGroupProfile)_sizeGroupHash[sizeGroup2];
                                    SizeCodeList scl_2 = sgp2.SizeCodeList;
                                    foreach (SizeCodeProfile scp1 in scl_1.ArrayList)
                                    {
                                        SizeCodeProfile scp2 = (SizeCodeProfile)scl_2.FindKey(scp1.Key);
                                        if (scp2 == null)
                                        {
                                            allSizesFound = false;
                                            break;
                                        }
                                    }
                                    if (!allSizesFound)
                                    {
                                        break;
                                    }
                                }
                            }
                            if (allSizesFound)
                            {
                                sizeGroupRID = sizeGroup1;
                                break;
                            }
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
            return sizeGroupRID;
        }

        private bool ValidAssortmentHeaderSelection(ref ArrayList addedHeaders)
        {
            bool errorFound = false;
			// Begin TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
            //bool validSelection = false;
            _validHeaderSelection = false;
			// End TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
            try
            {
                eHeaderType selHeaderType, addToHeaderType = eHeaderType.Assortment;
                int asrtCount = 0, addHeaderCount = 0;
                string errMessage = string.Empty;
                UltraGridRow addToRow = null;

                _placeHolderColor.Clear();
                _placeHolderColorIds.Clear();

                foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                {
                    selHeaderType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (selHeaderType == eHeaderType.Assortment || selHeaderType == eHeaderType.Placeholder)
                    {
                        addToRow = selRow;
                        addToHeaderType = selHeaderType;
                        asrtCount++;

                        if (asrtCount > 1)
                        {
                            errorFound = true;
                            errMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_OnlyOneAssrtAllowed);
                            errMessage = errMessage.Replace("{0}", ProcessName);	// TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                            break;
                        }
                        else if (selHeaderType == eHeaderType.Placeholder && !AllowPlaceholderUpdate(selRow))
                        {
                            errorFound = true;
                            string asrtType;
                            if (selHeaderType == eHeaderType.Assortment)
                            {
                                asrtType = MIDText.GetTextOnly((int)eHeaderType.Assortment);
                            }
                            else
                            {
                                asrtType = MIDText.GetTextOnly((int)eHeaderType.Placeholder);
                            }
                            errMessage = string.Format(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_InvalidAssrtStatus), asrtType);
                            foreach (UltraGridRow hRow in this.ugDetails.Selected.Rows)
                            {
                                eHeaderType headerType = (eHeaderType)Convert.ToInt32(hRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                                if (headerType != eHeaderType.Assortment && selHeaderType != eHeaderType.Placeholder)
                                {
                                    addedHeaders.Add(hRow);
                                }
                            }
                            break;
                        }
                        else if (selHeaderType == eHeaderType.Placeholder)
                        {
                            if (!ValidPlaceHolderColorId(selRow))
                            {
                            }
                            else if (!DuplicateColorCheckOK(selRow))
                            {
                                errorFound = true;
                                errMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AssortmentDupColorSizeMismatch);
                                break;
                            }
                        }
                    }
					//TT#686 - MD - DOConnell - Add Restrictions to what types of headers can be dropped on a placeholder.
                    //else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance)
                    else if (!(Convert.ToInt32(selRow.Cells["Status"].Value) == (int)eHeaderAllocationStatus.ReceivedInBalance || Convert.ToInt32(selRow.Cells["Status"].Value) == (int)eHeaderAllocationStatus.AllocationStarted) ||	// TT#1092 - MD - stodd - headers with "allocated started" can be dropped and removed -
                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.WorkupTotalBuy ||
                                    Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.IMO ||	// TT#4116 - stodd - prohibit dropping of VSW header
                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)))
                    {
                        errorFound = true;
                        // Begin TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                        //string status = MIDText.GetTextOnly((int)eHeaderAllocationStatus.ReceivedInBalance);
                        //errMessage = string.Format(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeaderNotReceivedInBalance), status);
                        errMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeaderNotReceivedInBalance);
                        errMessage = errMessage.Replace("{0}", ProcessName);
                        // End TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                        addedHeaders.Add(selRow);
                        break;
                    }
                    else if (selRow.Cells["AsrtRID"].Value == DBNull.Value)
                    {
                        addedHeaders.Add(selRow);
                        addHeaderCount++;
                    }
                }
                if (!errorFound)
                {
                    if (addToHeaderType == eHeaderType.Placeholder)
                    {
                        int phStyleHnRID = Convert.ToInt32(addToRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                        HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(phStyleHnRID);
                        bool phComponentsExist = addToRow.HasChild(false);

                        UltraGridRow row1 = (UltraGridRow)addedHeaders[0];
                        int row1Style = Convert.ToInt32(row1.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                        bool hdrComponentsExist = row1.HasChild(false);
                        
                        if (hnp.IsVirtual)  // if placeholder is virtual, all added styles must be the same
                        {
                            if (addedHeaders.Count > 1) // if count is 1, placeholder style will be changed to header style
                            {
                                for (int i = 1; i < addedHeaders.Count; i++)
                                {
                                    UltraGridRow row = (UltraGridRow)addedHeaders[i];
                                    if (Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture) != row1Style)
                                    {
                                        errorFound = true;
                                        errMessage = string.Format(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeadersMustHaveSameStyle), _hlpStyle.LevelID);
                                        break;
                                    }
                                    else if (row.HasChild(false) != hdrComponentsExist)
                                    {
                                        errorFound = true;
                                        errMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AssortmentComponentMismatch);
                                        break;
                                    }
                                    else if (!DuplicateColorCheckOK(row))
                                    {
                                        errorFound = true;
                                        errMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AssortmentDupColorSizeMismatch);
                                        break;
                                    }
                                }
                            }
                        }
                        else
                        {
                            for (int i = 0; i < addedHeaders.Count; i++)
                            {
                                UltraGridRow row = (UltraGridRow)addedHeaders[i];
                                if (Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture) != hnp.Key)
                                {
                                    errorFound = true;
                                    errMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PlaceholderStyleMismatch);
                                    break;
                                }
                                else if (phComponentsExist)
                                {
                                    if (!row.HasChild(false))
                                    {
                                        errorFound = true;
                                        errMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AssortmentComponentMismatch);
                                        break;
                                    }
                                }
                                if (!errorFound && !DuplicateColorCheckOK(row))
                                {
                                    errorFound = true;
                                    errMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AssortmentDupColorSizeMismatch);
                                    break;
                                }
                            }
                        }
                    }
                }
                if (errorFound)
                {
                    MessageBox.Show(errMessage, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                _validHeaderSelection = !errorFound;	// TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
            }
            catch
            {
                throw;
            }
            return _validHeaderSelection;	// TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
        }

        private bool ValidPlaceHolderColorId(UltraGridRow aSelectedRow)
        {
            bool OkToProcess = true;
            try
            {
                if (ugDetails.DisplayLayout.Bands.Exists("BulkColor"))
                {
                    if (aSelectedRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                    {
                        UltraGridRow colorRow = aSelectedRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                        while (colorRow != null)
                        {
                            string colorID = Convert.ToString(colorRow.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture).ToUpper().Trim();
                            // Allow same rid colors to be combined
                            int colorCodeRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                            if (_placeHolderColorIds.Contains(colorID))
                            {
                                int hashColorRID = (int)_placeHolderColorIds[colorID];
                                if (hashColorRID != colorCodeRID)
                                {
                                    OkToProcess = false;
                                    break;
                                }
                            }
                            else
                            {
                                _placeHolderColorIds.Add(colorID.ToUpper().Trim(), colorCodeRID);
                            }
                            colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            return OkToProcess;
        }
      
        private bool DuplicateColorCheckOK(UltraGridRow aSelectedRow)
        {
            bool OkToProcess = true;
            try
            {
                int colorRID;
            
                if (ugDetails.DisplayLayout.Bands.Exists("BulkColor"))
                {
                    if (aSelectedRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                    {
                        UltraGridRow colorRow = aSelectedRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);

                        while (colorRow != null)
                        {
                            bool hasSizes = false;
                            colorRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                            if (_placeHolderColor.ContainsKey(colorRID))
                            {
                                hasSizes = (bool)_placeHolderColor[colorRID];
                                if (hasSizes != colorRow.HasChild())
                                {
                                    if (hasSizes && !colorRow.HasChild())
                                    {
                                        OkToProcess = false;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                _placeHolderColor.Add(colorRID, colorRow.HasChild());
                            }
                            colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                }
            }   
            catch (Exception ex)
            {
                HandleException(ex);
            }
            return OkToProcess;
        }

        private void AddPlaceholderColorToLinkProfile(int aPlaceholderRID, UltraGridRow aPhcRow)
        {
            try
            {
                int bcRID = Convert.ToInt32(aPhcRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);

                if (!_phCompLinks.PlaceholderColorExists(aPlaceholderRID, bcRID))
                {
                    HeaderComponentProfile hcp = CreateHeaderComponentProfile(eComponentType.SpecificColor, aPhcRow);
                    _phCompLinks.AddPlaceholderColor(aPlaceholderRID, hcp);
                }
            }
            catch
            {
                throw;
            }
        }

        private void AddHeaderColorToLinkProfile(int aPlaceholderRID, UltraGridRow aColorRow)
        {
            try
            {
                int bcRID = Convert.ToInt32(aColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                int headerRID = Convert.ToInt32(aColorRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                if (!_phCompLinks.HeaderColorExists(aPlaceholderRID, headerRID, bcRID))
                {
                    HeaderComponentProfile hcp = CreateHeaderComponentProfile(eComponentType.SpecificColor, aColorRow);
                    _phCompLinks.AddHeaderColor(aPlaceholderRID, headerRID, hcp);
                }
            }
            catch
            {
                throw;
            }
        }

        private HeaderComponentProfile CreateHeaderComponentProfile(eComponentType aComponentType, UltraGridRow aRow)
        {
            try
            {
                int bcRID = Convert.ToInt32(aRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                HeaderComponentProfile hcp = new HeaderComponentProfile(bcRID, aComponentType);
                hcp.HeaderRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                hcp.HeaderID = Convert.ToString(aRow.ParentRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                hcp.HdrBCRID = bcRID;
                hcp.BulkColor = Convert.ToString(aRow.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture);
                hcp.ColorCodeRID = Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                hcp.Description = Convert.ToString(aRow.Cells["Description"].Value, CultureInfo.CurrentUICulture);
                hcp.Name = Convert.ToString(aRow.Cells["Name"].Value, CultureInfo.CurrentUICulture); // not used yet

                if (aRow.Cells["Sequence"].Value != DBNull.Value)
                {
                    hcp.Sequence = Convert.ToInt32(aRow.Cells["Sequence"].Value, CultureInfo.CurrentUICulture);
                }
                if (aRow.Cells["AsrtBCRID"].Value == DBNull.Value || (int)aRow.Cells["AsrtBCRID"].Value == Include.NoRID)
                {
                    hcp.AsrtBCRID = 0;
                }
                else
                {
                    hcp.AsrtBCRID = Convert.ToInt32(aRow.Cells["AsrtBCRID"].Value, CultureInfo.CurrentUICulture);
                }
                hcp.IsVirtual = Convert.ToBoolean(aRow.Cells["IsVirtual"].Value, CultureInfo.CurrentUICulture);
                return hcp;
            }
            catch
            {
                throw;
            }
        }

        private void AddComponentsToPlaceholder(UltraGridRow aPlaceholderRow, UltraGridRow aFromRow, bool bConsumedAllUnits)
        {
            string fromRowHeaderID;
			// BEGIN TT#453-MD - stodd - Pack changes
			bool addedPack = false;
			// END TT#453-MD - stodd - Pack changes
			// Begin TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
            bool addSizesToPlaceholderColors = false;
            UltraGridRow hdrColorRowWithSizes = null;
			// End TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
            bool bAddPlaceholderColor = false;   // TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly. 

			//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
			//_placeholderNewColorList = new List<PlaceholderNewColorInfo>();
			//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
			//_newPHColorRows = new List<UltraGridRow>();
			//_matchingHdrColorRows = new List<UltraGridRow>();
			//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
			//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder

            int headerRID = Convert.ToInt32(aFromRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);  // TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
            try
            {
                _headerPacksAdded = false;     // TT#2 - RMatelic - Assortment Planning-allocating header packs not totaling correctly
                if (aFromRow.HasChild(this.ugDetails.DisplayLayout.Bands["Pack"], false))
                {
                    this.ugDetails.ActiveRow = aPlaceholderRow;
                    fromRowHeaderID = Convert.ToString(aFromRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                    UltraGridRow packRow = aFromRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["Pack"]);

                    while (packRow != null)
                    {
                        AddPackToPlaceholder(aPlaceholderRow, packRow, fromRowHeaderID);
						// BEGIN TT#453-MD - stodd - Pack changes
						addedPack = true;
						// END TT#453-MD - stodd - Pack changes
						// BEGIN TT#2046 - stodd - units not correct when dragging headers unto placeholders
						if (packRow.HasChild(this.ugDetails.DisplayLayout.Bands["PackColor"], false))
						{
							//this.ugDetails.ActiveRow = aPlaceholderRow;
							//fromRowHeaderID = Convert.ToString(aFromRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
							UltraGridRow packColorRow = packRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["PackColor"]);

							while (packColorRow != null)
							{
								// Begin TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
                                if (packColorRow.HasChild())
                                {
                                    hdrColorRowWithSizes = packColorRow;
                                    addSizesToPlaceholderColors = true;
                                }
								// End TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
								_hdrColorRow = packColorRow;	// TT#854 - MD - stodd - enqueue error 
								// BEGIN TT#454-MD - stodd - Pack Color changes
								//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                                // Begin TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly. 
                                //AddPackColorAsBulkToPlaceholder(aPlaceholderRow, packColorRow);
								// Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
								//AddPackColorAsBulkToPlaceholder(aPlaceholderRow, packColorRow, ref bAddPlaceholderColor);
                                AddPackColorAsBulkToPlaceholder(aPlaceholderRow, packColorRow, ref bAddPlaceholderColor, headerRID);
								// End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                                // End TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly. 
								//AddPlaceholderColorToPlaceholder(aPlaceholderRow);
								//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
								// END TT#454-MD - stodd - Pack Color changes
								packColorRow = packColorRow.GetSibling(SiblingRow.Next, false, false);
							}
						}
                        // Begin TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
                        else
                        {
                            UltraGridRow phColorRow = null;
                            bool placeholderColorRowFound = IsPlaceholderColorRowPresent(aPlaceholderRow, ref phColorRow);
                            bAddPlaceholderColor = false;
                            if (!placeholderColorRowFound)
                            {
                                bAddPlaceholderColor = true;
                            }
                        }
                        // End TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
						// END TT#2046 - stodd - units not correct when dragging headers unto placeholders
						packRow = packRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }

                this.ugDetails.ActiveRow = aPlaceholderRow;

				

                if (aFromRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                {
                    UltraGridRow colorRow = aFromRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);

                    while (colorRow != null)
                    {
						// Begin TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
                        if (colorRow.HasChild())
                        {
                            hdrColorRowWithSizes = colorRow;
                            addSizesToPlaceholderColors = true;
                        }
						// End TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
						_hdrColorRow = colorRow;	// TT#854 - MD - stodd - enqueue error 
                        // Begin TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly.
                        //AddBulkColorToPlaceholder(aPlaceholderRow, colorRow);
                        // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                        //AddBulkColorToPlaceholder(aPlaceholderRow, colorRow, ref bAddPlaceholderColor);
                        AddBulkColorToPlaceholder(aPlaceholderRow, colorRow, ref bAddPlaceholderColor, headerRID);
                        // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                        // End TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly.
                        colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                    }
					// BEGIN TT#452-MD - stodd - Placeholder Color changes
					// ADD BACK FOR #452
					// AddPlaceholderColorToPlaceholder(aPlaceholderRow);
					// END TT#452-MD - stodd - Placeholder Color changes
                }

				// Begin TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
                if (addedPack)
                {
                    // BEGIN TT#453-MD - stodd - Pack changes
                    // Begin TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
					//if (addedPack && !PlaceholderHasColors(aPlaceholderRow))
					if (addedPack && !PlaceholderHasColors(aPlaceholderRow) && !bAddPlaceholderColor)
					// End TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
                    {
                        if (addSizesToPlaceholderColors)
                        {
                            AddSizesToPlaceholderColors(aPlaceholderRow, hdrColorRowWithSizes);
                        }
                    }
                    // Begin TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly.
                    //else if (!bConsumedAllUnits)
                    else if (!bConsumedAllUnits
                        && bAddPlaceholderColor)
                    // End TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly.
                    {
                        AddPlaceholderColorToPlaceholder(aPlaceholderRow);
                    }
                    // END TT#453-MD - stodd - Pack changes
                }
				// End TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
				
                this.ugDetails.UpdateData();
                _dsDetails.AcceptChanges();
            }
            catch
            {
                // Begin TT#1483-MD - RMatelic - Asst - when attaching a header receive mssg Unable to determine where to add row:please select a valid row before adding a new row.  Select OK get null reference exception
                //int headerRID =   Convert.ToInt32(aFromRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);  // TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                // Begin TT#1503-MD - RMatelic - ASST - Header not being attached to placeholder when drag/dropped from Allocation Workspace
                aFromRow.Cells["PlaceHolderRID"].Value = DBNull.Value;
                aFromRow.Cells["AsrtRID"].Value = DBNull.Value;
                WriteHeader(headerRID);
                RemoveAndDequeueHeader(headerRID);
                if (_deletedHeaderRows.Contains(headerRID))
                {
                    _deletedHeaderRows.Remove(headerRID);
                }
                _asrtCubeGroup.RemoveDeletedHeaderFromCubeGroup(headerRID);
                 // End TT#1483-MD
                // End TT#1503-MD
                throw;
            }
        }

		// BEGIN TT#453-MD - stodd - Pack changes
		private bool PlaceholderHasColors(UltraGridRow aPlaceholderRow)
		{
			bool hasColors = false;
			if (aPlaceholderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
			{
				UltraGridRow colorRow = aPlaceholderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
				if (colorRow != null)
				{
                    if (colorRow != null)
                    {
                        hasColors = true;
                    }

				}
			}
			return hasColors;
		}
		// END TT#453-MD - stodd - Pack changes

		// Begin TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
        private void AddSizesToPlaceholderColors(UltraGridRow aPlaceholderRow, UltraGridRow aHdrColorRow)
        {
            if (aPlaceholderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
            {
                UltraGridRow phColorRow = aPlaceholderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                int phHdrRID = Convert.ToInt32(aPlaceholderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                int colorCodeRID = Convert.ToInt32(phColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                int keyC = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                if (!phColorRow.HasChild())
                {
                    AddSizesToBulkColor(aPlaceholderRow, aHdrColorRow, phHdrRID, colorCodeRID, keyC);
                }
            }
        }
		// End TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty

        private void AddPackToPlaceholder(UltraGridRow aPlaceholderRow, UltraGridRow aPackRow, string aFromRowHeaderID)
        {
            try
            {
                int phHdrRID = Convert.ToInt32(aPlaceholderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                string packName = Convert.ToString(aPackRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture) + " [" + aFromRowHeaderID + "]";
                int packMultiple = Convert.ToInt32(aPackRow.Cells["QuantityPerPack"].Value, CultureInfo.CurrentUICulture);
                int phPackMultiple;
                ///////////// TEST CODE
                if (aPlaceholderRow.HasChild(this.ugDetails.DisplayLayout.Bands["Pack"], false))
                {
                    UltraGridRow phPackRow = aPlaceholderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["Pack"]);
                    while (phPackRow != null)
                    {
                        phPackMultiple = Convert.ToInt32(phPackRow.Cells["QuantityPerPack"].Value, CultureInfo.CurrentUICulture);

                        if ((phPackRow.Cells["PackType"].Value == aPackRow.Cells["PackType"].Value) && (phPackMultiple % packMultiple) == 0)
                        {
                        }
                        break;
                    }
                    phPackRow = phPackRow.GetSibling(SiblingRow.Next, false, false);
                }
                //////////////


                ugDetails.ActiveRow = aPlaceholderRow; // TT#1503-MD - RMatelic - ASST - Header not being attached to placeholder when drag/dropped from Allocation Workspace
                AddPackRow();
                UltraGridRow newPackRow = this.ugDetails.ActiveRow;
                // Begin TT#2101 - RMatelic - Defined and Saved Assortment.  The PhStyle 1 row is 5010 units.  I created a Header for 4920 units (Detail 6 ppk). Results for balance is not as expected.
                newPackRow.Cells["PackType"].Value = aPackRow.Cells["PackType"].Value;
                // End TT#2101 
                newPackRow.Cells["Pack"].Value = packName;
                newPackRow.Cells["KeyH"].Value = phHdrRID;
                // Begin TT#2101 - RMatelic - Defined and Saved Assortment.  The PhStyle 1 row is 5010 units.  I created a Header for 4920 units (Detail 6 ppk). Results for balance is not as expected.
                //newPackRow.Cells["PackType"].Value = aPackRow.Cells["PackType"].Value;
                // End TT#2101
                //newPackRow.Cells["TotalPacks"].Value = aPackRow.Cells["TotalPacks"].Value;
                //newPackRow.Cells["QuantityPerPack"].Value = aPackRow.Cells["QuantityPerPack"].Value;

                //if (!aPackRow.HasChild(this.ugDetails.DisplayLayout.Bands["PackColor"], false))
                //{
                //    newPackRow.Cells["ChildTotal"].Value = aPackRow.Cells["ChildTotal"].Value;
                //}

				newPackRow.Cells["TotalPacks"].Value = 0;
				// BEGIN TT#453-MD - stodd - pack changes
				newPackRow.Cells["QuantityPerPack"].Value = packMultiple;
				// END TT#453-MD - stodd - pack changes
                if (!aPackRow.HasChild(this.ugDetails.DisplayLayout.Bands["PackColor"], false))
                {
                    newPackRow.Cells["ChildTotal"].Value = 0;
                }

                newPackRow.Cells["AssociatedPackRID"].Value = aPackRow.Cells["KeyP"].Value;
                newPackRow.Update();

                if (aPackRow.HasChild(this.ugDetails.DisplayLayout.Bands["PackColor"], false))
                {
                    AddPackColorToPlaceholder(aPackRow, newPackRow);
                }
                else if (aPackRow.HasChild())
                {
                    this.ugDetails.ActiveRow = newPackRow;

                    AddPackSizeToPlaceholder(aPackRow, newPackRow);
                }
                // Begin TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
				else // pack with not components
                {
                    PlaceholderNewPackInfo pnpi = new PlaceholderNewPackInfo();
                    pnpi.PlaceholderPackName = packName;
                    pnpi.PlaceholderPackUnits = Convert.ToInt32(aPackRow.Cells["TotalPacks"].Value);
                    pnpi.Multiple = packMultiple;
                    _placeholderNewGenericPackList.Add(pnpi);
                    
                }
				// End TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
                _headerPacksAdded = true;     // TT#2 - RMatelic - Assortment Planning-allocating header packs not totaling correctly

            }
            catch
            {
                throw;
            }
        }

        private void AddPackColorToPlaceholder(UltraGridRow aFromPackRow, UltraGridRow aNewPackRow)
        {
            string errorMessage = string.Empty, packName;
            int colorCodeRID, sizeCodeRID, secondaryRID;
            try
            {
                string strKeyH = Convert.ToString(aFromPackRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                string strFromPackRID = Convert.ToString(aFromPackRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                int phHdrRID = Convert.ToInt32(aNewPackRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                AllocationProfile ap = GetAllocationProfile(phHdrRID);
                packName = Convert.ToString(aNewPackRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture);
                UltraGridRow packColorRow = aFromPackRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                while (packColorRow != null)
                {
                    AddPackColorRow();
                    string colorCodeID = Convert.ToString(packColorRow.Cells["PackColor"].Value, CultureInfo.CurrentUICulture);
                    UpdateColorValue(ugDetails.ActiveRow, colorCodeID, ref errorMessage);
                    ugDetails.ActiveRow.Cells["Description"].Value = packColorRow.Cells["Description"].Value;
                  
				  	//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                    ugDetails.ActiveRow.Cells["QuantityPerPack"].Value = packColorRow.Cells["QuantityPerPack"].Value;
                    //ugDetails.ActiveRow.Cells["QuantityPerPack"].Value = 0;
					//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                    if (_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                    {
                        //this.ugDetails.ActiveRow.Cells["ChildTotal"].Value = packColorRow.Cells["ChildTotal"].Value;
                        this.ugDetails.ActiveRow.Cells["ChildTotal"].Value = 0;
                    }
                   
                    ugDetails.ActiveRow.Update();

                    if (packColorRow.HasChild())	// PackColorSize
                    {
                        colorCodeRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                        int keyP = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                        int keyC = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                        UltraGridRow packColorSizeRow = packColorRow.GetChild(ChildRow.First);

                        string bandKey = packColorSizeRow.Band.Key;

                        string tableName = "PackColorSize" + "~"
                                        + phHdrRID.ToString(CultureInfo.CurrentUICulture) + "~"
                                        + keyP.ToString(CultureInfo.CurrentUICulture) + "~"
                                        + keyC.ToString(CultureInfo.CurrentUICulture);

                        DataTable dtPhPackColorSize = MIDEnvironment.CreateDataTable(tableName);
                        dtPhPackColorSize = _dsDetails.Tables[bandKey].Copy();
                        dtPhPackColorSize.TableName = tableName;
                        foreach (DataRow dr in dtPhPackColorSize.Rows)
                        {
                            dr["KeyH"] = phHdrRID;
                            dr["KeyP"] = keyP;
                            dr["KeyC"] = keyC;
                            dr["TotalQuantity"] = 0;
                            secondaryRID = Convert.ToInt32(dr["SecondaryRID"], CultureInfo.CurrentUICulture);
                            for (int i = 7; i < dtPhPackColorSize.Columns.Count; i++)
                            {
                                dr[i] = 0;
                                DataColumn dCol = dtPhPackColorSize.Columns[i];
                                string primary = dCol.ColumnName;

                                sizeCodeRID = Convert.ToInt32(dCol.ExtendedProperties[primary + "~" + secondaryRID], CultureInfo.CurrentUICulture);
                                ap.AddSizeToPackColor(packName, colorCodeRID, sizeCodeRID, 0, -1);
                            }
                        }

                        _dsAsrtSizes.Tables.Add(dtPhPackColorSize);
                        _dsAsrtSizes.AcceptChanges();
                    }

                    packColorRow = packColorRow.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void AddPackSizeToPlaceholder(UltraGridRow aFromPackRow, UltraGridRow aNewPackRow)
        {
            int phHdrRID, keyP, colorCodeRID, sizeCodeRID, secondaryRID;
            string packName;
            try
            {
                phHdrRID = Convert.ToInt32(aNewPackRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                keyP = Convert.ToInt32(aNewPackRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                packName = aNewPackRow.Cells["Pack"].Value.ToString();
                colorCodeRID = Include.DummyColorRID;
                AllocationProfile ap = GetAllocationProfile(phHdrRID);

                UltraGridRow packSizeRow = aFromPackRow.GetChild(ChildRow.First);
                string bandKey = packSizeRow.Band.Key;
                string tableName = "PackSize"
                                 + "~" + phHdrRID.ToString(CultureInfo.CurrentUICulture)
                                 + "~" + keyP.ToString(CultureInfo.CurrentUICulture)
                                 + "~" + Include.DummyColorRID.ToString(CultureInfo.CurrentUICulture);

                DataTable dtPhPackSize = MIDEnvironment.CreateDataTable(tableName);
                dtPhPackSize = _dsDetails.Tables[bandKey].Copy();
                dtPhPackSize.TableName = tableName;
                foreach (DataRow dr in dtPhPackSize.Rows)
                {
                    dr["KeyH"] = phHdrRID;
                    dr["KeyP"] = keyP;
                    dr["KeyC"] = Include.DummyColorRID;
                    dr["TotalQuantity"] = 0;
                    secondaryRID = Convert.ToInt32(dr["SecondaryRID"], CultureInfo.CurrentUICulture);
                    for (int i = 7; i < dtPhPackSize.Columns.Count; i++)
                    {
                        dr[i] = 0;
                        DataColumn dCol = dtPhPackSize.Columns[i];
                        string primary = dCol.ColumnName;

                        sizeCodeRID = Convert.ToInt32(dCol.ExtendedProperties[primary + "~" + secondaryRID], CultureInfo.CurrentUICulture);
                        ap.AddSizeToPackColor(packName, colorCodeRID, sizeCodeRID, 0, -1);
                    }
                }

                if (!DummyColorCheckOK(aNewPackRow))
                {
                    return;
                }

                _dsAsrtSizes.Tables.Add(dtPhPackSize);
            }
            catch
            {
                throw;
            }
        }

        // Begin TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly.
        //private void AddBulkColorToPlaceholder(UltraGridRow aPlaceholderRow, UltraGridRow aColorRow)
        // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
        //private void AddBulkColorToPlaceholder(UltraGridRow aPlaceholderRow, UltraGridRow aColorRow, ref bool bAddPlaceholderColor)
        private void AddBulkColorToPlaceholder(UltraGridRow aPlaceholderRow, UltraGridRow aColorRow, ref bool bAddPlaceholderColor, int fromHeaderRID)
        // End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
        // End TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly.
        {
			// BEGIN TT#2046 - stodd - units not correct when dragging headers unto placeholders
            int phHdrRID, colorCodeRID, keyC = 0;
            string colorID, colorDesc, errorMessage = string.Empty;
            bool dupColorRowFound = false, placeholderColorRowFound = false;
            try
            {
                phHdrRID = Convert.ToInt32(aPlaceholderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                colorCodeRID = Convert.ToInt32(aColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                colorID = Convert.ToString(aColorRow.Cells["BulkColor"].Value);
				colorDesc = aColorRow.Cells["Description"].Value.ToString();
                //dupColorRowFound = false;
                // if placeholder row already has the colorRID add to its qty, otherwise add a new row
				if (aPlaceholderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
				{
					UltraGridRow phColorRow = null;
					//Begin TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
					if (_dropCell != null && _dropRow != null && _dropCell.Column.Key == "BulkColor")
					{
						phColorRow = _dropRow;
                        // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                        //UpdateBulkColorData(phColorRow, colorID, colorDesc);
                        UpdateBulkColorData(phColorRow, colorID, colorDesc, fromHeaderRID, aColorRow, aPlaceholderRow);
                        // End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
						keyC = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
						//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
						//int accumQty = Convert.ToInt32(phColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
						//accumQty -= Convert.ToInt32(aColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
						//phColorRow.Cells["Quantity"].Value = accumQty >= 0 ? accumQty : 0;
						//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
						_dropRow = null;
						_dropCell = null;
						dupColorRowFound = true;
					}
					else
					{
						//END TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
						dupColorRowFound = IsDupColorRow(aPlaceholderRow, colorCodeRID, ref phColorRow);
						if (dupColorRowFound)
						{
							keyC = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
							//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
							//int accumQty = Convert.ToInt32(phColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
							//accumQty -= Convert.ToInt32(aColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
							//phColorRow.Cells["Quantity"].Value = accumQty >= 0 ? accumQty : 0;
							//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 

                            // Begin TT#2047-MD - JSmith - Remove a header from a PH and PH Qty increases greater than the header plus the residual Ph values.
                            for (int c = 0; c < _placeholderNewColorList.Count; c++)
                            {
                                PlaceholderNewColorInfo pnci = _placeholderNewColorList[c];
                                if (pnci.PlaceholderColorRid == colorCodeRID)
                                {
                                    if (pnci.AddedFromPack)
                                    {
                                        pnci.Multiple = 1;
                                        _placeholderNewColorList[c] = pnci;
                                    }
                                    break;
                                }
                            }
                            // End TT#2047-MD - JSmith - Remove a header from a PH and PH Qty increases greater than the header plus the residual Ph values.
						}
						else    // CHeck for placeholder color row
						{
							placeholderColorRowFound = IsPlaceholderColorRowPresent(aPlaceholderRow, ref phColorRow);
							if (placeholderColorRowFound)
							{
                                // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                                //UpdateBulkColorData(phColorRow, colorID, colorDesc);
                                UpdateBulkColorData(phColorRow, colorID, colorDesc, fromHeaderRID, aColorRow, aPlaceholderRow);
                                // End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
								keyC = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
								//BEGIN TT#676-MD - stodd - Placeholder colors not being created for balance of units when adding more than 1 color to a header.
								//===============================================================================================
								// If there are no more Placeholder color rows on placeholder and there are units remaining
								// after absorbing the header color, then we need to add a new placeholder color row
								// to contain the remaining units.
								//===============================================================================================
								UltraGridRow dummyRow = null;
								if (!IsPlaceholderColorRowPresent(aPlaceholderRow, ref dummyRow))
								{
									int placeholderColorQty = Convert.ToInt32(phColorRow.Cells["Quantity"].Value);
									int hdrColorQty = Convert.ToInt32(aColorRow.Cells["Quantity"].Value);
									int newPlaceholderColorQty = placeholderColorQty - hdrColorQty;
									if (newPlaceholderColorQty > 0)
									{
										//================================================================================
										// We need to reallocate the replaced PHC because the total units will change.
										// Adding it to the _placeholderNewColorList will make that happen.
										//================================================================================
										PlaceholderNewColorInfo pnci = new PlaceholderNewColorInfo();
										pnci.PlaceholderColorRid = colorCodeRID;
										pnci.PlaceholderColorUnits = hdrColorQty;
										pnci.Multiple = 1;
                                        pnci.AddedFromPack = false;  // TT#2047-MD - JSmith - Remove a header from a PH and PH Qty increases greater than the header plus the residual Ph values.
										_placeholderNewColorList.Add(pnci);
										//================================================================================
										// We also add a "placeholder" entry for the new placeholder color.
										// we don't know what it's ColorCodeRid will be yet.
										//================================================================================
										PlaceholderNewColorInfo pnci2 = new PlaceholderNewColorInfo();
										pnci2.PlaceholderColorRid = -1;
										pnci2.PlaceholderColorUnits = newPlaceholderColorQty;
										pnci2.Multiple = 1;
                                        pnci.AddedFromPack = false;  // TT#2047-MD - JSmith - Remove a header from a PH and PH Qty increases greater than the header plus the residual Ph values.
										_placeholderNewColorList.Add(pnci2);
									}
								}
								//END TT#676-MD - stodd - Placeholder colors not being created for balance of units when adding more than 1 color to a header.

								//phColorRow.Cells["ColorCodeRID"].Value = colorCodeRID;
								//keyC = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
								//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
								//int accumQty = Convert.ToInt32(phColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
								//accumQty -= Convert.ToInt32(aColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
								//phColorRow.Cells["Quantity"].Value = accumQty >= 0 ? accumQty : 0;
								//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
							}
						}
					}
				}
                bAddPlaceholderColor = false;   // TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly.
				if (!dupColorRowFound && !placeholderColorRowFound)
                {
                    bAddPlaceholderColor = true;   // TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly.
                    ugDetails.ActiveRow = aPlaceholderRow; // TT#1503-MD - RMatelic - ASST - Header not being attached to placeholder when drag/dropped from Allocation Workspace
                    AddBulkColorRow();
                    UpdateColorValue(ugDetails.ActiveRow, colorID, ref errorMessage);

					//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
					PlaceholderNewColorInfo pnci = new PlaceholderNewColorInfo();
					// BEGIN TT#856 - MD - stodd - total not spread error
					//pnci.PlaceholderColorRid = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value);
					pnci.PlaceholderColorRid = colorCodeRID;
					// END TT#856 - MD - stodd - total not spread error
					pnci.PlaceholderColorUnits = Convert.ToInt32(aColorRow.Cells["Quantity"].Value);
					pnci.Multiple = 1;	// TT#600-MD - stodd 
                    pnci.AddedFromPack = false;  // TT#2047-MD - JSmith - Remove a header from a PH and PH Qty increases greater than the header plus the residual Ph values.
					_placeholderNewColorList.Add(pnci);

					//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
					//_newPHColorRows.Add(ugDetails.ActiveRow);
					//_matchingHdrColorRows.Add(aColorRow);
					//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
					//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder

                    ugDetails.ActiveRow.Cells["Description"].Value = aColorRow.Cells["Description"].Value;

					// BEGIN TT#452-MD - stodd - Placeholder Color changes
					// REVERSE COMMENTS TO PUT #452 CHANGES BACK IN
                    //ugDetails.ActiveRow.Cells["Quantity"].Value = 0;
					//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
					//int accumQty = Convert.ToInt32(aPlaceholderRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
					//accumQty -= Convert.ToInt32(aColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
					//ugDetails.ActiveRow.Cells["Quantity"].Value = accumQty >= 0 ? accumQty : 0;
					//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
					// END TT#452-MD - stodd - Placeholder Color changes

                    if (_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                    {
                        ugDetails.ActiveRow.Cells["ChildTotal"].Value = 0;
                    }
                    
                    keyC = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                    ugDetails.ActiveRow.Update();
                }
                // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
				else if (dupColorRowFound && !placeholderColorRowFound)
                {
                    PlaceholderNewColorInfo pnci;
                    for (int i = 0; i < _placeholderNewColorList.Count; i++)
                    {
                        pnci = _placeholderNewColorList[i];
                        if (pnci.PlaceholderColorRid == colorCodeRID)
                        {
                            pnci.PlaceholderColorUnits += Convert.ToInt32(aColorRow.Cells["Quantity"].Value);
                            _placeholderNewColorList[i] = pnci;
                            break;
                        }
                    }
                }
				// End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                //{   // if new placeholder color HdrBCRID = -1, Before & After Cell updates won't fire so change it twice 
                if (keyC == Include.NoRID)
                {
                    aColorRow.Cells["AsrtBCRID"].Value = 0;
                }
                aColorRow.Cells["AsrtBCRID"].Value = keyC;
                //}

				//BEGIN TT#599 - MD - DOConnell - in assortment run "Size Proportional" and get "Size not defined for bulk color" error
				//Uncommented the code below to allow bulk sizes to be added to Placeholder Colors
				//==============================
				// Adds SIZES to colors
				//==============================
                if (aColorRow.HasChild())
                {
					// Begin TT#854 - MD - stodd - enqueue error 
					AddSizesToBulkColor(aPlaceholderRow, aColorRow, phHdrRID, colorCodeRID, keyC);
					// End TT#854 - MD - stodd - enqueue error 
                }
				//END TT#599 - MD - DOConnell - in assortment run "Size Proportional" and get "Size not defined for bulk color" error
            }
            catch
            {
                throw;
            }
			// END TT#2046 - stodd - units not correct when dragging headers unto placeholders
        }



		
		// BEGIN TT#452-MD - stodd - Placeholder Color changes
		/// <summary>
		/// Adds a "dummy" placeholder color to a placeholder as a holding bin for units not consumed by attached headers.
		/// </summary>
		/// <param name="aPlaceholderRow"></param>
		/// <returns></returns>
		// BEGIN TT#856 - MD - stodd - total not spread error
		//private string AddPlaceholderColorToPlaceholder(UltraGridRow aPlaceholderRow)
		private int AddPlaceholderColorToPlaceholder(UltraGridRow aPlaceholderRow)
		// END TT#856 - MD - stodd - total not spread error
		{
			string errorMessage = string.Empty;
			ArrayList PhColorRIDs = new ArrayList();
			int newColorCodeRid = -1;	// TT#856 - MD - stodd - total not spread error

			if (aPlaceholderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
			{
				UltraGridRow colorRow = aPlaceholderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
				while (colorRow != null)
				{
					int colorCodeRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
					if (Convert.ToBoolean(colorRow.Cells["IsVirtual"].Value, CultureInfo.CurrentUICulture))
					{
						if (!PhColorRIDs.Contains(colorCodeRID))
						{
							PhColorRIDs.Add(colorCodeRID);
						}
					}
					colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
				}
			}

			HierarchyMaintenance hm = new HierarchyMaintenance(SAB);
			ColorCodeList colorCodeList = hm.GetPlaceholderColors(1, PhColorRIDs);

			if (colorCodeList.Count > 0)
			{
				ColorCodeProfile ccp = (ColorCodeProfile)colorCodeList[0];
				newColorCodeRid = ccp.Key;		// TT#856 - MD - stodd - total not spread error
				AddBulkColorRow();
				UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
				ugDetails.ActiveRow.Cells["Description"].Value = ccp.Text;
				ugDetails.ActiveRow.Cells["Quantity"].Value = Convert.ToInt32(aPlaceholderRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
				ugDetails.ActiveRow.Cells["IsVirtual"].Value = true;

                // Begin TT#2019-MD - JSmith  - Receive system argument exception when adding a Detail Pack Header to a Placeholder.
				PlaceholderNewColorInfo pnci = new PlaceholderNewColorInfo();
                pnci.PlaceholderColorRid = ccp.Key;
                pnci.PlaceholderColorUnits = Convert.ToInt32(ugDetails.ActiveRow.Cells["Quantity"].Value);
                pnci.Multiple = 1;
                pnci.AddedFromPack = false;  // TT#2047-MD - JSmith - Remove a header from a PH and PH Qty increases greater than the header plus the residual Ph values.
                _placeholderNewPlaceholderColorList.Add(pnci);
				// End TT#2019-MD - JSmith  - Receive system argument exception when adding a Detail Pack Header to a Placeholder.

				 //int keyC = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                 ugDetails.ActiveRow.Update();
			}

			// Begin TT#854 - MD - stodd - enqueue error 
			//==============================
			// Adds SIZES to color
			//==============================
            //if (_hdrColorRow.HasChild())
			{
				int phHdrRID = Convert.ToInt32(aPlaceholderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
				//AddSizesToBulkColor(aPlaceholderRow, aColorRow, phHdrRID, colorCodeRID, keyC);
				DataTable dtBulkColor = _dsDetails.Tables["BulkColor"];
				DataRow[] aRow = dtBulkColor.Select("KeyH = " + phHdrRID.ToString() + " and ColorCodeRID = " + newColorCodeRid);
				int keyC = -1;
				if (aRow.Length > 0)
				{
					keyC = Convert.ToInt32(aRow[0]["KeyC"]);
				}
				else
				{

				}
				
				AddSizesToBulkColor(aPlaceholderRow, _hdrColorRow, phHdrRID, newColorCodeRid, keyC);
			}
			// END TT#854 - MD - stodd - enqueue error 
			
			// BEGIN TT#856 - MD - stodd - total not spread error
			//return errorMessage;
			return newColorCodeRid;
			// END TT#856 - MD - stodd - total not spread error
		}
		// END TT#452-MD - stodd - Placeholder Color changes

		// Begin TT#854 - MD - stodd - enqueue error 
		/// <summary>
		/// Adds sizes to bulk colors. 
		/// If aColorRow is NOT null, then it means we're here because of a header dropped upon a placeholder.
		/// If aColorRow is null, it means were here after other colors have been added to the placeholder.
		/// Either way, a placeholder color is being added to hold some unused color units.
		/// </summary>
		/// <param name="aPlaceholderRow"></param>
		/// <param name="aColorRow"></param>
		/// <param name="phHdrRID"></param>
		/// <param name="colorCodeRID"></param>
		/// <param name="keyC"></param>
		private void AddSizesToBulkColor(UltraGridRow aPlaceholderRow, UltraGridRow aColorRow, int phHdrRID, int colorCodeRID, int keyC)
		{
			string tableName = "BulkSize" + "~"
								+ phHdrRID.ToString(CultureInfo.CurrentUICulture) + "~"
								+ keyC.ToString(CultureInfo.CurrentUICulture);
			DataTable dtPhBulkSize = MIDEnvironment.CreateDataTable(tableName);
			string bandKey = string.Empty;

			// Begin  TT#1144-MD - stodd - null ref creating group - 
            if (aColorRow != null)
            {
			// End TT#1144-MD - stodd - null ref creating group - 
                UltraGridRow bulkSizeRow = aColorRow.GetChild(ChildRow.First);
                if (bulkSizeRow != null)	// TT#854 - MD _stodd - enqueue error 
                {
                    bandKey = bulkSizeRow.Band.Key;
                    dtPhBulkSize = _dsDetails.Tables[bandKey].Copy();

                    dtPhBulkSize.TableName = tableName;
                    foreach (DataRow dr in dtPhBulkSize.Rows)
                    {
                        dr["KeyH"] = phHdrRID;
                        dr["KeyC"] = keyC;
                    }
                    if (!_dsDetails.Tables.Contains(tableName))
                    {
                        if (!_dsAsrtSizes.Tables.Contains(tableName))
                        {
                            AllocationProfile ap = GetAllocationProfile(phHdrRID);
                            foreach (DataRow dr in dtPhBulkSize.Rows)
                            {
                                dr["TotalQuantity"] = 0;
                                int secondaryRID = Convert.ToInt32(dr["SecondaryRID"], CultureInfo.CurrentUICulture);
                                for (int i = 7; i < dtPhBulkSize.Columns.Count; i++)
                                {
                                    dr[i] = 0;
                                    DataColumn dCol = dtPhBulkSize.Columns[i];
                                    string primary = dCol.ColumnName;
                                    int sizeCodeRID = Convert.ToInt32(dCol.ExtendedProperties[primary + "~" + secondaryRID], CultureInfo.CurrentUICulture);
                                    ap.AddBulkSizeToColor(colorCodeRID, sizeCodeRID, 0, -1);
                                }
                            }
                            _dsAsrtSizes.Tables.Add(dtPhBulkSize);
                        }
                        else
                        {
                            MergeDataTableToTempDataSet(tableName, dtPhBulkSize, bulkSizeRow);
                        }
                    }
                    else
                    {
                        while (bulkSizeRow != null)
                        {
                            MergeRowToMainDataSet(aPlaceholderRow, tableName, bulkSizeRow);

                            bulkSizeRow = bulkSizeRow.GetSibling(SiblingRow.Next, false, false);
                        }
                        _dsDetails.Tables[tableName].AcceptChanges();
                        //_dsDetails.AcceptChanges();
                        //ugDetails.UpdateData();
                        BindDetailsGrid();
                        FormatAddedSizesLayout(ugDetails.DisplayLayout.Bands[tableName]);
                    }
                }
            }	// TT#1144-MD - stodd - null ref creating group - 
		}
		// End TT#854 - MD - stodd - enqueue error 

		// BEGIN TT#2046 - stodd - units not correct when dragging headers unto placeholders
		private bool IsDupColorRow(UltraGridRow aPlaceholderRow, int colorCodeRID, ref UltraGridRow phColorRow)
		{
			bool dupColorRowFound = false;
			phColorRow = aPlaceholderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
			while (phColorRow != null)
			{
				if (Convert.ToInt32(phColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture) == colorCodeRID)
				{
					dupColorRowFound = true;
					break;
				}
				//BEGIN TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
                //if (_dropCell != null && _dropRow != null &&_dropCell.Column.Key == "BulkColor")
                //{
                //    phColorRow = _dropRow;
                //}
                //else
                //{
                    phColorRow = phColorRow.GetSibling(SiblingRow.Next, false, false);
                //}
				//END TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
			}
			return dupColorRowFound;
		}

        // BEGIN TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
        private bool IsMultiColorRow(SelectedRowsCollection SelRows, UltraGridRow aRow)
        {
            ArrayList colorRIDs = new ArrayList();
            bool IsMultiColorRowFound = false;
            if (SelRows.Count > 1)
            {
                foreach (UltraGridRow selRow in SelRows)
                {
                    //BEGIN TT#586-MD - stodd - unrelated issue - dragging header with no components gets null ref 
                    if (selRow.Cells["NumBulkColors"].Value.ToString() == string.Empty || selRow.Cells["NumBulkColors"].Value == null)
                    {
                        // Although this header has NO colors, setting the switch to true will prevent dropping which is
                        // what we want to happen
                        IsMultiColorRowFound = true;

                    }
                    else if (Convert.ToInt32(selRow.Cells["NumBulkColors"].Value, CultureInfo.CurrentCulture) > 1)
                    //END TT#586-MD - stodd - unrelated issue - dragging header with no components gets null ref 
                    {
                        IsMultiColorRowFound = true;

                    }
                    else
                    {
                        AllocationHeaderProfile ahp = _sab.HeaderServerSession.GetHeaderData(Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture), aIncludeComponents: true, aIncludeCharacteristics: false, blForceGet: false);
                        foreach (DictionaryEntry bulkColor in ahp.BulkColors)
                        {
                            if (!colorRIDs.Contains(bulkColor))
                            {
                                colorRIDs.Add(bulkColor);
                            }
                        }
                    }
                }
                if (colorRIDs != null && colorRIDs.Count > 1)
                {
                    IsMultiColorRowFound = true;
                }
            }
            else
            {
                //BEGIN TT#586-MD - stodd - unrelated issue - dragging header with no components gets null ref 
                if (SelRows[0].Cells["NumBulkColors"].Value.ToString() == string.Empty || SelRows[0].Cells["NumBulkColors"].Value == null)
                {
                    //BEGIN TT#648 - MD - DOConnell - Add ability to drag & drop a header with a single pack/color onto a specific placeholder color 
                    // BEGIN TT#770-MD - Stodd - invalid cast exception
                    //if (Convert.ToInt32(SelRows[0].Cells["NumPacks"].Value, CultureInfo.CurrentUICulture) >= 1)
                    if (SelRows[0].Cells["NumPacks"].Value != null && SelRows[0].Cells["NumPacks"].Value.ToString() != string.Empty && Convert.ToInt32(SelRows[0].Cells["NumPacks"].Value, CultureInfo.CurrentUICulture) >= 1)
                    // END TT#770-MD - Stodd - invalid cast exception
                    {
                        int aHdrRID = Convert.ToInt32(SelRows[0].Cells["KeyH"].Value);
                        AllocationHeaderProfile ahp = _sab.HeaderServerSession.GetHeaderData(aHdrRID, true, true, true);
                        foreach (HeaderPackProfile hpp in ahp.Packs.Values)
                        {
                            if (hpp.Colors.Count == 0)
                            {
                                IsMultiColorRowFound = true;
                                break;
                            }
                        }
                        //IsMultiColorRowFound = true;  
                    }
                    else
                    {
                        // Although this header has NO colors, setting the switch to true will prevent dropping which is
                        // what we want to happen
                        IsMultiColorRowFound = true;
                    }
                    //END TT#648 - MD - DOConnell - Add ability to drag & drop a header with a single pack/color onto a specific placeholder color 
                }
                else if (Convert.ToInt32(SelRows[0].Cells["NumBulkColors"].Value, CultureInfo.CurrentCulture) > 1)
                //END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
                {
                    IsMultiColorRowFound = true;
                }
                else
                {
                    //BEGIN TT#748 - MD - DOConnell - When dropping header onto a color on a placeholder, the "duplicate Bulk Color" error should not continue adding the header to the placeholder.
                    foreach (UltraGridRow row in ugDetails.Rows)
                    {
                        //BEGIN TT#756 - MD - DOConnell - Recieve 'Key not found' Error when dragging a header over a PH color
                        if ((Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder) &&
                        (Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture)))
                        {
                            //Get the placeholder row being dropped on
                            int phHdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            AllocationHeaderProfile phAhp = _sab.HeaderServerSession.GetHeaderData(phHdrRID, true, true, true);

                            //Loop through the drag/drop row
                            foreach (UltraGridRow selRow in SelRows)
                            {
                                int aHdrRID = Convert.ToInt32(selRow.Cells["KeyH"].Value);
                                AllocationHeaderProfile ahp = _sab.HeaderServerSession.GetHeaderData(aHdrRID, true, true, true);
                                //Loop through the colors on the drag/drop row
                                foreach (DictionaryEntry hcb in ahp.BulkColors)
                                {
                                    //if (phAhp.BulkColors.Contains(aRow.Cells["ColorCodeRID"].Value))
                                    if (phAhp.BulkColors.Contains(hcb.Key))
                                    {
                                        // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                                        if (!aRow.Cells["Description"].Value.ToString().StartsWith("PHC"))
                                        {
                                            if (Convert.ToInt32(hcb.Key) != Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value))
                                            {
                                                IsMultiColorRowFound = true;
                                                break;
                                            }
											//if (Convert.ToInt32(hcb.Key) != Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value))
                                            //{
                                            //    IsMultiColorRowFound = false;
                                            //    return IsMultiColorRowFound;
                                            //}
                                            //else
                                            //{
                                            //    IsMultiColorRowFound = true;
                                            //    return IsMultiColorRowFound;
                                            //}
                                        }
                                        // End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                                    }
                                    else
                                    {
                                        if (!aRow.Cells["Description"].Value.ToString().StartsWith("PHC"))
                                        {
                                            IsMultiColorRowFound = true;
                                            return IsMultiColorRowFound;
                                        }
                                    }
                                }
                            }
                        }
                        //END TT#756 - MD - DOConnell - Recieve 'Key not found' Error when dragging a header over a PH color
                    }
                    //END TT#748 - MD - DOConnell - When dropping header onto a color on a placeholder, the "duplicate Bulk Color" error should not continue adding the header to the placeholder.
                }
            }
            return IsMultiColorRowFound;
        }
        // END TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color

		//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
		private bool IsComponentMismatch(SelectedRowsCollection SelRows, UltraGridRow aRow)
		{
			List<UltraGridRow> SelRowsList = new List<UltraGridRow>();
			foreach (UltraGridRow selRow in SelRows)
			{
				SelRowsList.Add(selRow);
			}
			return IsComponentMismatch(SelRowsList, aRow);
		}

		/// <summary>
		/// Verifies that the components on the header are compatable with the components on the placeholder.
		/// Basically, if a header color doesn't exist on the placeholder and there are not enough placeholderColors to handle it, the header is rejected for dropping.
		/// </summary>
		/// <param name="SelRows"></param>
		/// <param name="aRow"></param>
		/// <returns></returns>
		private bool IsComponentMismatch(List<UltraGridRow> SelRows, UltraGridRow aRow)
		{
			List<int> phColors = new List<int>();
			List<int> selHdrColors = new List<int>();
			bool isMismatch = true;
			// TEMP
			//return IsMultiColorRowFound;

			// BEGIN TT#600-MD - stodd 
			// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
			//AllocationProfile PhAllocProf = _transaction.GetAllocationProfile(Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
			AllocationProfile PhAllocProf = _transaction.GetAssortmentMemberProfile(Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
			// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
			int placeholderTempRid = -1;
			int noOfPhColors = 0;		//No of placeholder colors on placeholder (as opposed to real colors)
			int noOfPhHdrColorMatches = 0;
			if (PhAllocProf.BulkColors != null && PhAllocProf.BulkColors.Count > 0)
			{
				foreach (HdrColorBin aColor in PhAllocProf.BulkColors.Values)
				{
					if (aColor.ColorName != null && aColor.ColorName.StartsWith("PHC"))
					{
						phColors.Add(placeholderTempRid--);
						noOfPhColors++;
					}
					else
					{
						phColors.Add(aColor.ColorCodeRID);
					}
				}
			}
			else
			{
				// No colors on placeholder, so header colors will all be new.
				// NO mismatches.
				return false;
			}
			// END TT#600-MD - stodd 

			foreach (UltraGridRow selRow in SelRows)
			{
				//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                AllocationHeaderProfile ahp = _sab.HeaderServerSession.GetHeaderData(Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture), aIncludeComponents: true, aIncludeCharacteristics: false, blForceGet: true);	// TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
				foreach (DictionaryEntry aColor in ahp.BulkColors)
				{
					selHdrColors.Add(int.Parse(aColor.Key.ToString()));
				}
				foreach (HeaderPackProfile pack in ahp.Packs.Values)
				{
					if (pack.Colors.Count > 0)
					{
						foreach (HeaderPackColorProfile aPackColor in pack.Colors.Values)
						{
							if (!selHdrColors.Contains(aPackColor.Key))
							{
								selHdrColors.Add(aPackColor.Key);
							}
						}
					}
				}

				//if (selRow.Band.Key == "BulkColor")
				//{
				//    if (selRow.Cells["NumBulkColors"].Value.ToString() == string.Empty || selRow.Cells["NumBulkColors"].Value == null)
				//    {
				//        //No colors, No conflicts
				//    }
				//    else if (Convert.ToInt32(selRow.Cells["NumBulkColors"].Value, CultureInfo.CurrentCulture) == 0)
				//    {
				//        //No colors, No conflicts
				//    }
				//    else
				//    {
				//        foreach (DictionaryEntry aColor in ahp.BulkColors)
				//        {
				//            selHdrColors.Add(int.Parse(aColor.Key.ToString()));
				//        }
				//    }
				//}
				//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
			}

			//=======================
			// Check for conflicts
			//=======================
			noOfPhHdrColorMatches = 0;
			foreach (int hdrColor in selHdrColors)
			{
				if (phColors.Contains(hdrColor))
				{
					noOfPhHdrColorMatches++;
				}
			}

			// Begin TT#705-MD - stodd - removing dropping/removing header with packs does not adjust PH qty
            //PH has colors but header does not -- placeholder doesn't know where to take units from
            if (phColors.Count > 0 && selHdrColors.Count == 0)
            {
                isMismatch = true;
            }
            else
			// End TT#705-MD - stodd - removing dropping/removing header with packs does not adjust PH qty
            //BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
			// All colors match between PH and HDR
			if (noOfPhHdrColorMatches == selHdrColors.Count)
			{
				isMismatch = false;
			}
			// ALL of the non-matched colors between placeholer and header can be covered by placeholderColors
			else if (noOfPhColors >= (selHdrColors.Count - noOfPhHdrColorMatches))
			{
				isMismatch = false;
			}
			//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
			return isMismatch;
		}
		//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
		
		private bool IsPlaceholderColorRowPresent(UltraGridRow aPlaceholderRow, ref UltraGridRow phColorRow)
		{
			bool PlaceholderColorRowFound = false;
            if (phColorRow == null)
            {
                phColorRow = aPlaceholderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
            }
			while (phColorRow != null)
			{
				if (phColorRow.Cells["Description"].Value.ToString().StartsWith("PHC"))
				{
					PlaceholderColorRowFound = true;
					break;
				}
				phColorRow = phColorRow.GetSibling(SiblingRow.Next, false, false);
			}
			return PlaceholderColorRowFound;
		}

		/// <summary>
		/// Adds a PackColor as a Bulk Color on the Placeholder
		/// </summary>
		/// <param name="aPlaceholderRow"></param>
		/// <param name="aColorRow"></param>
        // Begin TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly.  
        //private void AddPackColorAsBulkToPlaceholder(UltraGridRow aPlaceholderRow, UltraGridRow aColorRow)
        // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
		//private void AddPackColorAsBulkToPlaceholder(UltraGridRow aPlaceholderRow, UltraGridRow aColorRow, ref bool bAddPlaceholderColor)
        private void AddPackColorAsBulkToPlaceholder(UltraGridRow aPlaceholderRow, UltraGridRow aColorRow, ref bool bAddPlaceholderColor, int fromHeaderRID)
		// End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
        // End TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly.  
        {
			int phHdrRID, colorCodeRID, keyC = 0;
			string colorID, colorDesc, errorMessage = string.Empty;
			bool dupColorRowFound = false, placeholderColorRowFound = false;
			try
			{
				phHdrRID = Convert.ToInt32(aPlaceholderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
				colorCodeRID = Convert.ToInt32(aColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
				colorID = Convert.ToString(aColorRow.Cells["PackColor"].Value);
				colorDesc = aColorRow.Cells["Description"].Value.ToString();
				int qtyPerPack = Convert.ToInt32(aColorRow.Cells["QuantityPerPack"].Value);
				int totalPacks = Convert.ToInt32(aColorRow.ParentRow.Cells["TotalPacks"].Value);
				int colorQty = qtyPerPack * totalPacks;
				//dupColorRowFound = false;
				// if placeholder row already has the colorRID add to its qty, otherwise add a new row
				if (aPlaceholderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
				{
					UltraGridRow phColorRow = null;
                    // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                    if (_dropCell != null && _dropRow != null && _dropCell.Column.Key == "BulkColor")
                    {
                        phColorRow = _dropRow;
                        
                        UpdateBulkColorData(phColorRow, colorID, colorDesc, fromHeaderRID, aColorRow, aPlaceholderRow);
                        keyC = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                        _dropRow = null;
                        _dropCell = null;
                        dupColorRowFound = true;
                    }
                    else
                    {
                        // End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                        dupColorRowFound = IsDupColorRow(aPlaceholderRow, colorCodeRID, ref phColorRow);
                        if (dupColorRowFound)
                        {
                            keyC = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                            //BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                            //int accumQty = Convert.ToInt32(phColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
                            //accumQty -= Convert.ToInt32(aColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
                            //accumQty -= colorQty;
                            //phColorRow.Cells["Quantity"].Value = accumQty >= 0 ? accumQty : 0;
                            //END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                        }
                        else    // CHeck for placeholder color row
                        {
                            placeholderColorRowFound = IsPlaceholderColorRowPresent(aPlaceholderRow, ref phColorRow);
                            if (placeholderColorRowFound)
                            {
                                // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                                //UpdateBulkColorData(phColorRow, colorID, colorDesc);
                                UpdateBulkColorData(phColorRow, colorID, colorDesc, fromHeaderRID, aColorRow, aPlaceholderRow);
                                // End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                                keyC = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);

                                //phColorRow.Cells["ColorCodeRID"].Value = colorCodeRID;
                                //keyC = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                                //BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                                //int accumQty = Convert.ToInt32(phColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
                                //accumQty -= Convert.ToInt32(aColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
                                //accumQty -= colorQty;
                                //phColorRow.Cells["Quantity"].Value = accumQty >= 0 ? accumQty : 0;
                                //END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                            }
                        }
                    }  // TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
				}
                bAddPlaceholderColor = false;   // TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly. 
				if (!dupColorRowFound && !placeholderColorRowFound)
				{
                    bAddPlaceholderColor = true;   // TT#2041-MD - JSmith - Create PH Colors for clr 005 and 410.  Attach pack header for color 005. PH Qty appear incorrectly. 
					AddBulkColorRow();
					//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
					UpdateColorValue(ugDetails.ActiveRow, colorID, ref errorMessage);
					ugDetails.ActiveRow.Cells["Description"].Value = aColorRow.Cells["Description"].Value;
					PlaceholderNewColorInfo pnci = new PlaceholderNewColorInfo();
					// Begin TT#854 - MD _stodd - enqueue error 
					//pnci.PlaceholderColorRid = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value);
					pnci.PlaceholderColorRid = colorCodeRID;
					// End TT#854 - MD _stodd - enqueue error 
					pnci.PlaceholderColorUnits = colorQty;
					pnci.Multiple = qtyPerPack;		// TT#600-MD - stodd
                    pnci.AddedFromPack = true;  // TT#2047-MD - JSmith - Remove a header from a PH and PH Qty increases greater than the header plus the residual Ph values.
					_placeholderNewColorList.Add(pnci);
					//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
					//_newPHColorRows.Add(ugDetails.ActiveRow);
					//_matchingHdrColorRows.Add(aColorRow);
					//ugDetails.ActiveRow.Cells["Quantity"].Value = aColorRow.Cells["Quantity"].Value;
					//ugDetails.ActiveRow.Cells["Quantity"].Value = 0;
					//int accumQty = Convert.ToInt32(aPlaceholderRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
					//accumQty -= Convert.ToInt32(aColorRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
					//accumQty -= colorQty;
					//ugDetails.ActiveRow.Cells["Quantity"].Value = accumQty >= 0 ? accumQty : 0;
					//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
					
					if (_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
					{
						//ugDetails.ActiveRow.Cells["ChildTotal"].Value = aColorRow.Cells["ChildTotal"].Value;
						ugDetails.ActiveRow.Cells["ChildTotal"].Value = 0;
					}

					keyC = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                    // Begin TT#790-MD - stodd - receive error Size not defined for bulk color.
                    if (aColorRow.HasChild())
                    {
						// Begin TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
                        AddSizesToBulkColor(aPlaceholderRow, aColorRow, phHdrRID, colorCodeRID, keyC);
						// End TT#790-MD - stodd - Attached a header with a detail pack to an assortment.  PH does not decrease in qty
                    }
	                // End TT#790-MD - stodd - receive error Size not defined for bulk color.
					ugDetails.ActiveRow.Update();
				}
                // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                else if (dupColorRowFound && !placeholderColorRowFound)
                {
                    PlaceholderNewColorInfo pnci;
                    for (int i = 0; i < _placeholderNewColorList.Count; i++)
                    {
                        pnci = _placeholderNewColorList[i];
                        if (pnci.PlaceholderColorRid == colorCodeRID)
                        {
                            pnci.PlaceholderColorUnits += colorQty;
                            _placeholderNewColorList[i] = pnci;
                            break;
                        }
                    }
                }
                // End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
				// TT#790-MD - stodd - removed commented coded that was here. Same code as in AddSizesToBulkColor().
				// if new placeholder color HdrBCRID = -1, Before & After Cell updates won't fire so change it twice 
				//if (keyC == Include.NoRID)
				//{
				//    aColorRow.Cells["AsrtBCRID"].Value = 0;
				//}
				//aColorRow.Cells["AsrtBCRID"].Value = keyC;
				//if (aColorRow.HasChild())
				//{
				//    UltraGridRow bulkSizeRow = aColorRow.GetChild(ChildRow.First);
				//    string bandKey = bulkSizeRow.Band.Key;
				//    string tableName = "BulkSize" + "~"
				//                        + phHdrRID.ToString(CultureInfo.CurrentUICulture) + "~"
				//                        + keyC.ToString(CultureInfo.CurrentUICulture);

				//    DataTable dtPhBulkSize = MIDEnvironment.CreateDataTable(tableName);
				//    dtPhBulkSize = _dsDetails.Tables[bandKey].Copy();
				//    dtPhBulkSize.TableName = tableName;
				//    foreach (DataRow dr in dtPhBulkSize.Rows)
				//    {
				//        dr["KeyH"] = phHdrRID;
				//        dr["KeyC"] = keyC;
				//    }
				//    if (!_dsDetails.Tables.Contains(tableName))
				//    {
				//        if (!_dsAsrtSizes.Tables.Contains(tableName))
				//        {
				//            AllocationProfile ap = GetAllocationProfile(phHdrRID);
				//            foreach (DataRow dr in dtPhBulkSize.Rows)
				//            {
				//                dr["TotalQuantity"] = 0;
				//                int secondaryRID = Convert.ToInt32(dr["SecondaryRID"], CultureInfo.CurrentUICulture);
				//                for (int i = 7; i < dtPhBulkSize.Columns.Count; i++)
				//                {
				//                    dr[i] = 0;
				//                    DataColumn dCol = dtPhBulkSize.Columns[i];
				//                    string primary = dCol.ColumnName;
				//                    int sizeCodeRID = Convert.ToInt32(dCol.ExtendedProperties[primary + "~" + secondaryRID], CultureInfo.CurrentUICulture);
				//                    ap.AddBulkSizeToColor(colorCodeRID, sizeCodeRID, 0, -1);
				//                }
				//            }
				//            _dsAsrtSizes.Tables.Add(dtPhBulkSize);
				//        }
				//        else
				//        {
				//            MergeDataTableToTempDataSet(tableName, dtPhBulkSize, bulkSizeRow);
				//        }
				//    }
				//    else
				//    {
				//        while (bulkSizeRow != null)
				//        {
				//            MergeRowToMainDataSet(aPlaceholderRow, tableName, bulkSizeRow);

				//            bulkSizeRow = bulkSizeRow.GetSibling(SiblingRow.Next, false, false);
				//        }
				//        _dsDetails.Tables[tableName].AcceptChanges();
				//        //_dsDetails.AcceptChanges();
				//        //ugDetails.UpdateData();
				//        BindDetailsGrid();
				//        FormatAddedSizesLayout(ugDetails.DisplayLayout.Bands[tableName]);
				//    }
				//}
			}
			catch
			{
				throw;
			}
		}
		// END TT#2046 - stodd - units not correct when dragging headers unto placeholders
		
        private void MergeDataTableToTempDataSet(string aTableName, DataTable dtMergeBulkSize, UltraGridRow aBulkSizeRow)
        {
            // if the size column and row currently exists for the color in the Assortment, add the quantities
            // if the size column doesn't exist for a found row, add the column
            // if the size row doesn't exist, add the row
            string mergeRowHeader, curPhRowHeader, mergeColName, curPhColName;
            bool rowFound, colFound;
            int addQty, qty, totalQty, accumQty, mergeSizeKey, curPhSizeKey, mergePrimaryRID, curPhPrimaryRID;
            try
            {
                DataTable dtCurPhBulkSize = _dsAsrtSizes.Tables[aTableName];
                //eAssortmentType asrtType = GetAssortmentType(aBulkSizeRow);

                foreach (DataRow mergeRow in dtMergeBulkSize.Rows)
                {
                    rowFound = false;
                    mergeRowHeader = Convert.ToString(mergeRow["Secondary"], CultureInfo.CurrentUICulture);
                    int mergeSecondaryRID = Convert.ToInt32(mergeRow["SecondaryRID"], CultureInfo.CurrentUICulture); 
                    foreach (DataRow curPhSizeRow in dtCurPhBulkSize.Rows)
                    {
                        curPhRowHeader = Convert.ToString(curPhSizeRow["Secondary"], CultureInfo.CurrentUICulture);
                        int curPhSecondaryRID = Convert.ToInt32(curPhSizeRow["SecondaryRID"], CultureInfo.CurrentUICulture);
                        if (curPhSecondaryRID == mergeSecondaryRID)
                        {
                            totalQty = Convert.ToInt32(curPhSizeRow["TotalQuantity"], CultureInfo.CurrentUICulture);
                            rowFound = true;
                            for (int i = 7; i < dtMergeBulkSize.Columns.Count; i++)
                            {
                                DataColumn dMergeCol = dtMergeBulkSize.Columns[i];
                                colFound = false;
                                mergeColName = dMergeCol.ColumnName;
                                mergePrimaryRID = Convert.ToInt32(dMergeCol.ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                                mergeSizeKey = Convert.ToInt32(dMergeCol.ExtendedProperties[mergeColName + "~" + mergeSecondaryRID], CultureInfo.CurrentUICulture);
                                curPhPrimaryRID = 0;
                                for (int j = 7; j < dtCurPhBulkSize.Columns.Count; j++)
                                {
                                    DataColumn dCurCol = dtCurPhBulkSize.Columns[j];
                                    curPhColName = dCurCol.ColumnName;
                                    curPhSizeKey = Convert.ToInt32(dCurCol.ExtendedProperties[curPhColName + "~" + curPhSecondaryRID], CultureInfo.CurrentUICulture);
                                    curPhPrimaryRID = Convert.ToInt32(dCurCol.ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                                   
                                    if (curPhPrimaryRID == mergePrimaryRID)
                                    {
                                        if (curPhSizeKey == mergeSizeKey)
                                        {
                                            colFound = true;
                                            addQty = (int)mergeRow[i];
                                            if (curPhSizeRow[j] == DBNull.Value)
                                            {
                                                curPhSizeRow[j] = 0;
                                            }
                                            qty = (int)curPhSizeRow[j];

                                            //if (asrtType == eAssortmentType.PostReceipt)
                                            //{
                                            //curPhSizeRow[j] = qty + addQty;
                                            //totalQty += addQty;
                                            //}
                                            //else
                                            //{
                                                //curPhSizeRow[j] = (qty - addQty >=0) ? qty - addQty : 0;
                                                //totalQty -= addQty;
                                            //}
                                            accumQty = qty - addQty;
                                            totalQty -= addQty;
                                            curPhSizeRow[j] = accumQty >= 0 ? accumQty : 0;
                                            curPhSizeRow["TotalQuantity"] = totalQty >= 0 ? totalQty : 0;
                                            break;
                                        }
                                    }
                                }
                                if (!colFound)
                                {
                                    if (dtCurPhBulkSize.Columns.Contains(mergeColName))
                                    {
                                        if (mergeSizeKey == Include.NoRID)
                                        {
                                            mergeColName += _dupSizeNameSeparator + "NoSize";
                                        }
                                        else
                                        {
                                            SizeCodeProfile scp = _sab.HierarchyServerSession.GetSizeCodeProfile(mergeSizeKey);
                                            mergeColName += _dupSizeNameSeparator + scp.SizeCodeID;
                                        }
                                    }
                                    addQty = (int)mergeRow[i];
                                    DataColumn newCol = dtCurPhBulkSize.Columns.Add(mergeColName, System.Type.GetType("System.Int32"));
                                    newCol.ExtendedProperties.Add(mergeColName + "~" + mergeSecondaryRID, mergeSizeKey);
                                    newCol.ExtendedProperties.Add("PrimaryRID", mergePrimaryRID);
                                   
                                    //curPhSizeRow[newCol] = addQty;
                                    //totalQty += addQty;
                                    curPhSizeRow[newCol] = 0;
                                    totalQty -= addQty;
                                    curPhSizeRow["TotalQuantity"] = totalQty >= 0 ? totalQty : 0;
                                }

                            }
                        }
                    }
                    if (!rowFound)
                    {
                        UltraGridRow bulkSizeRow = aBulkSizeRow;
                        string rowHeader = string.Empty;
                        while (bulkSizeRow != null)
                        {
                            rowHeader = Convert.ToString(bulkSizeRow.Cells["Secondary"].Value, CultureInfo.CurrentUICulture);
                            if (rowHeader == mergeRowHeader)
                            {
                                break;
                            }
                            bulkSizeRow = bulkSizeRow.GetSibling(SiblingRow.Next, false, false);
                        }
                        AddNewMergedSizeRow(ref dtCurPhBulkSize, bulkSizeRow);
                    }
                }
                _dsAsrtSizes.Tables[aTableName].AcceptChanges();
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void MergeRowToMainDataSet(UltraGridRow aPlaceholderRow, string aTableName, UltraGridRow aBulkSizeRow)
        {
            // if the size column and row currently exists for the color in the Assortment, add the quantities
            // if the size column doesn't exist for a found row, add the column
            // if the size row doesn't exist, add the row
            string mergeRowHeader, curPhRowHeader, mergeColName, curPhColName;
            bool rowFound = false, colFound = false;
            int addQty, qty, totalQty = 0, mergeSizeKey, curPhSizeKey, mergePrimaryRID, mergeSecondaryRID, curPhPrimaryRID, curPhSecondaryRID;
            try
            {
                mergeRowHeader = Convert.ToString(aBulkSizeRow.Cells["Secondary"].Value, CultureInfo.CurrentUICulture);
                mergeSecondaryRID = Convert.ToInt32(aBulkSizeRow.Cells["Secondary"].Tag, CultureInfo.CurrentUICulture);
                DataTable dtCurPhBulkSize = _dsDetails.Tables[aTableName];

                foreach (DataRow curPhSizeRow in dtCurPhBulkSize.Rows)
                {
                    rowFound = false;
                    curPhRowHeader = Convert.ToString(curPhSizeRow["Secondary"], CultureInfo.CurrentUICulture);
                    curPhSecondaryRID = Convert.ToInt32(curPhSizeRow["SecondaryRID"], CultureInfo.CurrentUICulture);
                    if (curPhSecondaryRID == mergeSecondaryRID)
                    {
                        rowFound = true;
                        UltraGridRow phSizeRow = GetPlaceholderBulkSizeRow(aPlaceholderRow, mergeRowHeader, aTableName);

                        for (int i = 7; i < aBulkSizeRow.Cells.Count; i++)
                        {
                            colFound = false;
                            mergeColName = aBulkSizeRow.Cells[i].Column.Key;
                            mergeSizeKey = Convert.ToInt32(aBulkSizeRow.Cells[i].Tag, CultureInfo.CurrentUICulture);
                            mergePrimaryRID = Convert.ToInt32(aBulkSizeRow.Cells[i].Column.Tag, CultureInfo.CurrentUICulture);
                            for (int j = 7; j < phSizeRow.Cells.Count; j++)
                            {
                                curPhColName = phSizeRow.Cells[j].Column.Key;
                                curPhSizeKey = Convert.ToInt32(phSizeRow.Cells[j].Tag, CultureInfo.CurrentUICulture);
                                curPhPrimaryRID = Convert.ToInt32(phSizeRow.Cells[j].Column.Tag, CultureInfo.CurrentUICulture);
                               
                                if (curPhPrimaryRID == mergePrimaryRID)
                                {
                                    if (curPhSizeKey == mergeSizeKey)
                                    {
                                        colFound = true;
                                        addQty = Convert.ToInt32(aBulkSizeRow.Cells[i].Value, CultureInfo.CurrentUICulture);
                                        qty = Convert.ToInt32(phSizeRow.Cells[j].Value, CultureInfo.CurrentUICulture);
                                        
                                        //phSizeRow.Cells[j].Value = qty + addQty;
                                        int accumQty = qty - addQty;
                                        phSizeRow.Cells[j].Value = accumQty >=0 ? accumQty : 0;
                                        break;
                                    }
                                }
                            }
                            if (!colFound && (int)aBulkSizeRow.Cells[i].Value > 0)
                            {
                                if (dtCurPhBulkSize.Columns.Contains(mergeColName))
                                {
                                    SizeCodeProfile scp = _sab.HierarchyServerSession.GetSizeCodeProfile(mergeSizeKey);
                                    mergeColName += _dupSizeNameSeparator + scp.SizeCodeID;
                                }
                                addQty = Convert.ToInt32(aBulkSizeRow.Cells[i].Value, CultureInfo.CurrentUICulture);
                                DataColumn newCol = dtCurPhBulkSize.Columns.Add(mergeColName, System.Type.GetType("System.Int32"));
                                newCol.ExtendedProperties.Add(mergeColName + "~" + mergeSecondaryRID, mergeSizeKey);
                                newCol.ExtendedProperties.Add("PrimaryRID", mergePrimaryRID);
                                foreach (DataRow phSizeDR in dtCurPhBulkSize.Rows)
                                {
                                    if (Convert.ToInt32(phSizeDR["SecondaryRID"], CultureInfo.CurrentUICulture) == curPhSecondaryRID)
                                    {
                                        //phSizeDR[mergeColName] = addQty;
                                        //totalQty = (int)phSizeDR["TotalQuantity"];
                                        //phSizeDR["TotalQuantity"] = totalQty + addQty;

                                        phSizeDR[mergeColName] = 0;
                                        totalQty = (int)phSizeDR["TotalQuantity"];
                                        int accumQty = totalQty - addQty;
                                        phSizeDR["TotalQuantity"] = accumQty >= 0 ? accumQty : 0;
                                        _sizesAutoAdded = true;
                                    }
                                    else
                                    {
                                        phSizeDR[mergeColName] = 0;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
                if (!rowFound)
                {
                    AddNewMergedSizeRow(ref dtCurPhBulkSize, aBulkSizeRow);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private UltraGridRow GetPlaceholderBulkSizeRow(UltraGridRow aPlaceholderRow, string aGridRowHeader, string bandKey)
        {
            UltraGridRow returnRow = null;
            try
            {
                UltraGridRow phColorRow = aPlaceholderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                while (phColorRow != null)
                {
                    if (phColorRow.HasChild(this.ugDetails.DisplayLayout.Bands[bandKey], false))
                    {
                        UltraGridRow phSizeRow = phColorRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands[bandKey]);
                        while (phSizeRow != null)
                        {
                            if (phSizeRow.Cells["Secondary"].Value.ToString() == aGridRowHeader)
                            {
                                returnRow = phSizeRow;
                                break;
                            }
                            phSizeRow = phSizeRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                    if (returnRow != null)
                    {
                        break;
                    }
                    phColorRow = phColorRow.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
            return returnRow;
        }

        private void AddNewMergedSizeRow(ref DataTable dtCurPhBulkSize, UltraGridRow bulkSizeRow)
        {
            string mergeColName, mergeRowHeader;
            bool colFound;
            int addQty, colorRID, phHdrRID, mergeSizeKey, mergePrimaryRID, mergeSecondaryRID, colorCodeRID;
            try
            {
                DataRow row = dtCurPhBulkSize.Rows[0];
                phHdrRID = Convert.ToInt32(row["KeyH"], CultureInfo.CurrentUICulture);
                colorRID = Convert.ToInt32(row["KeyC"], CultureInfo.CurrentUICulture);
                mergeRowHeader = Convert.ToString(bulkSizeRow.Cells["Secondary"].Value, CultureInfo.CurrentUICulture);
                mergeSecondaryRID = Convert.ToInt32(bulkSizeRow.Cells["Secondary"].Tag, CultureInfo.CurrentUICulture);

                colorCodeRID = Convert.ToInt32(bulkSizeRow.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                //DataRowView drv = (DataRowView)bulkSizeRow.ListObject;
                //int len = drv.Row.ItemArray.Length;
                //object[] dataRowArray = new object[drv.Row.ItemArray.Length];

                for (int c = 7; c < bulkSizeRow.Cells.Count; c++)
                {
                    UltraGridCell cell = bulkSizeRow.Cells[c];
                    mergeColName = cell.Column.Key;
                    mergeSizeKey = Convert.ToInt32(cell.Tag, CultureInfo.CurrentUICulture);
                    addQty = Convert.ToInt32(cell.Value, CultureInfo.CurrentUICulture);
                    mergePrimaryRID = Convert.ToInt32(cell.Column.Tag, CultureInfo.CurrentUICulture);
                    colFound = false;
                    for (int j = 7; j < dtCurPhBulkSize.Columns.Count; j++)
                    {
                        int curPrimaryRID = Convert.ToInt32(dtCurPhBulkSize.Columns[j].ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                        if (curPrimaryRID == mergePrimaryRID)
                        {
                            colFound = true;
                            DataColumn dCol = dtCurPhBulkSize.Columns[j];
                            if (!dCol.ExtendedProperties.ContainsKey(mergeColName + "~" + mergeSecondaryRID))
                            {
                                dCol.ExtendedProperties.Add(mergeColName + "~" + mergeSecondaryRID, mergeSizeKey);
                            }
                            break;
                        }
                    }

                    if (!colFound)
                    {
                        if (dtCurPhBulkSize.Columns.Contains(mergeColName))
                        {
                            SizeCodeProfile scp = _sab.HierarchyServerSession.GetSizeCodeProfile(mergeSizeKey);
                            mergeColName += _dupSizeNameSeparator + scp.SizeCodeID;
                        }
                        DataColumn newCol = dtCurPhBulkSize.Columns.Add(mergeColName, System.Type.GetType("System.Int32"));
                        newCol.ExtendedProperties.Add(mergeColName + "~" + mergeSecondaryRID, mergeSizeKey);
                        newCol.ExtendedProperties.Add("PrimryRID", mergePrimaryRID);
                        foreach (DataRow phSizeDR in dtCurPhBulkSize.Rows)
                        {
                            phSizeDR[newCol] = 0;
                        }
                    }
                }

                DataRow newRow = dtCurPhBulkSize.NewRow();

                newRow["KeyH"] = phHdrRID;
                newRow["KeyP"] = Include.NoRID;
                newRow["KeyC"] = colorRID; ;
                newRow["SecondaryRID"] = mergeSecondaryRID;
                newRow["Secondary"] = mergeRowHeader;

                if (mergeRowHeader == Include.NoSecondarySize || mergeRowHeader.Trim() == string.Empty || mergeRowHeader.Trim() == _noSizeDimensionLbl)
                {
                    newRow[" - "] = _lblQuantity;
                }
                else
                {
                    newRow[" - "] = mergeRowHeader;
                }

                // Begin TT#2 - Assortment Planning - placeholder size quantity incorrect
                //newRow["TotalQuantity"] = Convert.ToInt32(bulkSizeRow.Cells["TotalQuantity"].Value, CultureInfo.CurrentUICulture);
                newRow["TotalQuantity"] = 0;
                // End TT#2
                for (int i = 7; i < bulkSizeRow.Cells.Count; i++)
                {
                    mergeColName = bulkSizeRow.Cells[i].Column.Key;
                    mergeSizeKey = Convert.ToInt32(bulkSizeRow.Cells[i].Tag, CultureInfo.CurrentUICulture);
                    mergePrimaryRID = Convert.ToInt32(bulkSizeRow.Cells[i].Column.Tag, CultureInfo.CurrentUICulture);
                    for (int j = 7; j < dtCurPhBulkSize.Columns.Count; j++)
                    {
                        DataColumn tblCol = dtCurPhBulkSize.Columns[j];
                        string tblColName = tblCol.ColumnName;
                        int tblColPrimaryRID = Convert.ToInt32(tblCol.ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                        int tblSizeKey = Convert.ToInt32(tblCol.ExtendedProperties[tblColName + "~" + mergeSecondaryRID], CultureInfo.CurrentUICulture);

                        if (tblColName == mergeColName)
                        {
                            newRow[tblColName] = Convert.ToInt32(bulkSizeRow.Cells[i].Value, CultureInfo.CurrentUICulture);
                            if (!tblCol.ExtendedProperties.ContainsKey(mergeColName + "~" + mergeSecondaryRID))
                            {
                                tblCol.ExtendedProperties.Add(mergeColName + "~" + mergeSecondaryRID, mergeSizeKey);
                            }
                            if ((int)newRow[tblColName] > 0)
                            {
                                _sizesAutoAdded = true;
                            }
                        }
                        else if (!bulkSizeRow.Cells.Exists(tblColName))
                        {
                            newRow[tblColName] = 0;
                        }
                    }
                }
                // Begin TT#2 - Assortment Planning - placeholder size quantity incorrect
                AllocationProfile ap = GetAllocationProfile(phHdrRID);
                for (int i = 7; i < bulkSizeRow.Cells.Count; i++)
                {
                    mergeColName = bulkSizeRow.Cells[i].Column.Key;
                    newRow[mergeColName] = 0;
                    mergeSizeKey = Convert.ToInt32(bulkSizeRow.Cells[i].Tag, CultureInfo.CurrentUICulture);
                    ap.AddBulkSizeToColor(colorCodeRID, mergeSizeKey, 0, -1);
                }
                // End TT#@
                dtCurPhBulkSize.Rows.Add(newRow);
            }
            catch
            {
                throw;
            }
        }

        private void AddAssortmentSizeTables()
        {
            try
            {
                if (_dsAsrtSizes.Tables.Count == 0)
                {
                    return;
                }

                _sizesAutoAdded = true;
                DataTable[] dtRange = new DataTable[_dsAsrtSizes.Tables.Count];
                for (int i = 0; i < _dsAsrtSizes.Tables.Count; i++)
                {
                    dtRange[i] = _dsAsrtSizes.Tables[i].Copy();
                }

                _dsDetails.Tables.AddRange(dtRange);
                for (int i = 0; i < _dsAsrtSizes.Tables.Count; i++)
                {
                    DataTable dt = _dsAsrtSizes.Tables[i];
                    string tableName = dt.TableName;
                    string[] bandKeyParts = tableName.Split(new char[] { '~' });
                    ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, false);
                    switch (bandKeyParts[0])
                    {
                        case "PackColorSize":
                            _dsDetails.Relations.Add(tableName,
                                new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"], _dsDetails.Tables["PackColor"].Columns["KeyC"] },
                                new DataColumn[] { _dsDetails.Tables[tableName].Columns["KeyH"], _dsDetails.Tables[tableName].Columns["KeyP"], _dsDetails.Tables[tableName].Columns["KeyC"] }, true);

                            break;

                        case "PackSize":
                            _dsDetails.Relations.Add(tableName,
                               new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                               new DataColumn[] { _dsDetails.Tables[tableName].Columns["KeyH"], _dsDetails.Tables[tableName].Columns["KeyP"] }, true);
                            break;

                        case "BulkSize":
                            _dsDetails.Relations.Add(tableName,
                                new DataColumn[] { _dsDetails.Tables["BulkColor"].Columns["KeyH"], _dsDetails.Tables["BulkColor"].Columns["KeyC"] },
                                new DataColumn[] { _dsDetails.Tables[tableName].Columns["KeyH"], _dsDetails.Tables[tableName].Columns["KeyC"] }, true);
                            break;
                    }
                    _dsDetails.AcceptChanges();
                    BindDetailsGrid();
                    FormatAddedSizesLayout(ugDetails.DisplayLayout.Bands[tableName]);
                    ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, true);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                _dsAsrtSizes.Dispose();
            }
        }

        private void FormatAddedSizesLayout(UltraGridBand band)
        {
            try
            {
                band.Columns["KeyH"].Hidden = true;
                band.Columns["KeyP"].Hidden = true;
                band.Columns["KeyC"].Hidden = true;
                band.Columns["SecondaryRID"].Hidden = true;
                band.Columns["Secondary"].Hidden = true;
                band.Columns[" - "].CellActivation = Activation.NoEdit;
                band.Columns["TotalQuantity"].CellActivation = Activation.Disabled;

                foreach (Infragistics.Win.UltraWinGrid.UltraGridColumn column in band.Columns)
                {
                    switch (column.DataType.ToString())
                    {
                        case "System.Int32":
                            column.CellAppearance.TextHAlign = Infragistics.Win.HAlign.Right;
                            column.Format = "#,###,##0";
                            break;
                        case "System.Double":
                            column.CellAppearance.TextHAlign = Infragistics.Win.HAlign.Right;
                            column.Format = "#,###,###.00";
                            break;
                    }
                }

                IEnumerable enumerator = band.GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow sizeRow in enumerator)
                {
                    SetCellSizeKey(sizeRow);
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAddedSizeRows(UltraGridRow aHdrRow)
        {
            string bandKey;
            int qty, hdrRID, styleRID, colorCodeRID;
            ArrayList sizeAL;
            ColorCodeProfile ccp;
            // Changing the qty to 0 and then back forces the AfterCellUpdate event which updates the
            // AllocationProfile
            try
            {
                hdrRID = Convert.ToInt32(aHdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                styleRID = Convert.ToInt32(aHdrRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);

                if (aHdrRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                {
                    UltraGridRow colorRow = aHdrRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                    while (colorRow != null)
                    {
                        if (colorRow.HasChild())
                        {
                            colorCodeRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                            ccp = _sab.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);
                            sizeAL = new ArrayList();
                            colorRow.Cells["Balance"].Value = 0;
                            colorRow.Cells["ChildTotal"].Value = colorRow.Cells["Quantity"].Value;
                            UltraGridRow bulkSizeRow = colorRow.GetChild(ChildRow.First);
                            while (bulkSizeRow != null)
                            {
                                for (int i = 7; i < bulkSizeRow.Cells.Count; i++)
                                {
                                    if (bulkSizeRow.Cells[i].Value != DBNull.Value)
                                    {
                                        qty = (int)bulkSizeRow.Cells[i].Value;
                                        if (qty > 0)
                                        {
                                            bulkSizeRow.Cells[i].Value = 0;
                                            bulkSizeRow.Cells[i].Value = qty;
                                            AddSizeToArrayList(ref sizeAL, bulkSizeRow.Cells[i]);
                                        }
                                    }
                                }
                                bulkSizeRow = bulkSizeRow.GetSibling(SiblingRow.Next, false, false);
                            }
                            UpdateColorSizeHash(styleRID, ccp.ColorCodeID, sizeAL);
                        }
                        colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }

                if (aHdrRow.HasChild(this.ugDetails.DisplayLayout.Bands["Pack"], false))
                {
                    UltraGridRow packRow = aHdrRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["Pack"]);
                    while (packRow != null)
                    {
                        if (packRow.HasChild())
                        {
                            sizeAL = new ArrayList();
                            UltraGridRow packChildRow = packRow.GetChild(ChildRow.First);
                            while (packChildRow != null)
                            {
                                bandKey = packChildRow.Band.Key;
                                if (bandKey == "PackColor")
                                {
                                    colorCodeRID = Convert.ToInt32(packChildRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                    ccp = _sab.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);
                                    UltraGridRow packChildSizeRow = packChildRow.GetChild(ChildRow.First);
                                    while (packChildSizeRow != null)
                                    {
                                        for (int i = 7; i < packChildSizeRow.Cells.Count; i++)
                                        {
                                            qty = (int)packChildSizeRow.Cells[i].Value;
                                            if (qty > 0)
                                            {
                                                packChildSizeRow.Cells[i].Value = 0;
                                                packChildSizeRow.Cells[i].Value = qty;
                                                AddSizeToArrayList(ref sizeAL, packChildSizeRow.Cells[i]);
                                            }
                                        }
                                        packChildSizeRow = packChildSizeRow.GetSibling(SiblingRow.Next, true, false);
                                    }
                                    if (sizeAL.Count > 0)
                                    {
                                        UpdateColorSizeHash(styleRID, ccp.ColorCodeID, sizeAL);
                                        sizeAL.Clear();
                                    }
                                }
                                else if (bandKey.StartsWith("PackSize"))
                                {
                                    for (int i = 7; i < packChildRow.Cells.Count; i++)
                                    {
                                        qty = (int)packChildRow.Cells[i].Value;
                                        if (qty > 0)
                                        {
                                            packChildRow.Cells[i].Value = 0;
                                            packChildRow.Cells[i].Value = qty;
                                            AddSizeToArrayList(ref sizeAL, packChildRow.Cells[i]);
                                        }
                                    }
                                }
                                packChildRow = packChildRow.GetSibling(SiblingRow.Next, true, false);
                            }
                            if (sizeAL.Count > 0)
                            {
                                UpdateColorSizeHash(styleRID, Include.DummyColorID, sizeAL);
                                sizeAL.Clear();
                            }
                        }
                        packRow = packRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void AddSizeToArrayList(ref ArrayList aSizeAL, UltraGridCell aCell)
        {
            int sizeKey = (int)aCell.Tag;
            SizeCodeProfile scp = _sab.HierarchyServerSession.GetSizeCodeProfile(sizeKey);
            if (!aSizeAL.Contains(scp.SizeCodeID))
            {
                aSizeAL.Add(scp.SizeCodeID);
            }
        }

        #endregion

        #region Remove Headers from Assortment
        private bool RemoveHeaderFromAssortment(UltraGridRow aRow)
        {
            bool removeOK = true;
			try
			{
				int asrtHdrRID, phRID;
				//int selRowQty, selRowChildTotal, phHdrTotal, phChildTotal;
				//int phColorTotal = 0; //TT#443 - MD - DOConnell - After removing a header from the assortment there is a balance,  close and save assortment balance = 0, expect the balance to be 0 at the time it is removed.
				UltraGridRow asrtRow = null;
				UltraGridRow phRow = null;

				//Begin TT#2121 - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message �“Object cannot be cast from DBNull to other types.?
				//asrtHdrRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
				//phRID = Convert.ToInt32(aRow.Cells["PlaceHolderRID"].OriginalValue, CultureInfo.CurrentUICulture);

				if (aRow.Cells["AsrtRID"].Value != DBNull.Value)
				{
					asrtHdrRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
				}
				else
				{
					asrtHdrRID = Convert.ToInt32(aRow.Cells["AsrtRID"].OriginalValue, CultureInfo.CurrentUICulture);
				}
				if (aRow.Cells["PlaceHolderRID"].Value != DBNull.Value)
				{
					phRID = Convert.ToInt32(aRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture);
				}
				else
				{
					phRID = Convert.ToInt32(aRow.Cells["PlaceHolderRID"].OriginalValue, CultureInfo.CurrentUICulture);
				}
				//End TT#2121 - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message �“Object cannot be cast from DBNull to other types.?

				bool phRowFound = false;
				bool asrtRowFound = false;
				foreach (UltraGridRow row in ugDetails.Rows)
				{
					if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == asrtHdrRID)
					{
						asrtRow = row;
						asrtRowFound = true;
					}
					else if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == phRID)
					{
						phRow = row;
						phRowFound = true;
					}
					if (asrtRowFound && phRowFound)
					{
						break;
					}
				}

				//BEGIN TT#625-MD - stodd - When header(s) are removed from a placeholder the units do not got back to the colors in the correct proportion 
				//phHdrTotal = Convert.ToInt32(phRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
				//phChildTotal = Convert.ToInt32(phRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);

				//selRowQty = Convert.ToInt32(aRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
				//selRowChildTotal = Convert.ToInt32(aRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);

				//// Begin TT#2 - RMatelic - Assortment Planning-allocate headers attached to placeholders 
				//int selRowAllocatedQty = Convert.ToInt32(aRow.Cells["AllocatedUnits"].Value, CultureInfo.CurrentUICulture);
				//int phHdrAllocatedQty = Convert.ToInt32(phRow.Cells["AllocatedUnits"].Value, CultureInfo.CurrentUICulture);
				//phHdrAllocatedQty += selRowAllocatedQty;
				//// End TT#2
				//END TT#625-MD - stodd - When header(s) are removed from a placeholder the units do not got back to the colors in the correct proportion 

				eAssortmentType asrtType = (eAssortmentType)(Convert.ToInt32(asrtRow.Cells["AsrtType"].Value, CultureInfo.CurrentUICulture));

				//BEGIN TT#625-MD - stodd - When header(s) are removed from a placeholder the units do not got back to the colors in the correct proportion 
				////if (asrtType == eAssortmentType.PreReceipt)
				////{
				//phHdrTotal += selRowQty;
				//phChildTotal += selRowChildTotal;
				////}
				//END TT#625-MD - stodd - When header(s) are removed from a placeholder the units do not got back to the colors in the correct proportion 

				if (IsGroupAllocation)
				{
				CheckPlaceholderIntransit(phRID);   //  TT#2 - RMatelic - Assortment Planning-charge intransit to headers attached to intransit placeholders
				}
				if (!RemoveComponentsFromAssortment(aRow, phRow))
				{
					return false;
				}

				int hdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

				//Begin TT#2121 - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message “Object cannot be cast from DBNull to other types"
				ReapplyAllocatedUnitsBackToPlaceholder(phRID, hdrRID);
				//End TT#2121 - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message “Object cannot be cast from DBNull to other types"

				if (!_removedAsrtHeaders.Contains(hdrRID))
				{
					_removedAsrtHeaders.Add(hdrRID);
				}
				aRow.Cells["AsrtRID"].Value = DBNull.Value;
				aRow.Cells["AsrtRIDSortCol"].Value = DBNull.Value;
				aRow.Cells["PlaceHolderRID"].Value = DBNull.Value;
				aRow.Cells["PlaceHolderRIDSortCol"].Value = DBNull.Value;
				aRow.Cells["AsrtPlaceholderSortSeq"].Value = DBNull.Value;	// TT#1227 - stodd
				aRow.Cells["AsrtHeaderSortSeq"].Value = DBNull.Value;	// TT#1227 - stodd

				//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
				// Removes the ASRT_BC_COLOR valkyes from the header bulk colors
				ClearChildAssortmentColumns(aRow);
				//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder

				aRow.RefreshSortPosition();

				if (_assortmentGroups.ContainsKey(asrtHdrRID))
				{
					Hashtable asrtHeaderListHash = (Hashtable)_assortmentGroups[asrtHdrRID];
					if (asrtHeaderListHash.ContainsKey(hdrRID))
					{
						asrtHeaderListHash.Remove(hdrRID);
					}
				}
				//_removingHeaderFromAssortment = true; //  TT#2 - RMatelic -Assortment Planning- unnecessary placeholder size group change error message
				//phRow.Cells["SizeGroup"].Value = DetermineSizeGroup(phRID);   // TT#2 - move this line to after all headers are processed

				//BEGIN TT#625-MD - stodd - When header(s) are removed from a placeholder the units do not got back to the colors in the correct proportion 
				//phRow.Cells["ChildTotal"].Value = phChildTotal >= 0 ? phChildTotal : 0;
				//phRow.Cells["HdrQuantity"].Value = phHdrTotal >= 0 ? phHdrTotal : 0;

				//// Begin TT#2 - RMatelic - Assortment Planning-allocate headers attached to placeholders 
				//phRow.Cells["AllocatedUnits"].Value = phHdrAllocatedQty >= 0 ? phHdrAllocatedQty : 0;
				//// End TT#2
				//END TT#625-MD - stodd - When header(s) are removed from a placeholder the units do not got back to the colors in the correct proportion 

				//Begin TT#2121 - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message “Object cannot be cast from DBNull to other types"
				//_removingHeaderFromAssortment = false;    // TT#2 - RMatelic -Assortment Planning- unnecessary placeholder size group change error message
				// Begin TT#2 - RMatelic - Assortment Planning-allocate headers attached to placeholders 
				//ReapplyAllocatedUnitsBackToPlaceholder(phRID, hdrRID);
				// End TT#2
				//End TT#2121 - DOConnell - Assigned a header to a placeholder and then did a right click and remove received a message “Object cannot be cast from DBNull to other types"

				//BEGIN TT#625-MD - stodd - When header(s) are removed from a placeholder the units do not got back to the colors in the correct proportion 
				////BEGIN TT#443 - MD - DOConnell - After removing a header from the assortment there is a balance,  close and save assortment balance = 0, expect the balance to be 0 at the time it is removed.
				//ArrayList currentPhColorRIDs = new ArrayList();
				//if (phRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
				//{

				//    UltraGridRow phColorRow = phRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
				//    while (phColorRow != null)
				//    {
				//        phColorTotal = phColorTotal + Convert.ToInt32(phColorRow.Cells["Quantity"].Value);
				//        phColorRow = phColorRow.GetSibling(SiblingRow.Next, false, false);
				//    }
				//    phColorTotal = Convert.ToInt32(phRow.Cells["HdrQuantity"].Value) - phColorTotal;
				//    if (phColorTotal != 0)
				//    {
				//        phRow.Cells["Balance"].Value = phColorTotal;
				//    }
				//    else
				//    {
				//        phRow.Cells["Balance"].Value = System.DBNull.Value;
				//    }
				//}
				////END TT#443 - MD - DOConnell - After removing a header from the assortment there is a balance,  close and save assortment balance = 0, expect the balance to be 0 at the time it is removed.
				//END TT#625-MD - stodd - When header(s) are removed from a placeholder the units do not got back to the colors in the correct proportion 

				// If Post Receipt Assortment and Placeholders have no attached headers, delete the Placeholder 
				if (Convert.ToInt32(asrtRow.Cells["AsrtType"].Value, CultureInfo.CurrentUICulture) == (int)eAssortmentType.PostReceipt
				|| Convert.ToInt32(asrtRow.Cells["AsrtType"].Value, CultureInfo.CurrentUICulture) == (int)eAssortmentType.GroupAllocation)
				{
					CheckForPlaceholderDelete(phRow);
				}

				// Begin TT#2 - RMatelic - Assortment Planning-allocate headers attached to placeholders 
				// if placeholder has charged intransit but it is being deleted, remove it from array to process intransit
				if (_deletedHeaderRows.Contains(phRID) && _placeholdersIntransit.Contains(phRID))
				{
					_placeholdersIntransit.Remove(phRID);
				}
				// End TT#2
			}
			catch
			{
				throw;
			}
			finally
			{
				//BEGIN TT#579-MD - stodd -  After adding a header to a placeholder, placeholder has a balance value even though its units are all in balance  
				CalculatePlaceholderBalances();
				//END TT#579-MD - stodd -  After adding a header to a placeholder, placeholder has a balance value even though its units are all in balance  		
			}
            return removeOK;
        }
        
        // Begin TT#2 - RMatelic - Assortment Planning-allocate headers attached to placeholders 
        private void ReapplyAllocatedUnitsBackToPlaceholder(int aPlaceHolderRID, int aHeaderRID) 
        {
            try
            {
				//BEGIN TT#625-MD - stodd - When header(s) are removed from a placeholder the units do not got back to the colors in the correct proportion 
				//ArrayList headerGradeUnits = new ArrayList();
				//Hashtable hdrGradeUnitsHash = new Hashtable();
				Cube myCube = _asrtCubeGroup.GetCube(eCubeType.AssortmentPlaceholderGradeTotal);
				AssortmentCellReference asrtCellRef = new AssortmentCellReference((AssortmentPlaceholderGradeTotal)myCube);

				Cube myCube2 = _asrtCubeGroup.GetCube(eCubeType.AssortmentHeaderColorDetail);
				AssortmentCellReference asrtCellRef2 = new AssortmentCellReference((AssortmentHeaderColorDetail)myCube2);
                
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(aPlaceHolderRID);
                AllocationProfile ahp = (AllocationProfile)_allocProfileList.FindKey(aHeaderRID);
                AssortmentProfile asp = (AssortmentProfile)_allocProfileList.FindKey(ap.AsrtRID);

				// Begin TT#854 - MD - stodd - enqueue error 
				SelectedHeaderList selectedHdrList = GetSelectableHeaderList((int)eMethodType.BackoutAllocation, ahp.AppSessionTransaction, true);

				//SelectedHeaderList selectedHdrList = new SelectedHeaderList(eProfileType.SelectedHeader);
				//SelectedHeaderProfile selectedHeader = new SelectedHeaderProfile(ahp.Key);
				//selectedHeader.HeaderType = ahp.HeaderType;
				//selectedHdrList.Add(selectedHeader);
				// End TT#854 - MD - stodd - enqueue error 
				ahp.AppSessionTransaction.AssortmentSelectedHdrList = selectedHdrList;

				// Begin TT#1053 - MD - stodd - removing headers from GA
                TransactionProfileList_Load(selectedHdrList, ahp.AppSessionTransaction, false);
				// End TT#1053 - MD - stodd - removing headers from GA
				
				ahp.ActivateAssortment = true;		// TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder

				//=========================================
				// Cancel Allocation on Header
				//=========================================
				GeneralComponent aComponent = new GeneralComponent(eGeneralComponentType.Total);
				bool aReviewFlag = false;
				bool aUseSystemTolerancePercent = false;
				double aTolerancePercent = Include.DefaultBalanceTolerancePercent;
				int aStoreFilter = Include.AllStoreFilterRID;
				int aWorkFlowStepKey = -1;
				ApplicationBaseAction aMethod = ahp.AppSessionTransaction.CreateNewMethodAction(eMethodType.BackoutAllocation);
				AllocationWorkFlowStep aAllocationWorkFlowStep
						= new AllocationWorkFlowStep(aMethod, aComponent, aReviewFlag, aUseSystemTolerancePercent, aTolerancePercent, aStoreFilter, aWorkFlowStepKey);
				ahp.AppSessionTransaction.DoAllocationAction(aAllocationWorkFlowStep);

				//WriteHeader(ahp.Key);

				ahp.ActivateAssortment = false;		// TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder

				////BEGIN TT#573-MD - stodd -  Header not fully allocated after drag unto placeholder  
				////int phAllocatedUnits = ap.AllocatedUnits;
				//int phAllocatedUnits = ap.TotalUnitsAllocated;
				////END TT#573-MD - stodd -  Header not fully allocated after drag unto placeholder  
                
				//=========================================================================================================================
				// Zero out units for removed header in matrix screen. (Otherwise the units will be updated to the Allocation Profile.)
				//=========================================================================================================================
				ProfileList gradeList = asp.GetAssortmentStoreGrades();		// TT#488-MD - STodd - Group Allocation
				ProfileList sgll = _asrtCubeGroup.GetFilteredProfileList(eProfileType.StoreGroupLevel);

				foreach (StoreGroupLevelProfile sglp in sgll.ArrayList)
				{
					foreach (StoreGradeProfile sgp in gradeList.ArrayList)
					{
						ProfileList gradeStoreList = _asrtCubeGroup.GetStoresInSetGrade(sglp.Key, sgp.Key);
						ProfileList storeList = new ProfileList(eProfileType.Store);
						foreach (StoreProfile sp in gradeStoreList)
						{
							if (sp.Key != _transaction.ReserveStore.RID)
							{
								storeList.Add(sp);
							}
						}

						// get header units
						int currentUnitsHeader = 0;
						asrtCellRef2[eProfileType.AllocationHeader] = aHeaderRID;
						asrtCellRef2[eProfileType.StoreGroupLevel] = sglp.Key;
						asrtCellRef2[eProfileType.StoreGrade] = sgp.Key;
						asrtCellRef2[eProfileType.AssortmentDetailVariable] = _asrtCubeGroup.AssortmentComputations.AssortmentDetailVariables.VariableProfileList.FindKey((int)eAssortmentDetailVariables.TotalUnits).Key;
						asrtCellRef2[eProfileType.AssortmentQuantityVariable] = (int)eAssortmentQuantityVariables.Value;

						foreach (HdrColorBin hcb in ahp.BulkColors.Values)
						{
							asrtCellRef2[eProfileType.HeaderPack] = int.MaxValue;
							asrtCellRef2[eProfileType.HeaderPackColor] = hcb.ColorCodeRID;
							asrtCellRef2.SetEntryCellValue(0);
						}
						foreach (PackHdr pack in ahp.Packs.Values)
						{
							asrtCellRef2[eProfileType.HeaderPack] = pack.PackRID;
							if (pack.PackColorCount > 0)
							{
								foreach (PackColorSize pcs in pack.PackColors.Values)
								{
									asrtCellRef2[eProfileType.HeaderPackColor] = pcs.ColorCodeRID;
									asrtCellRef2.SetEntryCellValue(0);
								}
							}
							else
							{
								asrtCellRef2[eProfileType.HeaderPackColor] = int.MaxValue;
								asrtCellRef2.SetEntryCellValue(0);
							}
						}
						// Begin TT#2 - RMatelic - Assortment Planning - header units not displaying in correct grade column on the screen matrix
						if (currentUnitsHeader == 0 && ahp.BulkColorCount == 0 && ahp.PackCount == 0)
						{
							asrtCellRef2[eProfileType.HeaderPack] = int.MaxValue;
							asrtCellRef2[eProfileType.HeaderPackColor] = int.MaxValue;
							asrtCellRef2.SetEntryCellValue(0);
						}
						// End TT#2

						//// get placeholder units
						//int currentUnitsPlaceholder = 0;
						//asrtCellRef[eProfileType.PlaceholderHeader] = aPlaceHolderRID;
						//asrtCellRef[eProfileType.StoreGroupLevel] = sglp.Key;
						//asrtCellRef[eProfileType.StoreGrade] = sgp.Key;
						//asrtCellRef[eProfileType.AssortmentDetailVariable] = _asrtCubeGroup.AssortmentComputations.AssortmentDetailVariables.VariableProfileList.FindKey((int)eAssortmentDetailVariables.TotalUnits).Key;
						//asrtCellRef[eProfileType.AssortmentQuantityVariable] = (int)eAssortmentQuantityVariables.Value;
						//currentUnitsPlaceholder = (int)asrtCellRef.CurrentCellValue;  //total units for set & grade

						//// Begin TT#2 - RMatelic - Assortment Planning - removing multiple headers not updating the placeholder units correctly
						//// ap.SetAllocatedUnits(storeList, currentUnitsPlaceholder + currentUnitsHeader);
						//int newValue = currentUnitsPlaceholder + currentUnitsHeader;
						//ap.SetAllocatedUnits(storeList, newValue);
						//asrtCellRef.SetCompCellValue(eSetCellMode.Computation, (double)newValue);
					}
				}
				//END TT#625-MD - stodd - When header(s) are removed from a placeholder the units do not got back to the colors in the correct proportion 
            }
            catch
            {
                throw;
            }
        }
        // End TT#2

        private bool RemoveComponentsFromAssortment(UltraGridRow aRemovedRow, UltraGridRow aParentRow)
        {
            UltraGridRow placeHolderRow;
            bool removeOK = true;
            try
            {
                placeHolderRow = aParentRow;
                UltraGridRow childRow = aRemovedRow.GetChild(ChildRow.First);

                while (childRow != null)
                {
                    switch (childRow.Band.Key)
                    {
                        case "Pack":
                            removeOK = RemovePackFromPlaceholder(placeHolderRow, childRow);
                            break;

                        case "BulkColor":
							//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
							// Note: should never remove a color because a header was removed
							//removeOK = RemoveColorFromPlaceholder(placeHolderRow, childRow);
							//if (removeOK)
							//{
							//    childRow.Cells["AsrtBCRID"].Value = Include.NoRID;
							//}
							//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                            break;
                    }
                    if (removeOK)
                    {

                        childRow = childRow.GetSibling(SiblingRow.Next, true, false);
                    }
                    else
                    {
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
            return removeOK;
        }

        private bool RemovePackFromPlaceholder(UltraGridRow aPlaceHolderRow, UltraGridRow aPackRow)
        {
            int phHdrRID, removedPackRID;
            string removedPackName;
            bool removeOK = true;
            try
            {
                phHdrRID = Convert.ToInt32(aPlaceHolderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                AllocationProfile ap = GetAllocationProfile(phHdrRID);

                removedPackRID = Convert.ToInt32(aPackRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);

                UltraGridRow phPackRow = aPlaceHolderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["Pack"]);
                while (phPackRow != null)
                {
                    int associatedPackRID = Convert.ToInt32(phPackRow.Cells["AssociatedPackRID"].Value, CultureInfo.CurrentUICulture);
                    if (removedPackRID == associatedPackRID)
                    {
                        removedPackName = Convert.ToString(phPackRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture);

                        if (phPackRow.HasChild(this.ugDetails.DisplayLayout.Bands["PackColor"], false))
                        {
                            UltraGridRow phPCRow = phPackRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                            UltraGridRow deleteRow = null;
                            while (phPCRow != null)
                            {
                                if (deleteRow != null)
                                {
                                    if (RemoveComponentFromProfile(deleteRow))
                                    {
                                        deleteRow.Delete(false);
                                    }
                                    else
                                    {
                                        removeOK =  false;
                                    }
                                    deleteRow = null;
                                    if (!removeOK)
                                    {
                                        break;
                                    }
                                }
                                int packColorCodeRID = Convert.ToInt32(phPCRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                                deleteRow = phPCRow;
                                if (phPCRow.HasChild())
                                {
                                    UltraGridRow sizeRow = phPCRow.GetChild(ChildRow.First);
                                    string bandKey = sizeRow.Band.Key;
                                    if (!_deletedAsrtBands.Contains(bandKey))
                                    {
                                        _deletedAsrtBands.Add(bandKey);
                                    }
                                    while (sizeRow != null)
                                    {
                                        sizeRow.Delete(false);
                                        sizeRow = sizeRow.GetSibling(SiblingRow.Next, false, false);
                                    }
                                }
                                phPCRow = phPCRow.GetSibling(SiblingRow.Next, false, false);
                            }
                            if (deleteRow != null && removeOK)
                            {
                                if (RemoveComponentFromProfile(deleteRow))
                                {
                                    deleteRow.Delete(false);
                                }
                                else
                                {
                                    removeOK = false;
                                }
                                deleteRow = null;
                                if (!removeOK)
                                {
                                    break;
                                }
                            }
                        }
                        else if (phPackRow.HasChild())
                        {
                            UltraGridRow sizeRow =phPackRow.GetChild(ChildRow.First);
                            string bandKey = sizeRow.Band.Key;
                            if (!_deletedAsrtBands.Contains(bandKey))
                            {
                                _deletedAsrtBands.Add(bandKey);
                            }
                            while (sizeRow != null)
                            {
                                sizeRow.Delete(false);
                                sizeRow = sizeRow.GetSibling(SiblingRow.Next, false, false);
                            }
                        }
                        if (RemoveComponentFromProfile(phPackRow))
                        {
                            phPackRow.Delete(false);
                        }
                        else
                        {
                            removeOK = false;
                        }
                        break;
                    }
                    if (removeOK)
                    {
                        phPackRow = phPackRow.GetSibling(SiblingRow.Next, false, false);
                    }
                    else
                    {
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
            return removeOK;
        }

        private bool RemoveColorFromPlaceholder(UltraGridRow aPlaceHolderRow, UltraGridRow aColorRow)
        {
            int phHdrRID, removedRID, removedQty, phChildQty;
            bool removeOK = true;
            try
            {
                phHdrRID = Convert.ToInt32(aPlaceHolderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                removedRID = Convert.ToInt32(aColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                removedQty = Convert.ToInt32(aColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);

                UltraGridRow phColorRow = aPlaceHolderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                while (phColorRow != null)
                {
                    if (removedRID == Convert.ToInt32(phColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture))
                    {
                        phChildQty = Convert.ToInt32(phColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
                        if (removedQty == phChildQty)
                        {
                            if (phColorRow.HasChild())
                            {
                                UltraGridRow sizeRow = phColorRow.GetChild(ChildRow.First);
                                string bandKey = sizeRow.Band.Key;
                                if (!_deletedAsrtBands.Contains(bandKey))
                                {
                                    _deletedAsrtBands.Add(bandKey);
                                }
                                while (sizeRow != null)
                                {
                                    if (RemoveComponentFromProfile(sizeRow))
                                    {
                                        sizeRow.Delete(false);
                                    }
                                    else
                                    {
                                        removeOK = false;
                                        break;
                                    }
                                    sizeRow = sizeRow.GetSibling(SiblingRow.Next, false, false);
                                }
                            }
                            if (RemoveComponentFromProfile(phColorRow))
                            {
                                phColorRow.Delete(false);
                            }
                            else
                            {
                                removeOK = false;
                                break;
                            }
                        }
                        else
                        {
							//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                            //int calcQty;
                            //calcQty = phChildQty + removedQty;
                            //phColorRow.Cells["Quantity"].Value = calcQty >= 0 ? calcQty : 0;
							//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                            if (phColorRow.HasChild() && aColorRow.HasChild())
                            {
                                RemoveBulkSizes(phColorRow, aColorRow);
                            }
                        }
                        break;
                    }
                    phColorRow = phColorRow.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
            return removeOK;
        }

        private void RemoveBulkSizes(UltraGridRow aPhColorRow, UltraGridRow aRemovedColorRow)
        {
            string colName, sizetableName = string.Empty;
            int phHdrRID, removeQty, phQty, removedSizeKey, phSizeKey;
            int removedHdrRID, removedColorRID, removedPrimaryRID;
            try
            {
                Hashtable deleteColumns = new Hashtable();
                Hashtable deleteRows = new Hashtable();
                phHdrRID = Convert.ToInt32(aPhColorRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                removedHdrRID = Convert.ToInt32(aRemovedColorRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                removedColorRID = Convert.ToInt32(aRemovedColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                UltraGridRow removedSizeRow = aRemovedColorRow.GetChild(ChildRow.First);
                while (removedSizeRow != null)
                {
                    UltraGridRow phSizeRow = aPhColorRow.GetChild(ChildRow.First);
                    sizetableName = phSizeRow.Band.Key;
                    while (phSizeRow != null)
                    {
                        string asrtRowHeader = phSizeRow.Cells["Secondary"].Value.ToString();
                        string removeRowHeader = removedSizeRow.Cells["Secondary"].Value.ToString();
                        int phRowSecondaryRID = Convert.ToInt32(phSizeRow.Cells["SecondaryRID"].Value, CultureInfo.CurrentUICulture);
                        int removedRowSecondaryRID = Convert.ToInt32(removedSizeRow.Cells["SecondaryRID"].Value, CultureInfo.CurrentUICulture);
                        if (phRowSecondaryRID == removedRowSecondaryRID)
                        {
                            for (int i = 7; i < removedSizeRow.Cells.Count; i++)
                            {
                                colName = removedSizeRow.Cells[i].Column.Key.Trim();
                                removedSizeKey = Convert.ToInt32(removedSizeRow.Cells[i].Tag, CultureInfo.CurrentUICulture);

                                for (int j = 7; j < phSizeRow.Cells.Count; j++)
                                {
                                    phSizeKey = Convert.ToInt32(phSizeRow.Cells[j].Tag, CultureInfo.CurrentUICulture);
                                    if (phSizeKey == removedSizeKey)
                                    {
                                        removeQty = Convert.ToInt32(removedSizeRow.Cells[i].Value, CultureInfo.CurrentUICulture);
                                        phQty = Convert.ToInt32(phSizeRow.Cells[j].Value, CultureInfo.CurrentUICulture);

                                        int calcQty = phQty + removeQty; 
                                        
                                        phSizeRow.Cells[j].Value = calcQty >= 0 ? calcQty : 0;

                                        if ((int)phSizeRow.Cells[j].Value == 0)
                                        {
                                            removedPrimaryRID = Convert.ToInt32(removedSizeRow.Cells[i].Column.Tag, CultureInfo.CurrentUICulture);
                                            string removedColumnKey = Convert.ToString(removedSizeRow.Cells[i].Column.Key, CultureInfo.CurrentUICulture);
                                            if (!ColumnStillInUse(phHdrRID, removedHdrRID, removedColorRID, removedPrimaryRID, removedColumnKey))
                                            {
                                                //sizetableName = phSizeRow.Band.Key;
                                                ArrayList deletedSizes;
                                                if (!deleteColumns.ContainsKey(removedPrimaryRID))
                                                {
                                                    deletedSizes = new ArrayList();
                                                    deletedSizes.Add(phSizeKey);
                                                    deleteColumns.Add(removedPrimaryRID, deletedSizes);
                                                }
                                                else
                                                {
                                                    deletedSizes = (ArrayList)deleteColumns[removedPrimaryRID];
                                                    deletedSizes.Add(phSizeKey);
                                                }
                                            }
                                            else
                                            {
                                                //AllocationProfile ap = GetAllocationProfile(phHdrRID);
                                                //int[] sizeKeys = ap.GetBulkColorSizeCodeRIDs(removedColorRID);
                                                //if (sizeKeys.Length > 0)
                                                //{
                                                //    for (int n = 0; n < sizeKeys.Length; n++)
                                                //    {
                                                //        if (sizeKeys[n] == phSizeKey)
                                                //        {
                                                //            ap.RemoveBulkColorSize(removedColorRID, phSizeKey);
                                                //            break;
                                                //        }
                                                //    }
                                                //}
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                            deleteRows.Add(phRowSecondaryRID, phSizeRow); 
                            break;
                        }
                        phSizeRow = phSizeRow.GetSibling(SiblingRow.Next, false, false);
                    }
                    removedSizeRow = removedSizeRow.GetSibling(SiblingRow.Next, false, false);
                }

                if (deleteColumns.Count > 0)
                {
                    AllocationProfile ap = GetAllocationProfile(phHdrRID);
                    DataTable phSizeTable = _dsDetails.Tables[sizetableName];

                    for (int k = phSizeTable.Columns.Count - 1; k >= 7; k--)
                    {
                        DataColumn dCol = phSizeTable.Columns[k];
                        int primaryRID = (int)dCol.ExtendedProperties["PrimaryRID"];
                        if (deleteColumns.ContainsKey(primaryRID))
                        {
                            int[] sizeKeys = ap.GetBulkColorSizeCodeRIDs(removedColorRID); // Assortment: Color/Size changes
                            if (sizeKeys.Length > 0)
                            {
                                ArrayList deletedSizes = (ArrayList)deleteColumns[primaryRID];
                                foreach (int sizeRID in deletedSizes)
                                {
                                    for (int i = 0; i < sizeKeys.Length; i++)
                                    {
                                        if (sizeKeys[i] == sizeRID)
                                        {
                                            ap.RemoveBulkColorSize(removedColorRID, sizeRID);
                                            break;
                                        }
                                    }
                                }
                            }
                            phSizeTable.Columns.Remove(dCol);
                        }
                    }
                }
                //if (deleteRows.Count > 0)
                //{
                //    foreach (UltraGridRow phSizeRow in deleteRows.Values)
                //    {
                //        bool qtyFound = false;
                //        for (int j = 7; j < phSizeRow.Cells.Count; j++)
                //        {
                //            if (Convert.ToInt32(phSizeRow.Cells[j].Value, CultureInfo.CurrentUICulture) > 0)
                //            {
                //                qtyFound = true;
                //                break;
                //            }
                //        }
                //        if (!qtyFound)
                //        {
                //            //int phRowSecondaryRID = Convert.ToInt32(phSizeRow.Cells["SecondaryRID"].Value, CultureInfo.CurrentUICulture);
                //            //if (Convert.ToInt32(aPhColorRow.ParentRow.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture) == Include.UndefinedSizeGroupRID)
                //            //{
                //            //    DataTable asrtSizeTable = _dsDetails.Tables[sizetableName];
                //            //    for (int k = asrtSizeTable.Rows.Count - 1; k >= 0; k--)
                //            //    {
                //            //        DataRow dRow = asrtSizeTable.Rows[k];
                //            //        if (Convert.ToInt32(dRow["SecondaryRID"], CultureInfo.CurrentUICulture) == phRowSecondaryRID)
                //            //        {
                //            //            asrtSizeTable.Rows.Remove(dRow);
                //            //            break;
                //            //        }
                //            //    }
                //            //}
                //            phSizeRow.Delete(false);
                //        }
                //    }
                //}
            }
            catch
            {
                throw;
            }
        }

        private bool ColumnStillInUse(int aPhHdrRID, int aRemovedHdrRID, int aRemovedColorRID, int aColumnSizeRID, string aColumnKey)
        {
            bool sizeColumnFound = false;
            try
            {
                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null && !sizeColumnFound)
                {
                    if (row.Cells["PlaceHolderRID"].Value !=  DBNull.Value  
                     && Convert.ToInt32(row.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == aPhHdrRID 
                     && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != aRemovedHdrRID
                     && row.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                    {
                        UltraGridRow colorRow = row.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                        while (colorRow != null && !sizeColumnFound)
                        {
                            int colorRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                            if (colorRID == aRemovedColorRID)
                            {
                                if (colorRow.HasChild())
                                {
                                    UltraGridRow sizeRow = colorRow.GetChild(ChildRow.First);
                                    for (int i = 7; i < sizeRow.Cells.Count; i++)
                                    {
                                        if ((int)sizeRow.Cells[i].Column.Tag == aColumnSizeRID)
                                        {
                                            sizeColumnFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
            return sizeColumnFound;
        }

        private bool RemoveComponentFromProfile(UltraGridRow aRow)
        {
            try
            {
                AllocationProfile ap;
                UltraGridRow sizeRow = null;

                string deleteMessage = MIDText.GetTextOnly(eMIDTextCode.msg_as_PlaceholderChangeInvalid);
                string packName, colorName;
                int bulkColorCodeRID, packColorCodeRID, headerRID;
                int[] sizeKeys;

                headerRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                ap = GetAllocationProfile(headerRID);
                if (ap == null)
                {
                    return true;
                }

                UltraGridRow headerRow = aRow;
                while (headerRow.Band.Key != "Header")
                {
                    headerRow = headerRow.ParentRow;
                }

                string bandKey = aRow.Band.Key;
                string[] bandKeyParts = aRow.Band.Key.Split(new char[] { '~' });

                if ((bandKeyParts[0] != "Header") && !AllowPlaceholderUpdate(headerRow))
                {
                    MessageBox.Show(deleteMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return false;
                }

                switch (bandKeyParts[0])
                {
                    case "Pack":
                     
                        packName = aRow.Cells["Pack"].Value.ToString().Trim();
                        if (packName != string.Empty)
                        {
                            ap.RemovePack(packName);
                        }
                        CalculateBalancesFromDelete(aRow);
                        break;

                    case "PackColor":
                         
                        packName = aRow.ParentRow.Cells["Pack"].Value.ToString().Trim();
                        colorName = aRow.Cells["PackColor"].Value.ToString().Trim();
                        if (colorName != string.Empty && aRow.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                        {
                            packColorCodeRID = Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                            ap.RemovePackColor(packName, packColorCodeRID);
                            CalculateBalancesFromDelete(aRow);
                        }
                        break;
                 
                    case "BulkColor":

                        colorName = aRow.Cells["BulkColor"].Value.ToString().Trim();
                        if (colorName != string.Empty && aRow.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                        {
                            bulkColorCodeRID = Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                            ap.RemoveBulkColor(bulkColorCodeRID);
                        }
                        CalculateBalancesFromDelete(aRow);
                        break;

                    case "BulkSize":

                        bulkColorCodeRID = Convert.ToInt32(aRow.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                        sizeKeys = ap.GetBulkColorSizeCodeRIDs(bulkColorCodeRID);
                        for (int i = 0; i < sizeKeys.Length; i++)
                        {
                            ap.RemoveBulkColorSize(bulkColorCodeRID, sizeKeys[i]);
                        }

                        sizeRow = aRow.ParentRow.GetChild(ChildRow.First);
                        while (sizeRow != null)
                        {
                            CalculateBalancesFromDelete(sizeRow);
                            sizeRow = sizeRow.GetSibling(Infragistics.Win.UltraWinGrid.SiblingRow.Next, true, false);
                        }

                        break;

                    case "PackColorSize":


                        packName = aRow.ParentRow.ParentRow.Cells["Pack"].Value.ToString();
                        packColorCodeRID = Convert.ToInt32(aRow.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                        sizeKeys = ap.GetPackColorSizeKeys(packName, packColorCodeRID);
                        for (int i = 0; i < sizeKeys.Length; i++)
                        {
                            ap.RemovePackColorSize(packName, packColorCodeRID, sizeKeys[i]);
                        }

                        sizeRow = aRow.ParentRow.GetChild(ChildRow.First);
                        while (sizeRow != null)
                        {
                            CalculateBalancesFromDelete(sizeRow);
                            sizeRow = sizeRow.GetSibling(Infragistics.Win.UltraWinGrid.SiblingRow.Next, true, false);
                        }

                        _skipBeforeCellUpdate = true;
                        break;

                    case "PackSize":

                        packName = aRow.ParentRow.Cells["Pack"].Value.ToString();
                        packColorCodeRID = Include.DummyColorRID;

                        sizeKeys = ap.GetPackColorSizeKeys(packName, packColorCodeRID);
                        for (int i = 0; i < sizeKeys.Length; i++)
                        {
                            ap.RemovePackColorSize(packName, packColorCodeRID, sizeKeys[i]);
                        }

                        ap.RemovePackColor(packName, packColorCodeRID);

                        sizeRow = aRow.ParentRow.GetChild(ChildRow.First);
                        while (sizeRow != null)
                        {
                            CalculateBalancesFromDelete(sizeRow);
                            sizeRow = sizeRow.GetSibling(Infragistics.Win.UltraWinGrid.SiblingRow.Next, true, false);
                        }
                        break;
                }
            }
            catch
            {
                throw;
            }
            return true;
        }
     
        #endregion

        #region ugDetails Grid Events & Methods
        private void ugDetails_InitializeLayout(object sender, Infragistics.Win.UltraWinGrid.InitializeLayoutEventArgs e)
        {
            // Begin TT#984 - MD - stodd - save content grid format - 
            // check for saved layout
            InfragisticsLayoutData layoutData = new InfragisticsLayoutData();
            InfragisticsLayout layout = null;

            if (IsGroupAllocation)
            {
                layout = layoutData.InfragisticsLayout_Read(SAB.ClientServerSession.UserRID, eLayoutID.groupAllocationReviewContent);
            }
            else
            {
                layout = layoutData.InfragisticsLayout_Read(SAB.ClientServerSession.UserRID, eLayoutID.assortmentReviewContent);
            }

            string msg = string.Empty;
            if (layout.LayoutLength > 0 && !CreateAndAddHeaders)
            {
                // Begin TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                msg = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_LoadingSavedLayout);
                msg = msg.Replace("{0}", ProcessName);
                msg = msg.Replace("{1}", GroupName);
                //SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Information, "Group Allocation: " + GroupName + ", Loading saved Infragistics Layout.", this.GetType().Name, true);
                SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Debug, msg, this.GetType().Name);
                // End TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                ugDetails.DisplayLayout.Load(layout.LayoutStream);
                // Begin TT#996 - md - stodd - GA Size component has column headings that appear to be Database Names - 
                // If a grid is saved without size rows and then a different grid is opened with size rows,
                // the size rows are not formatted.
                FormatSizeRows(e);
                AssignValueLists(ugDetails);
                // End TT#996 - md - stodd - GA Size component has column headings that appear to be Database Names - 
            }
            else
            {	// DEFAULT grid layout
                // Begin TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
				//BEGIN TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                //msg = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_LoadingDefaultLayout);
                msg = MIDText.GetTextOnly(eMIDTextCode.msg_as_LoadingDefaultLayout);
				//END TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                msg = msg.Replace("{0}", ProcessName);
                msg = msg.Replace("{1}", GroupName);
                //SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Information, "Group Allocation: " + GroupName + ", Loading default Infragistics Layout.", this.GetType().Name, true);
                SAB.ApplicationServerSession.Audit.Add_Msg(eMIDMessageLevel.Debug, msg, this.GetType().Name);
                // End TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                MIDRetail.Windows.Controls.UltraGridLayoutDefaults ugld = new MIDRetail.Windows.Controls.UltraGridLayoutDefaults(ErrorImage);
                ugld.ApplyDefaults(e, false);
                DefaultGridLayout(e);
            }
            // End TT#984 - MD - stodd - save content grid format - 

            // Begin TT#3823 - RMatelic - GA Header selection is confusing
            ugDetails.DisplayLayout.Override.CellClickAction = Infragistics.Win.UltraWinGrid.CellClickAction.RowSelect;
            ugDetails.DisplayLayout.Grid.DrawFilter = new NoFocusRect();
            // End TT#3823
        }

		
        private void DefaultGridLayout(Infragistics.Win.UltraWinGrid.InitializeLayoutEventArgs e)
        {
            try
            {
                _assortmentGroups.Clear();
		// End TT#984 - MD - stodd - save content grid format - 
                //e.Layout.Override.RowSelectorHeaderStyle = RowSelectorHeaderStyle.None;
                e.Layout.MaxRowScrollRegions = 1;
                e.Layout.Override.RowAlternateAppearance.BackColor = Color.Snow; //.BlanchedAlmond;
                e.Layout.UseFixedHeaders = true;
                e.Layout.Override.FixedHeaderIndicator = FixedHeaderIndicator.None;
                e.Layout.Override.FixedCellAppearance.BackColor = Color.LightYellow;
                e.Layout.Override.HeaderClickAction = HeaderClickAction.SortMulti;
                e.Layout.ScrollStyle = ScrollStyle.Immediate;
                e.Layout.Override.AllowColSizing = AllowColSizing.Free;
                FormatColumns(ugDetails);

                foreach (UltraGridBand band in e.Layout.Bands)
                {
                    band.Override.ExpansionIndicator = Infragistics.Win.UltraWinGrid.ShowExpansionIndicator.CheckOnDisplay;
                    band.Columns["KeyH"].Hidden = true;
                    band.Columns["KeyP"].Hidden = true;
                    band.Columns["KeyC"].Hidden = true;

                    string[] bandKeyParts = band.Key.Split(new char[] { '~' });

                    switch (bandKeyParts[0])
                    {
                        case "Header":
                            InitializeHeaderLayout(band);
                            break;

                        case "BulkColor":
                            InitializeBulkColorLayout(band);
                            break;

                        case "Pack":
                            InitializePackLayout(band);
                            break;

                        case "PackColor":
                            InitializePackColorLayout(band);
                            break;

                        case "PackSize":
                        case "PackColorSize":
                        case "BulkSize":
                            InitializeSizeLayout(band);
                            break;
                    }
                }

                //ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                //foreach (UltraGridRow row in ugDetails.Rows)
                //{
                //    SetRowActivation(row, Activation.NoEdit);
                //    row.Selected = true;
                //}
                //ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		// Begin TT#996 - md - stodd - GA Size component has column headings that appear to be Database Names - 
        private void FormatSizeRows(Infragistics.Win.UltraWinGrid.InitializeLayoutEventArgs e)
        {
            foreach (UltraGridBand band in e.Layout.Bands)
            {
                string[] bandKeyParts = band.Key.Split(new char[] { '~' });

                switch (bandKeyParts[0])
                {
                    //case "Header":
                    //    InitializeHeaderLayout(band);
                    //    break;

                    //case "BulkColor":
                    //    InitializeBulkColorLayout(band);
                    //    break;

                    //case "Pack":
                    //    InitializePackLayout(band);
                    //    break;

                    //case "PackColor":
                    //    InitializePackColorLayout(band);
                    //    break;

                    case "PackSize":
                    case "PackColorSize":
                    case "BulkSize":
                        InitializeSizeLayout(band);
                        break;
                }
            }
        }
		// End TT#996 - md - stodd - GA Size component has column headings that appear to be Database Names - 
		
        private void FormatColumns(Infragistics.Win.UltraWinGrid.UltraGrid ultragrid)
        {
            try
            {
                foreach (Infragistics.Win.UltraWinGrid.UltraGridBand band in ultragrid.DisplayLayout.Bands)
                {
                    foreach (Infragistics.Win.UltraWinGrid.UltraGridColumn column in band.Columns)
                    {
                        switch (column.DataType.ToString())
                        {
                            case "System.Int32":
                                column.CellAppearance.TextHAlign = Infragistics.Win.HAlign.Right;
                                column.Format = "#,###,##0";
                                break;
                            case "System.Double":
                                column.CellAppearance.TextHAlign = Infragistics.Win.HAlign.Right;
                                column.Format = "#,###,###.00";
                                break;
                        }
                    }

                    switch (band.Key)
                    {
                        case "Header":
                            band.Columns["HdrGroupRID"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["AsrtRID"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["PlaceHolderRID"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["Type"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["Status"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["SizeGroup"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["Intransit"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["ShipStatus"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;

                            foreach (HeaderCharGroupProfile hcgp in _headerCharGroupProfileList)
                            {
                                band.Columns[hcgp.ID].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            }
                            break;

                        case "Pack":
                            band.Columns["PackType"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            break;

                        default:
                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void InitializeHeaderLayout(UltraGridBand band)
        {
            try
            {
                band.Override.RowSelectorHeaderStyle = RowSelectorHeaderStyle.ColumnChooserButton;
                band.Columns["KeyH"].Hidden = true;
                band.Columns["KeyP"].Hidden = true;
                band.Columns["KeyC"].Hidden = true;
                band.Columns["HdrGroupRID"].Hidden = true;
                //band.Columns["PlaceHolderRID"].Hidden = true;
                band.Columns["FunctionSecurity"].Hidden = true;
                band.Columns["StyleSecurity"].Hidden = true;
                band.Columns["Notes"].Hidden = true;
                band.Columns["Interfaced"].Hidden = true;
                band.Columns["AnchorHnRID"].Hidden = true;
                band.Columns["ProductRID"].Hidden = true;
                band.Columns["StyleHnRID"].Hidden = true;
                band.Columns["ChildTotal"].Hidden = true;
                band.Columns["MultiSortSeq"].Hidden = true;
                band.Columns["AsrtType"].Hidden = true;
				band.Columns["AsrtPlaceholderSortSeq"].Hidden = true;	// TT#1227 - stodd
				band.Columns["AsrtHeaderSortSeq"].Hidden = true;	    // TT#1227 - RMatelic
                band.Columns["CharUpdated"].Hidden = true;
                band.Columns["HdrGroupRID"].Hidden = true;
                band.Columns["AsrtRIDSortCol"].Hidden = true;
                band.Columns["PlaceHolderRIDSortCol"].Hidden = true;
				// BEGIN TT#775-MD - Stodd - Header ID field is populated with Placeholder ID when selected
				band.Columns["HeaderID"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
				// END TT#775-MD - Stodd - Header ID field is populated with Placeholder ID when selected
				// Begin TT#984 - MD - stodd - save content grid format - 
                band.Columns["AnchorNode"].Hidden = true;
                band.Columns["PlaceHolderRID"].Hidden = true;
				// End TT#984 - MD - stodd - save content grid format - 

                if (!this._sab.ClientServerSession.GlobalOptions.AppConfig.MasterAllocationInstalled)
                {
                    band.Columns["Master"].Hidden = true;
                    //band.Columns["AllocatedUnits"].Hidden = true;
                    band.Columns["OrigAllocatedUnits"].Hidden = true;
                    band.Columns["RsvAllocatedUnits"].Hidden = true;
                    band.Columns["Master"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                    //band.Columns["AllocatedUnits"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                    band.Columns["OrigAllocatedUnits"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                    band.Columns["RsvAllocatedUnits"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                }
                //if (!_sab.ClientServerSession.GlobalOptions.AppConfig.AssortmentInstalled)
                //{
                //    band.Columns["AsrtRID"].Hidden = true;
                //    band.Columns["AnchorNode"].Hidden = true;
                //    band.Columns["AsrtRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                //    band.Columns["AnchorNode"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                //}

                if (!_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                {
                    band.Columns["SizeGroup"].Hidden = true;
                    band.Columns["SizeGroup"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                }

                band.Columns["FirstHeaderInd"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;	// TT#1130 - md - stodd - mark first header - 
                band.Columns["KeyH"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["KeyP"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["KeyC"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; ;
                band.Columns["FunctionSecurity"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["HeaderID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["PlaceHolderRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["StyleSecurity"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["Notes"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;

                band.Columns["Status"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["Style"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["HdrQuantity"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;

                band.Columns["Interfaced"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["AnchorHnRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["ProductRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["StyleHnRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["ChildTotal"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["MultiSortSeq"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["AsrtType"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
				band.Columns["AsrtPlaceholderSortSeq"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;	// TT#1227 - stodd
                band.Columns["AsrtHeaderSortSeq"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;	        // TT#1227 - RMatelic
                band.Columns["CharUpdated"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["HdrGroupRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;

                band.Columns["AsrtRIDSortCol"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;	 
                band.Columns["PlaceHolderRIDSortCol"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.Columns["AnchorNode"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;		// TT#984 - MD - stodd - save content grid format -  

               
                //display Balance column
                band.Columns["Balance"].Hidden = false;
                band.Columns["HeaderID"].Header.Fixed = true;
                band.Columns["HeaderID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                band.Columns["HeaderID"].ButtonDisplayStyle = Infragistics.Win.UltraWinGrid.ButtonDisplayStyle.Always;
                //band.Columns["HeaderID"].MaxLength = 32;
                band.Columns["HeaderID"].AutoSizeEdit = DefaultableBoolean.True;

                band.Columns["HeaderID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_HeaderID);
                band.Columns["HdrGroupRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_MultiHeaderID);
				if (IsGroupAllocation)
				{
					// Begin TT#934 - MD - Correct GA Columns
                	//band.Columns["AsrtRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AssortmentID);
                	band.Columns["AsrtRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_GroupAllocationID);
                	band.Columns["PlaceHolderRID"].Hidden = true;
                	// Begin TT#934 - MD - Correct GA Columns
				}
				else
				{
	                band.Columns["AsrtRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AssortmentID);
				}
				// Begin TT#1130 - md - stodd - mark first header - 
                band.Columns["FirstHeaderInd"].Header.Caption = "";
                band.Columns["FirstHeaderInd"].Width = 5;
                band.Columns["FirstHeaderInd"].Header.VisiblePosition = 1;
				// End TT#1130 - md - stodd - mark first header - 
                band.Columns["PlaceHolderRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_PlaceholderID);
                band.Columns["Type"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Type);
                band.Columns["Date"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Date);
                band.Columns["Status"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_HeaderStatus);
                //band.Columns["AnchorNode"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AnchorNode);
                band.Columns["AnchorNode"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ApplyTo);
                band.Columns["Product"].Header.Caption = _hlpProduct.LevelID;
                band.Columns["Style"].Header.Caption = _hlpStyle.LevelID;
                band.Columns["Description"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_WorkspaceDescription);
                band.Columns["HdrQuantity"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Quantity);
                band.Columns["Balance"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Balance);
                band.Columns["UnitRetail"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_UnitRetail);
                band.Columns["UnitCost"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_UnitCost);
                band.Columns["SizeGroup"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_SizeGroup);
                band.Columns["Multiple"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Multiple);
                band.Columns["PO"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_PurchaseOrder);
                band.Columns["Vendor"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Vendor);
                band.Columns["Workflow"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Workflow);
                band.Columns["APIWorkflow"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_APIWorkflow);
                band.Columns["DC"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_DistCenter);
                band.Columns["Intransit"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Intransit);
                band.Columns["ShipStatus"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ShipStatus);
                band.Columns["Release"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Release);
                band.Columns["ChildTotal"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ChildTotal);
                band.Columns["Master"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_MasterSubord);
                band.Columns["AllocatedUnits"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AllocatedUnits);
                band.Columns["OrigAllocatedUnits"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_OrigAllocatedUnits);
                band.Columns["RsvAllocatedUnits"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_RsvAllocatedUnits);

                //band.Columns["HeaderID"].Width = 150;
                //band.Columns["HdrGroupRID"].Width = 150;

                //===================================================================================================
                // NOTE: The CellActivation for the column (below) is overriden by the SetEditActivation() method.
                //===================================================================================================
                band.Columns["HdrGroupRID"].CellActivation = Activation.NoEdit;
                band.Columns["AsrtRID"].CellActivation = Activation.NoEdit;
                band.Columns["PlaceHolderRID"].CellActivation = Activation.NoEdit;
                band.Columns["Status"].CellActivation = Activation.NoEdit;	// TT#1079 - md - stodd - status not updating - 
                band.Columns["Intransit"].CellActivation = Activation.Disabled;
                band.Columns["ShipStatus"].CellActivation = Activation.Disabled;
                band.Columns["Release"].CellActivation = Activation.Disabled;
                band.Columns["Interfaced"].CellActivation = Activation.Disabled;
                //band.Columns["Workflow"].CellActivation = Activation.Disabled;
                band.Columns["APIWorkflow"].CellActivation = Activation.Disabled;
                band.Columns["Balance"].CellActivation = Activation.Disabled;
                band.Columns["Notes"].CellActivation = Activation.NoEdit;

                if (this._sab.ClientServerSession.GlobalOptions.AppConfig.MasterAllocationInstalled)
                {
                    band.Columns["Master"].CellActivation = Activation.Disabled;
                    //band.Columns["AllocatedUnits"].CellActivation = Activation.Disabled;
                    band.Columns["OrigAllocatedUnits"].CellActivation = Activation.Disabled;
                    band.Columns["RsvAllocatedUnits"].CellActivation = Activation.Disabled;
                }
                band.Columns["HdrQuantity"].CellActivation = Activation.NoEdit;
                band.Columns["AllocatedUnits"].CellActivation = Activation.NoEdit;
                band.Columns["Type"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                band.Columns["SizeGroup"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                band.Columns["HdrGroupRID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;

                AssignValueLists(ugDetails);

                band.Columns["AsrtRID"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
                band.Columns["PlaceHolderRID"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);

                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    row.Activation = Activation.ActivateOnly;
                }
				// Begin TT#1227 - stodd - add seq numbers
                // Begin TT#2 - RMatelic - Assortment Planning - re-add the AsrtRID and PlaceHoldeeRID so auto-add post receipt placeholders are in correct order
                band.SortedColumns.Clear();
                //band.SortedColumns.Add("AsrtRID", false);
                //band.SortedColumns.Add("PlaceHolderRID", false);
                band.SortedColumns.Add("AsrtRIDSortCol", false);
                band.SortedColumns.Add("PlaceHolderRIDSortCol", false);	
                // End TT#2
				band.SortedColumns.Add("AsrtPlaceholderSortSeq", false);	// TT#1227 - stodd
				band.SortedColumns.Add("AsrtHeaderSortSeq", false);		
                //band.SortedColumns.Add("PlaceHolderRID", false);
				// End TT#1227 - stodd - add seq numbers
          
            }         
            catch
            {
                throw;
            }
        }

        private void AssignValueLists(UltraGrid aGrid)
        {
            try
            {
                aGrid.DisplayLayout.ResetValueLists();

                // Assortment
                aGrid.DisplayLayout.ValueLists.Add(_assortmentValueList);
                aGrid.DisplayLayout.Bands[0].Columns["AsrtRID"].ValueList = _assortmentValueList;

                // PlaceHolder
                aGrid.DisplayLayout.ValueLists.Add(_placeHolderValueList);
                aGrid.DisplayLayout.Bands[0].Columns["PlaceHolderRID"].ValueList = _placeHolderValueList;

                // Header Type 
                aGrid.DisplayLayout.ValueLists.Add(_headerTypeValueList);
                aGrid.DisplayLayout.Bands[0].Columns["Type"].ValueList = _headerTypeValueList;

                // Header Status
                aGrid.DisplayLayout.ValueLists.Add(_headerStatusValueList);
                aGrid.DisplayLayout.Bands[0].Columns["Status"].ValueList = _headerStatusValueList;

                // Size Group
                if (_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                {
                    aGrid.DisplayLayout.ValueLists.Add(_sizeGroupValueList);
                    aGrid.DisplayLayout.Bands[0].Columns["SizeGroup"].ValueList = _sizeGroupValueList;
                }

                // Header Intransit
                aGrid.DisplayLayout.ValueLists.Add(_headerIntransitValueList);
                aGrid.DisplayLayout.Bands[0].Columns["Intransit"].ValueList = _headerIntransitValueList;

                // Header Ship Status
                aGrid.DisplayLayout.ValueLists.Add(_headerShipStatusValueList);
                aGrid.DisplayLayout.Bands[0].Columns["ShipStatus"].ValueList = _headerShipStatusValueList;

                // Header Characteristics
                if (_charValueListsHash.Count > 0)
                {
                    foreach (string groupID in _charValueListsHash.Keys)
                    {
                        ValueList valueList = (ValueList)_charValueListsHash[groupID];
                        aGrid.DisplayLayout.ValueLists.Add(valueList);
                        aGrid.DisplayLayout.Bands[0].Columns[groupID].ValueList = valueList;
                        aGrid.DisplayLayout.Bands[0].Columns[groupID].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                    }
                }

                foreach (HeaderCharGroupProfile hcgp in _headerCharGroupProfileList)
                {
                    aGrid.DisplayLayout.Bands[0].Columns[hcgp.ID].Tag = hcgp;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetNotesCellButton(UltraGridRow aRow, bool bAllowUpdate)
        {
            try
            {
                string notes = Convert.ToString(aRow.Cells["Notes"].Value, CultureInfo.CurrentUICulture);
                if (notes != null && notes.Trim() != string.Empty)
                {    
                    aRow.Cells["HeaderID"].ButtonAppearance.Image = _eab.AllocationWorkspaceExplorer.NotesImage; //  MIDGraphics.NotesImage;
                }
                else if (bAllowUpdate)
                {
                    aRow.Cells["HeaderID"].ButtonAppearance.Image = null;
                }
                else
                {   // change the cell style so the edit button doesn't show
                    aRow.Cells["HeaderID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.Edit;
                }
            }
            catch
            {
                throw;
            }
        }

        private void InitializeBulkColorLayout(UltraGridBand band)
        {
            try
            {
                band.ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.SortedColumns.Add("Sequence", false);
                band.Columns["Sequence"].Hidden = true;
                band.Columns["ColorCodeRID"].Hidden = true;
                band.Columns["Name"].Hidden = true;
                band.Columns["AsrtBCRID"].Hidden = true;
                band.Columns["ChildTotal"].Hidden = true;
                band.Columns["IsNewColor"].Hidden = true;
                band.Columns["IsVirtual"].Hidden = true;
                if (!_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                {
                    band.Columns["Balance"].Hidden = true;
                }
                else
                {
                    band.Columns["Balance"].CellActivation = Activation.Disabled;
                }
                band.Columns["Quantity"].CellActivation = Activation.NoEdit;
                foreach (UltraGridColumn col in band.Columns)
                {
                    if (!col.Hidden)
                    {
                        col.PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void InitializePackLayout(UltraGridBand band)
        {
            try
            {
                band.ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.SortedColumns.Add("Sequence", false);
                band.Columns["Sequence"].Hidden = true;
                band.Columns["ChildTotal"].Hidden = true;
                band.Columns["AssociatedPackRID"].Hidden = true;
                band.Columns["TotalQuantity"].CellActivation = Activation.Disabled;
                band.Columns["Balance"].CellActivation = Activation.Disabled;

                band.Layout.ValueLists.Add("PackType");
                band.Columns["PackType"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                band.Columns["PackType"].ValueList = _packTypeValueList;
                band.Columns["TotalPacks"].CellActivation = Activation.NoEdit;        // always disallow quantity change
                band.Columns["QuantityPerPack"].CellActivation = Activation.NoEdit;
                foreach (UltraGridColumn col in band.Columns)
                {
                    if (!col.Hidden)
                    {
                        col.PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
                    }
                }
            }

            catch
            {
                throw;
            }
        }

        private void InitializePackColorLayout(UltraGridBand band)
        {
            try
            {
                band.ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                band.SortedColumns.Add("Sequence", false);
                band.Columns["Sequence"].Hidden = true;
                band.Columns["Name"].Hidden = true;
                band.Columns["ColorCodeRID"].Hidden = true;
                band.Columns["ChildTotal"].Hidden = true;
                band.Columns["IsNewColor"].Hidden = true;
                band.Columns["IsVirtual"].Hidden = true;
                if (!_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                {
                    band.Columns["Balance"].Hidden = true;
                }
                else
                {
                    band.Columns["Balance"].CellActivation = Activation.Disabled;
                }
                band.Columns["QuantityPerPack"].CellActivation = Activation.NoEdit;
                foreach (UltraGridColumn col in band.Columns)
                {
                    if (!col.Hidden)
                    {
                        col.PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
                    }
                }
            }

            catch
            {
                throw;
            }
        }

        private void InitializeSizeLayout(UltraGridBand band)
        {
            try
            {   //TODO if a header with sizes is added, deleted and readded, this code
                // is executing with the color band columns and not the size band columns???
                // so 'if...' was added as work around; shouldn't need it  
                band.ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                if (band.Columns.Exists("Secondary"))
                {
                    band.Columns["SecondaryRID"].Hidden = true;
                    band.Columns["Secondary"].Hidden = true;
                }
				// Begin TT#996 - md - stodd - GA Size component has column headings that appear to be Database Names - 
                band.Columns["KeyH"].Hidden = true;
                band.Columns["KeyP"].Hidden = true;
                band.Columns["KeyC"].Hidden = true;
				// End TT#996 - md - stodd - GA Size component has column headings that appear to be Database Names - 
                band.Columns[" - "].CellActivation = Activation.NoEdit;
                band.Columns["TotalQuantity"].CellActivation = Activation.Disabled;
                IEnumerable enumerator = band.GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow sizeRow in enumerator)
                {
                    SetCellSizeKey(sizeRow);
                }
            }

            catch
            {
                throw;
            }
        }

        private void SetRowActivation(UltraGridRow aRow, Activation aActivation)
        {
            try
            {
                if (aRow.Band.Key.StartsWith("BulkSize") ||
                    aRow.Band.Key.StartsWith("PackSize") ||
                    aRow.Band.Key.StartsWith("PackColorSize"))
                {
                    SetCellSizeKey(aRow);
                }

                aRow.Activation = aActivation;

                if (aRow.HasChild(false))
                {
                    UltraGridRow cRow = aRow.GetChild(ChildRow.First);
                    while (cRow != null)
                    {
                        SetRowActivation(cRow, aActivation);
                        cRow = cRow.GetSibling(SiblingRow.Next, true, false);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetCellSizeKey(UltraGridRow aRow)
        {
            try
            {
				// Begin TT#996 - md - stodd - GA Size component has column headings that appear to be Database Names - 
                aRow.Cells[" - "].Activation = Activation.NoEdit;
                aRow.Cells["TotalQuantity"].Activation = Activation.NoEdit;
				// End TT#996 - md - stodd - GA Size component has column headings that appear to be Database Names - 
                string primary, secondary;
                int sizeKey, primaryRID; // primaryRID is the RID for the Size Column 

                if (aRow.ListObject != null)
                {
                    DataRowView drv = (DataRowView)aRow.ListObject;
                    secondary = Convert.ToString(drv.Row["Secondary"], CultureInfo.CurrentUICulture);
                    int secondaryRID = Convert.ToInt32(drv.Row["SecondaryRID"], CultureInfo.CurrentUICulture);
                    aRow.Cells["Secondary"].Tag = secondaryRID;
                    for (int c = 7; c < drv.DataView.Table.Columns.Count; c++)
                    {
                        DataColumn dCol = drv.DataView.Table.Columns[c];
                        primary = dCol.ColumnName;
                        primaryRID = Convert.ToInt32(dCol.ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                        sizeKey = Convert.ToInt32(dCol.ExtendedProperties[primary + "~" + secondaryRID], CultureInfo.CurrentUICulture);
                        aRow.Cells[primary].Tag = sizeKey;
                        if (aRow.Cells[primary].Column.Tag == null)
                        {
                            aRow.Cells[primary].Column.Tag = primaryRID;
                        }
                        aRow.Cells[primary].Column.CellActivation = Activation.Disabled; //TT#651 - MD - DOConnell - Protect the size quantity fields on a placeholder so they cannot be entered.
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            try
            {
                UltraGridCell mouseCell;
                Infragistics.Win.UIElement mouseUIElement;
                Infragistics.Win.UIElement headerUIElement;
                HeaderUIElement headerUI = null;
                Point point = new Point(e.X, e.Y);

                UltraGrid grid = (UltraGrid)sender;
                _rClickGrid = grid;
                
                mouseUIElement = ugDetails.DisplayLayout.UIElement.ElementFromPoint(point);

                if (mouseUIElement == null)
                {
                    return;
                }

                if (e.Button == MouseButtons.Right)
                {
                    // retrieve the UIElement from the location of the mouse� 

                    headerUIElement = mouseUIElement.GetAncestor(typeof(HeaderUIElement));
                    if (null == headerUIElement)
                    {
                        // retrieve the Cell from the UIElement 
                        mouseCell = (Infragistics.Win.UltraWinGrid.UltraGridCell)mouseUIElement.GetContext(typeof(Infragistics.Win.UltraWinGrid.UltraGridCell));

                        // if there is a cell object reference, set to active cell and edit
                        if (mouseCell != null)
                        {
                            _gridCol = mouseCell.Column;
                            _gridBand = mouseCell.Band;
                        }
                    }
                    else if (headerUIElement.GetType() == typeof(HeaderUIElement))
                    {
                        headerUI = (HeaderUIElement)headerUIElement;
                        Infragistics.Win.UltraWinGrid.ColumnHeader colHeader = null;
                        _gridCol = null;
                        colHeader = (Infragistics.Win.UltraWinGrid.ColumnHeader)headerUI.SelectableItem;
                        _gridCol = colHeader.Column;
                        if (_gridCol == null)
                        {
                            return;
                        }
                        _gridBand = colHeader.Band;
                    }
                }
                _rClickRow = (UltraGridRow)mouseUIElement.GetContext(typeof(UltraGridRow));
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		private void ugDetails_MouseUp(object sender, MouseEventArgs e)
		{

		}

        private void ugDetails_BeforeColumnChooserDisplayed(object sender, Infragistics.Win.UltraWinGrid.BeforeColumnChooserDisplayedEventArgs e)
        {
            try
            {
                e.Dialog.Text = _lblColumnChooser;
                e.Dialog.ColumnChooserControl.ColumnDisplayOrder = ColumnDisplayOrder.SameAsGrid;
                e.Dialog.ColumnChooserControl.MultipleBandSupport = MultipleBandSupport.SingleBandOnly; // "Header" band only
                e.Dialog.ColumnChooserControl.Style = ColumnChooserStyle.AllColumnsWithCheckBoxes;      // this setting eliminates a "Header" caption at the top
                e.Dialog.ColumnChooserControl.ContextMenuStrip = cmsContentColChooser;
                e.Dialog.DisposeOnClose = DefaultableBoolean.True; // this causes the Chooser to match the grid order on subsequent opens

                UltraGrid grid = (UltraGrid)sender;
                grid.BeginInvoke(new PositionColumnChooserDialogDelegate(this.PositionColumnChooserDialog), new object[] { e.Dialog, grid });  
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
       
        public delegate void PositionColumnChooserDialogDelegate(ColumnChooserDialog dialog, UltraGrid grid);
        private void PositionColumnChooserDialog(ColumnChooserDialog dialog, UltraGrid grid) 
        {
            try
            {
                dialog.Location = grid.PointToScreen(grid.Location);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_BeforeRowsDeleted(object sender, BeforeRowsDeletedEventArgs e)
        {
            e.DisplayPromptMsg = false;
            string bandKey, message;
            string[] bandKeyParts;
            try
            {
                //if (_replacingSizes || _removingAssortment)
                if (_replacingSizes)
                {
                    e.Cancel = true;
                    return;
                }

                if (_deleteKeyPressed)
                {
                    _deleteKeyPressed = false;
                    if (!HeaderMaintainable(_rClickRow))
                    {
                        e.Cancel = true;
                        return;
                    }
					//BEGIN TT#200 - MD - DOConnell - Deleting a blank color on a placeholder and then adding a new color generates a null reference exception
                    else if (!_canDeleteHeader)
                    {
                        e.Cancel = true;
                        return;
                    }
					//END TT#200 - MD - DOConnell - Deleting a blank color on a placeholder and then adding a new color generates a null reference exception
                    else
                    {
                        ugDetails.ActiveRow = _rClickRow;
                    }
                }

                if (_rClickRow == null)
                {
                    return;
                }
                bandKey = _rClickRow.Band.Key;
                bandKeyParts = bandKey.Split(new char[] { '~' });

                switch (bandKeyParts[0])
                {
                    case "BulkSize":
                    case "PackColorSize":
                    case "PackSize":
                        message = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizeRowsToBeDeleted);
                        break;

                    case "Header":
                        if (ugDetails.Selected.Rows.Count > 1 &&
                            (eHeaderType)Convert.ToInt32(_rClickRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == eHeaderType.Assortment)
                        {
                            int headerRID = Convert.ToInt32(_rClickRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            for (int i = ugDetails.Selected.Rows.Count - 1; i >= 0; i--)
                            {
                                UltraGridRow selRow = ugDetails.Selected.Rows[i];
                                if (Convert.ToInt32(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == headerRID
                                 && Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != headerRID)
                                {
                                    selRow.Selected = false;
                                }
                            }
                        }
                        message = string.Format(MIDText.GetTextOnly(eMIDTextCode.msg_DeleteRows), ugDetails.Selected.Rows.Count.ToString());
                        break;

                    default:
                        message = string.Format(MIDText.GetTextOnly(eMIDTextCode.msg_DeleteRows), ugDetails.Selected.Rows.Count.ToString());
                        break;
                }

                message += Environment.NewLine + MIDText.GetTextOnly((int)eMIDTextCode.msg_ContinueQuestion);

                DialogResult diagResult = MessageBox.Show(message, _lblDeleteRow, System.Windows.Forms.MessageBoxButtons.YesNo,
                    System.Windows.Forms.MessageBoxIcon.Question);

                if (diagResult == System.Windows.Forms.DialogResult.No)
                {
                    _rowDeleted = false; //TT#722 - MD - DOConnell - Right clicking on a header with multiple child levels that is not selected generates a Key Not found error
                    e.Cancel = true;
                    return;
                }

                _deletedPlaceholderStyles.Clear();
                _deletedAssortmentStyles.Clear();
                foreach (UltraGridRow delRow in e.Rows)
                {
                    if (!OKToDeleteRow(delRow))
                    {
                        _rowDeleted = false; //TT#722 - MD - DOConnell - Right clicking on a header with multiple child levels that is not selected generates a Key Not found error
                        e.Cancel = true;
                        return;
                    }
                }

                _rClickRow.Selected = true;
                _rowDeleted = true;
                if (_rClickRow.HasChild())
                {
                    SelectChildRows(_rClickRow);
                }

                // reset field if row deleted
                if (_rowDeleted)
                {
                    _rClickRow = null;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool OKToDeleteRow(UltraGridRow aRow)
        {
            try
            {
                AllocationProfile ap;
                UltraGridRow sizeRow = null;

                string deleteMessage = MIDText.GetTextOnly(eMIDTextCode.msg_as_PlaceholderChangeInvalid);
                string packName, colorName;
                int bulkColorCodeRID, packColorCodeRID, headerRID;
                int[] sizeKeys;

                headerRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                ap = GetAllocationProfile(headerRID);
                if (ap == null)
                {
                    return true;
                }
                
                try //TT#1227 - MD- DOConnell - Get a spread lock error when trying to remove a color from a placeholder
                {
                    ap.ResetTempLocks(false); //TT#1227 - MD- DOConnell - Get a spread lock error when trying to remove a color from a placeholder

                    UltraGridRow headerRow = aRow;
                    while (headerRow.Band.Key != "Header")
                    {
                        headerRow = headerRow.ParentRow;
                    }

                    string bandKey = aRow.Band.Key;
                    string[] bandKeyParts = aRow.Band.Key.Split(new char[] { '~' });

                    if ((bandKeyParts[0] != "Header") && !AllowPlaceholderUpdate(headerRow))
                    {
                        MessageBox.Show(deleteMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return false;
                    }


                    switch (bandKeyParts[0])
                    {
                        case "Header":
                            if (!_deletedHeaderRows.Contains(headerRID))
                            {
                                if (!ap.Placeholder)
                                {
                                    _deletedHeaderRows.Add(headerRID);
                                }

                                //if (ap.Assortment)
                                //{
                                //    if (!_deletedAssortmentStyles.ContainsKey(headerRID))
                                //    {
                                //        _deletedAssortmentStyles.Add(headerRID, ap.StyleHnRID);
                                //    }
                                //    ArrayList deletedPlaceHolders = new ArrayList();
                                //    UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                                //    while (row != null)
                                //    {
                                //        if (row.Cells["AsrtRID"].Value != DBNull.Value
                                //         && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == headerRID
                                //         && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != headerRID)
                                //        {
                                //            if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                                //            {
                                //                int phRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                                //                if (!_deletedHeaderRows.Contains(phRID))
                                //                {
                                //                    _deletedHeaderRows.Add(phRID);
                                //                }
                                //                if (!_deletedPlaceholderStyles.ContainsKey(phRID))
                                //                {
                                //                    int styleRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                //                    _deletedPlaceholderStyles.Add(phRID, styleRID);
                                //                }
                                //                if (!deletedPlaceHolders.Contains(phRID))
                                //                {
                                //                    deletedPlaceHolders.Add(phRID);
                                //                }
                                //            }
                                //            else
                                //            {
                                //                ClearChildAssortmentColumns(row);
                                //                row.Cells["AsrtRID"].Value = DBNull.Value;
                                //                row.Cells["PlaceHolderRID"].Value = DBNull.Value;
                                //                row.Cells["AsrtPlaceholderSortSeq"].Value = DBNull.Value;	// TT#1227 - stodd
                                //            }
                                //        }
                                //        row = row.GetSibling(SiblingRow.Next, false, false);
                                //    }
                                //    if (deletedPlaceHolders.Count > 0)
                                //    {
                                //        ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, false);
                                //        for (int i = 0; i < deletedPlaceHolders.Count; i++)
                                //        {
                                //            int delRID = (int)deletedPlaceHolders[i];
                                //            for (int j = ugDetails.Rows.Count - 1; j >= 0; j--)
                                //            {
                                //                UltraGridRow delRow = ugDetails.Rows[j];
                                //                if (Convert.ToInt32(delRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == delRID)
                                //                {
                                //                    delRow.Delete(false);
                                //                }
                                //            }
                                //        }
                                //        ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, true);
                                //    }
                                //}
                                if (!ap.Placeholder && ap.Key < 0 && _allocProfileList.Contains(ap.Key))
                                {
                                    _allocProfileList.Remove(ap);
                                }
                            }
                            break;

                        case "Pack":

                            packName = aRow.Cells["Pack"].Value.ToString().Trim();
                            if (packName != string.Empty)
                            {
                                ap.RemovePack(packName);
                                AddToDeletedComponentHashtable(headerRID, aRow);
                            }
                            CalculateBalancesFromDelete(aRow);
                            break;

                        case "PackColor":

                            packName = aRow.ParentRow.Cells["Pack"].Value.ToString().Trim();
                            colorName = aRow.Cells["PackColor"].Value.ToString().Trim();
                            if (colorName != string.Empty && aRow.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                            {
                                packColorCodeRID = Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                ap.RemovePackColor(packName, packColorCodeRID);
                                AddToDeletedComponentHashtable(headerRID, aRow);
                                CalculateBalancesFromDelete(aRow);
                            }
                            break;

                        case "BulkColor":

                            colorName = aRow.Cells["BulkColor"].Value.ToString().Trim();
                            if (colorName != string.Empty && aRow.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                            {
                                bulkColorCodeRID = Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                ap.SetColorUnitsAllocated(bulkColorCodeRID, 0); //TT#455 - MD - DOConnell - Although the content screen appears correct after removing a color from a placeholder, behind the scenes the placeholder allocated units has not changed.
                                ap.RemoveBulkColor(bulkColorCodeRID);
                                AddToDeletedComponentHashtable(headerRID, aRow);
                            }
                            CalculateBalancesFromDelete(aRow);
                            //BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                            //ap.TotalUnitsToAllocate = ap.TotalUnitsToAllocate - (Convert.ToInt32(aRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture)); //TT#455 - MD - DOConnell - Although the content screen appears correct after removing a color from a placeholder, behind the scenes the placeholder allocated units has not changed.
                            //END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                            break;

                        case "BulkSize":

                            bulkColorCodeRID = Convert.ToInt32(aRow.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                            sizeKeys = ap.GetBulkColorSizeCodeRIDs(bulkColorCodeRID);
                            for (int i = 0; i < sizeKeys.Length; i++)
                            {
                                ap.RemoveBulkColorSize(bulkColorCodeRID, sizeKeys[i]);
                            }

                            sizeRow = aRow.ParentRow.GetChild(ChildRow.First);
                            while (sizeRow != null)
                            {
                                CalculateBalancesFromDelete(sizeRow);
                                sizeRow = sizeRow.GetSibling(Infragistics.Win.UltraWinGrid.SiblingRow.Next, true, false);
                            }

                            break;

                        case "PackColorSize":


                            packName = aRow.ParentRow.ParentRow.Cells["Pack"].Value.ToString();
                            packColorCodeRID = Convert.ToInt32(aRow.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                            sizeKeys = ap.GetPackColorSizeKeys(packName, packColorCodeRID);
                            for (int i = 0; i < sizeKeys.Length; i++)
                            {
                                ap.RemovePackColorSize(packName, packColorCodeRID, sizeKeys[i]);
                            }

                            sizeRow = aRow.ParentRow.GetChild(ChildRow.First);
                            while (sizeRow != null)
                            {
                                CalculateBalancesFromDelete(sizeRow);
                                sizeRow = sizeRow.GetSibling(Infragistics.Win.UltraWinGrid.SiblingRow.Next, true, false);
                            }

                            _skipBeforeCellUpdate = true;
                            break;

                        case "PackSize":

                            packName = aRow.ParentRow.Cells["Pack"].Value.ToString();
                            packColorCodeRID = Include.DummyColorRID;

                            sizeKeys = ap.GetPackColorSizeKeys(packName, packColorCodeRID);
                            for (int i = 0; i < sizeKeys.Length; i++)
                            {
                                ap.RemovePackColorSize(packName, packColorCodeRID, sizeKeys[i]);
                            }

                            ap.RemovePackColor(packName, packColorCodeRID);

                            sizeRow = aRow.ParentRow.GetChild(ChildRow.First);
                            while (sizeRow != null)
                            {
                                CalculateBalancesFromDelete(sizeRow);
                                sizeRow = sizeRow.GetSibling(Infragistics.Win.UltraWinGrid.SiblingRow.Next, true, false);
                            }
                            break;
                    }

                    switch (bandKeyParts[0])
                    {
                        case "BulkSize":
                        case "PackSize":
                        case "PackColorSize":

                            _dsDetails.Tables[bandKey].Constraints.Remove(bandKey);
                            _dsDetails.Relations.Remove(bandKey);
                            _dsDetails.Tables.Remove(bandKey);
                            break;

                        default:
                            break;
                    }


                    return true;
                }
                //BEGIN TT#1227 - MD- DOConnell - Get a spread lock error when trying to remove a color from a placeholder
                catch (MIDException MIDexc)
                {
                    HandleMIDException(MIDexc);
                    return false;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                    return false;
                }
                finally
                {
                    ap.ResetTempLocks(true);
                }
                //END TT#1227 - MD- DOConnell - Get a spread lock error when trying to remove a color from a placeholder

            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
                return false;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void AddToDeletedComponentHashtable(int aHeaderRID, UltraGridRow aRow)
        {
            try
            {
                int colorCodeRID = Include.NoRID;
                int packKeyRID = Include.NoRID;
                string colorName, packName;
                ArrayList rowAL;
                string[] bandKeyParts = aRow.Band.Key.Split(new char[] { '~' });
                switch (bandKeyParts[0])
                {
                    case "BulkColor":

                        colorName = aRow.Cells["BulkColor"].Value.ToString().Trim();
                        colorCodeRID = Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                        break;
                  
                    case "Pack":

                        packName = aRow.Cells["Pack"].Value.ToString().Trim();
                        packKeyRID = Convert.ToInt32(aRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                        break;

                    case "PackColor":

                        packKeyRID = Convert.ToInt32(aRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                        colorCodeRID = Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                        break;
                }
                foreach (DataRow row in _dtHeaders.Rows)
                {
                    int phRID = Convert.ToInt32(row["PLACEHOLDER_RID"], CultureInfo.CurrentUICulture);
                    int hdrRID = Convert.ToInt32(row["HEADER_RID"], CultureInfo.CurrentUICulture);
                    int colorRID = Convert.ToInt32(row["COLOR_RID"], CultureInfo.CurrentUICulture);
                    int packRID = Convert.ToInt32(row["PACK_RID"], CultureInfo.CurrentUICulture);
                    switch (bandKeyParts[0])
                    {
                        case "BulkColor":
                            if (phRID == aHeaderRID && colorRID == colorCodeRID && hdrRID == int.MaxValue && packRID == int.MaxValue)
                            {
                                if (!_deletedPhComponents.ContainsKey(aHeaderRID))
                                {
                                    rowAL = new ArrayList();
                                    rowAL.Add(row);
                                    _deletedPhComponents.Add(aHeaderRID, rowAL);
                                }
                                else
                                {
                                    rowAL = (ArrayList)_deletedPhComponents[aHeaderRID];
                                    if (!rowAL.Contains(row))
                                    {
                                        rowAL.Add(row);
                                    }
                                }
                            }
                            break;

                        case "Pack":
                            //if (phRID == aHeaderRID && colorRID == int.MaxValue && hdrRID == int.MaxValue && packRID == packKeyRID)
                            if (phRID == aHeaderRID && hdrRID == int.MaxValue && packRID == packKeyRID)
                            {
                                if (!_deletedPlaceholderPacks.Contains(packKeyRID))
                                {
                                    _deletedPlaceholderPacks.Add(packKeyRID);
                                }
                                if (!_deletedPhComponents.ContainsKey(aHeaderRID))
                                {
                                    rowAL = new ArrayList();
                                    rowAL.Add(row);
                                    _deletedPhComponents.Add(aHeaderRID, rowAL);
                                }
                                else
                                {
                                    rowAL = (ArrayList)_deletedPhComponents[aHeaderRID];
                                    if (!rowAL.Contains(row))
                                    {
                                        rowAL.Add(row);
                                    }
                                }
                            }
                            break;

                        case "PackColor":
                            if (phRID == aHeaderRID && colorRID == colorCodeRID && hdrRID == int.MaxValue && packRID == packKeyRID)
                            {
                                if (!_deletedPhComponents.ContainsKey(aHeaderRID))
                                {
                                    rowAL = new ArrayList();
                                    rowAL.Add(row);
                                    _deletedPhComponents.Add(aHeaderRID, rowAL);
                                }
                                else
                                {
                                    rowAL = (ArrayList)_deletedPhComponents[aHeaderRID];
                                    if (!rowAL.Contains(row))
                                    {
                                        rowAL.Add(row);
                                    }
                                }
                            }
                            break;
                    }
                 
                }
            }
            catch
            {
                throw;
            }
        } 
   
        private void CheckForPlaceholderDelete(UltraGridRow aPhRow)
        {
            try
            {
                int phRID = Convert.ToInt32(aPhRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                int asrtRID = Convert.ToInt32(aPhRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                bool headerRowFound = false;
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (row.Cells["PlaceHolderRID"].Value != DBNull.Value
                     && Convert.ToInt32(row.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == phRID
                     && Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Placeholder)
                    {
                        headerRowFound = true;
                        break;
                    }
                }
                if (!headerRowFound)
                {
                    if (!_deletedHeaderRows.Contains(phRID))
                    {
                        _deletedHeaderRows.Add(phRID);
                        aPhRow.Delete(false);
                        CheckForAssortmentTypeUpdate(asrtRID);
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void CheckForAssortmentTypeUpdate(int aAsrtRID)
        {
            try
            {
                UltraGridRow asrtRow = null;
                bool rowsFound = false;
				
				if (IsGroupAllocation)
				{
					EnableBalanceAssortmentAction(false);
					return;
				}

                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aAsrtRID)
                    {
                        asrtRow = row;
                    }
                    else if (row.Cells["AsrtRID"].Value != DBNull.Value
                          && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == aAsrtRID)
                    {
                        rowsFound = true;
                        break;
                    }
                }
                if (!rowsFound)
                {
                    asrtRow.Cells["AsrtType"].Value = (int)eAssortmentType.PreReceipt;
					// BEGIN TT#2148 - stodd - Assortment totals do not include header values
					EnableBalanceAssortmentAction(true);
					// BEGIN TT#2148 - stodd - Assortment totals do not include header values
                }
            }
            catch
            {
                throw;
            }
        }

        private void ClearChildAssortmentColumns(UltraGridRow aRow)
        {
            try
            {
                foreach (UltraGridChildBand childBand in aRow.ChildBands)
                {
                    switch (childBand.Key)
                    {
                        case "BulkColor":
                            foreach (UltraGridRow childRow in childBand.Rows)
                            {
                                childRow.Cells["AsrtBCRID"].Value = Include.NoRID;
                            }
                            break;

                        default:

                            break;
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SelectChildRows(UltraGridRow aRow)
        {
            try
            {
                foreach (UltraGridChildBand childBand in aRow.ChildBands)
                {
                    foreach (UltraGridRow childRow in childBand.Rows)
                    {
                        childRow.Selected = true;
                        if (childRow.HasChild())
                        {
                            SelectChildRows(childRow);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ScrollToHeaderRow(int aHeaderRID)
        {
            int index = -1;
            try
            {
                UltraGridRow headerRow = null;
                UltraGridRow gRow;
                for (int i = 0; i < ugDetails.Rows.Count; i++)
                {
                    gRow = ugDetails.Rows[i];
                    if (gRow.Band.Key == "Header" && (int)gRow.Cells["KeyH"].Value == aHeaderRID)
                    {
                        index = i;
                        headerRow = gRow;
                        break;
                    }
                }

                this.ugDetails.ActiveRow = null;
                this.ugDetails.ActiveRow = headerRow;

                this.ugDetails.BeginUpdate();
                headerRow.Expanded = true;

                ugDetails.DisplayLayout.RowScrollRegions[0].ScrollRowIntoView(headerRow);
                // Sometimes with the 5.3 grid the following code was going into a loop so 
                // comment out for now
                //while (ugDetails.DisplayLayout.RowScrollRegions[0].VisibleRows[0].Row != headerRow)
                //{
                //	ugDetails.DisplayLayout.RowScrollRegions[0].Scroll(RowScrollAction.LineDown); 
                //}

                ugDetails.EndUpdate();
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_AfterRowsDeleted(object sender, System.EventArgs e)
        {
            try
            {
                _dsDetails.AcceptChanges();
                //_changesPending = true;    // MID Track #5501 - add 'nag' message
				//BEGIN TT#455 - MD - DOConnell - Although the content screen appears correct after removing a color from a placeholder, behind the scenes the placeholder allocated units has not changed.
				// BEGIN TT#553-MD - stodd - Size View null reference from attr set
                //_transaction.RebuildWafers();
				_rebuildWafers = true;
				// END TT#553-MD - stodd - Size View null reference from attr set
                //Begin TT#517 - MD - DOConnell - Object Reference Error when removing a header that was attached to a placeholder on a Assortment
                //SaveChanges();

				// BEGIN TT#705-MD - stodd - Units incorrect on placeholder when header with pack/color is removed
				// I believe this save is superfuless. A save is done later in RemoveRowsFromAssortmentTab().SaveAndUpdateAssortmentTab().
                //_asrtCubeGroup.SaveCubeGroup();
				// END TT#705-MD - stodd - Units incorrect on placeholder when header with pack/color is removed

                //End TT#517 - MD - DOConnell -Object Reference Error when removing a header that was attached to a placeholder on a Assortment
				//END TT#455 - MD - DOConnell - Although the content screen appears correct after removing a color from a placeholder, behind the scenes the placeholder allocated units has not changed.
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		// BEGIN TT#1930 - stodd - argument exception
		private void ugDetails_AfterRowInsert(object sender, Infragistics.Win.UltraWinGrid.RowEventArgs e)
		{
			if (ugDetails.Rows.Count > 0 || g4.Rows.Count > 1)	// g4 will have one row for the headings
			{
				EnableCreatePlaceholderAction(false);
			}
			else
			{
				EnableCreatePlaceholderAction(true);
                EnableBalanceAssortmentAction(false);	// TT#1265-MD - stodd - Balance Assortment action gets “Action Successful” but values in grid do not change.
			}
			// BEGIN TT#553-MD - stodd - Size View null reference from attr set
			_rebuildWafers = true;
			// END TT#553-MD - stodd - Size View null reference from attr set
		}
		// END TT#1930 - stodd - argument exception

        private void RemoveSizeBands(int aHdrRID)
        {
            try
            {
                for (int i =  ugDetails.DisplayLayout.Bands.Count - 1; i >= 0; i--)
                {
                    UltraGridBand band = ugDetails.DisplayLayout.Bands[i];
                    string[] bandKeyParts = band.Key.Split(new char[] { '~' });
                    switch (bandKeyParts[0])
                    {
                        case "PackSize":
                        case "PackColorSize":
                        case "BulkSize":
                            if (bandKeyParts[1] == aHdrRID.ToString())
                            {
                                _dsDetails.Tables[band.Key].Constraints.Remove(band.Key);
                                _dsDetails.Relations.Remove(band.Key);
                                _dsDetails.Tables.Remove(band.Key);
                            }
                            break;
                    }
                }
                _dsDetails.AcceptChanges();
                ugDetails.UpdateData();
            }
            catch
            {
                throw;
            }
        }    

        private void ugDetails_BeforeSelectChange(object sender, BeforeSelectChangeEventArgs e)
        {
            try
            {
                if (ugDetails.Selected.Rows.Count > 0)
                {
                    foreach (UltraGridRow prevSelRow in ugDetails.Selected.Rows)
                    {
                        if (prevSelRow.Band.Key == "Header"
                         && Convert.ToInt32(prevSelRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                        {
                            prevSelRow.Cells["HeaderID"].Appearance.ForeColor = prevSelRow.Band.Layout.Override.FixedCellAppearance.BackColor;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		private void ugDetails_AfterSelectChange(object sender, Infragistics.Win.UltraWinGrid.AfterSelectChangeEventArgs e)
		{
			try
			{


				// BEGIN Stodd - 4.0 to 4.1 Manual merge
				string enqMessage = string.Empty;
				// BEGIN TT#67-MD - stodd - Context Menu not displaying on content tab
				AllocationHeaderProfileList allocProfileList = (AllocationHeaderProfileList)_transaction.GetMasterProfileList(eProfileType.AllocationHeader);
				if (_assortReviewContentSecurity.IsReadOnly || !_transaction.AreHeadersEnqueued(allocProfileList))
				//if (_assortReviewContentSecurity.IsReadOnly || !_transaction.EnqueueSelectedHeaders(out enqMessage))
				// END TT#67-MD - stodd 
				//if (_assortReviewContentSecurity.IsReadOnly || !_transaction.HeadersEnqueued)
				// END Stodd - 4.0 to 4.1 Manual merge
				{
					return;
				}
				if (typeof(UltraGridRow) == e.Type)
				{
					SelectRowsForMethodProcessing();
				}
                // Begin TT#2073-MD - JSmith - Asst Velocity when select alloate receive mssg Pack is not defined on the Subtotal
                if (!_bindingGrid)
                {
                // End TT#2073-MD - JSmith - Asst Velocity when select alloate receive mssg Pack is not defined on the Subtotal
                    _transaction.AllocationWafersNeedRebuilt = true;   // TT#2067-MD - JSmith/AGallagher - PPK & Bulk Header-Process Minimum rule-select Vel Str Detail- receive mssg Pack is not defined on subtotal
                }  // TT#2073-MD - JSmith - Asst Velocity when select alloate receive mssg Pack is not defined on the Subtotal
			}
			catch (Exception ex)
			{
				HandleException(ex);
			}
		}

        private void SelectRowsForMethodProcessing()
        {
            try
            {
                GeneralComponent aComponent;
                GeneralComponent anotherComponent;
				// BEGIN TT#371-MD - stodd -  Velocity Interactive on Assortment
                //_selectedHeaderKeyList.Clear();
				_selectedHeaderList.Clear();
				// END TT#371-MD - stodd -  Velocity Interactive on Assortment
                _selectedComponentList.Clear();
                int colorRID;
              
                _sab.ClientServerSession.ClearSelectedHeaderList();
                _sab.ClientServerSession.ClearSelectedComponentList();
                if (ugDetails.Selected.Rows.Count > 0)
                {
                    foreach (UltraGridRow row in ugDetails.Selected.Rows)
                    {
                        UltraGridRow selRow = row;

                        string[] bandKeyParts = selRow.Band.Key.Split(new char[] { '~' });
                        int hdrRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                        switch (bandKeyParts[0])
                        {
                            case "Header":
                                //  Assortment rows are skipped
                                eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                                if (headerType == eHeaderType.Assortment)
                                {
                                    continue;
                                }
                                break;

                            case "BulkColor":
                                if (row.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                                {
                                    colorRID = Convert.ToInt32(row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                    aComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorRID);
                                    GeneralComponentWrapper aComponentWrapper = new GeneralComponentWrapper(hdrRID, aComponent);
                                    _selectedComponentList.Add(aComponentWrapper);
                                }
                                selRow = selRow.ParentRow;
                                break;

                            case "BulkSize":
                                UltraGridRow ColorRow = selRow.ParentRow;
                                if (ColorRow.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                                {
                                    colorRID = Convert.ToInt32(ColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                    aComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorRID);
                                    GeneralComponent allSizeComp = new GeneralComponent(eGeneralComponentType.AllSizes);
                                    anotherComponent = new AllocationColorSizeComponent(aComponent, allSizeComp);
                                    GeneralComponentWrapper aComponentWrapper = new GeneralComponentWrapper(hdrRID, anotherComponent);
                                    _selectedComponentList.Add(aComponentWrapper);
                                }
                                selRow = selRow.ParentRow.ParentRow;
                                break;

                            case "Pack":
                                if (row.Cells["Pack"].Value != System.DBNull.Value)
                                {
                                    aComponent = new AllocationPackComponent(row.Cells["Pack"].Value.ToString());
                                    GeneralComponentWrapper aComponentWrapper = new GeneralComponentWrapper(hdrRID, aComponent);
                                    _selectedComponentList.Add(aComponentWrapper);
                                }
                                selRow = selRow.ParentRow;
                                break;

                            case "PackColor":
                                if (row.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                                {
                                    colorRID = Convert.ToInt32(row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                    aComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorRID);
                                    GeneralComponentWrapper aComponentWrapper = new GeneralComponentWrapper(hdrRID, aComponent);
                                    _selectedComponentList.Add(aComponentWrapper);
                                }
                                selRow = selRow.ParentRow.ParentRow;
                                break;

                            case "PackColorSize":
                                selRow = selRow.ParentRow.ParentRow.ParentRow;
                                break;

                            default:
                                selRow = selRow.ParentRow.ParentRow;
                                break;
                        }

						// BEGIN TT#371-MD - stodd -  Velocity Interactive on Assortment
                        if (!_selectedHeaderList.Contains(hdrRID))
                        {
                            string headerID = Convert.ToString(selRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                            eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);

                            // Begin TT#1258-MD - stodd - Assortment actions get “No Action Performed” when processed from the content tab. 
                            //if (IsPostReceiptAssortment() || IsProcessAsGroup)
                            if (IsProcessAsGroup)
                            // End TT#1258-MD - stodd - Assortment actions get “No Action Performed” when processed from the content tab.
                            {
                                // skip
                            }
                            else
                            {

                                SelectedHeaderProfile selectedHeader = new SelectedHeaderProfile(hdrRID);
                                selectedHeader.HeaderType = headerType;
                                _selectedHeaderList.Add(selectedHeader);
                                // BEGIN TT#371-MD - stodd -  Velocity Interactive on Assortment

                                int asrtRID;
                                if (selRow.Cells["AsrtRID"].Value == DBNull.Value)
                                {
                                    asrtRID = Include.NoRID;
                                }
                                else
                                {
                                    asrtRID = Convert.ToInt32(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                                }
                                if (hdrRID > Include.DefaultHeaderRID)
                                {
                                    int styleHnRID = Convert.ToInt32(selRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                    // Begin TT#1442 - RMatelic - Error processing General Allocation Method on Assortment>>> temporary
                                    //_sab.ClientServerSession.AddSelectedHeaderList(hdrRID, headerID, headerType, asrtRID, styleHnRID);
                                    _sab.ClientServerSession.AddSelectedHeaderList(hdrRID, headerID, headerType, asrtRID, styleHnRID, true);
                                    // End TT#2
                                }
                            }
							
                        }
                    }
                }
                if (_selectedComponentList.Count > 0)
                {
                    foreach (GeneralComponentWrapper gcw in _selectedComponentList)
                    {
                        _sab.ClientServerSession.AddSelectedComponentList(gcw);
                    }
                }
                // Begin TT#3823 - RMatelic - GA Header selection is confusing
                this.ultraToolbarsManager1.Tools["btnProcessAlloc"].SharedProps.Enabled = (ugDetails.Selected.Rows.Count > 0) ? true : false;
				// Begin TT#1450-MD - stodd - The "Process" button for Assortment Actions is disabled
				// The assortment process button is not controlled by the number of selected headers.
                //this.ultraToolbarsManager1.Tools["btnProcessAssort"].SharedProps.Enabled = (ugDetails.Selected.Rows.Count > 0) ? true : false;
                this.ultraToolbarsManager1.Tools["btnProcessAssort"].SharedProps.Enabled = true;
				// End TT#1450-MD - stodd - The "Process" button for Assortment Actions is disabled

                // End TT#3823
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_ClickCellButton(object sender, Infragistics.Win.UltraWinGrid.CellEventArgs e)
        {
            string title = _lblHeaderNotes + " ";
            try
            {
                switch (e.Cell.Column.Key)
                {
                    case "HeaderID":
                        AllocationProfile ap = GetAllocationProfile(Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                        if (ap == null)		// must be a new header
                        {
                            return;
                        }
                        else
                        {
                            TextDialog frm;
                            title = title + e.Cell.Text;
                            if (ap.Placeholder)
                            {
                                if (AllowPlaceholderUpdate(e.Cell.Row))
                                {
                                    frm = new TextDialog(title, e.Cell.Row.Cells["Notes"].Text, 250, _allocationNonInterfacedHeadersSecurity);
                                }
                                else
                                {
                                    frm = new TextDialog(title, e.Cell.Row.Cells["Notes"].Text);
                                }
                            }
                            else
                            {
                                frm = new TextDialog(title, e.Cell.Row.Cells["Notes"].Text);
                            }
                            if (frm.ShowDialog() == DialogResult.OK)
                            {
                                e.Cell.Row.Cells["Notes"].Value = frm.TextValue;
                                ap.AllocationNotes = frm.TextValue;
                                SetNotesCellButton(e.Cell.Row, true);
                            }
                            frm.Dispose();
                        }
                        break;

                    case "BulkColor":
                    case "PackColor":
                        _fromCellButton = true;
                        _colorSelectRow = e.Cell.Row;
                        ChooseColors(false, null);
                        break;

                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }

        }

        #region Choose Colors
        private void ChooseColors(bool aAllowPlaceHolders, ArrayList aColorRIDs)
        {
            try
            {
                if (_frmColorBrowser != null)
                {
                    _frmColorBrowser.Dispose();
                }
                _frmColorBrowser = new ColorBrowser(_sab, aAllowPlaceHolders, aColorRIDs);
                _frmColorBrowser.OnColorBrowserSelectHandler += new ColorBrowser.ColorBrowserSelectEventHandler(form_OnColorBrowserSelectHandler);

                if (this.ParentForm.GetType().FullName == "MIDRetail.Windows.Explorer")
                {
                    _frmColorBrowser.MdiParent = this.ParentForm;
                }
                else
                {
                    _frmColorBrowser.MdiParent = this.ParentForm.Owner;
                }
                _frmColorBrowser.StartPosition = FormStartPosition.CenterScreen;
                _frmColorBrowser.Show();
               // _frmColorBrowser.WindowState = FormWindowState.Normal;
            }
            catch
            {
                throw;
            }
        }

        private void form_OnColorBrowserSelectHandler(object source, ColorBrowserSelectEventArgs e)
        {
            bool okToContinue = true;
            int colorCodeRID;
            string errorMessage = string.Empty;
            _firstNewRow = null;
            // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
            bool canSpreadUnits = false;
            ArrayList colorCodeList; 
            int hdrRID = Include.NoRID;
            Cursor.Current = Cursors.WaitCursor;
            // End TT#1527-MD
            ugDetails.BeginUpdate();
            // ugDetails.SuspendRowSynchronization(); - the Suspend put the new rows at the top instead of the bottom
            ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, false);
            try
            {
                if (_colorSelectRow == null || (e.NumberOfPlaceholderColors == 0 && e.SelectedColors.Count == 0))
                {
                    return;
                }
                if (!_colorSelectRow.Selected)
                {
                    _colorSelectRow.Selected = true;
                }

                foreach (UltraGridRow selectedRow in ugDetails.Selected.Rows)
                {
                    // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                    canSpreadUnits = CanSpreadUnits(selectedRow); 
                    colorCodeList = new ArrayList();
                    // End TT#1527-MD
                 
                    // Begin TT#1550-MD - RMatelic - ASST - Adding PH Colors to a PH receive a Null Reference Exception.>>>> move code up to handle both 'if....' conditions
                    UltraGridRow selRow = selectedRow;
                    while (selRow.Band.Key != "Header")
                    {
                        selRow = selRow.ParentRow;
                    }
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    hdrRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture); 
                    // End TT #1550-MD
                    if (e.NumberOfPlaceholderColors > 0)
                    {
                        // Begin TT#1550-MD - RMatelic - ASST - Adding PH Colors to a PH receive a Null Reference Exception.>>>> move code up to handle both 'if....' conditions
                        //UltraGridRow selRow = selectedRow;

                        //while (selRow.Band.Key != "Header")
                        //{
                        //    selRow = selRow.ParentRow;
                        //}
                        //eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                        //hdrRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);     // TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                        // End TT#1550-MD
                        if (headerType == eHeaderType.Assortment || headerType == eHeaderType.Placeholder)
                        {
                            ArrayList colorRIDs = new ArrayList();

                            switch (_colorSelectRow.Band.Key)
                            {
                                case "Header":
                                //case "Placeholder":
                                case "BulkColor":
                                    colorRIDs = LoadCurrentColors(selRow, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                                    break;

                                case "Pack":
                                    colorRIDs = LoadCurrentColors(_colorSelectRow, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                                    break;

                                case "PackColor":
                                    colorRIDs = LoadCurrentColors(_colorSelectRow.ParentRow, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                                    break;
                            }
                            // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                            //_skipRowUpdate = true;
                            //if (!AddPlaceholderColorRows(selectedRow, colorRIDs, e.PlaceHolders, e.NumberOfPlaceholderColors))
                            //{
                            //    _skipRowUpdate = false;
                            //    return;
                            //}
                            ////SaveAndUpdateAssortmentTab();
                            //OnAssortmentSaveHeaderData(null);	// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                            //_skipRowUpdate = false;
                            //
                            _skipRowUpdate = true;
                            if (!AddPlaceholderColorRows(selectedRow, colorRIDs, e.PlaceHolders, e.NumberOfPlaceholderColors, ref colorCodeList))
                            {
                                _skipRowUpdate = false;
                                return;
                            }
                            _skipRowUpdate = false;
                            // End TT#1527-MD
                        }
                    }

                    if (okToContinue)
                    {
                        if (e.SelectedColors.Count > 0)
                        {
                            if (_fromCellButton)
                            {
                                colorCodeRID = (int)e.SelectedColors[0];
                                ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);
                                // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                                //UpdateColorValue(selectedRow, ccp.ColorCodeID, ref errorMessage);
                                okToContinue = UpdateColorValue(selectedRow, ccp.ColorCodeID, ref errorMessage);
                                // End TT#1527-MD
                            }
                            else
                            {
                                _skipRowUpdate = true;
                                // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                                //AddColorRows(selectedRow, e.SelectedColors);
                                okToContinue = AddColorRows(selectedRow, e.SelectedColors, ref colorCodeList);
                                // End TT#1527-MD
                                _skipRowUpdate = false;
                            }
                        }
                        // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                        //if (_firstNewRow != null)
                        //{
                        //    ugDetails.ActiveRow = _firstNewRow;
                        //}
                        if (okToContinue && _firstNewRow != null)
                        {
                            ugDetails.ActiveRow = _firstNewRow;
                        }
                        if (okToContinue && canSpreadUnits)
                        {
                            okToContinue = SetStoreAllocatedColorUnits(hdrRID, colorCodeList);
                        }
                        // End TT#1527-MD
                    }
                }
            }
            catch
            {
                okToContinue = false; // TT#1483-MD - RMatelic - Asst - when attaching a header receive mssg Unable to determine where to add row:please select a valid row before adding a new row.  Select OK get null reference exception
                throw;
            }
            finally
            {
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, true);
                // ugDetails.ResumeRowSynchronization();
                ugDetails.EndUpdate();
				// Begin TT#1426-MD - stodd - New Placeholder colors do not show up on Matrix tab
				// Updates the Matrix tab with the new colors added
                // Begin TT#1483-MD - RMatelic - Asst - when attaching a header receive mssg Unable to determine where to add row:please select a valid row before adding a new row.  Select OK get null reference exception
                //SaveAndUpdateAssortmentTab();
                if (okToContinue)
                {
                    SaveAndUpdateAssortmentTab();
                }
                // End TT#1483-MD
				// End TT#1426-MD - stodd - New Placeholder colors do not show up on Matrix tab
                Cursor.Current = Cursors.Default; // TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
            }
        }

        private ArrayList LoadCurrentColors(UltraGridRow aSelectedRow, UltraGridBand aColorBand)
        {
            try
            {
                ArrayList colorRIDs = new ArrayList();
                UltraGridRow colorRow = aSelectedRow.GetChild(ChildRow.First, aColorBand);
                while (colorRow != null)
                {
                    int colorCodeRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                    if (Convert.ToBoolean(colorRow.Cells["IsVirtual"].Value, CultureInfo.CurrentUICulture))
                    {
                        if (!colorRIDs.Contains(colorCodeRID))
                        {
                            colorRIDs.Add(colorCodeRID);
                        }
                    }
                    colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                }
                return colorRIDs;
            }
            catch
            {
                throw;
            }

        }
        // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
        //private bool AddPlaceholderColorRows(UltraGridRow aRow, ArrayList aExistingRIDs, ArrayList aPhColorList, int aRequestedCount)
        private bool AddPlaceholderColorRows(UltraGridRow aRow, ArrayList aExistingRIDs, ArrayList aPhColorList, int aRequestedCount, ref ArrayList aColorCodeList)
        // End TT#1527-MD
        {
            bool okToContinue = true;
            try
            {
                // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                //ArrayList colorCodeList = new ArrayList();
                //int hdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                // End TT#1282
                // End TT#1527-MD
                // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                //bool canSpreadUnits = CanSpreadUnits(aRow);
                // End TT#1527-MD
                string errorMessage = string.Empty;

                for (int i = 0; i < aRequestedCount; i++)
                {
                    ColorCodeProfile ccp = null;
                    int colorCodeRID = Include.NoRID;
                    for (int j = 0; j < aPhColorList.Count; j++)
                    {
                        ccp = (ColorCodeProfile)aPhColorList[j];

                        if (!aExistingRIDs.Contains(ccp.Key))
                        {
                            aExistingRIDs.Add(ccp.Key);
                            colorCodeRID = ccp.Key;
                            break;
                        }
                    }
                    if (colorCodeRID == Include.NoRID)
                    {
                        MessageBox.Show("Not enough available Placeholder colors");
                        return false;
                    }

                    ugDetails.ActiveRow = aRow;
                    switch (aRow.Band.Key)
                    {
                        case "Header":
                        //case "Placeholder":
                        case "BulkColor":
                            okToContinue = AddBulkColorRow();
                            break;

                        case "Pack":
                        case "PackColor":
                            okToContinue = AddPackColorRow();
                            break;
                    }
                    if (okToContinue)
                    {
                        // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                        //UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                        //if (_firstNewRow == null)
                        //{
                        //    _firstNewRow = ugDetails.ActiveRow;
                        //}
                        //if (ccp.VirtualInd && aRow.Band.Key == "Header")
                        //{
                        //    int phRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        //    //if (_phColorAutoAdd)
                        //    //{
                        //    //    AddPlaceholderColorToLinkProfile(phRID, ugDetails.ActiveRow);
                        //    //}
                        //}
                        // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                        //if (!colorCodeList.Contains(colorCodeRID))
                        //{
                        //    colorCodeList.Add(colorCodeRID);
                        //}
                        // End TT#1282
                        okToContinue = UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                        if (okToContinue)
                        {
                            if (_firstNewRow == null)
                            {
                                _firstNewRow = ugDetails.ActiveRow;
                            }
                            if (!aColorCodeList.Contains(colorCodeRID))
                            {
                                aColorCodeList.Add(colorCodeRID);
                            }
                        }
                        // End TT#1527-MD
                    }
                    else
                    {
                        break;
                    }
                }
                // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                //if (okToContinue && canSpreadUnits)
                //{
                //    okToContinue = SetStoreAllocatedColorUnits(hdrRID, colorCodeList); 
                //}
                // End TT#1282
                // End TT#1527-MD
            }
            catch
            {
                throw;
            }
            return okToContinue;
        }

        private bool CanSpreadUnits(UltraGridRow aRow)
        {
            bool canSpreadUnits = false;
            UltraGridRow phHeaderRow; 
            try
            {
                phHeaderRow = aRow;
                while (phHeaderRow.Band.Key != "Header")
                {
                    phHeaderRow = phHeaderRow.ParentRow;
                }
                if (!phHeaderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                {
                    canSpreadUnits = true;
                }
            }
            catch
            {
                throw;
            }
            return canSpreadUnits;
        }
        // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
        //private void AddColorRows(UltraGridRow aRow, ArrayList aSelectedColors)
        private bool AddColorRows(UltraGridRow aRow, ArrayList aSelectedColors, ref ArrayList aColorCodeList)
        // End TT#1527-MD
        {
            bool okToContinue = true; // TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
            try
            {
                string errorMessage = string.Empty;
                // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                //bool okToContinue = true;
                // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                //ArrayList colorCodeList = new ArrayList(); 
                //int hdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                // End TT#1282
                //bool canSpreadUnits = CanSpreadUnits(aRow);
                // End TT#1527-MD
                for (int i = 0; i < aSelectedColors.Count; i++)
                {
                    int colorCodeRID = (int)aSelectedColors[i];
                    ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);

                    ugDetails.ActiveRow = aRow;
                    switch (aRow.Band.Key)
                    {
                        case "Header":
                        case "BulkColor":
                            okToContinue = AddBulkColorRow();
                            break;

                        case "Pack":
                        case "PackColor":
                            okToContinue = AddPackColorRow();
                            break;
                    }
                    if (okToContinue)
                    {
                        okToContinue = UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                        // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                        //if (_firstNewRow == null)
                        //{
                        //    _firstNewRow = ugDetails.ActiveRow;
                        //}
                        // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                        //if (!colorCodeList.Contains(colorCodeRID))
                        //{
                        //    colorCodeList.Add(colorCodeRID);
                        //}
                        // End TT#1282
                        if (okToContinue)
                        {
                            if (_firstNewRow == null)
                            {
                                _firstNewRow = ugDetails.ActiveRow;
                            }
                            if (!aColorCodeList.Contains(colorCodeRID))
                            {
                                aColorCodeList.Add(colorCodeRID);
                            }
                        }
                        // End TT#1527-MD
                    }
                    if (!okToContinue)
                    {
                        break;
                    }
                }
                // Begin TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
                // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                //if (okToContinue && canSpreadUnits)
                //{
                //    okToContinue = SetStoreAllocatedColorUnits(hdrRID, colorCodeList);
                //}
                //// End TT#1282
                //if (okToContinue)
                //{
                //    //SaveAndUpdateAssortmentTab();
                //    OnAssortmentSaveHeaderData(null);	// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                //}
                // End TT#1527-MD
            }
            catch
            {
                throw;
            }
            return okToContinue; // TT#1527-MD - RMatelic - When adding multiple colors/place holder colors at once to placeholder, it should spread the Quantity equally amongst them
        }

        private bool UpdateColorValue(UltraGridRow aRow, string aColorCodeID, ref string errorMessage)
        {
            bool validColor = false;
            try
            {
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeCellUpdate, false);
                switch (aRow.Band.Key)
                {
                    case "BulkColor":
                        //aRow.Cells["BulkColor"].Value = aColorCodeID;
                        validColor = ValidBulkColor(aRow.Cells["BulkColor"], aColorCodeID, ref errorMessage);
                        if (validColor)
                        {
                            aRow.Cells["BulkColor"].Value = aColorCodeID;
                        }
                        break;

                    case "PackColor":
                        //aRow.Cells["PackColor"].Value = aColorCodeID;
                        validColor = ValidPackColor(aRow.Cells["PackColor"], aColorCodeID, ref errorMessage);
                        if (validColor)
                        {
                            aRow.Cells["PackColor"].Value = aColorCodeID;
                        }
                        break;
                }
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeCellUpdate, true);
            }
            catch
            {
                throw;
            }
            return validColor;
        }

        private bool AddBulkColorRow()
        {
            bool addOK = true;
            try
            {
                if (!RowActive())
                {
                    addOK = false;
                }
                else
                {
                    while (ugDetails.ActiveRow.Band.Key != "Header")
                    {
                        ugDetails.ActiveRow = ugDetails.ActiveRow.ParentRow;
						//BEGIN TT#418 - MD - DOConnell - Error stuck in loop when attempting to add a bulk color row when there are errors on an existing color row
                        if (_errors != null)
                        {
                            return false;
                        }
						//END TT#418 - MD - DOConnell - Error stuck in loop when attempting to add a bulk color row when there are errors on an existing color row
                    }
                    
                    int hdrRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                    UltraGridRow row = this.ugDetails.DisplayLayout.Bands["BulkColor"].AddNew();
                    //UltraGridRow row = null;
                    // sometimes AddNew() doesn't work, so add to table
					if (row == null || row.Cells["ColorCodeRID"].Value != DBNull.Value)    
                    {
                        object[] Keys = new object[2];
                        Keys[0] = hdrRID;
                        Keys[1] = 0;
                        DataRow drBulk = _dsDetails.Tables["BulkColor"].Rows.Find(Keys);
                        if (drBulk != null)
                        {
                            return false;
                        }
                        DataRow newRow = _dsDetails.Tables["BulkColor"].NewRow();
                        newRow["KeyH"] = hdrRID;
                        newRow["KeyC"] = 0;
                        newRow["ColorCodeRID"] = 0;
                        newRow["BulkColor"] = string.Empty;
                        _dsDetails.Tables["BulkColor"].Rows.Add(newRow);
                        _dsDetails.Tables["BulkColor"].AcceptChanges();
                        this.ugDetails.UpdateData();
                        _dsDetails.Tables["Header"].AcceptChanges();

                        row = ugDetails.ActiveRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                        while (row != null)
                        {
                            if ((int)row.Cells["KeyC"].Value == 0)
                            {
                                break;
                            }
                            row = row.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                    row.Cells["KeyH"].Value = hdrRID;
                    //this.ugDetails.ActiveRow.Cells["BulkColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                    row.Cells["BulkColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                  
                    // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                    if (_addingMTColorRow && !row.HasPrevSibling(false) && !row.HasNextSibling(false))
                    {
                        row.Cells["Quantity"].Value = row.ParentRow.Cells["HdrQuantity"].Value;
                    }
                    // End TT#1282
                   
                    CalculateBalances(eBalanceAction.RowAdded, row.Cells["Quantity"]);

                    this.ugDetails.ActiveRow = row;  // sometimes ActiveRow = null after this even though 'row' is instantiated; don't know why
                  
                    if (!RowActive())
                    {
                        addOK = false;
                    }
                    else
                    {
                        ugDetails.ActiveCell = row.Cells["BulkColor"];
                        if (Convert.ToInt32(row.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.WorkupTotalBuy)
                        {
                            row.Cells["Quantity"].Activation = Activation.NoEdit;
                        }
                        this.ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);

                        _rClickRow = row;
                    }
                }
            }
            catch
            {
                addOK = false;
                throw;
            }
            return addOK;
        }

        private bool AddPackColorRow()
        {
            bool addOK = true;

            try
            {
                if (!RowActive())
                {
                    addOK = false;
                }
                else
                {
                    while (ugDetails.ActiveRow.Band.Key != "Pack")
                    {
                        ugDetails.ActiveRow = this.ugDetails.ActiveRow.ParentRow;
                    }

                    int hdrRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    int packRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);

                    UltraGridRow row = this.ugDetails.DisplayLayout.Bands["PackColor"].AddNew();
                   
                    row.Cells["KeyH"].Value = hdrRID;
                    row.Cells["KeyP"].Value = packRID;
                 
                    this.ugDetails.ActiveRow.Cells["PackColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                    ugDetails.ActiveCell = row.Cells["PackColor"];
                    if (!_addingHeaderToAssortment)
                    {
                        ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                    }
                    CalculateBalances(eBalanceAction.RowAdded, row.Cells["QuantityPerPack"]);
                    if (!_skipRowUpdate && !_addingHeaderToAssortment)
                    {
                        row.Update();
                    }
                    _rClickRow = row;
                }
            }
            catch
            {
                addOK = false;
                throw;
            }
            return addOK;
        }

        private bool RowActive()
        {
            // TT#1483-MD - RMatelic - Asst - when attaching a header receive mssg Unable to determine where to add row:please select a valid row before adding a new row.  Select OK get null reference exception
            //if (ugDetails.ActiveRow == null)
            //{
            //    MessageBox.Show(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_UnableToAddRow),
            //                this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
            //    return false;
            //}
            //return true;
            bool rowActive = true;
            if (ugDetails.ActiveRow == null)
            {
                rowActive = false;
                throw new MIDException(eErrorLevel.severe, 0, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_UnableToAddRow));
            }
            return rowActive;
            // End TT#1483-MD
        }

        #endregion

        private void ugDetails_BeforeCellUpdate(object sender, BeforeCellUpdateEventArgs e)
        {
            try
            {
                if (_skipBeforeCellUpdate)
                {
                    _skipBeforeCellUpdate = false;
                    return;
                }

                switch (e.Cell.Band.Key)
                {
                    case "Header":
                        //case "Placeholder":
                        CheckHeaderBeforeCellUpdate(ref e);
                        break;

                    case "Pack":
                        CheckPackBeforeCellUpdate(ref e);
                        break;

                    case "PackColor":
                        CheckPackColorBeforeCellUpdate(ref e);
                        break;

                    case "BulkColor":
                        CheckBulkColorBeforeCellUpdate(ref e);
                        break;
                }
                if (e.Cancel)
                {
                    _invalidCell = e.Cell;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CheckHeaderBeforeCellUpdate(ref BeforeCellUpdateEventArgs e)
        {
            string errorMessage = string.Empty;
            try
            {
                AllocationProfile ap = GetAllocationProfile(Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                switch (e.Cell.Column.Key)
                {
                    case "HeaderID": //  needs to use NewValue
                        if (!ValidHeaderID(e.Cell, ref errorMessage, Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture)))
                        {
                            MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            e.Cancel = true;
                            return;
                        }
                        break;

                    case "Type":
                        switch ((eHeaderType)Convert.ToInt32(e.NewValue, CultureInfo.CurrentUICulture))
                        {
                            case eHeaderType.MultiHeader:
                                //if (!_creatingMulti)
                                //{
                                //    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_HeaderTypeNotAllowed);
                                //    MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                //    e.Cancel = true;
                                //}
                                break;

                            case eHeaderType.WorkupTotalBuy:
                                if (ap.Packs != null && ap.Packs.Count > 0)
                                {
                                    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_InvalidTypeForHeadersWithPacks);
                                    MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    e.Cancel = true;
                                }
                                break;

                            default:
                                break;
                        }
                        break;

                    case "AnchorNode":
                        if (!_skipAnchorEdit)
                        {
                            string anchorID = Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture);
                            int anchorKey = GetAnchorNodeKey(anchorID);
                            if (anchorKey == -1)
                            {
                                e.Cancel = true;
                            }
                            //else if (!ValidAssortmentLink(e.Cell.Row, anchorKey))
                            //{
                            //    e.Cancel = true;
                            //}    
                        }
                        break;

                    case "Product":
                        if (!_skipProductEdit)
                        {
                            string productID = Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture);
                            int key = GetProductIdKey(productID);
                            if (key == -1)
                            {
                                e.Cancel = true;
                            }
                        }
                        break;

                    case "Style":
                        if (!_skipStyleEdit)
                        {
                            string styleID = Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture);
                            if (styleID.Trim() == string.Empty)
                            {
                                errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_MustBeCorrectLevel), _hlpStyle.LevelID);
                                MessageBox.Show(errorMessage, _windowName);
                                e.Cancel = true;
                            }

                            if (!e.Cancel)
                            {
                                if (!ValidStyle(e.Cell, styleID, ref errorMessage))
                                {
                                    e.Cancel = true;
                                }
                            }
                        }
                        break;

                    case "SizeGroup":
                        // Begin TT#2 - RMatelic Assortment Planning-header packs not balancing >>> general fix unrelated to issue
                        if (ap == null)
                        {
                            e.Cancel = true;
                            return;
                        }
                        // End TT#2
                        if (Convert.ToInt32(e.NewValue, CultureInfo.CurrentUICulture) == Include.UndefinedSizeGroupRID && ap.Placeholder)
                        {
                            break;
                        }
                        ArrayList keys = new ArrayList();
                        if (ap.BulkColors.Count > 0)
                        {
                            foreach (HdrColorBin aColor in ap.BulkColors.Values)
                            {
                                if (aColor.ColorSizes.Count > 0)
                                {
                                    foreach (HdrSizeBin hsb in aColor.ColorSizes.Values)
                                    {
                                        if (!keys.Contains(hsb.SizeKey))
                                        {
                                            keys.Add(hsb.SizeKey);
                                        }
                                    }
                                }
                            }
                        }

                        if (ap.Packs.Count > 0)
                        {
                            foreach (PackHdr aPack in ap.Packs.Values)
                            {
                                foreach (PackColorSize pcs in aPack.PackColors.Values)
                                {
                                    if (pcs.ColorSizes.Count > 0)
                                    {
                                        foreach (PackContentBin pcb in pcs.ColorSizes.Values)
                                        {
                                            if (!keys.Contains(pcb.ContentCodeRID))
                                            {
                                                keys.Add(pcb.ContentCodeRID);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (keys.Count > 0)
                        {
                            bool allSizesFound = true;
                            int newSizeGroupRID = Convert.ToInt32(e.NewValue, CultureInfo.CurrentUICulture);
                            SizeGroupProfile sgp = new SizeGroupProfile(newSizeGroupRID);
                            SizeCodeList scl = sgp.SizeCodeList;
                            foreach (int sizeKey in keys)
                            {
                                SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(sizeKey);
                                if (scp == null)
                                {	// if an existing size is not in the newly selected group, error  
                                    allSizesFound = false;
                                    break;
                                }
                            }
                            if (!allSizesFound && ap.Placeholder && !_removingHeaderFromAssortment)
                            {
                                errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_DeleteExistingSizes);
                                MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                            else
                            {
                                _rebuildSizes = true;
                            }
                        }
                        break;
                    case "Workflow":
                        string workFlow = Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture).Trim();
                        int workflowRID = Include.UndefinedWorkflowRID;
                        if (workFlow != string.Empty)
                        {
                            if (!_workflowNameHash.ContainsValue(workFlow))
                            {
                                WorkflowBaseData workflowData = new WorkflowBaseData();
                                DataTable dt = workflowData.GetWorkflow(workFlow);
                                if (dt.Rows.Count == 0)
                                {
                                    errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_Data1NotValidData2),
                                                   workFlow, MIDText.GetTextOnly(eMIDTextCode.lbl_Workflow));
                                    MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    e.Cancel = true;
                                }
                                else
                                {
                                    DataRow row = dt.Rows[0];
                                    workflowRID = Convert.ToInt32(row["WORKFLOW_RID"], CultureInfo.CurrentUICulture);
                                    _workflowNameHash.Add(workflowRID, workFlow);
                                }
                            }
                        }
                        break;

                    case "AsrtType":
                    case "CharUpdated":
                    case "ChildTotal":
                    case "Balance":
                    case "StyleHnRID":
                    case "ProductRID":
                    case "AsrtRID":
                    case "AnchorHnRID":
                    case "PlaceHolderRID":
                        break;

                    default:
                        if (e.Cell.Column.Tag != null &&
                            e.Cell.Column.Tag.GetType() == typeof(HeaderCharGroupProfile))
                        {
                            CheckCharBeforeCellUpdate(ref e);
                        }
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CheckCharBeforeCellUpdate(ref BeforeCellUpdateEventArgs e)
        {
            string errorMessage = string.Empty;
            int charRID = 0;
            try
            {
                HeaderCharGroupProfile hcgp = (HeaderCharGroupProfile)e.Cell.Column.Tag;
                if (!hcgp.ListInd)
                {
                    switch (hcgp.Type)
                    {
                        case eHeaderCharType.text:
                            break;

                        case eHeaderCharType.number:
                        case eHeaderCharType.dollar:
                            if (!ValidCharNumber(ref e, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                            break;

                        case eHeaderCharType.date:
                            if (!ValidCharDate(ref e, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                            break;
                    }

                    if (!e.Cancel && e.NewValue != System.DBNull.Value && e.NewValue.ToString().Trim() != string.Empty)
                    {
                        charRID = _sab.HeaderServerSession.GetCharForCharGroup(hcgp.Key, e.NewValue);
                        if (charRID == Include.NoRID)
                        {
                            errorMessage = string.Format(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LevelNotFoundAddQuestion),
                                     hcgp.ID, e.NewValue.ToString());
                            DialogResult ret = MessageBox.Show(errorMessage, string.Empty, MessageBoxButtons.YesNo,
                                               MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
                            if (ret == DialogResult.No)
                            {
                                e.Cancel = true;
                            }
                            else
                            {
                                charRID = _sab.HeaderServerSession.UpdateCharInCharGroup(hcgp.Key, e.NewValue);
                            }
                        }
                        if (!e.Cancel)
                        {
                            int hdrRID = Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            DataRow dr = _dsDetails.Tables["Header"].Rows.Find(hdrRID);
                            DataColumn col = null;
                            for (int i = _nonCharColCount; i < _dsDetails.Tables["Header"].Columns.Count; i++)
                            {
                                col = _dsDetails.Tables["Header"].Columns[i];
                                if (col.ColumnName == hcgp.ID)
                                {
                                    break;
                                }
                            }
                            // need to save the char RID for update routine
                            string charString = hcgp.Key.ToString() + "~" + e.NewValue;
                            if (!col.ExtendedProperties.ContainsKey(charString))
                            {
                                col.ExtendedProperties.Add(charString, charRID);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CheckPackBeforeCellUpdate(ref BeforeCellUpdateEventArgs e)
        {
            string packName, errorMessage = string.Empty;
            try
            {
                switch (e.Cell.Column.Key)
                {
                    case "Pack":
                        errorMessage = string.Empty;
                        if (!_fromSaveAs && !_addingHeaderToAssortment)
                        {
                            if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                        }
                        if (!e.Cancel)
                        {
                            packName = e.NewValue.ToString();

                            if (!ValidPackName(e.Cell, packName, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cell.Appearance.Image = null;
                                e.Cell.Tag = null;
                                e.Cancel = true;
                            }
                        }
                        break;

                    default:
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CheckPackColorBeforeCellUpdate(ref BeforeCellUpdateEventArgs e)
        {
            string errorMessage = string.Empty;
            try
            {
                switch (e.Cell.Column.Key)
                {
                    case "PackColor":
                        string packColor = e.NewValue.ToString();
                        if (!_addingHeaderToAssortment)
                        {
                            if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                            else
                            {
                                ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(packColor);
                                if (ccp.Key != Include.NoRID && ccp.VirtualInd)
                                {

                                    errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PlaceholderEntryNotAllowed);
                                    MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    e.Cancel = true;
                                }
                            }
                        }
                        if (!e.Cancel)
                        {
                            if (!ValidPackColor(e.Cell, packColor, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cell.Appearance.Image = null;
                                e.Cell.Tag = null;
                                e.Cancel = true;
                            }
                        }
                        break;

                    default:
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CheckBulkColorBeforeCellUpdate(ref BeforeCellUpdateEventArgs e)
        {
            string errorMessage = string.Empty;
            try
            {
                switch (e.Cell.Column.Key)
                {
                    case "BulkColor":
                        errorMessage = string.Empty;
                        string bulkColor = e.NewValue.ToString();
                        if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                        {
                            MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            e.Cancel = true;
                        }
                        else
                        {
                            ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(bulkColor);
                            if (ccp.Key != Include.NoRID && ccp.VirtualInd)
                            {
                                errorMessage = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PlaceholderEntryNotAllowed);
                                MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                        }
                        if (!e.Cancel)
                        { 
                            if (!ValidBulkColor(e.Cell, bulkColor, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cell.Appearance.Image = null;
                                e.Cell.Tag = null;
                                e.Cancel = true;
                            }
                        }
                        break;

                    default:
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_BeforeCellDeactivate(object sender, CancelEventArgs e)
        {
            try
            {
                if (_invalidCell != null)
                {
                    e.Cancel = true;
                    ugDetails.ActiveCell = _invalidCell;
                    ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                    _invalidCell = null;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        // Begin TT#1278 - RMatelic - Assortment When selecting Save no hour glass appears and the user cannot tell if somethingis saved or not.  Selecting the X in the right had corner does not give a message asking if the user wants to save or not.
        private void ugDetails_CellChange(object sender, Infragistics.Win.UltraWinGrid.CellEventArgs e)
        {

            if (FormLoaded && _assortReviewContentSecurity.AllowUpdate)
            {
                ChangePending = true;
            }
        }
        // End TT#1278

        private void ugDetails_AfterCellUpdate(object sender, CellEventArgs e)
        {
            try
            {
                string[] bandKeyParts = e.Cell.Band.Key.Split(new char[] { '~' });

                switch (bandKeyParts[0])
                {
                    case "Header":
                        if (_skipHeaderEdit)
                        {
                            return;
                        }
                        UpdateHeaderData(e);
                        break;

                    case "Pack":
                        UpdatePackData(e);
                        break;

                    case "PackColor":
                        UpdatePackColorData(e);
                        break;

                    case "BulkColor":
                        UpdateBulkColorData(e);
                        break;

                    case "BulkSize":
                        UpdateBulkSizeData(e);
                        break;

                    case "PackSize":
                    case "PackColorSize":
                        UpdatePackSizeData(e);
                        break;

                    default:
                        break;
                }
                // Begin TT#1278 - RMatelic - Assortment When selecting Save no hour glass appears and the user cannot tell if somethingis saved or not.  Selecting the X in the right had corner does not give a message asking if the user wants to save or not.
                if (FormLoaded && _assortReviewContentSecurity.AllowUpdate && !_addingHeaderToAssortment)
                {
                    ChangePending = true;
                }
                // End TT#1278
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void UpdateHeaderData(CellEventArgs e)
        {
            try
            {
                bool updateHeaderID = true;
                string errorMessage;
                HierarchyNodeProfile productHnp;
                int hRID = Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
				int hdrQty = 0;

                AllocationProfile ap = GetAllocationProfile(Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));

                if (ap == null)
                {	// must be a new header
					//BEGIN TT#501 - MD - DOConnell - On matrix tab, grade quantities revert to 0 when store attribute is changed
                    if (e.Cell.Row.Cells["HeaderID"].Value == null)
                    {
                        return;
                    }
					//END TT#501 - MD - DOConnell - On matrix tab, grade quantities revert to 0 when store attribute is changed
                    string headerID = e.Cell.Row.Cells["HeaderID"].Value.ToString();

                    int newKey = (_allocProfileList.MinValue > 0) ? -1 : _allocProfileList.MinValue - 1;	// all new keys are negative
                    //ap = new AssortmentProfile(_transaction, headerID, newKey, _sab.ClientServerSession);
                    ap = new AllocationProfile(_transaction, headerID, newKey, _sab.ClientServerSession);
                    ap.HeaderDay = Convert.ToDateTime(e.Cell.Row.Cells["Date"].Value, CultureInfo.CurrentUICulture);
                    if ((eHeaderType)Convert.ToInt32(e.Cell.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == eHeaderType.Receipt)
                    {
						// BEGIN Stodd - 4.0 to 4.1 Manual merge
						MIDException exception = null;
						ap.SetHeaderType(eHeaderType.Receipt, out exception);
						// BEGIN Stodd - 4.0 to 4.1 Manual merge
                    }

                    // add header to list
                    _allocProfileList.Add(ap);
                    e.Cell.Row.Cells["KeyH"].Value = newKey;

                    updateHeaderID = false;
                }
                
                switch (e.Cell.Column.Key)
                {
                    case "HeaderID":
                        if (updateHeaderID)
                        {
                            string oldID = Convert.ToString(e.Cell.OriginalValue, CultureInfo.CurrentUICulture);
                            string newID = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                            ap.HeaderID = newID;
                            if (ap.Assortment)
                            {
                                UpdateAssortmentID(oldID, newID);
                            }
                            else if (ap.Placeholder)
                            {
                                UpdatePlaceholderID(ap.Key, newID, ap.HeaderID);
                            }
                        }
                        break;

                    case "Type":

						// BEGIN Stodd - 4.0 to 4.1 Manual merge
						eHeaderType hdrType = (eHeaderType)Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
						MIDException exception = null;
						ap.SetHeaderType(hdrType, out exception);

						if (hdrType == eHeaderType.Placeholder)
						{
							// Begin TT#1224 - stodd - committed
							AssortmentProfile asp = (AssortmentProfile)_asrtCubeGroup.DefaultAllocationProfile;
							DateRangeProfile drp = SAB.ClientServerSession.Calendar.GetDateRange(asp.AssortmentCalendarDateRangeRid);
							ap.ShipToDay = SAB.ClientServerSession.Calendar.GetFirstDayOfRange(drp).Date;
							// End TT#1224 - stodd - committed
						}

						////		first set the flags to false
						//ap.ASN = false;
						//ap.Assortment = false;
						//ap.DropShip = false;
						//ap.IsDummy = false;
						//ap.MultiHeader = false;
						//ap.Placeholder = false;
						//ap.IsPurchaseOrder = false;
						//ap.Receipt = false;
						//ap.Reserve = false;
						//ap.WorkUpTotalBuy = false;

						//switch ((eHeaderType)Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture))
						//{
						//    case eHeaderType.ASN:
						//        ap.ASN = true;
						//        break;

						//    case eHeaderType.Assortment:
						//        ap.Assortment = true;
						//        break;

						//    case eHeaderType.DropShip:
						//        ap.DropShip = true;
						//        break;

						//    case eHeaderType.Dummy:
						//        ap.IsDummy = true;
						//        break;

						//    case eHeaderType.MultiHeader:
						//        ap.MultiHeader = true;
						//        break;

						//    case eHeaderType.Placeholder:
						//        ap.Placeholder = true;
						//        // Begin TT#1224 - stodd - committed
						//        AssortmentProfile asp = (AssortmentProfile)_asrtCubeGroup.DefaultAllocationProfile;
						//        DateRangeProfile drp = SAB.ClientServerSession.Calendar.GetDateRange(asp.AssortmentCalendarDateRangeRid);
						//        ap.ShipToDay = SAB.ClientServerSession.Calendar.GetFirstDayOfRange(drp).Date;
						//        // End TT#1224 - stodd - committed
						//        break;

						//    case eHeaderType.PurchaseOrder:
						//        ap.IsPurchaseOrder = true;
						//        break;

						//    case eHeaderType.Receipt:
						//        ap.Receipt = true;
						//        break;

						//    case eHeaderType.Reserve:
						//        ap.Reserve = true;
						//        break;

						//    case eHeaderType.WorkupTotalBuy:
						//        ap.WorkUpTotalBuy = true;
						//        break;
						//}

						// END Stodd - 4.0 to 4.1 Manual merge
                        break;

                    case "Status":
                        switch ((eHeaderAllocationStatus)Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture))
                        {
                            case eHeaderAllocationStatus.InUseByMultiHeader:
                                //ap.InUseByMulti = true;
                                break;
                        }
                        break;

                    case "Date":
                        ap.HeaderDay = Convert.ToDateTime(e.Cell.Value, CultureInfo.CurrentUICulture);
                        break;

                    case "AnchorNode":
                        if (_skipAnchorEdit)
                        {
                            _skipAnchorEdit = false;
                            return;
                        }
                        string anchorID = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture);
                        int anchorKey = GetAnchorNodeKey(anchorID);
                        if (anchorKey != -1)
                        {
                            e.Cell.Row.Cells["AnchorHnRID"].Value = anchorKey;

                            HierarchyNodeProfile anchorHnp = this.GetNodeData(anchorKey);
                            _skipAnchorEdit = true;
                            e.Cell.Value = anchorHnp.LevelText;
                            UpdateAnchorNodeTable(e.Cell.Row);
                        }
                        break;

                    case "Product":
                        if (_skipProductEdit)
                        {
                            _skipProductEdit = false;
                            return;
                        }
                        string productID = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture);
                        int key = GetProductIdKey(productID);
                        if (key != -1)
                        {
                            e.Cell.Row.Cells["ProductRID"].Value = key;

                            productHnp = _sab.HierarchyServerSession.GetNodeData(key);
                            _skipProductEdit = true;
                            e.Cell.Value = productHnp.LevelText;
                            e.Cell.Row.Cells["Description"].Value = string.Empty;
                            _skipStyleEdit = true;
                            e.Cell.Row.Cells["Style"].Value = string.Empty;
                            string message = string.Empty;
                            RequiredFieldEntered(e.Cell.Row.Cells["Style"], ref message);
                            RequiredFieldEntered(e.Cell.Row.Cells["Description"], ref message);

                            errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_MustBeCorrectLevel), _hlpStyle.LevelID);
                            MessageBox.Show(errorMessage, _windowName);
                        }
                        break;

                    case "Style":
                        if (_skipStyleEdit)
                        {
                            _skipStyleEdit = false;
                            return;
                        }
                        string styleID = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture);
                        HierarchyNodeProfile styleHnp = _sab.HierarchyServerSession.GetNodeData(styleID);
                        e.Cell.Row.Cells["StyleHnRID"].Value = styleHnp.Key;
                        e.Cell.Row.Cells["Description"].Value = styleHnp.NodeDescription;

                        productHnp = _sab.HierarchyServerSession.GetNodeData(styleHnp.HomeHierarchyParentRID);

                        _skipProductEdit = true;
                        e.Cell.Row.Cells["ProductRID"].Value = productHnp.Key;
                        e.Cell.Row.Cells["Product"].Value = productHnp.LevelText;

                        _skipStyleEdit = true;
                        e.Cell.Value = styleHnp.LevelText;

                        // Begin TT#2123-MD - JSmith - PH showing in OTS Forecast Reveiw Multi Level down to Size
                        if (styleHnp.Key != Include.NoRID
                            && !productHnp.IsVirtual)
                        {
                            AddColorAndSizesToStyle(styleHnp.Key, e.Cell.Row, ap);
                        }
                        // End TT#2123-MD - JSmith - PH showing in OTS Forecast Reveiw Multi Level down to Size

                        // Begin TT#1503-MD - RMatelic - ASST - Header not being attached to placeholder when drag/dropped from Allocation Workspace
                        if (_skipStyleSave)
                        {
                            _skipStyleSave = false;
                            return;
                        }
                        // End TT#1503-MD
                        SaveAndUpdateAssortmentTab(); //TT#633-MD-DOConnell - Added a characteristic to an assortment.  It did not appear in the column chooser
                        break;

                    case "StyleHnRID":
                        if (ap.Placeholder)
                        {
                            // Begin TT#1613 - RMatelic - Unrelated
                            //int styleRID = Convert.ToInt32(e.Cell.Row.Cells["StyleHnRID"].OriginalValue, CultureInfo.CurrentUICulture);
							// BEGIN TT#488-MD - Stodd - Group Allocation
                            //int styleRID = Convert.ToInt32(e.Cell.OriginalValue, CultureInfo.CurrentUICulture);
							int styleRID = Include.NoRID;
							if (e.Cell.OriginalValue.ToString().Length > 0)
							{
								styleRID = Convert.ToInt32(e.Cell.OriginalValue, CultureInfo.CurrentUICulture);
							}
							// END TT#488-MD - Stodd - Group Allocation
                            // End TT#1613
                            if (!_deletedPlaceholderStyles.ContainsKey(ap.Key))
                            {
								if (styleRID != Include.NoRID)
								{
									_deletedPlaceholderStyles.Add(ap.Key, styleRID);
								}
                            }
                            // RMatelic - Commented out; don't know if this ever changes now 
                            //HierarchyNodeProfile anchorHnp = _hierMaint.GetAnchorNode(Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                            //if (anchorHnp.Key != Include.NoRID)
                            //{
                            //    _skipAnchorEdit = true;
                            //    e.Cell.Row.Cells["AnchorHnRID"].Value = anchorHnp.Key;
                            //    e.Cell.Row.Cells["AnchorNode"].Value = anchorHnp.LevelText;
                            //}
                            HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                            //e.Cell.Row.Cells["HeaderID"].Value = hnp.LevelText;
                            string oldPhID = Convert.ToString(e.Cell.Row.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                            //UpdatePlaceholderID(oldPhID, hnp.LevelText);
                            UpdatePlaceholderID(ap.Key, hnp.LevelText, ap.HeaderID);
                            // Begin TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, does not change the style
                            //     and Placeholder ID on the Assortment and Characteristics tab unless you save and close the Assorment and go back in to the Assortment
                            _buildProductCharsGrid = true;
                            int aNewStyleHnRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                            UpdateAssortmentTabStyle(styleRID, aNewStyleHnRID, ap.Key, hnp.LevelText);
                            // End TT#1613
                        }

                        ap.StyleHnRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        break;

                    case "Description":
                        if (e.Cell.Value.ToString().Trim() != string.Empty)
                        {
                            ap.HeaderDescription = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                            if (ap.Placeholder)
                            {
                                CheckForGridDescriptionUpdate(ap.StyleHnRID, ap.HeaderDescription, ap.Key);
                            }
                            string message = string.Empty;
                            RequiredFieldEntered(e.Cell, ref message);
                        }
                        break;

                    case "HdrQuantity":
						//BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                        //if (e.Cell.Value == System.DBNull.Value || e.Cell.Value.ToString().Trim() == string.Empty)
                        //{
                            //ap.TotalUnitsToAllocate = 0;
                        //}
                        //else if (Convert.ToInt32(e.Cell.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.MultiHeader)
                        //{
                            //ap.TotalUnitsToAllocate = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        //}
						//END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
						// Begin TT#1092 - MD - stodd - headers with "allocated started" can be dropped and removed -
                        //if (ap.Placeholder)
                        //{
                        //    if (ap.Key > 0 && ap.AllocationStarted)
                        //    {
                        //        //SetStoreAllocatedUnits(ap.Key);
                        //    }
                        //}
						// End TT#1092 - MD - stodd - headers with "allocated started" can be dropped and removed -
                        break;

                    case "UnitRetail":
                        if (e.Cell.Value == System.DBNull.Value || e.Cell.Value.ToString().Trim() == string.Empty)
                        {
                            ap.UnitRetail = 0;
                        }
                        else
                        {
                            ap.UnitRetail = Convert.ToDouble(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
						// BEGIN TT#1996 - stodd - Rtl and Cost do not update on Assortment tab dynamically
						hdrQty = Convert.ToInt32(e.Cell.Row.Cells["HdrQuantity"].Value);
						UpdateAssortmentTabUnitRetail(ap.Key, ap.UnitRetail, hdrQty);
						// END TT#1996 - stodd - Rtl and Cost do not update on Assortment tab dynamically
                        break;

                    case "UnitCost":
                        if (e.Cell.Value == System.DBNull.Value || e.Cell.Value.ToString().Trim() == string.Empty)
                        {
                            ap.UnitCost = 0;
                        }
                        else
                        {
                            ap.UnitCost = Convert.ToDouble(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }						
						// BEGIN TT#1996 - stodd - Rtl and Cost do not update on Assortment tab dynamically
						hdrQty = Convert.ToInt32(e.Cell.Row.Cells["HdrQuantity"].Value);
						UpdateAssortmentTabUnitCost(ap.Key, ap.UnitCost, hdrQty);
						// END TT#1996 - stodd - Rtl and Cost do not update on Assortment tab dynamically
                        break;

                    case "SizeGroup":

                        int sizeGroupRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        if (_rebuildSizes)
                        {
                            _rebuildSizes = false;
                            ap.SizeGroupRID = sizeGroupRID;
                            UltraGridRow headerRow = this.ugDetails.ActiveRow;
                            if (headerRow != null)
                            {
                                headerRow.ExpandAll();
                            }
                            return;
                        }
                        else
                        {
                            ap.SizeGroupRID = sizeGroupRID;
                        }
                        break;

                    case "Multiple":
                        errorMessage = string.Empty;
                        if (e.Cell.Value == System.DBNull.Value || e.Cell.Value.ToString().Trim() == string.Empty)
                        {
                            ap.AllocationMultiple = Include.DefaultUnitMultiple;
                        }
                        else if (!ValidMultiple(e.Cell, ref errorMessage))
                        {
                            MessageBox.Show(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_MultipleCannotBeLessThan1));
                            return;
                        }
                        else
                        {
                            ap.AllocationMultiple = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
                        break;

                    case "PO":
                        ap.PurchaseOrder = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                        break;

                    case "Vendor":
                        ap.Vendor = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                        break;

                    case "Workflow":
                        string workFlow = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                        int workFlowRID = Include.UndefinedWorkflowRID;
                        if (workFlow != string.Empty)
                        {
                            foreach (int wfRID in _workflowNameHash.Keys)
                            {
                                if (_workflowNameHash[wfRID].ToString() == workFlow)
                                {
                                    workFlowRID = wfRID;
                                    break;
                                }
                            }
                        }
                        ap.WorkflowRID = workFlowRID;
                        break;

                    case "DC":
                        ap.DistributionCenter = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                        break;

                    case "HdrGroupRID":
                        if (ap.InUseByMulti || Convert.ToInt32(e.Cell.Row.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader)
                        {
                            if (e.Cell.Value != DBNull.Value)
                            {
                                ap.HeaderGroupRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);

                            }
                            else // this should happen when a header is being removed from the Multiheader
                            {
                                ap.HeaderGroupRID = Include.UndefinedHeaderGroupRID;
                                //ap.InUseByMulti = false;
                                e.Cell.Row.Cells["Status"].Value = (int)ap.GetHeaderAllocationStatus(true);
                                e.Cell.Row.Cells["MultiSortSeq"].Value = DBNull.Value;
                            }
                        }
                        break;

                    case "AsrtRID":
                        if (e.Cell.Value != DBNull.Value)
                        {
                            ap.AsrtRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                            AssortmentProfile asp = (AssortmentProfile)_allocProfileList.FindKey(ap.AsrtRID);
                            ap.PlanHnRID = asp.AssortmentAnchorNodeRid; 
                        }
                        else
                        {
                            ap.AsrtRID = Include.NoRID;
                            ap.PlanHnRID = Include.DefaultPlanHnRID;
                        }
                        break;

                    case "PlaceHolderRID":
                        if (e.Cell.Value != DBNull.Value)
                        {
                            ap.PlaceHolderRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
                        else
                        {
                            ap.PlaceHolderRID = Include.NoRID;
                        }
                        break;

                    case "AsrtType":
                        ap.AsrtType = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        break;

                    case "AsrtPlaceholderSortSeq":
                        if (e.Cell.Value != DBNull.Value)
                        {
                            ap.AsrtPlaceholderSeq = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
                        else
                        {
                            ap.AsrtPlaceholderSeq = Include.UndefinedPlaceholderSeq;
                        }
                        break;
                    
                    case "AsrtHeaderSortSeq":
                        if (e.Cell.Value != DBNull.Value)
                        {
                            ap.AsrtHeaderSeq = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
                        else
                        {
                            ap.AsrtHeaderSeq = Include.UndefinedHeaderSeq;
                        }
                        break;

                    case "KeyH":
                    case "CharUpdated":
                    case "ChildTotal":
                    case "Balance":
                    case "AnchorHnRID":
                        break;

                    default:
                        if (e.Cell.Column.Tag != null &&
                            e.Cell.Column.Tag.GetType() == typeof(HeaderCharGroupProfile))  // Header Characteristic
                        {
                            if (e.Cell.Value != System.DBNull.Value)
                            {
                                if (e.Cell.Value.ToString().Trim() == string.Empty ||
                                    e.Cell.Value.ToString().Trim() == Include.NoRID.ToString())
                                {
                                    e.Cell.Value = System.DBNull.Value;
                                }
                            }
                            e.Cell.Row.Cells["CharUpdated"].Value = true;
                        }
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch
            {
                throw;
            }
        }

        // Begin TT#2123-MD - JSmith - PH showing in OTS Forecast Reveiw Multi Level down to Size
        private void AddColorAndSizesToStyle(int styleKey, UltraGridRow styleRow, AllocationProfile ap)
        {
            EditMsgs em = null;

            foreach (UltraGridRow colorRow in styleRow.ChildBands["BulkColor"].Rows)
            {
                int colorCodeRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);
                if (ccp.Purpose == ePurpose.Default)  // Do not add if not real color
                {
                    string bulkColorID = Convert.ToString(colorRow.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture).Trim();
                    string bulkColorDescription = Convert.ToString(colorRow.Cells["Description"].Value, CultureInfo.CurrentUICulture).Trim();
                    em = new EditMsgs();
                    int colorHnRID = _hierMaint.QuickAdd(ref em, styleKey, bulkColorID, bulkColorDescription);
                    if (em.ErrorFound)
                    {
                        DisplayMessages.Show(em, _sab, _windowName);
                        return;
                    }
                    // Get sizes from header
                    HdrColorBin aPhColor = (HdrColorBin)ap.BulkColors[colorCodeRID];
                    foreach (HdrSizeBin aSize in aPhColor.ColorSizes.Values)
                    {
                        em = new EditMsgs();
                        SizeCodeProfile scp = _sab.HierarchyServerSession.GetSizeCodeProfile(aSize.SizeCodeRID);
                        int sizeHnRID = _hierMaint.QuickAdd(ref em, colorHnRID, scp.SizeCodeID);
                        if (em.ErrorFound)
                        {
                            DisplayMessages.Show(em, _sab, _windowName);
                            return;
                        }
                    }
                }
            }

            foreach (UltraGridRow packRow in styleRow.ChildBands["Pack"].Rows)
            {
                foreach (UltraGridRow packColorRow in packRow.ChildBands["PackColor"].Rows)
                {
                    int colorCodeRID = Convert.ToInt32(packColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                    ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);
                    if (ccp.Purpose == ePurpose.Default)  // Do not add if not real color
                    {
                        string packName = Convert.ToString(packColorRow.ParentRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture).Trim();
                        string packColorID = Convert.ToString(packColorRow.Cells["PackColor"].Value, CultureInfo.CurrentUICulture).Trim();
                        string packColorDescription = Convert.ToString(packColorRow.Cells["Description"].Value, CultureInfo.CurrentUICulture).Trim();
                        em = new EditMsgs();
                        int colorHnRID = _hierMaint.QuickAdd(ref em, styleKey, packColorID, packColorDescription);
                        if (em.ErrorFound)
                        {
                            DisplayMessages.Show(em, _sab, _windowName);
                            return;
                        }
                        // Get sizes from header
                        PackHdr apPackHdr = (PackHdr)ap.Packs[packName];
                        PackColorSize packColor = (PackColorSize)apPackHdr.PackColors[colorCodeRID];
                        foreach (HdrSizeBin aSize in packColor.ColorSizes.Values)
                        {
                            em = new EditMsgs();
                            SizeCodeProfile scp = _sab.HierarchyServerSession.GetSizeCodeProfile(aSize.SizeCodeRID);
                            int sizeHnRID = _hierMaint.QuickAdd(ref em, colorHnRID, scp.SizeCodeID);
                            if (em.ErrorFound)
                            {
                                DisplayMessages.Show(em, _sab, _windowName);
                                return;
                            }
                        }
                    }
                }
            }
        }
        // End TT#2123-MD - JSmith - PH showing in OTS Forecast Reveiw Multi Level down to Size

        // Begin TT#2086-MD - JSmith - After attach 2nd Hdr to a PHC the stores are not allocated proportionally to the PH.  5 strs receive 200+ units, when all strs on the PHC had values.
		private List<Index_RID> GetStoreIndexRIDArray()
        {
            Index_RID storeIndexRID;
            ProfileList aStoreList = _asrtCubeGroup.GetMasterProfileList(eProfileType.Store);
            List<Index_RID> storeIndexRIDArray = new List<Index_RID>(aStoreList.Count);
            for (int s = 0; s < aStoreList.Count; s++)
            {
                StoreProfile sp = (StoreProfile)aStoreList.ArrayList[s];
                if (sp.Key != _transaction.ReserveStore.RID)
                {
                    storeIndexRID = this._transaction.StoreIndexRID(sp.Key);
                    storeIndexRIDArray.Add(storeIndexRID);
                }
            }
            return storeIndexRIDArray;
        }
        // End TT#2086-MD - JSmith - After attach 2nd Hdr to a PHC the stores are not allocated proportionally to the PH.  5 strs receive 200+ units, when all strs on the PHC had values.

        // Begin TT#2 - RMatelic - Assortment Planning-allocate headers attached to placeholders
		/// <summary>
		/// Allocates the newly added header & adjusts the placeholder accordingly.
		/// </summary>
		/// <param name="aPhAndHeadersHash"></param>
        private void AllocateHeaderAndPlaceholderUnits(Hashtable aPhAndHeadersHash)
        {
            try
            {
                foreach (int phRID in aPhAndHeadersHash.Keys)
                {
                    ArrayList headerList = (ArrayList)aPhAndHeadersHash[phRID];
                    AllocateHeaderAndPlaceholderUnits(phRID, headerList);
                }
            }
            catch
            {
                throw;
            }
        }
        
		/// <summary>
		/// Allocates the newly added header & adjusts the placeholder accordingly
		/// </summary>
		/// <param name="aPlaceHolderRID"></param>
		/// <param name="aHeaderList"></param>
        private void AllocateHeaderAndPlaceholderUnits(int aPlaceHolderRID, ArrayList aHeaderList) 
        {
			try
			{
				//BEGIN TT#562-MD - stodd -  Bulk is not getting properly updated upon an assortment save of placeholders 
                SetActivateAssortmentOnHeaders(aHeaderList, true);
				//END TT#562-MD - stodd -  Bulk is not getting properly updated upon an assortment save of placeholders 

				int[] headerRIDs = new int[aHeaderList.Count];
				int[] hdrUnitsToAllocate = new int[aHeaderList.Count];
				int i = 0;
				//int cUnitsTotal = 0; ////TT#443 - MD - DOConnell - After removing a header from the assortment there is a balance,  close and save assortment balance = 0, expect the balance to be 0 at the time it is removed.
				AllocationProfile ahp;
				foreach (int hdrRID in aHeaderList)
				{
					ahp = (AllocationProfile)_allocProfileList.FindKey(hdrRID);
					headerRIDs[i] = hdrRID;
					hdrUnitsToAllocate[i] = ahp.TotalUnitsToAllocate;
					i++;
				}

				AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(aPlaceHolderRID);
				AssortmentProfile asp = (AssortmentProfile)_allocProfileList.FindKey(ap.AsrtRID);

				ProfileList gradeList = asp.GetAssortmentStoreGrades();		// TT#488-MD - STodd - Group Allocation
				ProfileList sgll = _asrtCubeGroup.GetFilteredProfileList(eProfileType.StoreGroupLevel);

				Index_RID storeIndexRID;
				ProfileList aStoreList = _asrtCubeGroup.GetMasterProfileList(eProfileType.Store);
				List<Index_RID> storeIndexRIDArray = new List<Index_RID>(aStoreList.Count);
				for (int s = 0; s < aStoreList.Count; s++)
				{
					StoreProfile sp = (StoreProfile)aStoreList.ArrayList[s];
					// BEGIN TT#640-MD -Drag-Drop a header with a single color to a place holder with a single color allocates to the reserve store
					if (sp.Key != _transaction.ReserveStore.RID)
					{
						storeIndexRID = this._transaction.StoreIndexRID(sp.Key);
						storeIndexRIDArray.Add(storeIndexRID);
					}
					// END TT#640-MD -Drag-Drop a header with a single color to a place holder with a single color allocates to the reserve store
				}

				//===================================================================
				// Calculate header units proportional to the placeholder units
				// for the store group and grade
				//===================================================================
				//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
				//RuleBasedAllocation ruleAlloc = new RuleBasedAllocation(_transaction);
				//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
				for (int j = 0; j < headerRIDs.Length; j++)
				{
					ahp = (AllocationProfile)_allocProfileList.FindKey(headerRIDs[j]);
					ahp.ShipToDay = asp.AssortmentApplyToDate.Date;		// TT#596 - MD - stodd - force header to use assortments shipping date

					MIDException ex = null;

					RuleAllocationProfile ruleAllocProfile = null;
					//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
					if (ahp.BulkColors.Count > 0 || ahp.Packs.Count > 0)
					{
                        // Begin TT#2056-MD - JSmith - Attach PPK&Bulk header (4800 units) to a PHC(4893 units).  Some stores are allocated over the PHC allocation and some Under.  Do not expect stores to be allocated over the initial PHC allocation
                        // Process pack before bulk

                        ////BEGIN TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
                        //foreach (HdrColorBin aHdrColor in ahp.BulkColors.Values)
                        //{
                        //    HdrColorBin aPhColor = (HdrColorBin)ap.BulkColors[aHdrColor.ColorCodeRID];
                        //    //======================================================================================================
                        //    // This prepares the sizes on the placeholder color for the deduction of the header size units later
                        //    //======================================================================================================
                        //    bool isPhSizeAllocated = IsPlaceholderSizeAllocated(aPhColor);
                        //    if (isPhSizeAllocated)
                        //    {
                        //        SpreadColorUnitsToSizes(ap, aPhColor, storeIndexRIDArray);
                        //    }

                        //    AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aHdrColor.ColorCodeRID);
                        //    ruleAllocProfile = new RuleAllocationProfile(_transaction, ahp.Key, colorComponent, 1, true);	//TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
                        //    // BEGIN TT#586 MD - stodd - headerr colors getting "flat" allocation
                        //    GeneralComponent totalComponent = new GeneralComponent(eGeneralComponentType.Total);
                        //    //BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 

                        //    //================================================================================================================================================================================
                        //    // If the color on the placeholder has no units, instead of allocating a "flat" plan to the header, use the placeholder total units per store for the proportional allocation.
                        //    //================================================================================================================================================================================
                        //    int colorQty = ap.GetColorUnitsAllocated(aHdrColor.ColorCodeRID);

                        //    if (colorQty > 0)	// Use color allocation
                        //    {
                        //        _transaction.RuleBasedAllocation.CalculateProportionalAllocation(storeIndexRIDArray, ap, colorComponent, ahp, colorComponent, ref ruleAllocProfile, out ex);
                        //    }
                        //    else				// Use total allocation
                        //    {
                        //        _transaction.RuleBasedAllocation.CalculateProportionalAllocation(storeIndexRIDArray, ap, totalComponent, ahp, colorComponent, ref ruleAllocProfile, out ex);
                        //    }
                        //    // END TT#586 MD - stodd - headerr colors getting "flat" allocation
                        //    //END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
							
                        //    foreach (Index_RID aStoreIdx in storeIndexRIDArray)
                        //    {
                        //        int qty = ruleAllocProfile.GetStoreQtyAllocatedByRule(aStoreIdx.RID);
                        //        ahp.AdjustPlaceholder = true;  // TT#2039 - JSmith - Attach a PPK header to a PH.  After attaching the PH residual value is incorrect.
                        //        ahp.SetStoreQtyAllocated(aHdrColor.ColorCodeRID, aStoreIdx.RID, qty, eDistributeChange.ToParent, false); 	// TT#749-MD - Stodd - Assortment setting manually allocated to true
                        //        ahp.AdjustPlaceholder = false;  // TT#2039 - JSmith - Attach a PPK header to a PH.  After attaching the PH residual value is incorrect.
                        //    }

                        //    //=========================================================================
                        //    // Placeholder has allocated sizes, so we can allocate the header sizes
                        //    //=========================================================================
                        //    if (isPhSizeAllocated)
                        //    {
                        //        //==============================
                        //        // Allocated Header Color Sizes
                        //        //==============================
                        //        SpreadColorUnitsToSizes(ahp, aHdrColor, storeIndexRIDArray);

                        //        //========================================================================================
                        //        // Now that the header size units have been deducted from the placeholder size units,
                        //        // we have to re-spread the placeholder to balance sizes to color
                        //        //========================================================================================
                        //        SpreadColorUnitsToSizes(ap, aPhColor, storeIndexRIDArray);
                        //    }
                        //}
                        ////END TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
                        // End TT#2056-MD - JSmith - Attach PPK&Bulk header (4800 units) to a PHC(4893 units).  Some stores are allocated over the PHC allocation and some Under.  Do not expect stores to be allocated over the initial PHC allocation

						foreach (PackHdr aPack in ahp.Packs.Values)
						{
							//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
							if (aPack.PackColorCount > 0)
							{
								foreach (PackColorSize pcs in aPack.PackColors.Values)
								{
									AllocationPackComponent phPackComponent = new AllocationPackComponent(aPack.PackName + " [" + ahp.HeaderID + "]");
									AllocationPackComponent hdrPackComponent = new AllocationPackComponent(aPack.PackName);

									AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, pcs.ColorCodeRID);
									ruleAllocProfile = new RuleAllocationProfile(_transaction, ahp.Key, hdrPackComponent, 1, true);	//TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
									//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
									_transaction.RuleBasedAllocation.CalculateProportionalAllocation(storeIndexRIDArray, ap, colorComponent, ahp, hdrPackComponent, ref ruleAllocProfile, out ex);
									//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
								}
							}
							else
							{
								AllocationPackComponent phPackComponent = new AllocationPackComponent(aPack.PackName + " [" + ahp.HeaderID + "]");
								AllocationPackComponent hdrPackComponent = new AllocationPackComponent(aPack.PackName);
								ruleAllocProfile = new RuleAllocationProfile(_transaction, ahp.Key, hdrPackComponent, 1, true);	//TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
								//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
								_transaction.RuleBasedAllocation.CalculateProportionalAllocation(storeIndexRIDArray, ap, phPackComponent, ahp, hdrPackComponent, ref ruleAllocProfile, out ex);
								//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
							}
							foreach (Index_RID aStoreIdx in storeIndexRIDArray)
							{
								int qty = ruleAllocProfile.GetStoreQtyAllocatedByRule(aStoreIdx.RID);
                                ahp.AdjustPlaceholder = true;  // TT#2039 - JSmith - Attach a PPK header to a PH.  After attaching the PH residual value is incorrect.
								ahp.SetStoreQtyAllocated(aPack.PackName, aStoreIdx, qty, eDistributeChange.ToParent, false);	// TT#749-MD - Stodd - Assortment setting manually allocated to true
                                ahp.AdjustPlaceholder = false;  // TT#2039 - JSmith - Attach a PPK header to a PH.  After attaching the PH residual value is incorrect.
							}
							//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
						}

                        // Begin TT#2056-MD - JSmith - Attach PPK&Bulk header (4800 units) to a PHC(4893 units).  Some stores are allocated over the PHC allocation and some Under.  Do not expect stores to be allocated over the initial PHC allocation
                        foreach (HdrColorBin aHdrColor in ahp.BulkColors.Values)
                        {
                            HdrColorBin aPhColor = (HdrColorBin)ap.BulkColors[aHdrColor.ColorCodeRID];
                            //======================================================================================================
                            // This prepares the sizes on the placeholder color for the deduction of the header size units later
                            //======================================================================================================
                            bool isPhSizeAllocated = IsPlaceholderSizeAllocated(aPhColor);
                            if (isPhSizeAllocated)
                            {
                                SpreadColorUnitsToSizes(ap, aPhColor, storeIndexRIDArray);
                            }

                            AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aHdrColor.ColorCodeRID);
                            ruleAllocProfile = new RuleAllocationProfile(_transaction, ahp.Key, colorComponent, 1, true);	//TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
                            // BEGIN TT#586 MD - stodd - headerr colors getting "flat" allocation
                            GeneralComponent totalComponent = new GeneralComponent(eGeneralComponentType.Total);
                            //BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 

                            //================================================================================================================================================================================
                            // If the color on the placeholder has no units, instead of allocating a "flat" plan to the header, use the placeholder total units per store for the proportional allocation.
                            //================================================================================================================================================================================
                            int colorQty = ap.GetColorUnitsAllocated(aHdrColor.ColorCodeRID);

                            if (colorQty > 0)	// Use color allocation
                            {
                                _transaction.RuleBasedAllocation.CalculateProportionalAllocation(storeIndexRIDArray, ap, colorComponent, ahp, colorComponent, ref ruleAllocProfile, out ex);
                            }
                            else				// Use total allocation
                            {
                                _transaction.RuleBasedAllocation.CalculateProportionalAllocation(storeIndexRIDArray, ap, totalComponent, ahp, colorComponent, ref ruleAllocProfile, out ex);
                            }
                            // END TT#586 MD - stodd - headerr colors getting "flat" allocation
                            //END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 

                            foreach (Index_RID aStoreIdx in storeIndexRIDArray)
                            {
                                int qty = ruleAllocProfile.GetStoreQtyAllocatedByRule(aStoreIdx.RID);
                                ahp.AdjustPlaceholder = true;  // TT#2039 - JSmith - Attach a PPK header to a PH.  After attaching the PH residual value is incorrect.
                                ahp.SetStoreQtyAllocated(aHdrColor.ColorCodeRID, aStoreIdx.RID, qty, eDistributeChange.ToParent, false); 	// TT#749-MD - Stodd - Assortment setting manually allocated to true
                                ahp.AdjustPlaceholder = false;  // TT#2039 - JSmith - Attach a PPK header to a PH.  After attaching the PH residual value is incorrect.
                            }

                            //=========================================================================
                            // Placeholder has allocated sizes, so we can allocate the header sizes
                            //=========================================================================
                            if (isPhSizeAllocated)
                            {
                                //==============================
                                // Allocated Header Color Sizes
                                //==============================
                                SpreadColorUnitsToSizes(ahp, aHdrColor, storeIndexRIDArray);

                                //========================================================================================
                                // Now that the header size units have been deducted from the placeholder size units,
                                // we have to re-spread the placeholder to balance sizes to color
                                //========================================================================================
                                SpreadColorUnitsToSizes(ap, aPhColor, storeIndexRIDArray);
                            }
                        }
                        // End TT#2056-MD - JSmith - Attach PPK&Bulk header (4800 units) to a PHC(4893 units).  Some stores are allocated over the PHC allocation and some Under.  Do not expect stores to be allocated over the initial PHC allocation
					}
					//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
					else
					{
						GeneralComponent totComp = new GeneralComponent(eGeneralComponentType.Total);
						ruleAllocProfile = new RuleAllocationProfile(_transaction, ahp.Key, totComp, 1, true);
						//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
						_transaction.RuleBasedAllocation.CalculateProportionalAllocation(storeIndexRIDArray, ap, totComp, ahp, totComp, ref ruleAllocProfile, out ex);
						//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 

						foreach (Index_RID aStoreIdx in storeIndexRIDArray)
						{
							int qty = ruleAllocProfile.GetStoreQtyAllocatedByRule(aStoreIdx.RID);
							ahp.AdjustPlaceholder = true;  // TT#2039 - JSmith - Attach a PPK header to a PH.  After attaching the PH residual value is incorrect.
							ahp.SetStoreQtyAllocated(eAllocationSummaryNode.Total, aStoreIdx.RID, qty, eDistributeChange.ToAll, false); 	// TT#749-MD - Stodd - Assortment setting manually allocated to true
							ahp.AdjustPlaceholder = false;  // TT#2039 - JSmith - Attach a PPK header to a PH.  After attaching the PH residual value is incorrect.
						}
					}

				}
                SetActivateAssortmentOnHeaders(aHeaderList, false);
				//END TT#562-MD - stodd -  Bulk is not getting properly updated upon an assortment save of placeholders 


				//BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
				//==============================================================================
				// This code refreshes the content grids components for the placeholder to
				// show the correct quantities.
				//==============================================================================
				if (ap.BulkColors.Count > 0
					   || ap.Packs.Count > 0)
				{
					foreach (HdrColorBin aColor in ap.BulkColors.Values)
					{
						UpdateBulkColorQuantity(ap.Key, aColor.ColorCodeRID, aColor.ColorUnitsAllocated);
					}
					foreach (PackHdr aPack in ap.Packs.Values)
					{
						UpdatePackQuantity(ap.Key, aPack.PackRID, aPack.UnitsAllocated);
					}

				}
				//END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 

				// BEGIN TT#553-MD - stodd - Size View null reference from attr set
				_rebuildWafers = true;
				// END TT#553-MD - stodd - Size View null reference from attr set


			}
			catch
			{
				throw;
			}
			// BEGIN TT#534-MD - stodd -  Style Review Gets Null Reference when opening from Assortment
			//BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
			//finally
			//{
			//    // Because colors may have changed on Placeholder
			//    _transaction.RebuildWafers();
			//}
			//END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
			// END TT#534-MD - stodd -  Style Review Gets Null Reference when opening from Assortment
        }
        // End TT#2

		//BEGIN TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
		private bool IsPlaceholderSizeAllocated(HdrColorBin aPhColor)
		{
			bool isPhSizeAllocated = false;
			if (aPhColor != null && aPhColor.ColorSizes != null && aPhColor.ColorSizes.Count > 0)
			{
				isPhSizeAllocated = false;
				foreach (HdrSizeBin aSize in aPhColor.ColorSizes.Values)
				{
					if (aSize.SizeUnitsAllocated > 0)
					{
						isPhSizeAllocated = true;
						break;
					}
				}
			}
			return isPhSizeAllocated;
		}

		private void SpreadColorUnitsToSizes(AllocationProfile ap, HdrColorBin aColor, List<Index_RID> storeIndexRIDArray)
		{
			List<int> aRowTotalList = new List<int>();	// Stores
			List<int> aColTotalList = new List<int>();	// Sizes

			// Setup Constraints
			ConstraintBin[,] constraints = null;
			int[,] spreadSizeResults = new int[storeIndexRIDArray.Count, 1];
			bool unitsWereSpread = false;
			MIDException aMIDException;
			AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, aColor.ColorCodeRID);

			// Load rows with placeholder store data
			for (int s = 0; s < storeIndexRIDArray.Count; s++)
			{
				Index_RID storeIndex = storeIndexRIDArray[s];
				aRowTotalList.Add(ap.GetStoreQtyAllocated(colorComponent, storeIndex.RID));
			}

			aColTotalList.Clear();

			// load columns with placeholder size totals
			foreach (HdrSizeBin aSize in aColor.ColorSizes.Values)
			{
				int qty = aSize.SizeUnitsToAllocate;
				aColTotalList.Add(qty);
			}

            _transaction.RuleBasedAllocation.Do_2_DimensionalSpread(aRowTotalList, aColTotalList, constraints, out spreadSizeResults, out unitsWereSpread, out aMIDException, true);  // TT#2049-MD - JSmith - Attached Detail PPK header with Qty less than PH the PH values are not the difference between the Orig PH value and the Header Allocation.);

			int cs = 0;
			foreach (HdrSizeBin aSize in aColor.ColorSizes.Values)
			{
				//HdrSizeBin aSize = (HdrSizeBin)aColor.ColorSizes.[cs];
				for (int s = 0; s < storeIndexRIDArray.Count; s++)
				{
					Index_RID storeIndex = storeIndexRIDArray[s];
					ap.SetStoreQtyAllocated(aColor.ColorCodeRID, aSize.SizeCodeRID, storeIndex.RID, spreadSizeResults[s, cs], eDistributeChange.ToNone, false);	// TT#749-MD - Stodd - Assortment setting manually allocated to true
				}
				cs++;
			}
		}
		//END TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
		
		//BEGIN TT#575-MD - stodd - After a header is dropped onto a placeholder, both the placeholder and the header are in balance but it appears the Placeholder has too few units removed
		// this method is no longer used.
		//==================================================
		//// BEGIN TT#489-MD - stodd -  headers in received out of balance status
		///// <summary>
		///// This method reconciles the allocated with the units to allocate
		///// </summary>
		///// <param name="ap"></param>
		///// <param name="totalAllocatedUnits"></param>
		//private void ReconcileUnitsToAllocate(AllocationProfile ap, int totalAllocatedUnits)
		//{
		//    int cUnitsTotal = 0;
		//    if (ap.HeaderType == eHeaderType.Placeholder)
		//    {
		//        ap.TotalUnitsToAllocate = totalAllocatedUnits;
		//        // BEGIN TT#450-MD - stodd - color quantity units not getting updated
		//        if (ap.BulkColors != null)
		//        {
		//            foreach (HdrColorBin hcb in ap.BulkColors.Values)
		//            {
		//                int cUnits = (int)ap.GetAllocatedColorUnits(hcb.ColorCodeRID, _asrtCubeGroup.GetMasterProfileList(eProfileType.Store));
		//                ap.SetColorUnitsToAllocate(hcb.ColorCodeRID, cUnits);
		//                UpdateBulkColorQuantity(ap.Key, hcb.ColorCodeRID, cUnits);
		//                cUnitsTotal = cUnitsTotal + cUnits; //TT#443 - MD - DOConnell - After removing a header from the assortment there is a balance,  close and save assortment balance = 0, expect the balance to be 0 at the time it is removed.
		//            }
		//            UpdateBulkColorBalance(ap, cUnitsTotal); //TT#443 - MD - DOConnell - After removing a header from the assortment there is a balance,  close and save assortment balance = 0, expect the balance to be 0 at the time it is removed.
		//        }
		//    }
		//}
		//// END TT#489-MD - stodd -  headers in received out of balance status
		//END TT#575-MD - stodd - After a header is dropped onto a placeholder, both the placeholder and the header are in balance but it appears the Placeholder has too few units removed
        
        // Begin TT#2 - RMatelic Assortment Planning-Charge Intransit to headers attached to intransit placeholders 
        private void CheckPlaceholderIntransit(int aPlaceHolderRID)
        {
            try
            {
                if (!_placeholdersIntransit.Contains(aPlaceHolderRID))
                {
                    AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(aPlaceHolderRID);
                    if (ap.HeaderIntransitStatus != eHeaderIntransitStatus.NotIntransit)
                    {
                        _placeholdersIntransit.Add(aPlaceHolderRID);
                        // Begin TT#2 - RMatelic - Assortment Planning-charge intransit to headers attached to intransit placeholders
						// BEGIN TT#371-MD - stodd -  Velocity Interactive on Assortment
                        if (!_selectedHeaderList.Contains(aPlaceHolderRID))
                        {
							SelectedHeaderProfile selectedHeader = new SelectedHeaderProfile(aPlaceHolderRID);
							selectedHeader.HeaderType = eHeaderType.Placeholder;
							_selectedHeaderList.Add(selectedHeader);
                        }
						// END TT#371-MD - stodd -  Velocity Interactive on Assortment
                        // End TT#2
                    }
                }
            }
            catch
            {
                throw;
            }
        }
       
        // Begin TT#2 - RMatelic - Assortment Planning-charge intransit to headers attached to intransit placeholders
        private void UpdatePlaceholderAndHeaderIntransit()
        {
            try
            {
                int phRID = 0;
                if (_placeholdersIntransit.Count > 0)
                {
                    for (int i = 0; i < _placeholdersIntransit.Count; i++)
                    {
                        phRID = (int)_placeholdersIntransit[i];
                        UpdatePlaceholderAndHeaderIntransit(phRID);
                    }
                    _placeholdersIntransit.Clear();
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePlaceholderAndHeaderIntransit(int aPlaceHolderRID)
        {
            try
            {
                int action = (int)eAssortmentAllocationActionType.ChargeIntransit;
                ApplicationSessionTransaction actionTransaction = null;
                GeneralComponent aComponent = new GeneralComponent(eGeneralComponentType.Total);
                ApplicationBaseAction aMethod = _transaction.CreateNewMethodAction((eMethodType)action);
                aComponent = new GeneralComponent(eGeneralComponentType.Total);
                bool aReviewFlag = false;
                bool aUseSystemTolerancePercent = true;
                double aTolerancePercent = Include.DefaultBalanceTolerancePercent;
                int aStoreFilter = Include.AllStoreFilterRID;
                int aWorkFlowStepKey = -1;

                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(aPlaceHolderRID);
                if (ap.HeaderIntransitStatus != eHeaderIntransitStatus.NotIntransit)
                {
                    ap.Action(eAllocationMethodType.BackoutStyleIntransit, new GeneralComponent(eGeneralComponentType.Total), 0.0d, Include.NoRID, true);
                }
             
                ProcessAllocationMethod(ref actionTransaction, action, aComponent, aMethod, aReviewFlag, aUseSystemTolerancePercent, aTolerancePercent, aStoreFilter, aWorkFlowStepKey);

                if (actionTransaction == null)   // above action was not ok to process
                {
                    return;
                }
                // replace the _transaction headers with the updates from the action
				// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                //AllocationProfileList apl = (AllocationProfileList)actionTransaction.GetMasterProfileList(eProfileType.Allocation);
				AllocationProfileList apl = (AllocationProfileList)actionTransaction.GetMasterProfileList(eProfileType.AssortmentMember);
				// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                foreach (AllocationProfile ahp in apl)
                {
					// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                    //AllocationProfile allocProf = _transaction.GetAllocationProfile(ahp.Key);
					AllocationProfile allocProf = _transaction.GetAssortmentMemberProfile(ahp.Key);
					// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                    if (allocProf != null)
                    {
						// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                        //_transaction.RemoveAllocationProfile(allocProf);
                        //_transaction.AddAllocationProfile(ahp);
						_transaction.RemoveAssortmentMemberProfile(allocProf);
						_transaction.AddAssortmentMemberProfile(ahp);
						// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                        ReloadProfileToGrid(ahp.Key);
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
        private bool SetStoreAllocatedColorUnits(int aPlaceHolderRID, ArrayList aColorCodeList)
        {
            bool okToContinue = true;
            try
            {
                Cube myCube = _asrtCubeGroup.GetCube(eCubeType.AssortmentPlaceholderGradeTotal);
                //double cellValue = 0.0d;
                AssortmentCellReference asrtCellRef = new AssortmentCellReference((AssortmentPlaceholderGradeTotal)myCube);
                               
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(aPlaceHolderRID);
                AssortmentProfile asp = (AssortmentProfile)_allocProfileList.FindKey(ap.AsrtRID);
				ProfileList gradeList = asp.GetAssortmentStoreGrades();		// TT#488-MD - STodd - Group Allocation
                ProfileList sgll = _asrtCubeGroup.GetFilteredProfileList(eProfileType.StoreGroupLevel);
                ProfileList storeList = new ProfileList(eProfileType.Store);
                foreach (StoreGroupLevelProfile sglp in sgll.ArrayList)
                {
                    foreach (StoreGradeProfile sgp in gradeList.ArrayList)
                    {
                        ProfileList gradeStoreList = _asrtCubeGroup.GetStoresInSetGrade(sglp.Key, sgp.Key);

                        asrtCellRef[eProfileType.PlaceholderHeader] = aPlaceHolderRID;
                        asrtCellRef[eProfileType.StoreGroupLevel] = sglp.Key;
                        asrtCellRef[eProfileType.StoreGrade] = sgp.Key;
                        asrtCellRef[eProfileType.AssortmentDetailVariable] = _asrtCubeGroup.AssortmentComputations.AssortmentDetailVariables.VariableProfileList.FindKey((int)eAssortmentDetailVariables.TotalUnits).Key;
                        asrtCellRef[eProfileType.AssortmentQuantityVariable] = (int)eAssortmentQuantityVariables.Value;
                        int unitsToSpread = (int)asrtCellRef.CurrentCellValue;  //total units for set & grade
                       
                        storeList.Clear();
                        foreach (StoreProfile sp in gradeStoreList)
                        {
                            if (sp.Key != _transaction.ReserveStore.RID)
                            {
                                storeList.Add(sp);
                            }
                        }

                        ap.SpreadStoreAllocatedColorUnits(aColorCodeList, storeList, unitsToSpread, eDistributeChange.ToParent, false);		// TT#749-MD - Stodd - Assortment setting manually allocated to true
                    }
                }

                foreach (HdrColorBin aColor in ap.BulkColors.Values)
                {
                    double quantity = (double)ap.GetColorUnitsAllocated(aColor.ColorCodeRID);
                    UpdateBulkColorQuantity(aPlaceHolderRID, aColor.ColorCodeRID, quantity); 
                }
            }
            catch
            {
                okToContinue = false;
                throw;
            }
            return okToContinue;
        }    
        // End TT#1282

        private void UpdateQuantityFromAssortmentGrid(int aHeaderRID, int aPackRID, int aColorRID, double aQuantity)
        {
            try
            {
                // Begin TT#2 - RMatelic Assortment Planning-header packs not balancing >>> general fix unrelated to issue
                if (_addingHeaderToAssortment)
                {
                    return;
                }
                // End TT#2
                //BEGIN TT#489 - MD - DOConnell - After real headers are allocated the headers are then Received Out of Balance instead of Allocated Out of Balance 
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aHeaderRID)
                    {
                        // BEGIN TT#219 - stodd - quantity is changing on Header. It should not.
                        eHeaderType headerType = (eHeaderType)Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                        // Begin TT#2-Assortment Planning-header quantities zeroing out when other headers removed from assortment
                        if (_removingHeaderFromAssortment)
                        {
                            //BEGIN TT#489 - MD - DOConnell - After real headers are allocated the headers are then Received Out of Balance instead of Allocated Out of Balance 
                            //foreach (UltraGridRow row in ugDetails.Rows)
                            //{
                            //    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aHeaderRID)
                            //    {
                            //        eHeaderType headerType = (eHeaderType)Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                                    if (headerType != eHeaderType.Placeholder && headerType != eHeaderType.Assortment)
                                    {
                                        return;
                                    }
                            //    }
                            //}
                            //END TT#489 - MD - DOConnell - After real headers are allocated the headers are then Received Out of Balance instead of Allocated Out of Balance 
                        }
                        // End TT#2

                        //LoadContentGrid(); //TT#791 - MD - DOConnell - Assortment -> Content Tab-> does not stay collapsed after selected
						
                        if (aPackRID == int.MaxValue && aColorRID == int.MaxValue)   // Header or Placeholder Style
                        {
                            //BEGIN TT#489 - MD - DOConnell - After real headers are allocated the headers are then Received Out of Balance instead of Allocated Out of Balance 
                            //foreach (UltraGridRow row in ugDetails.Rows)
                            //{
                            //    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aHeaderRID)
                            //    {
                            //        // BEGIN TT#219 - stodd - quantity is changing on Header. It should not.
                            //        eHeaderType headerType = (eHeaderType)Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                                    if (headerType == eHeaderType.Placeholder)
                                    {
                                        row.Cells["HdrQuantity"].Value = aQuantity;
                                    }
                                    // END TT#219 - stodd - quantity is changing on Header. It should not.
                                    // Begin TT#2 - RMatelic - Assortment Planning - Matrix placeholder quantities not displaying correct values
                                    row.Cells["AllocatedUnits"].Value = aQuantity;
                                    // End TT#2
                                    // Begin TT#1737 - RMatelic - Assortment Contents-Delete Placeholder, get Foreign Key violation >>>> unrelated
                                    int asrtRID = Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                                    UpdateAssortmentQuantity(asrtRID);
                                    // End TT#1737
                                    break;
                            //    }
                            //}
                            //END TT#489 - MD - DOConnell - After real headers are allocated the headers are then Received Out of Balance instead of Allocated Out of Balance 
                        }
                        else if (aPackRID == int.MaxValue && aColorRID != int.MaxValue)
                        {
                            //BEGIN TT#489 - MD - DOConnell - After real headers are allocated the headers are then Received Out of Balance instead of Allocated Out of Balance 
                            if (headerType == eHeaderType.Placeholder)
                            {
                                UpdateBulkColorQuantity(aHeaderRID, aColorRID, aQuantity);
                            }
                            //END TT#489 - MD - DOConnell - After real headers are allocated the headers are then Received Out of Balance instead of Allocated Out of Balance 
                        }
                        else if (aPackRID != int.MaxValue && aColorRID == int.MaxValue)
                        {
                            //BEGIN TT#489 - MD - DOConnell - After real headers are allocated the headers are then Received Out of Balance instead of Allocated Out of Balance 
                            if (headerType == eHeaderType.Placeholder)
                            {
								UpdatePackQuantity(aHeaderRID, aPackRID, aQuantity);	// TT#665-MD - stodd - asst with placeholder and placeholder colors when input avg units in the matrix units not spread evenly to placeholder colors.
                            }
                            //END TT#489 - MD - DOConnell - After real headers are allocated the headers are then Received Out of Balance instead of Allocated Out of Balance 
                        }
                    }
                }
                //END TT#489 - MD - DOConnell - After real headers are allocated the headers are then Received Out of Balance instead of Allocated Out of Balance 
            }
            catch
            {
                throw;
            }
        }

        private void UpdateBulkColorQuantity(int aHeaderRID, int aColorRID, double aQuantity)
        {
            try
            {
                IEnumerable enumerator = ugDetails.DisplayLayout.Bands["BulkColor"].GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aHeaderRID
                      && Convert.ToInt32(row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture) == aColorRID)
                    {
                        row.Cells["Quantity"].Value = aQuantity;
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

		//BEGIN TT#666-MD - stodd - Post-Receipt Assortment - last header added is automatically allocated
		private void UpdateStatusColumn(int aHeaderRID, eHeaderAllocationStatus aStatus)
		{
			try
			{
                // Begin TT#1266-MD - stodd - After typing in units on matrix grid, header still shows status of “Received in Balance” on content grid
                //if (ugDetails.DisplayLayout.Bands.Contains("Header"))
                if (DoesGridContainBand("Header"))
                // End TT#1266-MD - stodd - After typing in units on matrix grid, header still shows status of “Received in Balance” on content grid
                {
                    IEnumerable enumerator = ugDetails.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
                    foreach (UltraGridRow row in enumerator)
                    {
                        if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aHeaderRID)
                        {
                            row.Cells["Status"].Value = (int)aStatus;
                            break;
                        }
                    }
                }
			}
			catch
			{
				throw;
			}
		}
		//END TT#666-MD - stodd - Post-Receipt Assortment - last header added is automatically allocated

        // Begin TT#1266-MD - stodd - After typing in units on matrix grid, header still shows status of “Received in Balance” on content grid
        private bool DoesGridContainBand(string searchBand)
        {
            bool contains = false;

            foreach (UltraGridBand aBand in ugDetails.DisplayLayout.Bands)
            {
                if (aBand.Key == searchBand)
                {
                    contains = true;
                    break;
                }
            }
            return contains;
        }
        // End TT#1266-MD - stodd - After typing in units on matrix grid, header still shows status of “Received in Balance” on content grid

		//BEGIN TT#443 - MD - DOConnell - After removing a header from the assortment there is a balance,  close and save assortment balance = 0, expect the balance to be 0 at the time it is removed.
        private void UpdateBulkColorBalance(AllocationProfile ap, double aQuantity)
        {
            try
            {
                IEnumerable enumerator = ugDetails.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == ap.Key)
                    {
                        row.Cells["Balance"].Value = ap.TotalUnitsAllocated - aQuantity;
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
        }
		//END TT#443 - MD - DOConnell - After removing a header from the assortment there is a balance,  close and save assortment balance = 0, expect the balance to be 0 at the time it is removed.
        private void UpdatePackQuantity(int aHeaderRID, int aPackRID, double aQuantity)
        {
            try
            {
                IEnumerable enumerator = ugDetails.DisplayLayout.Bands["Pack"].GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aHeaderRID
                      && Convert.ToInt32(row.Cells["KeyP"].Value, CultureInfo.CurrentUICulture) == aPackRID)
                    {
						//BEGIN TT#665-MD - stodd - asst with placeholder and placeholder colors when input avg units in the matrix units not spread evenly to placeholder colors.
						int qtyPerPack = 1;
						if (row.Cells["QuantityPerPack"] != null)
						{
							qtyPerPack = Convert.ToInt32(row.Cells["QuantityPerPack"].Value);
							if (qtyPerPack < 1)
							{
								qtyPerPack = 1;
							}
						}
                        row.Cells["TotalQuantity"].Value = aQuantity;
						row.Cells["TotalPacks"].Value = aQuantity / qtyPerPack;
						//END TT#665-MD - stodd - asst with placeholder and placeholder colors when input avg units in the matrix units not spread evenly to placeholder colors.
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAssortmentQuantity(int aAsrtRID)
        {
            try
            {
                int asrtQty = 0;
                UltraGridRow asrtRow = null;
              
                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aAsrtRID)
                    {
                        asrtRow = row;  // save assortment row
                    }
                    else if (row.Cells["AsrtRID"].Value != DBNull.Value && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == aAsrtRID)
                    {
                        asrtQty += Convert.ToInt32(row.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }
                if (asrtRow != null)
                {
                    asrtRow.Cells["HdrQuantity"].Value = asrtQty;   // update assortment row
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAnchorNodeTable(UltraGridRow aRow)
        {
            try
            {
                int phStyleRID, oldAnchorRID, newAnchorRID;

                phStyleRID = Convert.ToInt32(aRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                if (_anchorNodes.Rows.Contains(phStyleRID))
                {
                    _anchorNodes.Rows.Remove(_anchorNodes.Rows.Find(phStyleRID));
                }

                oldAnchorRID = Convert.ToInt32(aRow.Cells["AnchorHnRID"].OriginalValue, CultureInfo.CurrentUICulture);
                newAnchorRID = Convert.ToInt32(aRow.Cells["AnchorHnRID"].Value, CultureInfo.CurrentUICulture);
                _anchorNodes.Rows.Add(new object[] { phStyleRID, oldAnchorRID, newAnchorRID });
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAssortmentID(string aOldID, string aNewID)
        {
            try
            {
                foreach (DataRow dRow in _assortments.Rows)
                {
                    if (dRow["AssortmentID"].ToString() == aOldID)
                    {
                        dRow["AssortmentID"] = aNewID;
                        break;
                    }
                }
                _assortments.AcceptChanges();
                ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Clear();
                foreach (DataRow mRow in _assortments.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Add(Convert.ToInt32(mRow["AsrtRID"], CultureInfo.CurrentUICulture), mRow["AssortmentID"].ToString());
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePlaceholderID(int aPhRID, string aNewID, string aHeaderID)
        {
            try
            {
                foreach (DataRow dRow in _placeHolders.Rows)
                {
                    if (Convert.ToInt32(dRow["PlaceHolderRID"], CultureInfo.CurrentUICulture) == aPhRID)
                    {
                        if (aNewID == null || aNewID.Trim() == string.Empty)
                        {
                            dRow["PlaceHolderID"] = aHeaderID;
                        }
                        else
                        {
                            dRow["PlaceHolderID"] = aNewID;
                        }
                        break;
                    }
                }
                _placeHolders.AcceptChanges();
                ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Clear();
                foreach (DataRow mRow in _placeHolders.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Add(Convert.ToInt32(mRow["PlaceHolderRID"], CultureInfo.CurrentUICulture), mRow["PlaceHolderID"].ToString());
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAssortmentKeys(int aOldRID, int aNewRID)
        {
            try
            {
                foreach (DataRow dRow in _assortments.Rows)
                {
                    if ((int)dRow["AsrtRID"] == aOldRID)
                    {
                        dRow["AsrtRID"] = aNewRID;
                        break;
                    }
                }
                _assortments.AcceptChanges();
                ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Clear();
                foreach (DataRow dr in _assortments.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Add(Convert.ToInt32(dr["AsrtRID"], CultureInfo.CurrentUICulture), dr["AssortmentID"].ToString());
                }

                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (row.Cells["AsrtRID"].Value != DBNull.Value &&
                         Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == aOldRID)
                    {
                        row.Cells["AsrtRID"].Value = aNewRID;
                        row.Cells["AsrtRIDSortCol"].Value = aNewRID;
                        row.Update();
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePlaceholderKeys(int aOldRID, int aNewRID)
        {
            try
            {
                foreach (DataRow dRow in _placeHolders.Rows)
                {
                    if ((int)dRow["PlaceHolderRID"] == aOldRID)
                    {
                        dRow["PlaceHolderRID"] = aNewRID;
                        break;
                    }
                }
                _placeHolders.AcceptChanges();
                ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Clear();
                foreach (DataRow dr in _placeHolders.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Add(Convert.ToInt32(dr["PlaceHolderRID"], CultureInfo.CurrentUICulture), dr["PlaceHolderID"].ToString());
                }

                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (row.Cells["PlaceHolderRID"].Value != DBNull.Value &&
                         Convert.ToInt32(row.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == aOldRID)
                    {
                        row.Cells["PlaceHolderRID"].Value = aNewRID;
                        row.Cells["PlaceHolderRIDSortCol"].Value = aNewRID;
                        row.Update();
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePackData(CellEventArgs e)
        {
            try
            {
                string errorMessage, packName;
               
                AllocationProfile ap = GetAllocationProfile(Convert.ToInt32(e.Cell.Row.ParentRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));

                packName = e.Cell.Row.Cells["Pack"].Value.ToString();
                errorMessage = string.Empty;
               
                if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                {
                    MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
               
                switch (e.Cell.Column.Key)
                {
                    case "Pack":
                        if (!ap.PackIsOnHeader(e.Cell.Row.Cells["Pack"].OriginalValue.ToString()))
                        {
                            if (!ap.PackIsOnHeader(packName))
                            {  
                                if (!ap.MultiHeader)
                                {
                                    ap.AddPack(packName,
                                            (eAllocationType)Convert.ToInt32(e.Cell.Row.Cells["PackType"].Value, CultureInfo.CurrentUICulture),
                                            Convert.ToInt32(e.Cell.Row.Cells["QuantityPerPack"].Value, CultureInfo.CurrentUICulture),
                                            Convert.ToInt32(e.Cell.Row.Cells["TotalPacks"].Value, CultureInfo.CurrentUICulture),
                                            -1);
                                    // set pack key
                                    e.Cell.Row.Cells["KeyP"].Value = ap.Packs.Count * -1;
                                }
                                else
                                {
                                    UltraGridRow row = e.Cell.Row.GetSibling(SiblingRow.First, false);
                                    int packCount = 0;
                                    while (row != null)
                                    {
                                        packCount++;
                                        row = row.GetSibling(SiblingRow.Next, false);
                                    }
                                    // set pack key
                                    e.Cell.Row.Cells["KeyP"].Value = packCount * -1;
                                }
                            }  
                        }
                        else
                        {
                            ap.SetPackName(e.Cell.OriginalValue.ToString(), packName);
                        }
                        //AddToAssortmentTab(ugDetails.ActiveRow);
                        if (!_addingHeaderToAssortment)
                        { 
                            //SaveAndUpdateAssortmentTab();
                            OnAssortmentSaveHeaderData(null);	// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                        }
                        break;

                    case "PackType":
                        // Begin TT#2101 - RMatelic - Defined and Saved Assortment.  The PhStyle 1 row is 5010 units.  I created a Header for 4920 units (Detail 6 ppk). Results for balance is not as expected.
                        if (_addingHeaderToAssortment)
                        {
                            return;
                        }
                        // End TT#2101
                        if (!PackNameEntered(e.Cell.Row))
                        {
                            return;
                        }
                        else
                        {   
                            if (!ap.MultiHeader)
                            {
                                ap.SetPackGeneric(packName, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture) == (int)eAllocationType.GenericType);
                            }
                        }    
                        break;
                    case "TotalPacks":
                        if (_skipEdit)
                        {
                            _skipEdit = false;
                            return;
                        }
                        if (!PackNameEntered(e.Cell.Row))
                        {
                            return;
                        }
                        else
                        {    
                            if (!ap.MultiHeader)
                            {
								//BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                                //ap.SetPacksToAllocate(packName, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
								//END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                            }
                        }     
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                        break;

                    case "QuantityPerPack":
                        if (_skipEdit)
                        {
                            _skipEdit = false;
                            return;
                        }
                        if (!PackNameEntered(e.Cell.Row))
                        {
                            return;
                        }
                        else
                        {    
                            if (!ap.MultiHeader)
                            {
                                ap.SetPackMultiple(packName, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                            }
                        }    
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                        break;

                    case "AssociatedPackRID":
                        if (!ap.MultiHeader)
                        {
                            ap.SetAssociatedPackRID(packName, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                        }
                        break;

                    default:
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePackColorData(CellEventArgs e)
        {
            try
            {
                int colorHnRID, prevColorCodeRID = Include.NoRID;
                ColorCodeProfile ccp;
                ColorCodeProfile ccpOrig;
                EditMsgs em;
                string errorMessage;
                int headerRID = Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
               
                AllocationProfile ap = GetAllocationProfile(headerRID);


                UltraGridRow hdrRow = e.Cell.Row.ParentRow;
                while (hdrRow.Band.Key != "Header")
                {
                    hdrRow = hdrRow.ParentRow;
                }
                int styleHnRID = Convert.ToInt32(hdrRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
               
                string packName = Convert.ToString(e.Cell.Row.ParentRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture).Trim();
                string packColor = Convert.ToString(e.Cell.Row.Cells["PackColor"].Value, CultureInfo.CurrentUICulture).Trim();
                string packColorDescription = Convert.ToString(e.Cell.Row.Cells["Description"].Value, CultureInfo.CurrentUICulture).Trim();

                if (e.Cell.Row.Cells["ColorCodeRID"].Value != DBNull.Value)
                {
                    prevColorCodeRID = Convert.ToInt32(e.Cell.Row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                }

                ccp = _sab.HierarchyServerSession.GetColorCodeProfile(packColor);

                switch (e.Cell.Column.Key)
                {
                    case "PackColor":
                        string origValue = e.Cell.Row.Cells["PackColor"].OriginalValue.ToString();

                        if (ccp.Key == Include.NoRID)
                        {
                            // color doesn't exist, need to add it
                            ccp.ColorCodeID = packColor;

                            if (packColorDescription.Trim() != string.Empty)
                            {
                                ccp.ColorCodeName = packColorDescription;
                            }
                            else
                            {
                                ccp.ColorCodeName = packColor;
                                packColorDescription = packColor;
                            }
                            ccp.ColorCodeChangeType = eChangeType.add;
                            ccp = _sab.HierarchyServerSession.ColorCodeUpdate(ccp);
                            e.Cell.Row.Cells["IsNewColor"].Value = true;
                            e.Cell.Row.Cells["Description"].Value = packColorDescription;
                        }
                        else if (packColorDescription.Trim() == string.Empty || packColor != origValue)
                        {
                            if (!ccp.VirtualInd)
                            {

                                colorHnRID = Include.NoRID;
                                HierarchyNodeProfile hnp_style = _sab.HierarchyServerSession.GetNodeData(styleHnRID);
                                if (_sab.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
                                {
                                    HierarchyNodeProfile hnp_color = _sab.HierarchyServerSession.GetNodeData(colorHnRID);
                                    packColorDescription = hnp_color.NodeDescription;
                                }
                                else
                                {
                                    packColorDescription = ccp.ColorCodeName;
                                }
                                e.Cell.Row.Cells["Description"].Value = packColorDescription;
                            }
                            else
                            {
                                packColorDescription = ccp.ColorCodeName;
                            }
                        }
                        // now add it to the hierarchy -- probably need to move this to the save
                        if (packColor != string.Empty &&
                            packColorDescription != string.Empty && !ccp.VirtualInd)
                        {
                            em = new EditMsgs();
                            //colorHnRID = _hierMaint.QuickAdd(ref em, ahp.StyleHnRID, packColor, packColorDescription);
                            if (em.ErrorFound)
                            {
                                DisplayMessages.Show(em, _sab, _windowName);
                            }
                        }

                        if (e.Cell.Row.Cells["PackColor"].OriginalValue.ToString() == string.Empty)
                        {
                            // finally, add it to the pack

                            if (!ap.MultiHeader)
                            {
                                ap.AddColorToPack(packName, ccp.Key,
                                Convert.ToInt32(e.Cell.Row.Cells["QuantityPerPack"].Value, CultureInfo.CurrentUICulture), 0);
                            }
                            e.Cell.Row.Cells["ColorCodeRID"].Value = ccp.Key;

                            if (!ap.MultiHeader)
                            {
                                PackHdr aPack = ap.GetPackHdr(packName);
                                e.Cell.Row.Cells["KeyC"].Value = aPack.PackColors.Count * -1;
                            }
                            else
                            {
                                UltraGridRow row = e.Cell.Row.GetSibling(SiblingRow.First, false);
                                int pcCount = 0;
                                while (row != null)
                                {
                                    pcCount++;
                                    row = row.GetSibling(SiblingRow.Next, false);
                                }
                                // set pack key
                                e.Cell.Row.Cells["KeyC"].Value = pcCount * -1;
                            }

                            if (ccp.VirtualInd)
                            {
                                ap.SetPackColorName(packName, ccp.Key, packColor);
                                e.Cell.Row.Cells["Description"].Value = packColorDescription;
                            }
                        }
                        else
                        {
                            if (prevColorCodeRID == Include.NoRID)
                            {
                                ccpOrig = _sab.HierarchyServerSession.GetColorCodeProfile(e.Cell.OriginalValue.ToString());
                                ap.SetPackColorCodeRID(packName, ccpOrig.Key, ccp.Key);
                            }
                            else
                            {
                                ap.SetPackColorCodeRID(packName, prevColorCodeRID, ccp.Key);
                            }
                            e.Cell.Row.Cells["ColorCodeRID"].Value = ccp.Key;
                            if (!ccp.VirtualInd)
                            {
                                ap.SetPackColorName(packName, ccp.Key, null);
                                ap.SetPackColorDescription(packName, ccp.Key, null);
                            }
                            else
                            {
                                ap.SetPackColorName(packName, ccp.Key, packColor);
                                e.Cell.Row.Cells["Description"].Value = packColorDescription;
                            }
                        }
                        e.Cell.Row.Cells["IsVirtual"].Value = ccp.VirtualInd;
                        if (_addingMTColorRow)
                        {
                            _addingMTColorRow = false;
                            //SaveAndUpdateAssortmentTab();
                            OnAssortmentSaveHeaderData(null);	// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                        }
                        break;

                    case "Description":
                        if (ccp.Key != Include.NoRID)
                        {
                            if (!ccp.VirtualInd)
                            {
                                em = new EditMsgs();
                                colorHnRID = Include.NoRID;
                                HierarchyNodeProfile hnp_style = _sab.HierarchyServerSession.GetNodeData(styleHnRID);
                                if (_sab.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
                                {
                                    HierarchyNodeProfile hnp_color = _sab.HierarchyServerSession.GetNodeData(colorHnRID);
                                    hnp_color.NodeDescription = packColorDescription;
                                    hnp_color.NodeChangeType = eChangeType.update;
                                    _hierMaint.ProcessNodeProfileInfo(ref em, hnp_color);
                                }
                                if (Convert.ToBoolean(e.Cell.Row.Cells["IsNewColor"].Value, CultureInfo.CurrentUICulture) == true
                                    && packColorDescription.Trim() != ccp.ColorCodeName)
                                {
                                    ccp.ColorCodeName = packColorDescription;
                                    ccp.ColorCodeChangeType = eChangeType.update;
                                    ccp = _sab.HierarchyServerSession.ColorCodeUpdate(ccp);
                                    e.Cell.Row.Cells["IsNewColor"].Value = false;
                                }
                            }
                            else       // Placeholder color
                            {
                                ap.SetPackColorDescription(packName, ccp.Key, packColorDescription);
                            }
                        }
                        break;

                    case "QuantityPerPack":
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                        {
                            MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }

                        if (!ap.MultiHeader)
                        {
                            ap.SetColorUnitsInPack(packName, ccp.Key, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                        }
                         
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                        break;

                    default:
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch
            {
                throw;
            }
        }

        private void UpdateBulkColorData(CellEventArgs e)
        {
            try
            {
                int colorHnRID;
                ColorCodeProfile ccp;
                ColorCodeProfile ccpOrig;
                EditMsgs em;
                string errorMessage;
                int headerRID, prevColorCodeRID = Include.NoRID;
                headerRID = Convert.ToInt32(e.Cell.Row.ParentRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
              
                AllocationProfile ap = GetAllocationProfile(headerRID);

                string bulkColor = Convert.ToString(e.Cell.Row.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture).Trim();
                string bulkDescription = Convert.ToString(e.Cell.Row.Cells["Description"].Value, CultureInfo.CurrentUICulture).Trim();

                if (e.Cell.Row.Cells["ColorCodeRID"].Value != DBNull.Value)
                {
                    prevColorCodeRID = Convert.ToInt32(e.Cell.Row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                }

                ccp = _sab.HierarchyServerSession.GetColorCodeProfile(bulkColor);

				// Begin TT#1562-MD - stodd - Type in a color over a PH color go to add the Bulk size and receive a warning "color not defined for bulk.
                bool bulkColorColumnChanged = _isColorChanging;   // TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, not reflected on other tabs 
				// End TT#1562-MD - stodd - Type in a color over a PH color go to add the Bulk size and receive a warning "color not defined for bulk.
				
                switch (e.Cell.Column.Key)
                {
                    case "BulkColor":
						// Begin TT#1454-MD - stodd - Asst-Contents tab Add a Place holder color to an Assortment ID on contents tab and the quantity goes to zero for the line. 
                        if (prevColorCodeRID != -1 && prevColorCodeRID != ccp.Key || _addingMTColorRow)		// TT#1465-MD - stodd - new color row not showing up on matrix grid
                        {
                            bulkColorColumnChanged = true; // TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, not reflected on other tabs 
                        }
						// End TT#1454-MD - stodd - Asst-Contents tab Add a Place holder color to an Assortment ID on contents tab and the quantity goes to zero for the line. 
                        string origValue = Convert.ToString(e.Cell.Row.Cells["BulkColor"].OriginalValue, CultureInfo.CurrentUICulture);
                        if (ccp.Key == Include.NoRID)
                        {
                            // color doesn't exist, need to add it
                            ccp.ColorCodeID = bulkColor;
                            ccp.ColorCodeName = bulkColor;
                            bulkDescription = bulkColor;

                            e.Cell.Row.Cells["Description"].Value = bulkDescription;

                            if (!Convert.ToBoolean(e.Cell.Row.Cells["IsVirtual"].Value, CultureInfo.CurrentUICulture))
                            {
                                ccp.ColorCodeChangeType = eChangeType.add;
                                ccp = _sab.HierarchyServerSession.ColorCodeUpdate(ccp);
                            }
                            e.Cell.Row.Cells["IsNewColor"].Value = true;
                        }
                        else if (bulkDescription.Trim() == string.Empty || bulkColor != origValue)
                        {
                            if (!ccp.VirtualInd)
                            {
                                colorHnRID = Include.NoRID;
                                HierarchyNodeProfile hnp_style = _sab.HierarchyServerSession.GetNodeData(ap.StyleHnRID);
                                if (_sab.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
                                {
                                    HierarchyNodeProfile hnp_color = _sab.HierarchyServerSession.GetNodeData(colorHnRID);
                                    bulkDescription = hnp_color.NodeDescription;
                                }
                                else
                                {
                                    bulkDescription = ccp.ColorCodeName;
                                }
								// Begin TT#1426-MD - stodd - New Placeholder colors do not show up on Matrix tab
								// Caused looping when adding colors and was not neccessary
                                //e.Cell.Row.Cells["BulkColor"].Value = bulkColor;	// TT#1410-MD - stodd - Adding a header to a placeholder with placeholder colors(s) defined sometimes gets a "Color not defined for Bulk" error.
								// End TT#1426-MD - stodd - New Placeholder colors do not show up on Matrix tab
                                _isColorChanging = true;	// TT#1562-MD - stodd - Type in a color over a PH color go to add the Bulk size and receive a warning "color not defined for bulk.
                                e.Cell.Row.Cells["Description"].Value = bulkDescription;
                                _isColorChanging = false;	// TT#1562-MD - stodd - Type in a color over a PH color go to add the Bulk size and receive a warning "color not defined for bulk.
                            }
                            else
                            {
                                bulkDescription = ccp.ColorCodeName;
                            }
                        }
                        // now add it to the hierarchy -- probably need to move this to the save
                        if (bulkColor != string.Empty &&
                            bulkDescription != string.Empty && !ccp.VirtualInd)
                        {
                            em = new EditMsgs();
                            colorHnRID = _hierMaint.QuickAdd(ref em, ap.StyleHnRID, bulkColor, bulkDescription);
                            if (em.ErrorFound)
                            {
                                DisplayMessages.Show(em, _sab, _windowName);
                                return;
                            }
                        }

                        if (e.Cell.OriginalValue.ToString() == string.Empty)
                        {
                            // finally, add it to the header
                            //BEGIN TT#619 - MD - DOConnell - Added a color to a placeholder using the bulk color empty row and receive a warning  message :  Color Units to allocate is calculated when header is Work Up Bulk Color Buy.
							//ap.AddBulkColor(ccp.Key,
							//Convert.ToInt32(e.Cell.Row.Cells["Quantity"].Value, CultureInfo.CurrentUICulture), 0);
							ap.AddBulkColor(ccp.Key, 0, 0);
                            //END TT#619 - MD - DOConnell - Added a color to a placeholder using the bulk color empty row and receive a warning  message :  Color Units to allocate is calculated when header is Work Up Bulk Color Buy.
                            e.Cell.Row.Cells["KeyH"].Value = ap.Key;
                            e.Cell.Row.Cells["ColorCodeRID"].Value = ccp.Key;
                            e.Cell.Row.Cells["KeyC"].Value = ap.BulkColors.Count * -1;
                            if (ccp.VirtualInd)
                            {
                                ap.SetBulkColorName(ccp.Key, bulkColor);
                                e.Cell.Row.Cells["Description"].Value = bulkDescription;
                            }
                        }
                        else
                        {
                            UltraGridRow headerRow = e.Cell.Row.ParentRow;
                            bool bypassChecks = AllowPlaceholderUpdate(headerRow);
                            if (prevColorCodeRID == Include.NoRID)
                            {
                                ccpOrig = _sab.HierarchyServerSession.GetColorCodeProfile(e.Cell.OriginalValue.ToString());
                                ap.SetBulkColorCodeRID(ccpOrig.Key, ccp.Key, bypassChecks);
                            }
                            else
                            {
                                ap.SetBulkColorCodeRID(prevColorCodeRID, ccp.Key, bypassChecks);
                            }
                            e.Cell.Row.Cells["ColorCodeRID"].Value = ccp.Key;
                            if (!ccp.VirtualInd)
                            {
                                ap.SetBulkColorName(ccp.Key, null);
                                ap.SetBulkColorDescription(ccp.Key, null);
                            }
                            else
                            {
                                ap.SetBulkColorName(ccp.Key, bulkColor);
                                e.Cell.Row.Cells["Description"].Value = bulkDescription;
                            }
                        }
                        e.Cell.Row.Cells["IsVirtual"].Value = ccp.VirtualInd;
                        if (_addingMTColorRow)
                        {
                            // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
							//BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                            //ap.SetColorUnitsToAllocate(ccp.Key, Convert.ToInt32(e.Cell.Row.Cells["Quantity"].Value, CultureInfo.CurrentUICulture));
							//END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                            ArrayList colorCodeList = new ArrayList();
                            colorCodeList.Add(ccp.Key);
                            if (!e.Cell.Row.HasPrevSibling(false) && !e.Cell.Row.HasNextSibling(false))
                            {
                                SetStoreAllocatedColorUnits(ap.Key, colorCodeList);
                            }
                            //End TT#1282

                            _addingMTColorRow = false;
                            //SaveAndUpdateAssortmentTab();
                            OnAssortmentSaveHeaderData(null);	// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                        }
                        // Begin TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, does not change the style
                        //     and Placeholder ID on the Assortment and Characteristics tab unless you save and close the Assorment and go back in to the Assortment 
                        else
                        {
                            _buildProductCharsGrid = true;
                            UpdateAssortmentTabColor(ap.Key, ap.StyleHnRID, prevColorCodeRID, ccp.Key, bulkDescription);
                            e.Cell.Band.Columns["BulkColor"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
                            e.Cell.Band.Columns["Description"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);                           
                        }
                        // End TT#1613
	
						// Begin TT#1561-MD - stodd - drag/drop a PPK header to a place holder and receive a null reference exception
                        if (bulkColorColumnChanged && !IsPostReceiptAssortment())
                        {
                            UpdateData(true, true);
                        }
						// End TT#1561-MD - stodd - drag/drop a PPK header to a place holder and receive a null reference exception
                        break;

                    case "Description":
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                        {
                            MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }

                        if (ccp.Key != Include.NoRID)
                        {
                            if (!ccp.VirtualInd)
                            {
                                em = new EditMsgs();
                                colorHnRID = Include.NoRID;
                                HierarchyNodeProfile hnp_style = _sab.HierarchyServerSession.GetNodeData(ap.StyleHnRID);
                                if (_sab.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
                                {
                                    HierarchyNodeProfile hnp_color = _sab.HierarchyServerSession.GetNodeData(colorHnRID);
                                    hnp_color.NodeDescription = bulkDescription;
                                    hnp_color.NodeChangeType = eChangeType.update;
                                    _hierMaint.ProcessNodeProfileInfo(ref em, hnp_color);
                                }
                                if (Convert.ToBoolean(e.Cell.Row.Cells["IsNewColor"].Value, CultureInfo.CurrentUICulture)
                                 && bulkDescription.Trim() != ccp.ColorCodeName)
                                {
                                    ccp.ColorCodeName = bulkDescription;
                                    ccp.ColorCodeChangeType = eChangeType.update;
                                    ccp = _sab.HierarchyServerSession.ColorCodeUpdate(ccp);
                                    e.Cell.Row.Cells["IsNewColor"].Value = false;
                                }
                            }
                            else       // Placeholder color
                            {
                                ap.SetBulkColorDescription(ccp.Key, bulkDescription);
                            }
                        }
                        // Begin TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, not reflected on other tabs 
                        if (!bulkColorColumnChanged)  // only description changed
                        {
                            UpdateAssortmentTabColor(ap.Key, ap.StyleHnRID, ccp.Key, ccp.Key, bulkDescription);
                            UpdateCharacteristicColorDescription(ap.StyleHnRID, ccp.Key, bulkDescription);
                            e.Cell.Band.Columns["Description"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand); 
                        }
                        // End TT#1613
                        break;

                    case "Quantity":
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                        {
                            MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }
                        // Multi header totals get calculated in AllocationProfile
                        if (!ap.MultiHeader)
                        {
                            // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                            if (!_addingMTColorRow)
                            {
								//BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                                //ap.SetColorUnitsToAllocate(ccp.Key, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
								//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
                                // Begin TT#1549-MD - stodd - unning size need on a PH sizes are out of Balance, not expected.  Select Balance to Reserve sizes are allocated out of Balance.  Close and reopne asst and the PH is all in Balance.
                                ProfileList aStoreList = _asrtCubeGroup.GetMasterProfileList(eProfileType.Store);
                                int colorAllocated = (int)ap.GetAllocatedColorUnits(ccp.Key, aStoreList);
                                if (colorAllocated != Convert.ToInt32(e.Cell.Value))
                                {
                                    AllocatePlaceholderColor(ap, ccp.Key, Convert.ToInt32(e.Cell.Value));   // TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
                                }
                                // End TT#1549-MD - stodd - unning size need on a PH sizes are out of Balance, not expected.  Select Balance to Reserve sizes are allocated out of Balance.  Close and reopne asst and the PH is all in Balance.
								//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
								//END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                            }
                            // End TT#1282
                        }
                        // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                        //CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                        if (!_addingMTColorRow)
                        {
                            CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                        }
                        // End TT#1282
                        break;

                    case "AsrtBCRID":
                        if (ap != null)
                        {
                            int bcRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                            if (bcRID != 0)
                            {
                                ap.SetAsrtBCRID(ccp.Key, bcRID);
                            }
                        }
                        break;

                    default:
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch
            {
                throw;
            }
        }

		//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
		/// <summary>
		/// Allocate a placeholder color using the total component as the basis.
		/// </summary>
		/// <param name="ap"></param>
		/// <param name="colorCodeRid"></param>
		/// <param name="units"></param>
		private void AllocatePlaceholderColor(AllocationProfile ap, int colorCodeRid, int units)	// TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
		{
			Index_RID storeIndexRID;
			//HdrColorBin aColor = ap.GetHdrColorBin(colorCodeRid);
			ProfileList aStoreList = _asrtCubeGroup.GetMasterProfileList(eProfileType.Store);
			//ap.SetAllocatedColorUnits(colorCodeRid, aStoreList, units);
			List<Index_RID> storeIndexRIDArray = new List<Index_RID>(aStoreList.Count);
			for (int s = 0; s < aStoreList.Count; s++)
			{
				StoreProfile sp = (StoreProfile)aStoreList.ArrayList[s];
				// BEGIN TT#640-MD -Drag-Drop a header with a single color to a place holder with a single color allocates to the reserve store
				if (sp.Key != _transaction.ReserveStore.RID)
				{
					storeIndexRID = this._transaction.StoreIndexRID(sp.Key);
					storeIndexRIDArray.Add(storeIndexRID);
				}
				// END TT#640-MD -Drag-Drop a header with a single color to a place holder with a single color allocates to the reserve store
			}

			MIDException ex = null;
			GeneralComponent totalComponent = new GeneralComponent(eGeneralComponentType.Total);
			//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
			//RuleBasedAllocation ruleAlloc = new RuleBasedAllocation(_transaction);
			//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
			RuleAllocationProfile ruleAllocProfile = new RuleAllocationProfile(_transaction, ap.Key, totalComponent, 1, true);

			AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorCodeRid);
			//GeneralComponent color = new GeneralComponent(eGeneralComponentType.DetailType);
			ruleAllocProfile = new RuleAllocationProfile(_transaction, ap.Key, totalComponent, 1, true);
			//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
			_transaction.RuleBasedAllocation.CalculateProportionalAllocation(storeIndexRIDArray, ap, totalComponent, units, ap, colorComponent, ref ruleAllocProfile, out ex);
			//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
			foreach (Index_RID aStoreIdx in storeIndexRIDArray)
			{
				int qty = ruleAllocProfile.GetStoreQtyAllocatedByRule(aStoreIdx.RID);
				ap.SetStoreQtyAllocated(colorCodeRid, aStoreIdx.RID, qty, eDistributeChange.ToParent, false);	// TT#749-MD - Stodd - Assortment setting manually allocated to true
			}
		}
		//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 

        // Begin TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.
        /// <summary>
        /// Allocate a placeholder pack using the total component as the basis.
        /// </summary>
        private void AllocatePlaceholderPack(AllocationProfile ap, string packName, int multiple, int units)
        {
            Index_RID storeIndexRID;
            ProfileList aStoreList = _asrtCubeGroup.GetMasterProfileList(eProfileType.Store);
            List<Index_RID> storeIndexRIDArray = new List<Index_RID>(aStoreList.Count);
            for (int s = 0; s < aStoreList.Count; s++)
            {
                StoreProfile sp = (StoreProfile)aStoreList.ArrayList[s];
                if (sp.Key != _transaction.ReserveStore.RID)
                {
                    storeIndexRID = this._transaction.StoreIndexRID(sp.Key);
                    storeIndexRIDArray.Add(storeIndexRID);
                }
            }

            MIDException ex = null;
            GeneralComponent totalComponent = new GeneralComponent(eGeneralComponentType.Total);
            RuleAllocationProfile ruleAllocProfile = new RuleAllocationProfile(_transaction, ap.Key, totalComponent, 1, true);

            AllocationPackComponent packComponent = new AllocationPackComponent(packName);
            ruleAllocProfile = new RuleAllocationProfile(_transaction, ap.Key, totalComponent, 1, true);
            _transaction.RuleBasedAllocation.CalculateProportionalAllocation(storeIndexRIDArray, ap, totalComponent, units, ap, packComponent, ref ruleAllocProfile, out ex);
            foreach (Index_RID aStoreIdx in storeIndexRIDArray)
            {
                int qty = ruleAllocProfile.GetStoreQtyAllocatedByRule(aStoreIdx.RID);
                ap.SetStoreQtyAllocated(packName, aStoreIdx, qty, eDistributeChange.ToParent, false);
            }
        }

        private void AllocatePlaceholderPack(AllocationProfile ap, int remainingUnits)
        {
            int col;
            List<int> aRowTotalList = new List<int>();	// Stores
            List<int> aColTotalList = new List<int>();	// Colors and packs

            // Setup Constraints
            ConstraintBin[,] constraints = null;
            bool unitsWereSpread = false;
            MIDException aMIDException;

            Index_RID storeIndexRID;
            ProfileList aStoreList = _asrtCubeGroup.GetMasterProfileList(eProfileType.Store);
            List<Index_RID> storeIndexRIDArray = new List<Index_RID>(aStoreList.Count);
            for (int s = 0; s < aStoreList.Count; s++)
            {
                StoreProfile sp = (StoreProfile)aStoreList.ArrayList[s];
                if (sp.Key != _transaction.ReserveStore.RID)
                {
                    storeIndexRID = this._transaction.StoreIndexRID(sp.Key);
                    storeIndexRIDArray.Add(storeIndexRID);
                }
            }

            for (int s = 0; s < storeIndexRIDArray.Count; s++)
            {
                Index_RID storeIndex = storeIndexRIDArray[s];
                aRowTotalList.Add(ap.GetStoreQtyAllocated(eAllocationSummaryNode.Total, storeIndex.RID));
            }

            aColTotalList.Clear();

            // Add column total for each new placeholder color
            for (int i = 0; i < _placeholderNewPlaceholderColorList.Count; i++)
            {
                PlaceholderNewColorInfo pnci = _placeholderNewPlaceholderColorList[i];
                aColTotalList.Add(remainingUnits);
            }

            // Add column total for each new placeholder generic pack
            for (int c = 0; c < _placeholderNewGenericPackList.Count; c++)
            {
                PlaceholderNewPackInfo pnpi = _placeholderNewGenericPackList[c];
                aColTotalList.Add(pnpi.PlaceholderPackUnits * pnpi.Multiple);
            }

            // Add constraints for colors and packs
            constraints = new ConstraintBin[storeIndexRIDArray.Count, _placeholderNewPlaceholderColorList.Count + _placeholderNewGenericPackList.Count];
            for (int r = 0; r < storeIndexRIDArray.Count; r++)
            {
                col = 0;
                for (int c = 0; c < _placeholderNewPlaceholderColorList.Count; c++)
                {
                    ConstraintBin cBin = new ConstraintBin(0, 0, int.MaxValue, (uint)_placeholderNewPlaceholderColorList[c].Multiple, false, false);
                    constraints[r, col] = cBin;
                    col++;
                }
                for (int c = 0; c < _placeholderNewGenericPackList.Count; c++)
                {
                    ConstraintBin cBin = new ConstraintBin(0, 0, int.MaxValue, (uint)_placeholderNewGenericPackList[c].Multiple, false, false);
                    constraints[r, col] = cBin;
                    col++;
                }
            }

            int[,] spreadPackResults = null;

            unitsWereSpread = false;
            _transaction.RuleBasedAllocation.Do_2_DimensionalSpread(aRowTotalList, aColTotalList, constraints, out spreadPackResults, out unitsWereSpread, out aMIDException, true);

            col = 0;
            for (int c = 0; c < _placeholderNewPlaceholderColorList.Count; c++)
            {
                for (int s = 0; s < storeIndexRIDArray.Count; s++)
                {
                    Index_RID storeIndex = storeIndexRIDArray[s];
                    ap.SetStoreQtyAllocated(_placeholderNewPlaceholderColorList[c].PlaceholderColorRid, storeIndex.RID, spreadPackResults[s, col], eDistributeChange.ToAll, false);	
                }
                col++;
            }

            for (int c = 0; c < _placeholderNewGenericPackList.Count; c++)
            {
                for (int s = 0; s < storeIndexRIDArray.Count; s++)
                {
                    Index_RID storeIndex = storeIndexRIDArray[s];
                    ap.SetStoreQtyAllocated(_placeholderNewGenericPackList[c].PlaceholderPackName, storeIndex, spreadPackResults[s, col] / _placeholderNewGenericPackList[c].Multiple, eDistributeChange.ToAll, false);
                }
                col++;
            }
        }
        // End TT#2069-MD - JSmith - Generic PPK Attach to a PH and the PH does not reduce.

		//BEGIN TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
		// Even though this method is commented out, I'd like to keep the code for future use.
		/// <summary>
		/// Allocates a placeholder size when a user enters a 
		/// </summary>
		/// <param name="ap"></param>
		/// <param name="colorCodeRid"></param>
		/// <param name="sizeCodeRid"></param>
		/// <param name="units"></param>
		private void AllocatePlaceholderSize(AllocationProfile ap, int colorCodeRid, int sizeCodeRid, int units)
		{
			//ProfileList aStoreList = _asrtCubeGroup.GetMasterProfileList(eProfileType.Store);
			//List<Index_RID> storeIndexRIDArray = new List<Index_RID>(aStoreList.Count);
			//for (int s = 0; s < aStoreList.Count; s++)
			//{
			//    StoreProfile sp = (StoreProfile)aStoreList.ArrayList[s];
			//    if (sp.Key != _transaction.ReserveStore.RID)
			//    {
			//        Index_RID storeIndexRID = this._transaction.StoreIndexRID(sp.Key);
			//        storeIndexRIDArray.Add(storeIndexRID);
			//    }
			//}

			//List<int> aRowTotalList = new List<int>();	// Stores
			//List<int> aColTotalList = new List<int>();	// Sizes

			//// Setup Constraints
			//ConstraintBin[,] constraints = null;
			//int[,] spreadSizeResults = new int[aStoreList.Count, 1];
			//bool unitsWereSpread = false;
			//MIDException aMIDException;
			//AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorCodeRid);

			//// Load rows with placeholder color store data
			//for (int s = 0; s < storeIndexRIDArray.Count; s++)
			//{
			//    Index_RID storeIndex = storeIndexRIDArray[s];
			//    aRowTotalList.Add(ap.GetStoreQtyAllocated(colorComponent, storeIndex.RID));
			//}

			//aColTotalList.Clear();
			//HdrColorBin aPhColor = null;
			//HdrSizeBin aPhSize = null;
			//if (ap.BulkColorIsOnHeader(colorCodeRid))
			//{
			//    aPhColor = (HdrColorBin)ap.BulkColors[colorCodeRid];
			//    if (aPhColor.SizeIsInColor(sizeCodeRid))
			//    {
			//        aPhSize = aPhColor.GetSizeBin(sizeCodeRid);
			//    }
			//}

			//if (aPhColor == null || aPhSize == null)
			//{
			//    // ERROR
			//    return;
			//}
			
			//// load columns with header size totals
			//// we're only doing  a single size
			//aColTotalList.Add(units);
			
			//_transaction.RuleBasedAllocation.Do_2_DimensionalSpread(aRowTotalList, aColTotalList, constraints, out spreadSizeResults, out unitsWereSpread, out aMIDException);

			//// Only 1 size
			//for (int s = 0; s < storeIndexRIDArray.Count; s++)
			//{
			//    Index_RID storeIndex = storeIndexRIDArray[s];
			//    Debug.WriteLine(spreadSizeResults[s, 0]);
			//    ap.SetStoreQtyAllocated(colorCodeRid, sizeCodeRid, storeIndex.RID, spreadSizeResults[s, 0]);
			//}
			
			// first try....

			//Index_RID storeIndexRID;
			//ProfileList aStoreList = _asrtCubeGroup.GetMasterProfileList(eProfileType.Store);
			//List<Index_RID> storeIndexRIDArray = new List<Index_RID>(aStoreList.Count);
			//for (int s = 0; s < aStoreList.Count; s++)
			//{
			//    StoreProfile sp = (StoreProfile)aStoreList.ArrayList[s];
			//    if (sp.Key != _transaction.ReserveStore.RID)
			//    {
			//        storeIndexRID = this._transaction.StoreIndexRID(sp.Key);
			//        storeIndexRIDArray.Add(storeIndexRID);
			//    }
			//}

			//MIDException ex = null;
			//AllocationColorOrSizeComponent colorComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorCodeRid);
			//AllocationColorOrSizeComponent SizeComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificSize, colorCodeRid);
			//RuleAllocationProfile ruleAllocProfile = new RuleAllocationProfile(_transaction, ap.Key, SizeComponent, 1, true);
			//_transaction.RuleBasedAllocation.CalculateProportionalAllocation(storeIndexRIDArray, ap, colorComponent, units, ap, SizeComponent, ref ruleAllocProfile, out ex);
			//foreach (Index_RID aStoreIdx in storeIndexRIDArray)
			//{
			//    int qty = ruleAllocProfile.GetStoreQtyAllocatedByRule(aStoreIdx.RID);
			//    ap.SetStoreQtyAllocated(colorCodeRid, sizeCodeRid, aStoreIdx.RID, qty);
			//}
		}
		//END TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 

		// BEGIN TT#2046 - stodd - units not correct when dragging headers unto placeholders
        // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
        //private void UpdateBulkColorData(UltraGridRow aColorRow, string colorId, string colorDesc)
        private void UpdateBulkColorData(UltraGridRow aColorRow, string colorId, string colorDesc, int fromHeaderRID, UltraGridRow aFromColorRow, UltraGridRow aPlaceholderRow)
        // End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
		{
			try
			{
				int colorHnRID;
				ColorCodeProfile ccp;
				ColorCodeProfile ccpOrig;
				EditMsgs em;
                string errorMessage = string.Empty;  // TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
				int headerRID, prevColorCodeRID = Include.NoRID;
				headerRID = Convert.ToInt32(aColorRow.ParentRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

				AllocationProfile ap = GetAllocationProfile(headerRID);

				//string bulkColor = Convert.ToString(aColorRow.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture).Trim();
				//string bulkDescription = Convert.ToString(aColorRow.Cells["Description"].Value, CultureInfo.CurrentUICulture).Trim();
				string bulkColor = colorId;
				string bulkDescription = colorDesc;

				if (aColorRow.Cells["ColorCodeRID"].Value != DBNull.Value)
				{
					prevColorCodeRID = Convert.ToInt32(aColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
				}

				ccp = _sab.HierarchyServerSession.GetColorCodeProfile(colorId);

				bool bulkColorColumnChanged = false;   // TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, not reflected on other tabs 

				//switch (e.Cell.Column.Key)
				//{
				//    case "BulkColor":
						bulkColorColumnChanged = true; // TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, not reflected on other tabs 
						string origValue = aColorRow.Cells["BulkColor"].Value.ToString();
						if (ccp.Key == Include.NoRID)
						{
							// color doesn't exist, need to add it
							ccp.ColorCodeID = colorId;
							ccp.ColorCodeName = colorId;
							bulkDescription = colorDesc;

							aColorRow.Cells["BulkColor"].Value = colorId;
							aColorRow.Cells["Description"].Value = bulkDescription;

							if (!Convert.ToBoolean(aColorRow.Cells["IsVirtual"].Value, CultureInfo.CurrentUICulture))
							{
								ccp.ColorCodeChangeType = eChangeType.add;
								ccp = _sab.HierarchyServerSession.ColorCodeUpdate(ccp);
							}
							aColorRow.Cells["IsNewColor"].Value = true;
						}
						else if (bulkDescription.Trim() == string.Empty || bulkColor != origValue)
						{
							if (!ccp.VirtualInd)
							{
								colorHnRID = Include.NoRID;
								HierarchyNodeProfile hnp_style = _sab.HierarchyServerSession.GetNodeData(ap.StyleHnRID);
								if (_sab.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
								{
									HierarchyNodeProfile hnp_color = _sab.HierarchyServerSession.GetNodeData(colorHnRID);
									bulkDescription = hnp_color.NodeDescription;
								}
								else
								{
									bulkDescription = ccp.ColorCodeName;
								}

                                // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
                                //aColorRow.Cells["BulkColor"].Value = colorId;
                                //aColorRow.Cells["Description"].Value = bulkDescription;
                                // Determines if color already exists on Placeholder.  If it does, the place holder's color and place holder color are adjusted based on the units in the header
								if (ValidBulkColor(aColorRow.Cells["BulkColor"], colorId, ref errorMessage))
                                {
                                    aColorRow.Cells["BulkColor"].Value = colorId;
                                    aColorRow.Cells["Description"].Value = bulkDescription;
                                }
                                else
                                {
                                    UpdateExistingBulkColorDataFromHeader(aPlaceholderRow, aFromColorRow, aColorRow, ap, fromHeaderRID);
                                }
								// End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
							}
							else
							{
								bulkDescription = ccp.ColorCodeName;
							}
						}
						// now add it to the hierarchy -- probably need to move this to the save
						if (bulkColor != string.Empty &&
							bulkDescription != string.Empty && !ccp.VirtualInd)
						{
							em = new EditMsgs();
							colorHnRID = _hierMaint.QuickAdd(ref em, ap.StyleHnRID, bulkColor, bulkDescription);
							if (em.ErrorFound)
							{
								DisplayMessages.Show(em, _sab, _windowName);
								return;
							}
						}

						//if (e.Cell.OriginalValue.ToString() == string.Empty)
						//{
						//    // finally, add it to the header
						//    ap.AddBulkColor(ccp.Key,
						//    Convert.ToInt32(e.Cell.Row.Cells["Quantity"].Value, CultureInfo.CurrentUICulture), 0);
						//    e.Cell.Row.Cells["KeyH"].Value = ap.Key;
						//    e.Cell.Row.Cells["ColorCodeRID"].Value = ccp.Key;
						//    e.Cell.Row.Cells["KeyC"].Value = ap.BulkColors.Count * -1;
						//    if (ccp.VirtualInd)
						//    {
						//        ap.SetBulkColorName(ccp.Key, bulkColor);
						//        e.Cell.Row.Cells["Description"].Value = bulkDescription;
						//    }
						//}
						//else
						{
							//UltraGridRow headerRow = aColorRow.ParentRow;
							//bool bypassChecks = AllowPlaceholderUpdate(headerRow);
							//if (prevColorCodeRID == Include.NoRID)
							//{
							//    ccpOrig = _sab.HierarchyServerSession.GetColorCodeProfile(origValue);
							//    ap.SetBulkColorCodeRID(ccpOrig.Key, ccp.Key, bypassChecks);
							//}
							//else
							//{
							//    ap.SetBulkColorCodeRID(prevColorCodeRID, ccp.Key, bypassChecks);
							//}
							//aColorRow.Cells["ColorCodeRID"].Value = ccp.Key;
							//if (!ccp.VirtualInd)
							//{
							//    ap.SetBulkColorName(ccp.Key, null);
							//    ap.SetBulkColorDescription(ccp.Key, null);
							//}
							//else
							//{
							//    ap.SetBulkColorName(ccp.Key, bulkColor);
							//    aColorRow.Cells["Description"].Value = bulkDescription;
							//}
						}

                        // Begin TT#502 - MD - JEllis - remove Lock code from special Assortment code
                        //AllocationSubtotalProfileList subtotalList = (AllocationSubtotalProfileList)_transaction.GetMasterProfileList(eProfileType.AllocationSubtotal);
                        //if (subtotalList != null)
                        //{
                        //    foreach (AllocationSubtotalProfile asp in subtotalList)
                        //    {
                        //        asp.RemoveAllSubtotalMembers();
                        //    }
                        //    _transaction.RemoveAllocationSubtotalProfileList();
                        //}
                        //END TT#502 - MD - JEllis - remove Lock code from special Assortment code

						aColorRow.Cells["IsVirtual"].Value = ccp.VirtualInd;
						if (_addingMTColorRow)
						{
							// Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
							//BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
							//ap.SetColorUnitsToAllocate(ccp.Key, Convert.ToInt32(aColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture));
							//END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
							ArrayList colorCodeList = new ArrayList();
							colorCodeList.Add(ccp.Key);
							if (!aColorRow.HasPrevSibling(false) && !aColorRow.HasNextSibling(false))
							{
								SetStoreAllocatedColorUnits(ap.Key, colorCodeList);
							}
							//End TT#1282
							_addingMTColorRow = false;
							//SaveAndUpdateAssortmentTab();
                            OnAssortmentSaveHeaderData(null);	// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
						}
						// Begin TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, does not change the style
						//     and Placeholder ID on the Assortment and Characteristics tab unless you save and close the Assorment and go back in to the Assortment 
						else
						{
							_buildProductCharsGrid = true;
							UpdateAssortmentTabColor(ap.Key, ap.StyleHnRID, prevColorCodeRID, ccp.Key, bulkDescription);
							aColorRow.Band.Columns["BulkColor"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
							aColorRow.Band.Columns["Description"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
						}
						// End TT#1613

					//case "Description":
						//errorMessage = string.Empty;
						//if (!RequiredFieldEntered(e.Cell, ref errorMessage))
						//{
						//    MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
						//    return;
						//}

					//    if (ccp.Key != Include.NoRID)
					//    {
					//        if (!ccp.VirtualInd)
					//        {
					//            em = new EditMsgs();
					//            colorHnRID = Include.NoRID;
					//            HierarchyNodeProfile hnp_style = _sab.HierarchyServerSession.GetNodeData(ap.StyleHnRID);
					//            if (_sab.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
					//            {
					//                HierarchyNodeProfile hnp_color = _sab.HierarchyServerSession.GetNodeData(colorHnRID);
					//                hnp_color.NodeDescription = bulkDescription;
					//                hnp_color.NodeChangeType = eChangeType.update;
					//                _hierMaint.ProcessNodeProfileInfo(ref em, hnp_color);
					//            }
					//            if (Convert.ToBoolean(e.Cell.Row.Cells["IsNewColor"].Value, CultureInfo.CurrentUICulture)
					//             && bulkDescription.Trim() != ccp.ColorCodeName)
					//            {
					//                ccp.ColorCodeName = bulkDescription;
					//                ccp.ColorCodeChangeType = eChangeType.update;
					//                ccp = _sab.HierarchyServerSession.ColorCodeUpdate(ccp);
					//                e.Cell.Row.Cells["IsNewColor"].Value = false;
					//            }
					//        }
					//        else       // Placeholder color
					//        {
					//            ap.SetBulkColorDescription(ccp.Key, bulkDescription);
					//        }
					//    }
					//    // Begin TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, not reflected on other tabs 
					//    if (!bulkColorColumnChanged)  // only description changed
					//    {
					//        UpdateAssortmentTabColor(ap.Key, ap.StyleHnRID, ccp.Key, ccp.Key, bulkDescription);
					//        UpdateCharacteristicColorDescription(ap.StyleHnRID, ccp.Key, bulkDescription);
					//        e.Cell.Band.Columns["Description"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
					//    }
					//    // End TT#1613

					////case "Quantity":
					//    errorMessage = string.Empty;
					//    if (!RequiredFieldEntered(e.Cell, ref errorMessage))
					//    {
					//        MessageBox.Show(errorMessage, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
					//        return;
					//    }
					//    // Multi header totals get calculated in AllocationProfile
					//    if (!ap.MultiHeader)
					//    {
					//        // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
					//        if (!_addingMTColorRow)
					//        {
					//            ap.SetColorUnitsToAllocate(ccp.Key, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
					//        }
					//        // End TT#1282
					//    }
					//    // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
					//    //CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
					//    if (!_addingMTColorRow)
					//    {
					//        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
					//    }
					//    // End TT#1282

					////case "AsrtBCRID":
					//    if (ap != null)
					//    {
					//        int bcRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
					//        if (bcRID != 0)
					//        {
					//            ap.SetAsrtBCRID(ccp.Key, bcRID);
					//        }
					//    }

				//    default:
				//        break;
				//}
			}
			catch (MIDException MIDexc)
			{
				HandleMIDException(MIDexc);
			}
			catch
			{
				throw;
			}
		}
		// END TT#2046 - stodd - units not correct when dragging headers unto placeholders

        // Begin TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
        /// <summary>
        /// Update the color rows from the header dropped on the place holder color
        /// </summary>
        /// <param name="aPlaceholderRow">The row of the place holder header</param>
        /// <param name="aFromColorRow">The color row of the dropped header</param>
        /// <param name="aColorRow">The place holder color row</param>
        /// <param name="PhAllocProf">The place holder Allocation Profile</param>
        /// <param name="fromHeaderRID">The key of the dropped header</param>
        private void UpdateExistingBulkColorDataFromHeader(UltraGridRow aPlaceholderRow, UltraGridRow aFromColorRow, UltraGridRow aColorRow, AllocationProfile PhAllocProf, int fromHeaderRID)
        {
            UltraGridRow existingColorRow = null;

            AllocationProfile ap = GetAllocationProfile(fromHeaderRID);
            int colorQuantity = 0;
            switch (aFromColorRow.Band.Key)
            {
                case "PackColor":
                    colorQuantity = Convert.ToInt32(aFromColorRow.ParentRow.Cells["TotalQuantity"].Value);
                    break;
                default:
                    colorQuantity = Convert.ToInt32(aFromColorRow.Cells["Quantity"].Value);
                    break;
            }
            int PhColorQuantity = Convert.ToInt32(aColorRow.Cells["Quantity"].Value);
            int colorCodeRID = Convert.ToInt32(aFromColorRow.Cells["ColorCodeRID"].Value);
            int PhColorCodeRID = Convert.ToInt32(aColorRow.Cells["ColorCodeRID"].Value);

            // get existing row for the color in the place holder
            IEnumerable enumerator = ugDetails.DisplayLayout.Bands["BulkColor"].GetRowEnumerator(GridRowType.DataRow);
            foreach (UltraGridRow row in enumerator)
            {
                if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == PhAllocProf.Key
                  && Convert.ToInt32(row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture) == colorCodeRID)
                {
                    existingColorRow = row;
                    break;
                }
            }

            // Begin TT#2086-MD - JSmith - After attach 2nd Hdr to a PHC the stores are not allocated proportionally to the PH.  5 strs receive 200+ units, when all strs on the PHC had values.
			// Move units from place holder color to color
            foreach (Index_RID aStoreIdx in GetStoreIndexRIDArray())
            {
                int qty = PhAllocProf.GetStoreQtyAllocated(PhColorCodeRID, aStoreIdx.RID) + PhAllocProf.GetStoreQtyAllocated(colorCodeRID, aStoreIdx.RID);
                PhAllocProf.SetStoreQtyAllocated(colorCodeRID, aStoreIdx.RID, qty, eDistributeChange.ToParent, false);
                PhAllocProf.SetStoreQtyAllocated(PhColorCodeRID, aStoreIdx.RID, 0, eDistributeChange.ToParent, false);
            }
			// End TT#2086-MD - JSmith - After attach 2nd Hdr to a PHC the stores are not allocated proportionally to the PH.  5 strs receive 200+ units, when all strs on the PHC had values.

            // subtract the value from the place holder color
            UpdateBulkColorQuantity(PhAllocProf.Key, PhColorCodeRID, PhColorQuantity - colorQuantity < 0 ? 0 : PhColorQuantity - colorQuantity);
            // Add the value to the color in the place holder
            if (existingColorRow != null)
            {
                UpdateBulkColorQuantity(PhAllocProf.Key, colorCodeRID, colorQuantity);
            }

            // Add any new sizes
            int keyC = Convert.ToInt32(existingColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
            AddSizesToBulkColor(aPlaceholderRow, aColorRow, PhAllocProf.Key, colorCodeRID, keyC);
        }
		// End TT#2050-MD - JSmith - Values after attaching 1st hdr to a  PH the  PH values are incorrect.  After attach the 2nd header the PH is not reduced and the allocation is incorrect.
		
        private void UpdateBulkSizeData(CellEventArgs e)
        {
            try
            {
                if (e.Cell.Column.Key != "TotalQuantity")
                {
                    int quantity, originalValue, sizeCodeKey;
                  
                    AllocationProfile ap = GetAllocationProfile(Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                    int colorCodeKey = Convert.ToInt32(e.Cell.Row.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                    if (e.Cell.Value == System.DBNull.Value)
                    {
                        quantity = 0;
                    }
                    else
                    {
                        quantity = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                    }

                    if (e.Cell.OriginalValue == System.DBNull.Value)
                    {
                        originalValue = 0;
                    }
                    else
                    {
                        originalValue = Convert.ToInt32(e.Cell.OriginalValue, CultureInfo.CurrentUICulture);
                    }

                    if (e.Cell.Tag != System.DBNull.Value)
                    {
                        sizeCodeKey = Convert.ToInt32(e.Cell.Tag, CultureInfo.CurrentUICulture);

                        if (sizeCodeKey != Include.NoRID)
                        {
                            if (!ap.MultiHeader)     // MID Track #5654, #5655, #5657 - MultiHeader errors
                            {
                                if (!ap.SizeIsOnBulkColor(colorCodeKey, sizeCodeKey))
                                {
                                    ap.AddBulkSizeToColor(colorCodeKey, sizeCodeKey, quantity, -1);
                                }
                                else
                                {
									//BEGIN TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                                    //ap.SetSizeUnitsToAllocate(colorCodeKey, sizeCodeKey, quantity);
									//BEGIN TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
									AllocatePlaceholderSize(ap, colorCodeKey, sizeCodeKey, quantity);
									//END TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
									//END TT#546-MD - stodd -  Change Allocation to treat a placeholder like a WorkUpBuy 
                                }
                            }
                        }
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                    }
                }

            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePackSizeData(CellEventArgs e)
        {
            try
            {
                if (e.Cell.Column.Key != "TotalQuantity")
                {
                    int quantity, originalValue, sizeCodeKey, colorCodeKey;
                    string packName;
                   
                    AllocationProfile ap = GetAllocationProfile(Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                    if (e.Cell.Band.Key.StartsWith("PackSize"))
                    {
                        packName = e.Cell.Row.ParentRow.Cells["Pack"].Value.ToString();
                        colorCodeKey = Include.DummyColorRID;
                    }
                    else
                    {
                        packName = e.Cell.Row.ParentRow.ParentRow.Cells["Pack"].Value.ToString();
                        colorCodeKey = Convert.ToInt32(e.Cell.Row.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                    }

                    if (e.Cell.Value == System.DBNull.Value)
                    {
                        quantity = 0;
                    }
                    else
                    {
                        quantity = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                    }

                    if (e.Cell.OriginalValue == System.DBNull.Value)
                    {
                        originalValue = 0;
                    }
                    else
                    {
                        originalValue = Convert.ToInt32(e.Cell.OriginalValue, CultureInfo.CurrentUICulture);
                    }

                    if (e.Cell.Tag != System.DBNull.Value)
                    {
                        sizeCodeKey = Convert.ToInt32(e.Cell.Tag, CultureInfo.CurrentUICulture);

                        if (sizeCodeKey != Include.NoRID)
                        {
                            if (!ap.MultiHeader)    // MID Tracks 5769, 5827 - multiheader processing errors
                            {
                                if (!ap.SizeIsOnPackColor(packName, colorCodeKey, sizeCodeKey))
                                {
                                    ap.AddSizeToPackColor(packName, colorCodeKey, sizeCodeKey, quantity, -1);
                                }
                                else
                                {
                                    ap.SetPackColorSizeUnits(packName, colorCodeKey, sizeCodeKey, quantity);
                                }
                            }
                        }
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                    }
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch
            {
                throw;
            }
        }

        private void CalculateBalancesFromDelete(UltraGridRow aRow)
        {
            try
            {
                string[] bandKeyParts = aRow.Band.Key.Split(new char[] { '~' });
                switch (bandKeyParts[0])
                {
                    case "Header": 
                        break;

                    case "Pack":
						//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
						CalculateBalances(eBalanceAction.RowDeleted, aRow.Cells["TotalQuantity"]);
                        break;
						//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
                    case "PackColor":
						// BEGIN TT#453-MD - stodd - Pack changes
						//BEGIN TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
						CalculateBalances(eBalanceAction.RowDeleted, aRow.Cells["QuantityPerPack"]);
						//CalculateBalances(eBalanceAction.RowDeleted, aRow.Cells["TotalQuantity"]);
						//END TT#600-MD - stodd - Dragging a header with  pack(s) does not properly adjust the placeholder
						// END TT#453-MD - stodd - Pack changes
                        break;

                    case "BulkColor":
                        CalculateBalances(eBalanceAction.RowDeleted, aRow.Cells["Quantity"]);
                        break;

                    case "PackSize":
                    case "PackColorSize":
                    case "BulkSize":
                        CalculateBalances(eBalanceAction.RowDeleted, aRow.Cells["TotalQuantity"]);
                        break;

                    default:
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		// Begin TT#854 - MD - stodd - enqueue error 
		/// <summary>
		/// returns a BulkColor Row with sizes. Expects a header row to com in as the parameter.
		/// </summary>
		/// <param name="aRow"></param>
		/// <returns></returns>
		private UltraGridRow GetPlaceholderBulkColorRow(UltraGridRow aRow)
		{
			UltraGridRow colorRow = null;
			if (aRow.Band.Key.StartsWith("BulkColor"))
			{
				return aRow;
			}

			if (aRow.HasChild())
			{
				UltraGridRow childRow = aRow.GetChild(ChildRow.First);
				while (childRow != null)
				{
					colorRow = GetPlaceholderBulkColorRow(childRow);
					if (colorRow != null)
					{
						if (colorRow.GetChild(ChildRow.First) != null)
						{
							break;
						}
					}
					childRow = childRow.GetSibling(SiblingRow.Next, true);
				}
			}
			return colorRow;
		}
		// END TT#854 - MD - stodd - enqueue error 

		//BEGIN TT#579-MD - stodd -  After adding a header to a placeholder, placeholder has a balance value even though its units are all in balance  
		/// <summary>
		/// This recursively moves through the content grid and reapplys the balance values based upon the parent total vs any child row total
		/// for PLACEHOLDERS ONLY.
		/// </summary>
		/// <returns></returns>
		private bool CalculatePlaceholderBalances()
		{
			bool allInBalance = true;
			foreach (UltraGridRow row in ugDetails.Rows)
			{
				if (row.Band.Key == "Header" && Convert.ToInt32(row.Cells["Type"].Value) == (int)eHeaderType.Placeholder)
				{
					bool inBalance = CalculatePlaceholderBalances(row);
					if (!inBalance)
					{
						allInBalance = false;
					}
				}
			}

			return allInBalance;
		}

		private bool CalculatePlaceholderBalances(UltraGridRow aRow)
		{
			bool allInBalance = false;

			if (aRow.HasChild())
			{
				int childTotal = GetChildrenTotalQuantity(aRow);
				//BEGIN TT#600-MD - stodd
				string rowBand = aRow.Band.ToString();
				int rowQty = 0;
				if (rowBand == "Pack")
				{
					rowQty = GetRowQuantity(aRow, true);
				}
				else
				{
					rowQty = GetRowQuantity(aRow, false);
				}
				//END TT#600-MD - stodd
				int diff = rowQty - childTotal;
				aRow.Cells["Balance"].Value = diff; ;
				aRow.Cells["ChildTotal"].Value = childTotal;

				UltraGridRow childRow = aRow.GetChild(ChildRow.First);
				while (childRow != null)
				{
					CalculatePlaceholderBalances(childRow);
					childRow = childRow.GetSibling(SiblingRow.Next, true);
				}
			}
			return allInBalance;
		}

		private int GetChildrenTotalQuantity(UltraGridRow aRow)
		{
			//int totalQty = GetRowQuantity(aRow);
			int totalQty = 0;
			UltraGridRow SibRow = aRow.GetChild(ChildRow.First);
			while (SibRow != null)
			{
				totalQty += GetRowQuantity(SibRow, false);	// TT#600-MD - stodd
				SibRow = SibRow.GetSibling(SiblingRow.Next, true);
			}
			return totalQty;
		}

		/// <summary>
		/// gets the corrected qty for a component row
		/// </summary>
		/// <param name="aRow"></param>
		/// <param name="isParentPack">If the pack is the parent row, then we are comparing it to packColor quantity/pack so we want the pack's quantity/pack.</param>
		/// <returns></returns>
		private int GetRowQuantity(UltraGridRow aRow, bool isParentPack)
		{
			int qty = 0;
			string rowBand = aRow.Band.ToString();
			//BEGIN TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
			// Sometimes the size bands have extra information in the band name
			int pos = rowBand.IndexOf('~');
			if (pos > 0)
			{
				rowBand = rowBand.Substring(0, pos);
			}
			//END TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
			switch (rowBand)
			{
				case "Header":
					qty = Convert.ToInt32(aRow.Cells["HdrQuantity"].Value);
					break;

				case "Pack":
					//BEGIN TT#600-MD - stodd
					if (isParentPack)
					{
						qty = Convert.ToInt32(aRow.Cells["QuantityPerPack"].Value);
					}
					else
					{
						qty = Convert.ToInt32(aRow.Cells["TotalQuantity"].Value);
					}
					//END TT#600-MD - stodd
					break;

				case "PackColor":
					qty = Convert.ToInt32(aRow.Cells["QuantityPerPack"].Value);
					break;

				case "BulkColor":
					qty = Convert.ToInt32(aRow.Cells["Quantity"].Value);
					break;
				//BEGIN TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
				case "PackSize":
				case "PackColorSize":
				case "BulkSize":
					qty = Convert.ToInt32(aRow.Cells["TotalQuantity"].Value);
					break;
				//END TT#650-MD - stodd - Sizes on header not getting allocated when dropped onto a placeholder 
				default:
					qty = 0;
					break;
			}

			return qty;
		}
		//END TT#579-MD - stodd -  After adding a header to a placeholder, placeholder has a balance value even though its units are all in balance  
		
		//Begin TT#957 - MD - stodd - "Errors Found" message when clicking on header - 
        private UltraGridRow GetFirstHeaderRowInAssortment(UltraGridRow aRow)
        {
            UltraGridRow firstHeaderRow = null;

            try
            {
                UltraGridRow gRow = aRow;
                while (gRow != null )
                {
                    if (gRow.IsGroupByRow)
                    {
                        firstHeaderRow = GetFirstHeaderRowInAssortment(gRow.GetChild(ChildRow.First));
                        if (firstHeaderRow != null)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (gRow.Band.Key == "Header" && Convert.ToInt32(gRow.Cells["Type"].Value) != (int)eHeaderType.Assortment && Convert.ToInt32(gRow.Cells["Type"].Value) != (int)eHeaderType.Placeholder)
                        {
                            firstHeaderRow = gRow;
                            break;
                        }
                    }
                    gRow = gRow.GetSibling(SiblingRow.Next, true, false);
                }

                return firstHeaderRow;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return firstHeaderRow;
            }
        }
		//End TT#957 - MD - stodd - "Errors Found" message when clicking on header - 

        //BEGIN TT#658 - MD - DOConnell - Assortment Workspace quantity is not updaed on a Post-Receipt Assortment
        private void CalculateTotalsForWkSpc()
        {
            int totUnitsToAllocate = 0;
            try
            {
                foreach (AllocationHeaderProfile ahp in _headerList)
                {
                    if (ahp.HeaderType != eHeaderType.Assortment)
                    {
						// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                        //AllocationProfile ap = _transaction.GetAllocationProfile(ahp.Key);
						AllocationProfile ap = _transaction.GetAssortmentMemberProfile(ahp.Key);
						// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                        totUnitsToAllocate = totUnitsToAllocate + ap.TotalUnitsToAllocate;
                    }
                }
                _asrtCubeGroup.DefaultAllocationProfile.TotalUnitsToAllocate = totUnitsToAllocate;
				// Begin TT#854 - MD - stodd - enqueue error 
                //_transaction.SaveHeaders();
				WriteHeader(_asrtCubeGroup.DefaultAllocationProfile.Key);
				// END TT#854 - MD - stodd - enqueue error 
				// Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                //_eab.AssortmentWorkspaceExplorer.IRefresh();
                ReloadUpdatedHeadersInAssortmentWorkspace();
				// End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        //END TT#658 - MD - DOConnell - Assortment Workspace quantity is not updaed on a Post-Receipt Assortment

		// Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
        private void ReloadUpdatedHeadersInAssortmentWorkspace()
        {
			// Begin TT#952 - MD - stodd - add matrix to Group Allocation Review
            if (IsAssortment)
            {
                AllocationProfileList apl = _transaction.GetAssortmentMemberProfileList();
                //return (AllocationProfile)apl.FindKey(aHeaderRID);
                ArrayList asrtArray = new ArrayList();
                foreach (AllocationProfile ap in apl.ArrayList)
                {
                    if (ap.HeaderType == eHeaderType.Assortment)
                    {
                        asrtArray.Add(ap.Key);
                    }
					// Begin TT#1479-MD - stodd - ASST - Select Balance Assortment and receive system argument exception.
                    //int[] asrtList = new int[asrtArray.Count];
                    // asrtList = (int[])asrtArray.ToArray(typeof(int));
                    // _eab.AssortmentWorkspaceExplorer.ReloadUpdatedAssortments(asrtList);
                }
                if (asrtArray.Count > 0)
                {
                    int[] asrtList = new int[asrtArray.Count];
                    asrtList = (int[])asrtArray.ToArray(typeof(int));
                    _eab.AssortmentWorkspaceExplorer.ReloadUpdatedAssortments(asrtList);
                } 
				// End TT#1479-MD - stodd - ASST - Select Balance Assortment and receive system argument exception.
            }
			// End TT#952 - MD - stodd - add matrix to Group Allocation Review
        }

        private void ReloadUpdatedHeadersInAllocationWorkspace()
        {
            AllocationProfileList apl = _transaction.GetAssortmentMemberProfileList();
            //return (AllocationProfile)apl.FindKey(aHeaderRID);
            ArrayList hdrRidArray = new ArrayList();
            foreach (AllocationProfile ap in apl.ArrayList)
            {
                if (ap.HeaderType != eHeaderType.Assortment && ap.HeaderType != eHeaderType.Placeholder)
                {
                    hdrRidArray.Add(ap.Key);
                    // Begin TT#1966-MD - JSmith- DC Fulfillment
                    if (ap.IsMasterHeader)
                    {
                        foreach (int subordinateRID in ap.SubordinateRIDs)
                        {
                            hdrRidArray.Add(subordinateRID);
                        }
                    }
                    // End TT#1966-MD - JSmith- DC Fulfillment
                }
				// Begin TT#1479-MD - stodd - ASST - Select Balance Assortment and receive system argument exception.
                //int[] hdrRidList = new int[hdrRidArray.Count];
                //hdrRidList = (int[])hdrRidArray.ToArray(typeof(int));
                //ReloadUpdatedHeadersInAllocationWorkspace(hdrRidList);
            }

            if (hdrRidArray.Count > 0)
            {
                int[] hdrRidList = new int[hdrRidArray.Count];
                hdrRidList = (int[])hdrRidArray.ToArray(typeof(int));
                ReloadUpdatedHeadersInAllocationWorkspace(hdrRidList);
            }
			// End TT#1479-MD - stodd - ASST - Select Balance Assortment and receive system argument exception.
        }

        private void ReloadUpdatedHeadersInAllocationWorkspace(int [] hdrRidList)
        {
            _eab.AllocationWorkspaceExplorer.ReloadUpdatedHeaders(hdrRidList);
        }
		// End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces

        private void CalculateBalances(eBalanceAction aBalanceAction, UltraGridCell aCell)
        {
            try
            {
                int originalValue = 0;
                int quantity = 0;
                switch (aBalanceAction)
                {
                    case eBalanceAction.RowDeleted:

                        if (aCell.Value == System.DBNull.Value)
                        {
                            quantity = 0;
                        }
                        else
                        {
                            quantity = Convert.ToInt32(aCell.Value, CultureInfo.CurrentUICulture) * -1;
                        }
                        break;

                    case eBalanceAction.RowAdded:

                        if (aCell.Value == System.DBNull.Value ||
                            Convert.ToString(aCell.Value, CultureInfo.CurrentUICulture) == string.Empty)
                        {
                            quantity = 0;
                        }
                        else
                        {
                            quantity = Convert.ToInt32(aCell.Value, CultureInfo.CurrentUICulture);
                        }
                        break;

                    default:

                        if (aCell.OriginalValue == System.DBNull.Value)
                            originalValue = 0;
                        else
                            originalValue = Convert.ToInt32(aCell.OriginalValue, CultureInfo.CurrentUICulture);

                        if (aCell.Value == System.DBNull.Value)
                        {
                            quantity = 0;
                        }
                        else
                        {
                            quantity = Convert.ToInt32(aCell.Value, CultureInfo.CurrentUICulture);
                        }
                        break;
                }

                string[] bandKeyParts = aCell.Row.Band.Key.Split(new char[] { '~' });
                switch (bandKeyParts[0])
                {
                    case "Header":
                        if (aBalanceAction != eBalanceAction.RowDeleted)
                        {
                            if (aCell.Row.Cells["ChildTotal"].Value == System.DBNull.Value)
                            {
                                aCell.Row.Cells["ChildTotal"].Value = 0;
                            }
                            if (aCell.Row.HasChild(false))
                            {
                                if (aCell.Row.Cells["Balance"].Value == System.DBNull.Value)
                                {
                                    aCell.Row.Cells["Balance"].Value = 0;
                                }
                                aCell.Row.Cells["Balance"].Value = Convert.ToInt32(aCell.Value, CultureInfo.CurrentUICulture)
                                    - Convert.ToInt32(aCell.Row.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                            }
							// Begin TT#1465-MD - stodd - Assortment - Content Tab-> Qty, Balance, and Allocated Units columns are out of sync
                            else
                            {
                                aCell.Row.Cells["Balance"].Value = System.DBNull.Value;
                            }
							// End TT#1465-MD - stodd - Assortment - Content Tab-> Qty, Balance, and Allocated Units columns are out of sync
                        }
                        break;
                    case "Pack":

                        if (aCell.Row.ParentRow.Cells["HdrQuantity"].Value == System.DBNull.Value)
                        {
                            aCell.Row.ParentRow.Cells["HdrQuantity"].Value = 0;
                        }
                        if (aBalanceAction == eBalanceAction.RowDeleted)
                        {
                            // adjust header balance
                            int packTotal = Convert.ToInt32(aCell.Row.Cells["TotalPacks"].Value) * Convert.ToInt32(aCell.Row.Cells["QuantityPerPack"].Value);
                            if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                            {
                                aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                            }

                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value) - packTotal;
                            if (Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture) == 0)
                            {
                                aCell.Row.ParentRow.Cells["Balance"].Value = System.DBNull.Value;
                            }
                            else
                            {
                                aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["HdrQuantity"].Value)
                                    - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value);
                            }
                        }
                        else
                        {
                            switch (aCell.Column.Key)
                            {
                                case "TotalPacks":
                                    {
                                        if (aBalanceAction != eBalanceAction.RowDeleted)
                                        {
                                            // adjust header balance
                                            int originalPackTotal = originalValue * Convert.ToInt32(aCell.Row.Cells["QuantityPerPack"].Value);
                                            int packTotal = quantity * Convert.ToInt32(aCell.Row.Cells["QuantityPerPack"].Value);
                                            aCell.Row.Cells["TotalQuantity"].Value = packTotal;
                                            if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                                            {
                                                aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                                            }
                                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value) - originalPackTotal + packTotal;
                                            aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["HdrQuantity"].Value)
                                                - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value);
                                        }
                                        break;
                                    }
                                case "QuantityPerPack":
                                    {
                                        // adjust header balance
                                        int originalPackTotal = originalValue * Convert.ToInt32(aCell.Row.Cells["TotalPacks"].Value);
                                        int packTotal = quantity * Convert.ToInt32(aCell.Row.Cells["TotalPacks"].Value);
                                        aCell.Row.Cells["TotalQuantity"].Value = packTotal;
                                        if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                                        {
                                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                                        }
                                        aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value) - originalPackTotal + packTotal;
                                        aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["HdrQuantity"].Value)
                                            - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value);
                                        // adjust pack balance
                                        if (aCell.Row.HasChild(false))
                                        {
                                            if (aCell.Row.Cells["ChildTotal"].Value != System.DBNull.Value)
                                            {
                                                aCell.Row.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.Cells["QuantityPerPack"].Value, CultureInfo.CurrentUICulture)
                                                    - Convert.ToInt32(aCell.Row.Cells["ChildTotal"].Value);
                                            }
                                        }
                                        break;
                                    }
                            }
                        }
                        break;
                    case "PackColor":
                        // adjust pack balance
                        if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                        {
                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                        }
                        aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value) - originalValue + quantity;
                        aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["QuantityPerPack"].Value)
                            - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value);
                        // adjust size balance
                        if (_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                        {
                            if (aBalanceAction != eBalanceAction.RowDeleted)
                            {
                                if (aCell.Row.HasChild(false))
                                {
                                    if (aCell.Row.Cells["ChildTotal"].Value == System.DBNull.Value)
                                    {
                                        aCell.Row.Cells["ChildTotal"].Value = 0;
                                    }
                                    aCell.Row.Cells["Balance"].Value = quantity - Convert.ToInt32(aCell.Row.Cells["ChildTotal"].Value);
                                }
								// Begin TT#1465-MD - stodd - Assortment - Content Tab-> Qty, Balance, and Allocated Units columns are out of sync
                                else
                                {
                                    aCell.Row.Cells["Balance"].Value = System.DBNull.Value;
                                }
								// End TT#1465-MD - stodd - Assortment - Content Tab-> Qty, Balance, and Allocated Units columns are out of sync
                            }
                        }
                        break;
                    case "BulkColor":
                        // adjust header balance
                        if (aCell.Row.ParentRow.Cells["HdrQuantity"].Value == System.DBNull.Value)
                        {
                            aCell.Row.ParentRow.Cells["HdrQuantity"].Value = 0;
                        }
                        if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                        {
                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                        }
                        aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value) - originalValue + quantity;
                        if (Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture) == 0)
                        {
                            aCell.Row.ParentRow.Cells["Balance"].Value = System.DBNull.Value;
                        }
                        else
                        {
                            aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["HdrQuantity"].Value)
                                - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value);
                        }
                        if (_sab.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                        {
                            if (aBalanceAction != eBalanceAction.RowDeleted)
                            {
                                if (aCell.Row.HasChild(false))
                                {
                                    if (aCell.Row.Cells["ChildTotal"].Value == System.DBNull.Value)
                                    {
                                        aCell.Row.Cells["ChildTotal"].Value = 0;
                                    }
                                    aCell.Row.Cells["Balance"].Value = Convert.ToInt32(aCell.Value, CultureInfo.CurrentUICulture)
                                        - Convert.ToInt32(aCell.Row.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                                }
								// Begin TT#1465-MD - stodd - Assortment - Content Tab-> Qty, Balance, and Allocated Units columns are out of sync
                                else
                                {
                                    aCell.Row.Cells["Balance"].Value = System.DBNull.Value;
                                }
								// End TT#1465-MD - stodd - Assortment - Content Tab-> Qty, Balance, and Allocated Units columns are out of sync
                            }
                        }
                        break;

                    case "PackSize":
                    case "PackColorSize":
                    case "BulkSize":
                        if (aBalanceAction != eBalanceAction.RowDeleted)
                        {
                            aCell.Row.Cells["TotalQuantity"].Value = Convert.ToInt32(aCell.Row.Cells["TotalQuantity"].Value, CultureInfo.CurrentUICulture) - originalValue + quantity;
                        }
                        if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                        {
                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                        }

                        aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture) - originalValue + quantity;

                        string qtyCell = bandKeyParts[0] == "BulkSize" ? "Quantity" : "QuantityPerPack";

                        aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells[qtyCell].Value, CultureInfo.CurrentUICulture)
                            - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                        break;

                    default:
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch
            {
                throw;
            }
        }

        private void ugDetails_BeforeRowDeactivate(object sender, CancelEventArgs e)
        {
            try
            {
                _errors = null;		// TT#936 - MD - Prevent the saving of empty Group Allocations
                EditMsgs em = new EditMsgs();
                UltraGridRow activeRow = ugDetails.ActiveRow;
                if (activeRow.Cells == null || !_inEditMode || _addingPlaceholder)
                {
                    return;
                }
                if (!ValidateSpecificFields(activeRow, ref em))
                {
                    if (em.EditMessages.Count > 0)
                    {
                        //_errors = null;		// TT#936 - MD - Prevent the saving of empty Group Allocations
                        for (int i = 0; i < em.EditMessages.Count; i++)
                        {
                            EditMsgs.Message emm = (EditMsgs.Message)em.EditMessages[i];
                            AddErrorMessage(emm);
                        }
                        MessageBox.Show(_errors, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    e.Cancel = true;
                }
            }
            catch
            {
                throw;
            }
        }

        private void ugDetails_KeyDown(object sender, KeyEventArgs e)
        {
            try
            {
                _gridKeyEvent = e;
                _deleteKeyPressed = false;
                if (e.KeyData == Keys.Delete && this.ugDetails.ActiveRow != null)
                {
                    _rClickRow = this.ugDetails.ActiveRow;
                    _deleteKeyPressed = true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_Error(object sender, Infragistics.Win.UltraWinGrid.ErrorEventArgs e)
        {
            try
            {
                EditMsgs em = new EditMsgs();
                if (_fromRightClick)
                {
                    _fromRightClick = false;
                    e.Cancel = true;
                }
                else if (_addingHeaderToAssortment || _fromCellButton)
                {
                    e.Cancel = true;
                }
                else if (e.DataErrorInfo.Row == null)
                {
                    e.Cancel = true;
                }
                else if (!ValidateSpecificFields(e.DataErrorInfo.Row, ref em))
                {
                    if (em.EditMessages.Count > 0)
                    {
                        _errors = null;
                        for (int i = 0; i < em.EditMessages.Count; i++)
                        {
                            EditMsgs.Message emm = (EditMsgs.Message)em.EditMessages[i];
                            AddErrorMessage(emm);
                        }
                        MessageBox.Show(_errors, _windowName, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    e.Cancel = true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_DragEnter(object sender, DragEventArgs e)
        {
			// "inits" the ugDetails toolTip to null for any drag and drop errors later
			SetUltraGridDragOverToolTip(ugDetails, null);	// TT#742-MD - Stodd - Assortment tooltips
            Image_DragEnter(sender, e);
        }

        private void ugDetails_DragOver(object sender, DragEventArgs e)
        {
            try
            {
				// BEGIN Stodd - 4.0 to 4.1 Manual merge
				string enqMessage = string.Empty;
				//BEGIN TT#9-MD - DOConnell - Cannot drag and drop header into assortment 
                AllocationHeaderProfileList allocProfileList = (AllocationHeaderProfileList)_transaction.GetMasterProfileList(eProfileType.AllocationHeader);
                if (_assortReviewContentSecurity.IsReadOnly || !_transaction.AreHeadersEnqueued(allocProfileList))
				//if (_assortReviewContentSecurity.IsReadOnly || !_transaction.EnqueueSelectedHeaders(out enqMessage))
                //if (_assortReviewContentSecurity.IsReadOnly || !_transaction.HeadersEnqueued)
				// END Stodd - 4.0 to 4.1 Manual merge
				//END TT#9-MD - DOConnell - Cannot drag and drop header into assortment
                {
                    e.Effect = DragDropEffects.None;
                    return;
                }

                Image_DragOver(sender, e);

                Infragistics.Win.UIElement aUIElement;

                Point realPoint = ugDetails.PointToClient(new Point(e.X, e.Y)); 
                aUIElement = ugDetails.DisplayLayout.UIElement.ElementFromPoint(realPoint);

                if (aUIElement == null)
                {
                    e.Effect = DragDropEffects.None;
                    return;
                }

                string msg = string.Empty;	// TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                bool validDrag = false;
                if (row == null)
                {
                    if (e.Data.GetDataPresent(typeof(SelectedRowsCollection)))
                    {
                        SelectedRowsCollection SelRows = (SelectedRowsCollection)e.Data.GetData(typeof(SelectedRowsCollection));
                        validDrag = true;
                        foreach (UltraGridRow selRow in SelRows)
                        {
                            if (selRow.Cells["HdrGroupRID"].Value != DBNull.Value
                             || selRow.Cells["GroupAllocRID"].Value != DBNull.Value     // Begin TT#909 - MD - stodd - allowed to drop Group allocation into assortment
                             || selRow.Cells["AsrtRID"].Value != DBNull.Value)
                            {
								// Begin TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
								//BEGIN TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                //msg = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeaderBelongsToOtherAssortment);
                                msg = MIDText.GetTextOnly(eMIDTextCode.msg_as_HeaderBelongsToOtherAssortment);
								//END TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                msg = msg.Replace("{0}", ProcessName);
                                SetUltraGridDragOverToolTip(ugDetails, msg);		// TT#742-MD - Stodd - Assortment tooltips
								// End TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                                validDrag = false;
                                break;
                            }
							//TT#686 - MD - DOConnell - Add Restrictions to what types of headers can be dropped on a placeholder.
                            //else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance)
                            else if (!(Convert.ToInt32(selRow.Cells["Status"].Value) == (int)eHeaderAllocationStatus.ReceivedInBalance || Convert.ToInt32(selRow.Cells["Status"].Value) == (int)eHeaderAllocationStatus.AllocationStarted) ||	// TT#1092 - MD - stodd - headers with "allocated started" can be dropped and removed -
                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.WorkupTotalBuy ||
                                    Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.IMO ||	// TT#4116 - stodd - prohibit dropping of VSW header
                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)))
                            {
								// Begin TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
								//BEGIN TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                //msg = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeaderNotReceivedInBalance);
								//END TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                msg = MIDText.GetTextOnly(eMIDTextCode.msg_as_HeaderNotReceivedInBalance);
                                msg = msg.Replace("{0}", ProcessName);
                                SetUltraGridDragOverToolTip(ugDetails, msg);		// TT#742-MD - Stodd - Assortment tooltips
								// End TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                                validDrag = false;
                                break;
                            }
                        }
                    }
                }
                else
                {
                    validDrag = false;
                    switch (row.Band.Key)
                    {
                        case "Header":
                            //case "Placeholder":
                            validDrag = DragOverHeader(sender, aUIElement, ref e);
                            break;

                        case "BulkColor":
                            validDrag = DragOverBulkColor(sender, aUIElement, ref e);
                            break;

                        case "Pack":
                            validDrag = DragOverPack(sender, aUIElement, ref e);
                            break;

                        case "PackColor":
                            validDrag = DragOverPackColor(sender, aUIElement, ref e);
                            break;

                        default:
                            break;
                    }
                }

                if (validDrag)
                {
                    e.Effect = DragDropEffects.All;
                }
                else
                {
                    e.Effect = DragDropEffects.None;
					ShowUltraGridToolTip(ugDetails);	// TT#742-MD - Stodd - Assortment tooltips
                }

            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool DragOverHeader(object sender, Infragistics.Win.UIElement aUIElement, ref DragEventArgs e)
        {
            TreeNodeClipboardList cbList;
            string msg = string.Empty;	// TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
            //TreeNodeClipboardProfile cbProf;
            try
            {
                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                UltraGridCell dragOverCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));

                //if (dragOverCell == null || dragOverCell.Activation != Activation.AllowEdit)
                if (dragOverCell == null)
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
               
                bool validDrag = true;
                switch (dragOverCell.Column.Key)
                {
                    case "Style":
                    case "Product":
                    case "AnchorNode":

                        if (dragOverCell.Activation != Activation.AllowEdit)
                        {
                            validDrag = false;
                        }
                        else if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                        {
                            cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));

                            if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                            {
                                HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(_mainHp.Key, cbList.ClipboardProfile.Key);

                                if (dragOverCell.Column.Key == "AnchorNode")
                                {
                                    if (hnp.HomeHierarchyLevel >= _hlpStyle.Level)
                                    {
                                        validDrag = false;
                                    }
                                }
                                else if (hnp.LevelType != eHierarchyLevelType.Style &&
                                         hnp.HomeHierarchyLevel != _hlpProduct.Level)
                                {
                                    validDrag = false;
                                }
                            }
                            else
                            {
                                validDrag = false;
                            }
                        }
                        break;

                    case "Workflow":

                        if (dragOverCell.Activation != Activation.AllowEdit)
                        {
                            validDrag = false;
                        }
                        else if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                        {
                            cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));

                            if (cbList.ClipboardDataType != eProfileType.Workflow)
                            {
                                validDrag = false;
                            }
                        }
                        break;

                    case "HeaderID":

                        if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                        {
                            cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));
                        
                            if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                            {
                                HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(_mainHp.Key, cbList.ClipboardProfile.Key);
                                if (hnp.LevelType != eHierarchyLevelType.Color)
                                {
                                    validDrag = false;
                                }

                            }
                            else if (cbList.ClipboardDataType != eProfileType.ColorCode)
                            {
                                validDrag = false;
                            }
                            else if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                            {
                                validDrag = false;
                            }
                            else if (ugDetails.ActiveRow != row)
                            {
							
                                validDrag = false;
                            }
                        }
                        else if (e.Data.GetDataPresent(typeof(SelectedRowsCollection)))
                        {
                            int asrtRID = 0;
                            eHeaderType hdrType = (eHeaderType)Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                            if (row.Cells["AsrtRID"].Value != DBNull.Value)
                            {
                                asrtRID = Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                            }
                            SelectedRowsCollection SelRows = (SelectedRowsCollection)e.Data.GetData(typeof(SelectedRowsCollection));

                            switch (hdrType)
                            {
                                case eHeaderType.Assortment:
                                    foreach (UltraGridRow selRow in SelRows)
                                    {
                                        if (selRow.Cells["HdrGroupRID"].Value != DBNull.Value
                                         || selRow.Cells["GroupAllocRID"].Value != DBNull.Value     // Begin TT#909 - MD - stodd - allowed to drop Group allocation into assortment
                                         || selRow.Cells["AsrtRID"].Value != DBNull.Value)
                                        {
											//BEGIN TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
											//SetUltraGridDragOverToolTip(ugDetails, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeaderBelongsToOtherAssortment));		// TT#742-MD - Stodd - Assortment tooltips
                                            SetUltraGridDragOverToolTip(ugDetails, MIDText.GetTextOnly(eMIDTextCode.msg_as_HeaderBelongsToOtherAssortment));
											//END TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                            validDrag = false;
                                            break;
                                        }
										//TT#686 - MD - DOConnell - Add Restrictions to what types of headers can be dropped on a placeholder.
                                        //else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance)
                                        else if (!(Convert.ToInt32(selRow.Cells["Status"].Value) == (int)eHeaderAllocationStatus.ReceivedInBalance || Convert.ToInt32(selRow.Cells["Status"].Value) == (int)eHeaderAllocationStatus.AllocationStarted) ||	// TT#1092 - MD - stodd - headers with "allocated started" can be dropped and removed -
                                                (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.WorkupTotalBuy ||
                                                Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.IMO ||	// TT#4116 - stodd - prohibit dropping of VSW header
                                                (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)))
                                        {
											// Begin TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
											//BEGIN TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                            //msg = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeaderNotReceivedInBalance);
                                            msg = MIDText.GetTextOnly(eMIDTextCode.msg_as_HeaderNotReceivedInBalance);
											//END TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                            msg = msg.Replace("{0}", ProcessName);
											SetUltraGridDragOverToolTip(ugDetails, msg);		// TT#742-MD - Stodd - Assortment tooltips
											// End TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                                            validDrag = false;
                                            break;
                                        }
                                    }
                                    break;
                                case eHeaderType.Placeholder:
                                    if (!AllowPlaceholderUpdate(row))
                                    {
										//BEGIN TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
										//SetUltraGridDragOverToolTip(ugDetails, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeaderDropInvalidSecurity));		// TT#742-MD - Stodd - Assortment tooltips
                                        SetUltraGridDragOverToolTip(ugDetails, MIDText.GetTextOnly(eMIDTextCode.msg_as_HeaderDropInvalidSecurity));
										//END TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                        validDrag = false;
                                    }
                                    else
                                    {
                                        int phHdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                                        foreach (UltraGridRow selRow in SelRows)
                                        {
                                            if (selRow.Cells["HdrGroupRID"].Value != DBNull.Value
                                             || selRow.Cells["GroupAllocRID"].Value != DBNull.Value     // Begin TT#909 - MD - stodd - allowed to drop Group allocation into assortment
                                             || selRow.Cells["AsrtRID"].Value != DBNull.Value)
                                            {
												//BEGIN TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                                //SetUltraGridDragOverToolTip(ugDetails, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeaderBelongsToOtherAssortment));		// TT#742-MD - Stodd - Assortment tooltips
                                                SetUltraGridDragOverToolTip(ugDetails, MIDText.GetTextOnly(eMIDTextCode.msg_as_HeaderBelongsToOtherAssortment));
												//END TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment	
                                                validDrag = false;
                                                break;
                                            }
											//TT#686 - MD - DOConnell - Add Restrictions to what types of headers can be dropped on a placeholder.
                                            //else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance)
                                            else if (!(Convert.ToInt32(selRow.Cells["Status"].Value) == (int)eHeaderAllocationStatus.ReceivedInBalance || Convert.ToInt32(selRow.Cells["Status"].Value) == (int)eHeaderAllocationStatus.AllocationStarted) ||	// TT#1092 - MD - stodd - headers with "allocated started" can be dropped and removed -
                                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.WorkupTotalBuy ||
                                                    Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.IMO ||	// TT#4116 - stodd - prohibit dropping of VSW header
                                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)))
                                            {
												// Begin TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                                                //BEGIN TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
												//msg = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeaderNotReceivedInBalance);
                                                msg = MIDText.GetTextOnly(eMIDTextCode.msg_as_HeaderNotReceivedInBalance);
												//END TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                                msg = msg.Replace("{0}", ProcessName);
												SetUltraGridDragOverToolTip(ugDetails, msg );		// TT#742-MD - Stodd - Assortment tooltips
												// End TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                                                validDrag = false;
                                                break;
                                            }
                                            else
                                            {

                                                int styleHnRID = Convert.ToInt32(selRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                                foreach (UltraGridRow row2 in ugDetails.Rows)
                                                {
													// Begin - TT#1227 - stodd
													// discovered this while testing TT#1227
													if ((row2.Cells["AsrtRID"].Value == DBNull.Value) ||
														 (Convert.ToInt32(row2.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == asrtRID
														&& Convert.ToInt32(row2.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder
														&& Convert.ToInt32(row2.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != phHdrRID
														&& Convert.ToInt32(row2.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture) == styleHnRID))
													// End - TT#1227 - stodd
                                                    {
                                                        validDrag = false;
														// BEGIN TT#773-MD - Stodd - replace hashtable with dictionary - wrong message text
														string errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_as_DupPhStylesNotAllowed), _lblPlaceholder + " " + _hlpStyle.LevelID);
														SetUltraGridDragOverToolTip(ugDetails, errorMessage);
														//SetUltraGridDragOverToolTip(ugDetails, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PlaceholderHeaderComponentMismatch));		// TT#742-MD - Stodd - Assortment tooltips
														// END TT#773-MD - Stodd - replace hashtable with dictionary
                                                        break;
                                                    }
                                                }
												//BEGIN TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
												if (validDrag)
												{
													if (IsComponentMismatch(SelRows, row))
													{
														//BEGIN TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment
                                                        //SetUltraGridDragOverToolTip(ugDetails, _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PlaceholderHeaderComponentMismatch));		// TT#742-MD - Stodd - Assortment tooltips
                                                        SetUltraGridDragOverToolTip(ugDetails, MIDText.GetTextOnly(eMIDTextCode.msg_as_PlaceholderHeaderComponentMismatch));
                                                        //END TT#1518 - MD- DOConnell - Audit is being proliferated with "Null" messages when working within an assortment	
														e.Effect = DragDropEffects.None;
														return false;
													}    
												}
												//END TT#586-MD - stodd - dragging a header with components to a placeholder w/o any components is not correctly adjusting the placeholder 
                                            }
                                        }
                                    }
                                    break;

                                default:
                                    validDrag = false;
                                    break;
                            }
                        }
                        else
                        {
                            validDrag = false;
                        }
                        break;

                    default:
                        validDrag = false;
                        break;
                }
                if (!validDrag)
                {
					e.Effect = DragDropEffects.None; 
                }
                return validDrag;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool DragOverBulkColor(object sender, Infragistics.Win.UIElement aUIElement, ref DragEventArgs e)
        {
            TreeNodeClipboardList cbList = null;
            try
            {
                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                UltraGridCell dragOverCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));
                SelectedRowsCollection SelRows = (SelectedRowsCollection)e.Data.GetData(typeof(SelectedRowsCollection)); //TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
                if (dragOverCell == null || dragOverCell.Activation != Activation.AllowEdit)
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }

                if (dragOverCell != row.Cells["BulkColor"])
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
                else if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                {
                    cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));

                    if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                    {
                        HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(_mainHp.Key, cbList.ClipboardProfile.Key);
                        if (hnp.LevelType != eHierarchyLevelType.Color)
                        {
                            e.Effect = DragDropEffects.None;
                            return false;
                        }
                    }
                    else if (cbList.ClipboardDataType != eProfileType.ColorCode)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.ActiveRow != row)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                }
				//BEGIN TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
                else if (e.Data.GetDataPresent(typeof(SelectedRowsCollection)))
                {
                    if (IsMultiColorRow(SelRows, row))
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }                    
                }
				//END TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
                else
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool DragOverPack(object sender, Infragistics.Win.UIElement aUIElement, ref DragEventArgs e)
        {
            TreeNodeClipboardList cbList;
            try
            {
                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                UltraGridCell dragOverCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));
                if (dragOverCell == null || dragOverCell.Activation != Activation.AllowEdit)
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }

                if (dragOverCell != row.Cells["Pack"])
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
                else if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                {
                    cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));
                    if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                    {
                        HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(_mainHp.Key, cbList.ClipboardProfile.Key);
                        if (hnp.LevelType != eHierarchyLevelType.Color)
                        {
                            e.Effect = DragDropEffects.None;
                            return false;
                        }
                    }
                    else if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.ActiveRow != row)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                }
                else if (e.Data.GetDataPresent(typeof(ColorCodeClipboardList)))
                {
                    if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.ActiveRow != row)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                }
                else
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool DragOverPackColor(object sender, Infragistics.Win.UIElement aUIElement, ref DragEventArgs e)
        {
            TreeNodeClipboardList cbList;
            try
            {
                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                UltraGridCell dragOverCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));
                if (dragOverCell == null || dragOverCell.Activation != Activation.AllowEdit)
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }

                if (dragOverCell != row.Cells["PackColor"])
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
                else if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                {
                    cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));

                    if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                    {
                        HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(_mainHp.Key, cbList.ClipboardProfile.Key);
                        if (hnp.LevelType != eHierarchyLevelType.Color)
                        {
                            e.Effect = DragDropEffects.None;
                            return false;
                        }
                    }
                    else if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.ActiveRow != row)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                }
                else if (e.Data.GetDataPresent(typeof(ColorCodeClipboardList)))
                {
                    if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.ActiveRow != row)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                }
                else
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void ugDetails_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                Infragistics.Win.UIElement aUIElement;
                SelectedRowsCollection SelRows;
                TreeNodeClipboardList cbList;
                //ColorCodeClipboardList ccList;
                string errMessage = string.Empty; //TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color

                Point realPoint = ugDetails.PointToClient(new Point(e.X, e.Y)); 
                aUIElement = ugDetails.DisplayLayout.UIElement.ElementFromPoint(realPoint);

                UltraGridRow dropRow = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                UltraGridCell dropCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));

                _dropCell = dropCell; //TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
                _dropRow = dropRow; //TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color

                if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                {
                    cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));
					// BEGIN TT#1810 - stodd - dragging color 
					if (dropRow != null)
					{
						ugDetails.ActiveRow = dropRow;
					}
					// END TT#1810 - stodd - dragging color 
                    switch (cbList.ClipboardDataType)
                    {
                        case eProfileType.HierarchyNode:
                            if (cbList.ClipboardItems.Count == 1)
                            {
                                NodeDragDrop(dropRow, cbList.ClipboardProfile, dropCell); 
                            }
                            else
                            {
                                HierNodeListDragDrop(dropRow, cbList);
                            }
                            break;

                        case eProfileType.ColorCode:
                            ColorListDragDrop(dropRow, cbList);
                            break;
                        
                        case eProfileType.Workflow:
                            WorkflowDragDrop(dropRow, cbList.ClipboardProfile);
                            break;
                    }
                }
                //else if (e.Data.GetDataPresent(typeof(ColorCodeClipboardList)))
                //{
                //    ccList = (ColorCodeClipboardList)e.Data.GetData(typeof(ColorCodeClipboardList));

                //    ColorListDragDrop(dropRow, ccList);

                //}
                else if (e.Data.GetDataPresent(typeof(SelectedRowsCollection)))
                {
                    SelRows = (SelectedRowsCollection)e.Data.GetData(typeof(SelectedRowsCollection));
                    try
                    {
						//BEGIN TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
                        if (dropCell != null && dropCell.Column.Key == "BulkColor")
						{

							if (!IsMultiColorRow(SelRows, dropRow))
							{
								dropRow = dropRow.ParentRow;
							}
						}
						//END TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
                        HeaderDragDrop(dropRow, SelRows);
                    }
                    catch
                    {
                        ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, false);
                        foreach (UltraGridRow selRow in SelRows)
                        {
                            int hRID1 = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            foreach (UltraGridRow row in ugDetails.Rows)
                            {
                                int hRID2 = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                                if (hRID2 == hRID1)
                                {
                                    row.Delete(false);
                                    break;
                                }
                            }
                        }
                        ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, true);
                    }
                }
                else
                {
                    MessageBox.Show(MIDText.GetTextOnly(eMIDTextCode.msg_InvalidDataType));
                }
            }
            catch (Exception)
            {
                //string text = string.Format(MIDText.GetTextOnly(eMIDTextCode.msg_MustBeStyleOrProductNode), _hlpStyle.LevelID, _hlpProduct.LevelID);
                string text = MIDText.GetTextOnly(eMIDTextCode.msg_InvalidDataType);
                MessageBox.Show(text);
            }
        }

        private void NodeDragDrop(UltraGridRow aRow, TreeNodeClipboardProfile aCBProfile, UltraGridCell aDropCell) //TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
		//private void NodeDragDrop(UltraGridRow aRow, SelectedRowsCollection aSelRows, UltraGridCell aDropCell)
        {
            string errorMessage = string.Empty;
            try
            {
				//BEGIN TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
                TreeNodeClipboardProfile cbp = aCBProfile;

                HierarchyNodeSecurityProfile securityNode = _sab.ClientServerSession.GetMyUserNodeSecurityAssignment(cbp.Key, (int)eSecurityTypes.Allocation);
                if (!securityNode.AllowUpdate)
                {
                    MessageBox.Show(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_NotAuthorizedForNode));
                }
                else
				//END TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
                {
                    string message = string.Empty;
                    HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(_mainHp.Key, cbp.Key); //TT#564 - MD - DOConnell - Allow a header to be dragged and dropped onto a placeholder color
                    if (hnp.LevelType == eHierarchyLevelType.Color)
                    {
                        ColorDragDrop(aRow, hnp.ColorOrSizeCodeRID);
                    }
                    else if (aDropCell == aRow.Cells["AnchorNode"])
                    {
                        //TODO  validate ancestor link to assortment anchor node
                        //if (!ValidAssortmentLink(aRow, hnp.Key))
                        //{
                        //    return;
                        //}
                        _skipAnchorEdit = true;
                        int oldNodeRID = Convert.ToInt32(aRow.Cells["AnchorHnRID"].Value, CultureInfo.CurrentUICulture);
                        aRow.Cells["AnchorNode"].Value = hnp.LevelText;
                        aRow.Cells["AnchorHnRID"].Value = hnp.Key;
                        UpdateAnchorNodeTable(aRow);
                    }
                    else if (hnp.LevelType == eHierarchyLevelType.Style)
                    {
                        if (Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                        {
                            if (!ValidPlaceholderStyle(aRow, hnp.Key, ref errorMessage))
                            {
                                return;
                            }
                            else
                            {
                                int phHdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                                int styleRID = Convert.ToInt32(aRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                if (!_deletedPlaceholderStyles.ContainsKey(phHdrRID))
                                {
                                    _deletedPlaceholderStyles.Add(phHdrRID, styleRID);
                                }
                            }
                        }
                        _skipStyleEdit = true;
                        aRow.Cells["Style"].Value = hnp.LevelText;
                        aRow.Cells["StyleHnRID"].Value = hnp.Key;
                        aRow.Cells["Description"].Value = hnp.NodeDescription;
                        HierarchyNodeProfile productHnp = _sab.HierarchyServerSession.GetNodeData(hnp.HomeHierarchyParentRID);
            
                        RequiredFieldEntered(aRow.Cells["Style"], ref message);
                        RequiredFieldEntered(aRow.Cells["Description"], ref message);

                        // Begin TT#2127-MD - JSmith - Drag/Drop style to a header with PH colors and size receive severe error.
                        if (!hnp.IsVirtual)
                        {
                            AllocationProfile ap = GetAllocationProfile(Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                            AddColorAndSizesToStyle(hnp.Key, aRow, ap);
                        }
                        // End TT#2127-MD - JSmith - Drag/Drop style to a header with PH colors and size receive severe error.

                        _skipProductEdit = true;
                        aRow.Cells["ProductRID"].Value = productHnp.Key;
                        aRow.Cells["Product"].Value = productHnp.LevelText;
                        RequiredFieldEntered(aRow.Cells["Product"], ref message);
                        aRow.Cells["StyleSecurity"].Value = (int)eSecurityType.Update;
                    }
                    else if (hnp.HomeHierarchyLevel == _hlpProduct.Level)
                    {
                        _skipProductEdit = true;
                        aRow.Cells["ProductRID"].Value = hnp.Key;
                        aRow.Cells["Product"].Value = hnp.LevelText;
                        RequiredFieldEntered(aRow.Cells["Product"], ref message);

                        _skipStyleEdit = true;
                        aRow.Cells["Style"].Value = string.Empty;
                        aRow.Cells["StyleHnRID"].Value = Include.NoRID;
                        aRow.Cells["StyleSecurity"].Value = (int)eSecurityType.Update;
                        aRow.Cells["Description"].Value = string.Empty;
                        
                        RequiredFieldEntered(aRow.Cells["Style"], ref message);
                        RequiredFieldEntered(aRow.Cells["Description"], ref message);

                        errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_MustBeCorrectLevel), _hlpStyle.LevelID);
                        MessageBox.Show(errorMessage, this.Text);
                        aRow.Cells["Style"].Activated = true;
                        ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                    }
                    else
                    {
                        throw new Exception();
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void HierNodeListDragDrop(UltraGridRow aRow, TreeNodeClipboardList aCBList)
        {
            try
            {
                // Dropping on a BulkColor or PackColor row replaces the color
                // Dropping on a Header or Pack row adds new color rows

                string errorMessage = string.Empty;
                ColorCodeProfile ccp;

                // Change profile key from NodeRID to ColorCodeRID  
                foreach (TreeNodeClipboardProfile cbpColor in aCBList.ClipboardItems)
                {
                    HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(_mainHp.Key, cbpColor.Key);
                    cbpColor.Key = hnp.ColorOrSizeCodeRID;
                }

                ugDetails.BeginUpdate();
                ugDetails.SuspendRowSynchronization();
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, false);
                switch (aRow.Band.Key)
                {
                    case "Header":
                    case "Pack":
                        AddColorRowsFromList(aRow, aCBList);
                        break;

                    case "BulkColor":
                        ccp = _sab.HierarchyServerSession.GetColorCodeProfile(aCBList.ClipboardProfile.Key);
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["BulkColor"].Value = ccp.ColorCodeID;
                        break;

                    case "PackColor":
                        ccp = _sab.HierarchyServerSession.GetColorCodeProfile(aCBList.ClipboardProfile.Key);
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["PackColor"].Value = ccp.ColorCodeID;
                        break;
                }

                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, true);
                ugDetails.ResumeRowSynchronization();
                ugDetails.EndUpdate();
            }
            catch
            {
                throw;
            }
        }

        private void ColorDragDrop(UltraGridRow aRow, int aColorCodeRID)
        {
            try
            {
                // Dropping on a BulkColor or PackColor row replaces the color
                // Dropping on a Header or Pack row adds new color rows
                ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(aColorCodeRID);
                bool okToContinue = false;
                string errorMessage = string.Empty;
                switch (aRow.Band.Key)
                {
                    case "BulkColor":
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["BulkColor"].Value = ccp.ColorCodeID;
                        break;

                    case "PackColor":
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["PackColor"].Value = ccp.ColorCodeID;
                        break;

                    case "Header":
                        okToContinue = AddBulkColorRow();
                        if (okToContinue)
                        {
                            UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                        }
                        break;

                    case "Pack":
                        _skipRowUpdate = true;
                        okToContinue = AddPackColorRow();
                        if (okToContinue)
                        {
                            UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                        }
                        _skipRowUpdate = false;
                        break;
                }
            }
            catch
            {
                throw;
            }
            finally
            {
                if (_frmColorBrowser != null)
                {
                    _frmColorBrowser.Dispose();
                }
            }
        }

        private void ColorListDragDrop(UltraGridRow aRow, TreeNodeClipboardList aCCList)
        {
            try
            {
                // Dropping on a BulkColor or PackColor row replaces the color with the 1st one selected 
                // Dropping on a Header or Pack row adds new color rows

                string errorMessage = string.Empty;
                ColorCodeProfile ccp;

                ugDetails.BeginUpdate();
                ugDetails.SuspendRowSynchronization();
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, false);
                switch (aRow.Band.Key)
                {
                    case "Header":
                    case "Pack":
                        AddColorRowsFromList(aRow, aCCList);
                        break;

                    case "BulkColor":
                        ccp = _sab.HierarchyServerSession.GetColorCodeProfile(aCCList.ClipboardProfile.Key);
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["BulkColor"].Value = ccp.ColorCodeID;
                        break;

                    case "PackColor":
                        ccp = _sab.HierarchyServerSession.GetColorCodeProfile(aCCList.ClipboardProfile.Key);
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["PackColor"].Value = ccp.ColorCodeID;
                        break;
                }

                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, true);
                ugDetails.ResumeRowSynchronization();
                ugDetails.EndUpdate();
            }
            catch
            {
                throw;
            }
            finally
            {
                _frmColorBrowser.Dispose();
            }
        }

        private void AddColorRowsFromList(UltraGridRow aRow, TreeNodeClipboardList aCCList)
        {
            try
            {
                bool okToContinue = true;
                string errorMessage = string.Empty;
                if (!aRow.Selected)
                {
                    aRow.Selected = true;
                }

                // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                ArrayList colorCodeList = new ArrayList();
                // End TT#1282
                
                bool canSpreadUnits = CanSpreadUnits(aRow);

                _skipRowUpdate = true;
                foreach (UltraGridRow row in ugDetails.Selected.Rows)
                {
                    colorCodeList.Clear();
                    int hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    int i = 0;
                    foreach (TreeNodeClipboardProfile cbp in aCCList.ClipboardItems)
                    {
                        ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(cbp.Key);
                        ugDetails.ActiveRow = row;
                        if (aRow.Band.Key == "Header")
                        {
                            okToContinue = AddBulkColorRow();
                        }
                        else
                        {
                            okToContinue = AddPackColorRow();
                        }
                        if (okToContinue)
                        {
                            okToContinue = UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                           
                            // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                            if (!colorCodeList.Contains(ccp.Key))
                            {
                                 colorCodeList.Add(ccp.Key);
                            }
                            // End TT#1282
                            i++;
                        }
                        if (!okToContinue)
                        {
                            break;
                        }
                    }
                    if (!okToContinue)
                    {
                        break;
                    }
                    // Begin TT#1282 - RMatelic - Assortment - Added colors to a style, the style originally had quantities in it.  When I added the colors the style went to 0
                    else if (canSpreadUnits)   
                    {
                        okToContinue = SetStoreAllocatedColorUnits(hdrRID, colorCodeList);
                    }
                    // End TT#1282
                }
                _skipRowUpdate = false;
                if (okToContinue)
                {
                    //SaveAndUpdateAssortmentTab();
                    OnAssortmentSaveHeaderData(null);					// TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                }
            }
            catch
            {
                throw;
            }
        }

        private void WorkflowDragDrop(UltraGridRow aRow, TreeNodeClipboardProfile aCBProfile)
        {
            try
            {
                aRow.Cells["Workflow"].Value = ((MIDWorkflowMethodTreeNode)aCBProfile.Node).Name;
                // Begin TT#1278 - RMatelic - Assortment When selecting Save no hour glass appears and the user cannot tell if somethingis saved or not.  Selecting the X in the right had corner does not give a message asking if the user wants to save or not.
                if (_assortReviewContentSecurity.AllowUpdate)
                {
                    ChangePending = true;
                }
                // End TT#1278 
            }
            catch
            {
            }
        }

        public void HeaderDragDrop(UltraGridRow aRow, SelectedRowsCollection aSelRows)
        {
            try
            {
                if (!ContinueHeaderDrop(aSelRows))
                {
                    // Begin TT#1069 - md - stodd - exception when dropping headers
                    //throw new Exception();
                    return;
                    // End TT#1069 - md - stodd - exception when dropping headers
                }

                ugDetails.BeginUpdate();
                ugDetails.SuspendRowSynchronization();
                ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);

                _dsDetails.AcceptChanges();
               
                BindDetailsGrid();
         
                ugDetails.Selected.Rows.Clear();

                if (aRow != null)
                {
                    aRow.Selected = true;
                }
                else 
                {
                    // Begin TT#1227 - RMatelic - Placeholders s/b sorted by a sequence number
                    //aRow = ugDetails.Rows[0];
                    //aRow.Selected = true;
                    UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                    while (row != null)
                    {
                        if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Assortment)
                        {
                            aRow = row;
                            aRow.Selected = true;
                            break;
                        }
                        row = row.GetSibling(SiblingRow.Next, false);
                    }  
                    // End TT#1227
                }
                foreach (UltraGridRow selRow in aSelRows)
                {

                    int hRID1 = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    foreach (UltraGridRow row in ugDetails.Rows)
                    {
                        int hRID2 = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        if (hRID2 == hRID1)
                        {
                            row.Selected = true;
                            break;
                        }
                    }
                }

                ugDetails.ResumeRowSynchronization();
                ugDetails.EndUpdate();
                ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);

                if (aRow != null)
                {
                    EventArgs args = new EventArgs();
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);

                    switch (headerType)
                    {
                        case eHeaderType.Assortment:
                        case eHeaderType.Placeholder:
                            _addingHeaderToAssortment = true;
                            AddHeadersToAssortment();
                            _addingHeaderToAssortment = false;
                            break;

                        default:
                            break;
                    }
                }
                else
                {
                    SetEditActivation();
                }
                // Begin TT#1278 - RMatelic - Assortment When selecting Save no hour glass appears and the user cannot tell if somethingis saved or not.  Selecting the X in the right had corner does not give a message asking if the user wants to save or not.
                //if (_assortReviewContentSecurity.AllowUpdate)
                //{
                //    ChangePending = true;
                //}
                // End TT#1278 
            }
            catch
            {
                ugDetails.ResumeRowSynchronization();
                ugDetails.EndUpdate();
                ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                throw;
            }
        }

        private bool ContinueHeaderDrop(SelectedRowsCollection aSelRows)
        {
            bool continueDrop = true;
            string errMessage = string.Empty;
            try
            {
               	// Begin TT#1053 - MD - stodd - removing/adding headers to GA - 
                AssortmentProfile asp = GetAssortmentProfile();
                if (asp != null && asp.AllocationStarted && !asp.AllUnitsInReserve && IsGroupAllocation)	// TT#1516-MD - stodd - Decreasing the Quantity on a header attached to an Assortment causes a "Quantity to allocate cannot be less than zero" error 
                {
                    errMessage = MIDText.GetTextOnly(eMIDTextCode.msg_al_HeadersCannotBeAddedToGroupAllocation);
                    DialogResult diagResult = _transaction.SAB.MessageCallback.HandleMessage(
                                errMessage,
                                "Invalid Header Add",
                                System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Asterisk);
                    return false;
                }
               	// End TT#1053 - MD - stodd - removing/adding headers to GA - 

                ArrayList hdrArrayList = new ArrayList();
                _addedHeaders.Clear();
                foreach (UltraGridRow selRow in aSelRows)
                {
                    bool rowAlreadyExists = false;
                    int hRID1 = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    string hdrID = Convert.ToString(selRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                    foreach (UltraGridRow row in ugDetails.Rows)
                    {
                        int hRID2 = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        if (hRID2 == hRID1)
                        {
                            rowAlreadyExists = true;
                            break;
                        }
                    }
                    if (!rowAlreadyExists)
                    {
                        hdrArrayList.Add(hRID1);
                        _addedHeaders.Add(hRID1, hdrID);
                    }
                }

                if (hdrArrayList.Count == 0)
                {
                    continueDrop = false;
                }
                // Begin TT#1069 - md - stodd - exception when dropping headers
                else if (!HeadersAddedEnqueued(hdrArrayList, ref errMessage))
                {
                    DialogResult diagResult = _transaction.SAB.MessageCallback.HandleMessage(
                                errMessage,
                                "Enqueue Error",
                                System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Asterisk);
                    return false;
                // Begin TT#1069 - md - stodd - exception when dropping headers
                }
                else
                {
                    for (int i = 0; i < hdrArrayList.Count; i++)
                    {
                        int hdrRID = (int)hdrArrayList[i];
                        if (_headerList.Contains(hdrRID))
                        {
                            AllocationHeaderProfile ahp = (AllocationHeaderProfile)_headerList.FindKey(hdrRID);
                            _headerList.Remove(ahp);
                        }
                        LoadHeader(hdrRID);
                    }
                }
            }
            catch
            {
                throw;
            }
            return continueDrop;
        }    

        #region Enqueue/Dequeue Methods
        private bool HeadersAddedEnqueued(ArrayList aHdrList, ref string enqMessage)    // TT#1069 - md - stodd - exception when dropping headers
        {
			// BEGIN Stodd - 4.0 to 4.1 Manual merge
			//string enqMessage = string.Empty;
            try
            {
				List<int> hdrRidList = new List<int>();
				foreach (int key in aHdrList)
				{
					hdrRidList.Add(key);
				}
				return _transaction.EnqueueHeaders(hdrRidList, out enqMessage);
                //return _transaction.HeadersAddedToEnqueList(aHdrList);
            }
            catch (HeaderConflictException)
            {
				DisplayEnqueueConflict(enqMessage);
                return false;
            }
			// END Stodd - 4.0 to 4.1 Manual merge
        }

		// BEGIN Stodd - 4.0 to 4.1 Manual merge
        private void DisplayEnqueueConflict(string enqMessage)
        {
			//SecurityAdmin secAdmin = new SecurityAdmin();
			//string errMsg = _sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_HeadersInUse) + ":" + System.Environment.NewLine;

			//foreach (HeaderConflict hdrCon in _transaction.AllocationCriteria.HeaderEnqueue.HeaderConflictList)
			//{
			//    string headerID = _addedHeaders[hdrCon.HeaderRID].ToString();
			//    errMsg += System.Environment.NewLine + headerID + ", User: " + secAdmin.GetUserName(hdrCon.UserRID);
			//}
			//errMsg += System.Environment.NewLine + System.Environment.NewLine;
            DialogResult diagResult = _transaction.SAB.MessageCallback.HandleMessage(
				enqMessage,
                "Header Lock Conflict",
                System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Asterisk);
        }
		// END Stodd - 4.0 to 4.1 Manual merge

        private void RemoveAndDequeueHeader(int aHeaderRID)
        {
            try
            {
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, false);
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aHeaderRID)
                    {
                        if (OKToDeleteRow(row))
                        {
							// BEGIN Stodd - 4.0 to 4.1 Manual merge
                            //_transaction.AllocationCriteria.HeaderEnqueue.DequeueHeader(aHeaderRID);
							List<int> hdrKeyList = new List<int>();
							hdrKeyList.Add(aHeaderRID);
							_transaction.DequeueHeaders(hdrKeyList);
							// END Stodd - 4.0 to 4.1 Manual merge
                            RemoveDetailGridRows(row);
                
                            AllocationProfile ap = GetAllocationProfile(aHeaderRID);
                            if (ap != null)
                            {
                                _allocProfileList.Remove(ap);
                            }
                            if (_headerList.Contains(aHeaderRID))
                            {
                                AllocationHeaderProfile ahp = (AllocationHeaderProfile)_headerList.FindKey(aHeaderRID);
                                _headerList.Remove(ahp);
                            }
                        }
                        break;
                    }
                }
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, true);
            }
            catch
            {
                throw;
            }
        }
        #endregion

        private void ugDetails_DragLeave(object sender, EventArgs e)
        {
            Image_DragLeave(sender, e);
        }

        private void ugDetails_MouseEnterElement(object sender, UIElementEventArgs e)
        {
            try
            {
                ShowUltraGridToolTip(ugDetails, e);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_AfterSortChange(object sender, BandEventArgs e)
        {
            try
            {
                for (int i = 0; i < e.Band.SortedColumns.Count; i++)
                {
                    UltraGridColumn sortColumn = e.Band.SortedColumns[i];

                    if (sortColumn.Key == "AsrtRID")
                    {
                        if (!e.Band.SortedColumns.Exists("AsrtPlaceholderSortSeq"))
                        {
                            e.Band.SortedColumns.Add("AsrtPlaceholderSortSeq", false);
							e.Band.SortedColumns.Add("AsrtHeaderSortSeq", false);	// TT#1227 - stodd
                        }
                        break;
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_InitializeRow(object sender, InitializeRowEventArgs e)
        {
            try
            {
                string bandKey = e.Row.Band.Key;
                if (e.Row.Band.Key == "Header")
                {
                    //eHeaderType headerType = (eHeaderType)Convert.ToInt32(e.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture);

                    UltraGridColumn hdrTypeColumn = e.Row.Band.Columns["Type"];
                    UltraGridColumn asrtTypeColumn = e.Row.Band.Columns["AsrtType"];
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(e.Row.GetCellValue(hdrTypeColumn), CultureInfo.CurrentUICulture);
                    switch (headerType)
                    {
                        case eHeaderType.Assortment:    // safety precaution for Assortments added prior to AsrtType  

                            if (e.Row.GetCellValue(asrtTypeColumn) != DBNull.Value &&
                                Convert.ToInt32(e.Row.GetCellValue(asrtTypeColumn), CultureInfo.CurrentUICulture) == (int)eAssortmentType.Undefined)
                            {
								// GA MERGE STODD
								if (IsGroupAllocation)
								{
								e.Row.Cells["AsrtType"].Value = (int)eAssortmentType.GroupAllocation;
								}
								else
								{
                                e.Row.Cells["AsrtType"].Value = (int)eAssortmentType.PreReceipt;
								}
								// BEGIN TT#2148 - stodd - Assortment totals do not include header values
								EnableBalanceAssortmentAction(true);
								// BEGIN TT#2148 - stodd - Assortment totals do not include header values

                            }
                            e.Row.Hidden = true;
                            break;

                        case eHeaderType.Placeholder:

                            if (GetAssortmentType(e.Row) == eAssortmentType.PostReceipt || GetAssortmentType(e.Row) == eAssortmentType.GroupAllocation)
                            {
                                e.Row.Hidden = true;  
                            }
                            break;

                        default:
                            break;
                    }
                }
                else if (e.Row.Band.Key == "Pack")
                {
                    if (Convert.ToInt32(e.Row.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                    {
                        e.Row.Cells["Pack"].Tag = e.Row.Cells["Pack"].Value.ToString();
                        e.Row.Cells["Pack"].Column.PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        

        private void BindDetailsGrid()
        {
            try
            {
                _bindingGrid = true;  // TT#2073-MD - JSmith - Asst Velocity when select alloate receive mssg Pack is not defined on the Subtotal
                BindingSource bsDetails = new BindingSource(_dsDetails, "");
                this.ugDetails.DataSource = bsDetails;
                this.ugDetails.DisplayLayout.MaxBandDepth = _maxBandDepth;
            }
            catch
            {
                throw;
            }
            // Begin TT#2073-MD - JSmith - Asst Velocity when select alloate receive mssg Pack is not defined on the Subtotal
            finally
            {
                _bindingGrid = false;
            }
            // End TT#2073-MD - JSmith - Asst Velocity when select alloate receive mssg Pack is not defined on the Subtotal
        }

		// BEGIN TT#490-MD - stodd -  post-receipts should not show placeholders
		/// <summary>
		/// Checks the Content Grid (or the assortment profile) to get the Assortment Type (Pre-Receipt or Post-Receipt).
		/// </summary>
		/// <returns></returns>
		private eAssortmentType GetAssortmentType()
        {
			// BEGIN TT#530-MD - stodd -  Columns not correct on matrix tab
			eAssortmentType asrtType = _asrtCubeGroup.AssortmentType;
			// END TT#530-MD - stodd -  Columns not correct on matrix tab

            // If it's Group Allocation, we're done.
            if (asrtType == eAssortmentType.GroupAllocation)
                return asrtType;
			
			//========================================================================
			// if this is true, it means the content grid hasn't been built yet.
			// It's only built if the use selects that tab.
			//========================================================================
			if (_buildDetailsGrid)
			{
				AssortmentProfile asp = (AssortmentProfile)_asrtCubeGroup.DefaultAllocationProfile;
				asrtType = (eAssortmentType)asp.AsrtType;
			}
			else
			{
				foreach (UltraGridRow aRow in this.ugDetails.Rows)
				{
					if (Convert.ToInt32(aRow.Cells["Type"].Value) == (int)eHeaderType.Assortment)
					{
						asrtType = (eAssortmentType)(Convert.ToInt32(aRow.Cells["AsrtType"].Value));
						break;
					}
				}
			}
			
			// BEGIN TT#530-MD - stodd -  Columns not correct on matrix tab
			if (_asrtCubeGroup.AssortmentType != asrtType && !_formLoading)
			{
				_asrtTypeChanged = true;
			}
			// END TT#530-MD - stodd -  Columns not correct on matrix tab
			// BEGIN TT#500-MD - stodd -  Assortment Matrix - Total % values are not correct
			_asrtCubeGroup.AssortmentType = asrtType;
			// END TT#500-MD - stodd -  Assortment Matrix - Total % values are not correct
			return asrtType;
		}
		// END TT#490-MD - stodd -  post-receipts should not show placeholders

        private eAssortmentType GetAssortmentType(UltraGridRow aRow)
        {
            eAssortmentType asrtType = eAssortmentType.Undefined;
            try
            {
                UltraGridRow headerRow = aRow;

                while (headerRow.Band.Key != "Header")
                {
                    headerRow = headerRow.ParentRow;
                }

                UltraGridColumn asrtRidColumn = headerRow.Band.Columns["AsrtRID"];
                int asrtRID = Convert.ToInt32(headerRow.GetCellValue(asrtRidColumn), CultureInfo.CurrentUICulture);

                IEnumerable enumerator = headerRow.Band.GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    UltraGridColumn keyHColumn = row.Band.Columns["KeyH"];
                    UltraGridColumn asrtTypeColumn = row.Band.Columns["AsrtType"];
                    if (Convert.ToInt32(row.GetCellValue(keyHColumn), CultureInfo.CurrentUICulture) == asrtRID)  // the Assortment row
                    {
                        asrtType = (eAssortmentType)Convert.ToInt32(row.GetCellValue(asrtTypeColumn), CultureInfo.CurrentUICulture);
                        break;
                    }
                }

				// BEGIN TT#2148 - stodd - Assortment totals do not include header values
                if (asrtType == eAssortmentType.PostReceipt || asrtType == eAssortmentType.GroupAllocation)
				{
					EnableBalanceAssortmentAction(false);
				}
				else
				{
					EnableBalanceAssortmentAction(true);
				}
				// END TT#2148 - stodd - Assortment totals do not include header values

            }
            catch
            {
                throw;
            }
            return asrtType;
        }

		private bool IsFirstHeader(int aAsrtRID)
		{
			bool isFirst = true;
			try
			{
				foreach (UltraGridRow row in ugDetails.Rows)
				{
					if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aAsrtRID)
					{
						// skip
					}
					else if (row.Cells["AsrtRID"].Value != DBNull.Value
						  && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == aAsrtRID)
					{
						isFirst = false;
						break;
					}
				}
			}
			catch
			{
				throw;
			}
			return isFirst;
		}
		
		// BEGIN TT#2148 - stodd - Assortment totals do not include header values
		private bool IsPostReceiptAssortment()
		{
			bool isPostReceipt = false;

			try
			{
				int assortmentCount = 0;
                int placeholderCount = 0;	// TT#1429-MD - stodd - Object reference error when dropping a header with sizes onto a post-receipt.
                int headerCount = 0;		// TT#1429-MD - stodd - Object reference error when dropping a header with sizes onto a post-receipt.
				_headerList = (AllocationHeaderProfileList)_asrtCubeGroup.GetHeaderList();

				foreach (AllocationHeaderProfile ahp in _headerList)
				{
				    if (ahp.HeaderType == eHeaderType.Assortment)
				    {
				        assortmentCount++;
						if (ahp.AsrtType == (int)eAssortmentType.PostReceipt)
				        {
				            isPostReceipt = true;
				        }
				    }
					// Begin TT#1429-MD - stodd - Object reference error when dropping a header with sizes onto a post-receipt.
                    else if (ahp.HeaderType == eHeaderType.Placeholder)
                    {
                        placeholderCount++;
                    }
                    else
                    {
                        headerCount++;
                    }
					// End TT#1429-MD - stodd - Object reference error when dropping a header with sizes onto a post-receipt.
				}

				if (assortmentCount > 1)
				{
					isPostReceipt = false;
				// Begin TT#1429-MD - stodd - Object reference error when dropping a header with sizes onto a post-receipt.
				}
                else
                {
                    // This catches the initial drop of header(s) onto an assortment to make it a post receipt.
                    if (!isPostReceipt && placeholderCount == 0 && headerCount > 0)
                    {
                        isPostReceipt = true;
                    }
                }
				// End TT#1429-MD - stodd - Object reference error when dropping a header with sizes onto a post-receipt.

				return isPostReceipt;
			}
			catch
			{
				throw;
			}
		}
		// END TT#2148 - stodd - Assortment totals do not include header values
		
        private void HandleMIDException(MIDException MIDexc)
        {
            string Title = _windowName, errLevel, Msg;
            MessageBoxIcon icon;
            MessageBoxButtons buttons;
            buttons = MessageBoxButtons.OK;
            switch (MIDexc.ErrorLevel)
            {
                case eErrorLevel.severe:
                    icon = MessageBoxIcon.Stop;
                    errLevel = MIDText.GetText(Convert.ToInt32(eMIDMessageLevel.Severe));
                    break;

                case eErrorLevel.information:
                    icon = MessageBoxIcon.Information;
                    errLevel = MIDText.GetText(Convert.ToInt32(eMIDMessageLevel.Information));
                    break;

                case eErrorLevel.warning:
                    icon = MessageBoxIcon.Warning;
                    errLevel = MIDText.GetText(Convert.ToInt32(eMIDMessageLevel.Warning));
                    break;

                default:
                    icon = MessageBoxIcon.Stop;
                    errLevel = MIDText.GetText(Convert.ToInt32(eMIDMessageLevel.Severe));
                    break;
            }
            Title += " - ";
            if (MIDexc.InnerException != null)
            {
                Title += errLevel + " - " + MIDexc.Message;
                Msg = MIDexc.InnerException.Message;
            }
            else
            {
                Title += errLevel;
                Msg = MIDexc.Message;
            }
            MessageBox.Show(this, Msg, Title, buttons, icon);
        }

        #endregion

        #region Save Header Data
        private void SaveAndUpdateAssortmentTab()
        {
            try
            {
                _dtHeaders.AcceptChanges();
                OnAssortmentSaveHeaderData(null);
				// BEGIN TT#376-MD - stodd - Update Enqueue logic
				if (!_enqueueHeaderError)
				{
				// END TT#376-MD - stodd - Update Enqueue logic
					SetGridRedraws(false);
					StopPageLoadThreads();
					_asrtCubeGroup.SaveCubeGroup();
                    _asrtCubeGroup.SaveBlockedStyles();   // TT#2037-MD - JSmith - Opened a closed style for grade b and type in value.  Add a Ph color and go back to the matrix the style is now closed all values are gone.
					//CloseAndReOpenCubeGroup();

                    // Begin TT#502 - MD - JEllis - remove Lock code from special Assortment code
					//AllocationSubtotalProfileList subtotalList = (AllocationSubtotalProfileList)_transaction.GetMasterProfileList(eProfileType.AllocationSubtotal);
                    //if (subtotalList != null)
                    //{
                    //    foreach (AllocationSubtotalProfile asp in subtotalList)
                    //    {
                    //        asp.RemoveAllSubtotalMembers();
                    //    }
                    //    _transaction.RemoveAllocationSubtotalProfileList();
                    //}
                    //End TT#502 - MD - JEllis - remove Lock code from special Assortment code

					// ReRead headers in assortment cube to get latest data

					//_asrtCubeGroup.ReReadHeaders();	// TT#1110 - MD - stodd - incorrect style on group allocation header - 
					CloseAndReOpenCubeGroup();
					UpdateData(true);
                    //BEGIN TT#808-MD-DOConnell-Placeholder with existing style-color not showing header on hand and intransit in the velocity detail screen.

                    //_asrtCubeGroup.ReReadHeaders(true);	// TT#705 - MD - stodd - total not spread error // TT#1110 - MD - stodd - incorrect style on group allocation header - 
                    //END TT#808-MD-DOConnell-Placeholder with existing style-color not showing header on hand and intransit in the velocity detail screen.

					SetGridRedraws(true);
					LoadSurroundingPages();

					// Begin TT#1178 - RMatelic - Placeholder Styles do not match Placeholder ID's - need consistency
					_buildProductCharsGrid = true;
					LoadProductCharGrid();
					// End TT#1178

					UpdateOtherViews();
					
					//BEGIN TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment
                    //UpdateSelectableComponentList(true); //TT#416 - MD - DOConnell - Characteristics do not appear in the Column Chooser unless you save the assortment, close the application, and go back in.  Should update automatically.
					//END TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment
					
					// BEGIN TT#115 - stodd - exception removing placeholder
					ChangePending = false;
					// END TT#115 - stodd - exception removing placeholder
				}
            }
            catch (Exception ex)
            {
                HandleExceptions(ex);
            }
        }

        void OnAssortmentSaveHeaderData(object source)
        {
            try
            {
				// Begin TT#2 - stodd - Balance Assortment
				//if (_dsDetails == null)
				//{
				//    LoadContentGrid();
				//}
				// Begin TT#2 - stodd - Balance Assortment
                SaveGridChanges();
                //UpdateData();
				
				// Begin TT#857 - MD - stodd - assortment not honoring view
                int viewRid = Include.NoRID;
                if (source != null)
                {
                    AssortmentViewSave asrtViewSave = (AssortmentViewSave)source;
                    viewRid = asrtViewSave.AssortmentSaveParms.ViewRID;
                }
                SaveUserAssortmentData(viewRid);
				// End TT#857 - MD - stodd - assortment not honoring view
                // Begin TT#1278 - RMatelic - Assortment When selecting Save no hour glass appears and the user cannot tell if somethingis saved or not.  Selecting the X in the right hand corner does not give a message asking if the user wants to save or not.
                ChangePending = false;
                // End TT#1278

            }
            catch (Exception ex)
            {
                HandleExceptions(ex);
            }
        }

        private void SaveGridChanges()
        {
            int hdrRID;
            try
            {
                if (ugDetails.ActiveRow != null && ugDetails.ActiveRow.DataChanged)
                {
                    ugDetails.ActiveRow.Update();
                }

				// Begin TT#2 - stodd - Balance Assortment
				if (_dsDetails == null)
				{
					LoadContentGrid();
				}
				// End TT#2 - stodd - Balance Assortment
                _dsDetails.AcceptChanges();

                // update the quantity on each assortment 
                foreach (DataRow dRow in _assortments.Rows)
                {
                    UpdateAssortmentQuantity(Convert.ToInt32(dRow["AsrtRID"], CultureInfo.CurrentUICulture));                        
                }
         
                // check to save any added colors and sizes
                if (_addedColorSizeHash.Count > 0)
                {
                    SaveAddedColorsSizes();
                }

                // need to first update any headers with components that were removed from Assortments
                // to avoid referential integrity errors in the subsequent loop
				bool success = true;
                if (_removedAsrtHeaders.Count > 0)
                {
                    foreach (int hRID in _removedAsrtHeaders)
                    {
						// BEGIN TT#376-MD - stodd - Update Enqueue logic
						success = WriteHeader(hRID);
						if (!success)
						{
							break;
						}
						// END TT#376-MD - stodd - Update Enqueue logic
						// BEGIN Stodd - 4.0 to 4.1 Manual merge
						//_transaction.AllocationCriteria.HeaderEnqueue.DequeueHeader(hRID);
						List<int> hdrKeyList = new List<int>();
						hdrKeyList.Add(hRID);
						_transaction.DequeueHeaders(hdrKeyList);
						// END Stodd - 4.0 to 4.1 Manual merge
                    
                        AllocationProfile ap = GetAllocationProfile(hRID);
                        if (ap != null)
                        {
                            _allocProfileList.Remove(ap);
							// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                            // Begin TT#607-MD - RMAtelic - Size Review not displaying new sizes added when header is dropped on an assortment placeholder
                            //_transaction.RemoveAllocationProfileFromGrandTotal(ap);
                            // End TT#607-MD
							// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                        }
						// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                        //AllocationProfileList apl = (AllocationProfileList)_transaction.GetMasterProfileList(eProfileType.Allocation);
						AllocationProfileList apl = (AllocationProfileList)_transaction.GetMasterProfileList(eProfileType.AssortmentMember);
						// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                        if (apl != null)
                        {
                            AllocationProfile allocProf = (AllocationProfile)apl.FindKey(hRID);
                            if (allocProf != null)
                            {
								// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                                //_transaction.RemoveAllocationProfile(allocProf);
								_transaction.RemoveAssortmentMemberProfile(allocProf);
								// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                            }
                        }
                    }
                }
             
                // Begin TT#2-Assortment Planning-Multiple headers added to assortment results in header with no PlaceholderrID error
                //foreach (UltraGridRow dRow in ugDetails.Rows)
                //{
                //    UltraGridRow row = dRow;
                //    hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                //    if (!_removedAsrtHeaders.Contains(hdrRID))  // not already updated in prior loop
                //    {
                //        WriteHeader(hdrRID);
                //    }
                //    if (Convert.ToBoolean(row.Cells["CharUpdated"].Value, CultureInfo.CurrentUICulture))
                //    {
                //        UpdateHeaderCharacteristics(row);
                //    }
                //}

				// BEGIN TT#2163 - stodd - in post-receipt, header does not get assigned to placeholder 
				// Description: in TT#1806 the problem was that if 3 placeholders where added,
				//  they got the keys of -1, -2, -3. When added to the hdrRids list, -3 would be first and get added first.
				//  This caused the placeholders to be in the wrong order on the content tab. Addig the "reverse" to the 
				//  entire list corrected this, but caused another issue...
				//  In a post-receipt the placeholder is new (-1 key) and the header being attached already exists. Reversing the 
				//  caused the header to be processed BEFORE the placeholder recieved it's real key (not -1).
				//  Solution(and reason for the funky two hdrRid lists): It's really only the negative keys that need to be reversed.
				//  And they need to be processed first. So there are now two lists that get put back into one with the negative keys
				//  first.
				// BEGIN TT#1806 - stodd - new placeholders not displaying in correct order
                //int[] hdrRIDs = new int[ugDetails.Rows.Count];

				// BEGIN TT#376-MD - stodd - Update Enqueue logic
				if (success)
				{
				// END TT#376-MD - stodd - Update Enqueue logic
					List<int> hdrRIDs = new List<int>();
					List<int> negHdrRIDs = new List<int>();
					List<int> posHdrRIDs = new List<int>();
					for (int i = 0; i < ugDetails.Rows.Count; i++)
					{
						UltraGridRow row = ugDetails.Rows[i];
						hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
						if (hdrRID < 0)
						{
							negHdrRIDs.Add(hdrRID);
						}
						else
						{
							posHdrRIDs.Add(hdrRID);
						}
					}
					negHdrRIDs.Reverse();
					foreach (int hdrRid in negHdrRIDs)
					{
						hdrRIDs.Add(hdrRid);
					}
					foreach (int hdrRid in posHdrRIDs)
					{
						hdrRIDs.Add(hdrRid);
					}
					// END TT#2163 - stodd - in post-receipt, header does not get assigned to placeholder 

					for (int i = 0; i < hdrRIDs.Count; i++)
					{
						if (!_removedAsrtHeaders.Contains(hdrRIDs[i]))  // not already updated in prior loop
						{
							// BEGIN TT#376-MD - stodd - Update Enqueue logic
							success = WriteHeader(hdrRIDs[i]);
							if (!success)
							{
								break;
							}
							// END TT#376-MD - stodd - Update Enqueue logic
						}
					}
					// END TT#1806 - stodd - new placeholders not displaying in correct order

					// BEGIN TT#376-MD - stodd - Update Enqueue logic
					if (success)
					{
					// END TT#376-MD - stodd - Update Enqueue logic
						foreach (UltraGridRow dRow in ugDetails.Rows)
						{
							if (Convert.ToBoolean(dRow.Cells["CharUpdated"].Value, CultureInfo.CurrentUICulture))
							{
								UpdateHeaderCharacteristics(dRow);
							}
						}
						// End TT#2

						if (_deletedHeaderRows.Count > 0)
						{
							DeleteHeaders();
						}

						CheckForPlaceholderStyleDelete(true);
						UpdateAnchorNodes();

						_dsDetailsSaved = null;
						_dsDetailsSaved = _dsDetails.Copy();
						if (_headerAdded)   // this may be temporary; HeaderServerSession doesn't
						{                   // have newly added headers, so it needs to reload them   
                            FilterHeaderOptions headerFilterOptions = new FilterHeaderOptions();
                            headerFilterOptions.USE_WORKSPACE_FIELDS = true;
                            headerFilterOptions.filterType = filterTypes.AssortmentFilter;
                            _sab.HeaderServerSession.RebuildHeaderCharacteristicData(SharedRoutines.GetHeaderFilterForAssortmentView(), headerFilterOptions); //TT#1313-MD -jsobek -Header Filters
							_headerAdded = false;
						}
                        CalculateTotalsForWkSpc(); //TT#774 - MD - DOConnell - Change how TotalUnitsToAllocate are calculated for an assortment profile so it is calculated as needed instead of maintained by the assortment review.
						// Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
						//_eab.AllocationWorkspaceExplorer.IRefresh();
						//_eab.AssortmentWorkspaceExplorer.IRefresh();
                        ReloadUpdatedHeadersInAllocationWorkspace();
                        ReloadUpdatedHeadersInAssortmentWorkspace();
						// End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces

						foreach (UltraGridRow row in ugDetails.Rows)
						{
							row.RefreshSortPosition();
						}

						_removedAsrtHeaders.Clear();
						
						//BEGIN TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment
                        //_characteristicsChanged = true; //TT#416 - MD - DOConnell - Characteristics do not appear in the Column Chooser unless you save the assortment, close the application, and go back in.  Should update automatically.
                        //SaveProductCharacteristics();
						//END TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment
						
						// Begin TT#2 - RMatelic - Assortment Planning-charge intransit to headers attached to intransit placeholders
						UpdatePlaceholderAndHeaderIntransit();
						// End TT#2

						_transaction.RemoveMasterProfileList(_headerList);
						_transaction.SetMasterProfileList(_headerList);
					}
				}
            }
            catch
            {
                throw;
            }
        }

		// BEGIN TT#2 - stodd-assortment
		/// <summary>
		/// copies detail cubes' data to AllocationProfile
		/// </summary>
		private bool SaveDetailCubeGroup()
		{
			try
			{
				_asrtCubeGroup.SaveCubeGroup();
				return true;
			}
			catch (MIDException MIDexc)
			{
				HandleMIDException(MIDexc);
				return false;
			}
			catch (Exception ex)
			{
				HandleException(ex);
				return false;
			}
		}
		// END TT#2 - stodd-assortment

        private void CloseAndReOpenCubeGroup()
        {
            try
            {
                _asrtCubeGroup.CloseCubeGroup();

                //Create an AssortmentCubeGroup
                _asrtCubeGroup = new AssortmentCubeGroup(_sab, _transaction, _windowType);
                _openParms = LoadParmsFromTransaction(_transaction.AssortmentViewLoadedFrom);	// TT#857 - MD - stodd - assortment not honoring view
                _asrtCubeGroup.OpenCubeGroup(_openParms);


                if (IsAssortment || IsGroupAllocation)
                {
                    // Begin TT#2008-MD - JSmith - Rule method after processing using sets previous values in matrix go to 0.
                    //if (_transaction.AssortmentViewLoadedFrom == eAssortmentBasisLoadedFrom.AssortmentProperties)
                    //{
                    //    _asrtCubeGroup.SetStoreGroup(StoreMgmt.StoreGroup_Get(_asrtCubeGroup.AssortmentStoreGroupRID)); //_sab.StoreServerSession.GetStoreGroup(_asrtCubeGroup.AssortmentStoreGroupRID));
                    //}
                    //else if (_transaction.AssortmentViewLoadedFrom == eAssortmentBasisLoadedFrom.UserSelectionCriteria)
                    //{
                    //    _asrtCubeGroup.SetStoreGroup(StoreMgmt.StoreGroup_Get(_transaction.AssortmentStoreAttributeRid)); //_sab.StoreServerSession.GetStoreGroup(_transaction.AssortmentStoreAttributeRid));
                    //}
                    //else
                    //{
                    //    // Begin TT#1216-MD - stodd - change attribute, ran need, values go to zeros
                    //    // Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //    //Infragistics.Win.UltraWinToolbars.ComboBoxTool cbo = (Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.ultraToolbarsManager1.Tools["cbxAttribute"];	
                    //    //int SgRid = int.Parse(((ValueListItem)cbo.SelectedItem).DataValue.ToString());
                    //    Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.ultraToolbarsManager1.Tools["ControlContainerAttribute"];
                    //    MIDAttributeComboBox cmbStoreAttribute = (MIDAttributeComboBox)cct.Control;
                    //    //_asrtCubeGroup.SetStoreGroup(_sab.StoreServerSession.GetStoreGroup(SgRid));
                    //    _asrtCubeGroup.SetStoreGroup(StoreMgmt.StoreGroup_Get(int.Parse(cmbStoreAttribute.SelectedValue.ToString()))); //_sab.StoreServerSession.GetStoreGroup(int.Parse(cmbStoreAttribute.SelectedValue.ToString())));
                    //    // End TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //    //_asrtCubeGroup.SetStoreGroup(_sab.StoreServerSession.GetStoreGroup(Include.AllStoreGroupRID));
                    //    // End TT#1216-MD - stodd - change attribute, ran need, values go to zeros
                    //}

                    Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.ultraToolbarsManager1.Tools["ControlContainerAttribute"];
                    MIDAttributeComboBox cmbStoreAttribute = (MIDAttributeComboBox)cct.Control;
                    if (cmbStoreAttribute != null
                        && cmbStoreAttribute.SelectedValue != null)
                    {
                        _asrtCubeGroup.SetStoreGroup(StoreMgmt.StoreGroup_Get(int.Parse(cmbStoreAttribute.SelectedValue.ToString())));
                    }
                    else if (_transaction.AssortmentViewLoadedFrom == eAssortmentBasisLoadedFrom.AssortmentProperties)
                    {
                        _asrtCubeGroup.SetStoreGroup(StoreMgmt.StoreGroup_Get(_asrtCubeGroup.AssortmentStoreGroupRID)); //_sab.StoreServerSession.GetStoreGroup(_asrtCubeGroup.AssortmentStoreGroupRID));
                    }
                    else if (_transaction.AssortmentViewLoadedFrom == eAssortmentBasisLoadedFrom.UserSelectionCriteria)
                    {
                        _asrtCubeGroup.SetStoreGroup(StoreMgmt.StoreGroup_Get(_transaction.AssortmentStoreAttributeRid)); //_sab.StoreServerSession.GetStoreGroup(_transaction.AssortmentStoreAttributeRid));
                    }
                    // End TT#2008-MD - JSmith - Rule method after processing using sets previous values in matrix go to 0.
                }
                else
                {
                    // Begin TT#1216-MD - stodd - change attribute, ran need, values go to zeros
					// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //Infragistics.Win.UltraWinToolbars.ComboBoxTool cbo = (Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.ultraToolbarsManager1.Tools["cbxAttribute"];
                    //int SgRid = int.Parse(((ValueListItem)cbo.SelectedItem).DataValue.ToString());
                    Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.ultraToolbarsManager1.Tools["ControlContainerAttribute"];
                    MIDAttributeComboBox cmbStoreAttribute = (MIDAttributeComboBox)cct.Control;
                    //_asrtCubeGroup.SetStoreGroup(_sab.StoreServerSession.GetStoreGroup(SgRid));
                    _asrtCubeGroup.SetStoreGroup(StoreMgmt.StoreGroup_Get(int.Parse(cmbStoreAttribute.SelectedValue.ToString()))); //_sab.StoreServerSession.GetStoreGroup(int.Parse(cmbStoreAttribute.SelectedValue.ToString())));
					// End TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //_asrtCubeGroup.SetStoreGroup(_sab.StoreServerSession.GetStoreGroup(Include.AllStoreGroupRID));
                    // End TT#1216-MD - stodd - change attribute, ran need, values go to zeros
                }
                // Set current Store Filter
                //Begin TT#2047 - DOConnell - Assortment View filter is coming from USER_ALLOCATION table
                //_asrtCubeGroup.SetStoreFilter(_transaction.AllocationFilterID);
                _asrtCubeGroup.SetStoreFilter(Include.NoRID, null);
                //End TT#2047 - DOConnell - Assortment View filter is coming from USER_ALLOCATION table
				// Begin TT#1954-MD - JSmith - Assortment
				//ComponentsChanged();
                ComponentsChanged(false);
				// End TT#1954-MD - JSmith - Assortment
                // Begin TT#3842 - stodd - Total % not recalculating when total units change
                if (_asrtCubeGroup.AssortmentType == eAssortmentType.Undefined)
                {
                    GetAssortmentType();
                }
                // End TT#3842 - stodd - Total % not recalculating when total units change
            }
            catch
            {
                throw;
            }
        }
    
        private bool WriteHeader(int aKey)
        {
            //AssortmentProfile ap;
			AllocationProfile ap;
            DataRow dr = null;
            try
            {
				// BEGIN TT#2 - stodd - assortment
				// It's the AP from the transaction that has the assortment view details
                //ap = (AssortmentProfile)_allocProfileList.FindKey(aKey);
				// BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
				//ap = _transaction.GetAllocationProfile(aKey);
				ap = _transaction.GetAssortmentMemberProfile(aKey);
				// END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
				if (ap == null)
				{
                    ap = GetAllocationProfile(aKey);
				}
				// END TT#2 - stodd - assortment
                if (ap != null && ap.HeaderID != null)
                {
                    // Begin TT#1441 - RMatelic - Need doesn’t process – can’t find plan - moved next line from below
                    AssortmentProfile asp;  
                    if (!ap.Placeholder && !ap.Assortment && ap.AsrtRID != Include.NoRID && !ap.AllocationStarted)
                    {
                        asp = (AssortmentProfile)_allocProfileList.FindKey(ap.AsrtRID);
						// GA MERGE STODD
						if (IsGroupAllocation)
						{
							// Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                        	//ap.ShipToDay = asp.AssortmentApplyToDate.Date;  // apply to all headers
                        	ap.ShipToDay = asp.ShipToDay;
							// End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
						}
						else
						{
						
                        	ap.ShipToDay = asp.AssortmentApplyToDate.Date;  // apply to all headers
                            ap.BeginDay = asp.AssortmentBeginDay.Date;  // TT#2066-MD - JSmith - Ship to Date validation.  Is this how it should be working
						}
                    }
                    // End TT#1441
					// BEGIN TT#376-MD - stodd - Update Enqueue logic
					if (!ap.WriteHeader())
					{
						EnqueueError(ap);
						return false;
					}
					// END TT#376-MD - stodd - Update Enqueue logic
                    if (aKey != ap.Key)
                    {   // this was a new header
                        dr = _dsDetails.Tables["Header"].Rows.Find(aKey);
                        dr["KeyH"] = ap.Key;

                        _allocProfileList.HashRebuild();

                        if (ap.Assortment)
                        {
                            UpdateAssortmentKeys(aKey, ap.Key);
                        }
                        else if (ap.Placeholder)
                        {
                            UpdatePlaceholderKeys(aKey, ap.Key);
                        }

                        if ((ap.Packs.Count > 0 || ap.BulkColors.Count > 0))
                        {
                            UpdateDataRowSizeKeys(aKey, ap);	// TT#854 - MD - stodd - enqueue error 
                        }

                        if (aKey < 0 && _allocProfileList.Contains(aKey))
                        {
                            _allocProfileList.Remove(GetAllocationProfile(aKey));
                        }
						// Begin TT#1224 - stodd - committed
						// Can't update shiptoday during add, so must do it in update...
                        // Begin TT#1441 - RMatelic - Need doesn’t process – can’t find plan - moved next line up for all headers;  add PlaceholderRID update
                        //AssortmentProfile asp = (AssortmentProfile)_asrtCubeGroup.DefaultAllocationProfile;
                        asp = (AssortmentProfile)_allocProfileList.FindKey(ap.AsrtRID);
						
						// GA MERGE STODD
						if (IsGroupAllocation)
						{
                            // Begin TT#4389  - stodd - Drag/Drop a header in to a GA, which is not the same plan level of the Lead header and receive a System Null Reference Exception.
                            if (ap.HeaderType != eHeaderType.Placeholder)
                            {
                            // End TT#4389  - stodd - Drag/Drop a header in to a GA, which is not the same plan level of the Lead header and receive a System Null Reference Exception.
                                // Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                                //ap.ShipToDay = asp.AssortmentApplyToDate.Date;  // apply to all headers
                                ap.ShipToDay = asp.ShipToDay;
                                // End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                            }   // TT#4389  - stodd - Drag/Drop a header in to a GA, which is not the same plan level of the Lead header and receive a System Null Reference Exception.
						}
						else
						{
						
                        	ap.ShipToDay = asp.AssortmentApplyToDate.Date;  // apply to all headers
                            ap.BeginDay = asp.AssortmentBeginDay.Date;   // TT#2066-MD - JSmith - Ship to Date validation.  Is this how it should be working
						}
						                    
                        if (ap.Placeholder)
                        {
                            ap.PlaceHolderRID = Include.NoRID;
                        }
                        // End TT#1441

						// BEGIN TT#376-MD - stodd - Update Enqueue logic
						if (!ap.WriteHeader())
						{
							EnqueueError(ap);
							return false;
						}
						// END TT#376-MD - stodd - Update Enqueue logic
						// End TT#1224 - stodd - committed
                    }

					// BEGIN TT#528-MD - stodd -  Content Tab no long contains headers after running Spread average
					// This line is needed for Spread Average to work properly.
                    //ReloadProfileToGrid(ap.Key); TT#501 - MD - DOConnell - On matrix tab, grade quantities revert to 0 when store attribute is changed
                    // Begin TT#903 - MD - "There are no headers to enqueue" error
                    if (ap.HeaderType != eHeaderType.Assortment)
                    {
                        ReloadProfileToGrid(ap.Key);
                    }
                    // End TT#903 - MD - "There are no headers to enqueue" error
					// BEGIN TT#528-MD - stodd -  Content Tab no long contains headers after running Spread average
                }
                return true;
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
                return false;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void UpdateDataRowSizeKeys(int aOldHdrKey, AllocationProfile ap)	// TT#854 - MD - stodd - enqueue error 
        {
            try
            {
                string oldSizeTableName = string.Empty;
                string newSizeTableName = string.Empty;
                int oldPackKey = 0, oldColorCodeRID = 0;
                if (ap.Packs.Count > 0)
                {
                    object[] Keys = new object[2];
                    Keys[0] = ap.Key;
                    foreach (PackHdr aPack in ap.Packs.Values)
                    {
                        Keys[1] = aPack.PackName;
                        DataRow drPack = _dsDetails.Tables["Pack"].Rows.Find(Keys);
                        if (drPack != null)
                        {
                            oldPackKey = (int)drPack["KeyP"];
                            if (oldPackKey < 0)
                            {
                                oldSizeTableName = "PackSize" + "~" + aOldHdrKey.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + oldPackKey.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + Include.DummyColorRID.ToString(CultureInfo.CurrentUICulture);
                                newSizeTableName = "PackSize" + "~" + ap.Key.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + aPack.PackRID.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + Include.DummyColorRID.ToString(CultureInfo.CurrentUICulture);
                                drPack["KeyP"] = aPack.PackRID;
                                drPack["Sequence"] = aPack.Sequence;
                                _dsDetails.Tables["Pack"].AcceptChanges();

                                ReplaceSizeTable("PackSize", oldSizeTableName, newSizeTableName);
                                if (ap.Placeholder)
                                {
                                    UpdateAssortmentLinkedPacks(ap.Key, oldPackKey, aPack.PackRID);
                                }
                            }
                            if (aPack.PackColors != null && aPack.PackColors.Count > 0)
                            {
                                UpdatePackColorCodeRIDs(aOldHdrKey, ap.Key, oldPackKey, aPack);
                            }
                        }
                    }
                }

                if (ap.BulkColors.Count > 0)
                {
                    object[] Keys = new object[2];
                    Keys[0] = ap.Key;
                    foreach (HdrColorBin aColor in ap.BulkColors.Values)
                    {
                        Keys[1] = aColor.ColorCodeRID;
                        DataRow drColor = _dsDetails.Tables["BulkColor"].Rows.Find(Keys);
                        if (drColor != null)
                        {
                            if ((int)drColor["KeyC"] < 0)
                            {
                                oldColorCodeRID = (int)drColor["KeyC"];
                                oldSizeTableName = "BulkSize" + "~" + aOldHdrKey.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + oldColorCodeRID.ToString(CultureInfo.CurrentUICulture);
                                newSizeTableName = "BulkSize" + "~" + ap.Key.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + aColor.HdrBCRID.ToString(CultureInfo.CurrentUICulture);

                                drColor["KeyC"] = aColor.HdrBCRID;
                                drColor["Sequence"] = aColor.ColorSequence;
                                ReplaceSizeTable("BulkSize", oldSizeTableName, newSizeTableName);
                                if (ap.Placeholder)
                                {
                                    UpdateAssortmentLinkedColors(ap.Key, oldColorCodeRID, aColor.HdrBCRID);
                                }

								// Begin TT#854 - MD - stodd - enqueue error 
								//DataTable dtSizes = _dsDetails.Tables[newSizeTableName];
								//if (dtSizes != null)
								//{
								//    foreach (DataRow dr in dtSizes.Rows)
								//    {
								//        int secondaryRID = Convert.ToInt32(dr["SecondaryRID"], CultureInfo.CurrentUICulture);
								//        for (int i = 7; i < dtSizes.Columns.Count; i++)
								//        {
								//            dr[i] = 0;
								//            DataColumn dCol = dtSizes.Columns[i];
								//            string primary = dCol.ColumnName;
								//            int sizeCodeRID = Convert.ToInt32(dCol.ExtendedProperties[primary + "~" + secondaryRID], CultureInfo.CurrentUICulture);
								//            ap.AddBulkSizeToColor(aColor.ColorCodeRID, sizeCodeRID, 0, -1);
								//        }
								//    }
								//}
								// END TT#854 - MD - stodd - enqueue error 
                            }
                        }
                    }
                }

            }
            catch
            {
                throw;
            }
        }

        private void UpdateAssortmentLinkedColors(int aPhKey, int aOldValue, int aNewValue)
        {
            try
            {
                IEnumerable enumerator = ugDetails.DisplayLayout.Bands["BulkColor"].GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    if (Convert.ToInt32(row.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Placeholder
					// BEGIN TT#621-MD - Stodd - invalid cast exception
                      && (row.ParentRow.Cells["PlaceHolderRID"].Value != DBNull.Value && Convert.ToInt32(row.ParentRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == aPhKey)
					// END TT#621-MD - Stodd - invalid cast exception
                      && Convert.ToInt32(row.Cells["AsrtBCRID"].Value, CultureInfo.CurrentUICulture) == aOldValue)
                    {
                        row.Cells["AsrtBCRID"].Value = aNewValue;
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAssortmentLinkedPacks(int aPhKey, int aOldValue, int aNewValue)
        {
            try
            {
                IEnumerable enumerator = ugDetails.DisplayLayout.Bands["Pack"].GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    if (Convert.ToInt32(row.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Placeholder
                      && Convert.ToInt32(row.ParentRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == aPhKey
                      && Convert.ToInt32(row.Cells["AssociatedPackRID"].Value, CultureInfo.CurrentUICulture) == aOldValue)
                    {
                        row.Cells["AssociatedPackRID"].Value = aNewValue;
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePackColorCodeRIDs(int aOldHdrKey, int aNewHdrRID, int aOldPackKey, PackHdr aPack)
        {
            try
            {  // aOldHdrKey & aNewBdrRID may be the same; aOldPAckKey & aPack.PackRID may be the same;
                string oldSizeTableName = string.Empty;
                string newSizeTableName = string.Empty;
                object[] pcKeys = new object[3];
                //pcKeys[0] = aOldHdrKey;
                pcKeys[0] = aNewHdrRID;
                //pcKeys[1] = aOldPackKey;
                pcKeys[1] = aPack.PackRID;

                foreach (PackColorSize aColor in aPack.PackColors.Values)
                {
                    if (aColor.ColorCodeRID != Include.DummyColorRID)
                    {
                        pcKeys[2] = aColor.ColorCodeRID;
                        DataRow drPackColor = _dsDetails.Tables["PackColor"].Rows.Find(pcKeys);
                        int oldPackColorRID = (int)drPackColor["KeyC"];

                        if (oldPackColorRID < 0)
                        {
                            oldSizeTableName = "PackColorSize" + "~" + aOldHdrKey.ToString(CultureInfo.CurrentUICulture)
                                                + "~" + aOldPackKey.ToString(CultureInfo.CurrentUICulture)
                                                + "~" + oldPackColorRID.ToString(CultureInfo.CurrentUICulture);
                            newSizeTableName = "PackColorSize" + "~" + aNewHdrRID.ToString(CultureInfo.CurrentUICulture)
                                                + "~" + aPack.PackRID.ToString(CultureInfo.CurrentUICulture)
                                                + "~" + aColor.HdrPCRID.ToString(CultureInfo.CurrentUICulture);
                            drPackColor["KeyC"] = aColor.HdrPCRID;
                            drPackColor["Sequence"] = aColor.ColorSequenceInPack;
                            ReplaceSizeTable("PackColorSize", oldSizeTableName, newSizeTableName);
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
        }
        private void ReplaceSizeTable(string aBandKey, string aOldTableName, string aNewTableName)
        {
            try
            {
                if (_dsDetails.Relations.Contains(aOldTableName))
                {
                    DataTable dtSize = _dsDetails.Relations[aOldTableName].ChildTable.Copy();

                    _dsDetails.Tables[aOldTableName].Constraints.Remove(aOldTableName);
                    _dsDetails.Relations.Remove(aOldTableName);
                    _dsDetails.Tables.Remove(aOldTableName);
                    _dsDetails.AcceptChanges();

                    dtSize.TableName = aNewTableName;
                    _dsDetails.Tables.Add(dtSize);

                    switch (aBandKey)
                    {
                        case "BulkSize":
                            _dsDetails.Relations.Add(aNewTableName,
                                new DataColumn[] { _dsDetails.Tables["BulkColor"].Columns["KeyH"], _dsDetails.Tables["BulkColor"].Columns["KeyC"] },
                                new DataColumn[] { _dsDetails.Tables[aNewTableName].Columns["KeyH"], _dsDetails.Tables[aNewTableName].Columns["KeyC"] }, true);
                            break;

                        case "PackSize":
                            _dsDetails.Relations.Add(aNewTableName,
                                new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                                new DataColumn[] { _dsDetails.Tables[aNewTableName].Columns["KeyH"], _dsDetails.Tables[aNewTableName].Columns["KeyP"] }, true);
                            break;

                        case "PackColorSize":
                            _dsDetails.Relations.Add(aNewTableName,
                              new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"], _dsDetails.Tables["PackColor"].Columns["KeyC"] },
                              new DataColumn[] { _dsDetails.Tables[aNewTableName].Columns["KeyH"], _dsDetails.Tables[aNewTableName].Columns["KeyP"], _dsDetails.Tables[aNewTableName].Columns["KeyC"] }, true);
                            break;
                    }

                    _dsDetails.AcceptChanges();
                }
            }
            catch
            {
                throw;
            }
        }

        private void DeleteHeaders()
        {
            try
            {
                int[] selectedHeaderArray = new int[_deletedHeaderRows.Count];
                _deletedHeaderRows.CopyTo(selectedHeaderArray, 0);

                // BEGIN TT#115 - stodd - exception removing placeholder
                //ApplicationSessionTransaction trans = _sab.ApplicationServerSession.CreateTransaction();
                //trans.NewAllocationMasterProfileList();
                //trans.LoadHeaders(selectedHeaderArray);
                // END TT#115 - stodd - exception removing placeholder

                ArrayList blockedKeyList = new ArrayList();
                BlockedListHashKey blockedKey;
                IDictionaryEnumerator iEnum;

                foreach (int headerRID in _deletedHeaderRows)
                {
                    AllocationProfile ap = GetAllocationProfile(headerRID);
                    if (ap == null)
                    {
                        continue;
                    }

                    if (ap.Key != Include.NoRID)
                    {
                        //BEGIN TT#661-MD - stodd - Drag/Drop Header onto Placeholder Style/Color and recieve error 80036: Color not defined for Bulk  
                        // This is to protect us from EVER trying to delete a REAL header.
                        // BEGIN TT#115 - stodd - exception removing placeholder
                        if (ap.HeaderType == eHeaderType.Assortment || ap.HeaderType == eHeaderType.Placeholder)
                        {
                            // BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                            //bool success = _transaction.DeleteAllocationHeader(headerRID);
                            bool success = _transaction.DeleteAssortmentMemberHeader(headerRID);
                            // END TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member

                            // BEGIN TT#955 - MD - stodd - Dup Color Error on Drag Drop Header into Group
                        }
                        else if (ap.HeaderType == eHeaderType.Placeholder)
                        {
                            bool success = _transaction.DeleteAllocationHeader(headerRID);
                        }
                        // END TT#955 - MD - stodd - Dup Color Error on Drag Drop Header into Group
                        // END TT#115 - stodd - exception removing placeholder
                        //END TT#661-MD - stodd - Drag/Drop Header onto Placeholder Style/Color and recieve error 80036: Color not defined for Bulk  

                    }
                    if (ap.Placeholder)
                    {
                        if (_assortmentGroups.ContainsKey(ap.AsrtRID))
                        {
                            Hashtable asrtHeaderListHash = (Hashtable)_assortmentGroups[ap.AsrtRID];
                            if (asrtHeaderListHash.ContainsKey(ap.Key))
                            {
                                asrtHeaderListHash.Remove(ap.Key);
                            }
                        }

                        iEnum = _asrtCubeGroup.BlockedList.GetEnumerator();

                        while (iEnum.MoveNext())
                        {
                            blockedKey = (BlockedListHashKey)iEnum.Key;
                            if (blockedKey.PlaceholderRID == headerRID)
                            {
                                if (!blockedKeyList.Contains(blockedKey))
                                {
                                    blockedKeyList.Add(blockedKey);
                                }
                            }
                        }
                    }
                    else if (ap.Assortment)
                    {
                        if (_assortmentGroups.ContainsKey(ap.Key))
                        {
                            _assortmentGroups.Remove(ap.Key);
                        }
                    }
                    _allocProfileList.Remove(ap);
                    AllocationHeaderProfile ahp = (AllocationHeaderProfile)_headerList.FindKey(headerRID);
                    if (ahp != null)
                    {
                        _headerList.Remove(ahp);
                    }

                    // Begin TT#1737 - RMatelic - Assortment Contents-Delete Placeholder, get Foreign Key violation
                    _asrtCubeGroup.RemoveDeletedHeaderFromCubeGroup(ap.Key);
                    // End TT#1737        
                }
                if (blockedKeyList.Count > 0)
                {
                    foreach (BlockedListHashKey bKey in blockedKeyList)
                    {
                        _asrtCubeGroup.RemovePlaceholderFromBlockedList(bKey.PlaceholderRID, bKey.StrGrpLvlRID, bKey.GradeRID);
                    }
                }

            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CheckForPlaceholderStyleDelete(bool fromSave)
        {
            try
            {
                if (_deletedPlaceholderStyles.Count > 0)
                {
                    if (fromSave)   // user selected Save
                    {
                        foreach (int styleRID in _deletedPlaceholderStyles.Values)
                        {
                            if (_anchorNodes.Rows.Contains(styleRID))
                            {
                                _anchorNodes.Rows.Remove(_anchorNodes.Rows.Find(styleRID));
                            }
                            DeletePlaceholderStyle(styleRID);
                        }
                    }
                    else   // user selected Cancel; only delete Placeholder styles on unsaved Placeholder headers  
                    {
                        foreach (int hdrRID in _deletedPlaceholderStyles.Keys)
                        {
                            if (hdrRID < 0) // header not saved
                            {
                                int styleRID = (int)_deletedPlaceholderStyles[hdrRID];
                                DeletePlaceholderStyle(styleRID);
                            }
                        }
                    }
                    _deletedPlaceholderStyles.Clear();
                }

                if (_deletedAssortmentStyles.Count > 0)
                {
                    if (fromSave)   // user selected Save
                    {
                        foreach (int styleRID in _deletedAssortmentStyles.Values)
                        {
                            if (_anchorNodes.Rows.Contains(styleRID))
                            {
                                _anchorNodes.Rows.Remove(_anchorNodes.Rows.Find(styleRID));
                            }
                            DeletePlaceholderStyle(styleRID);
                        }
                    }
                    else   // user selected Cancel; only delete Assortment styles on unsaved Assortment headers  
                    {
                        foreach (int hdrRID in _deletedAssortmentStyles.Keys)
                        {
                            if (hdrRID < 0) // header not saved
                            {
                                int styleRID = (int)_deletedAssortmentStyles[hdrRID];
                                DeletePlaceholderStyle(styleRID);
                            }
                        }
                    }
                    _deletedAssortmentStyles.Clear();
                }
            }
            catch
            {
                throw;
            }
        }

        private void DeletePlaceholderStyle(int aStyleRID)
        {
            try
            {
                EditMsgs em = new EditMsgs();
                HierarchyNodeProfile styleHnp = _sab.HierarchyServerSession.GetNodeData(aStyleRID);
                if (styleHnp.IsVirtual && (styleHnp.Purpose == ePurpose.Placeholder || styleHnp.Purpose == ePurpose.Assortment))
                {
                    HierarchyMaintenance hierMaint = new HierarchyMaintenance(_sab);
                    hierMaint.DeletePlaceholderStyleAnchorNode(aStyleRID, ref em);
                }
                if (em.ErrorFound)
                {
                    DisplayMessages.Show(em, _sab, _windowName);
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAnchorNodes()
        {
            int phStyleRID, oldAnchorRID, newAnchorRID;
            try
            {
                if (_anchorNodes.Rows.Count > 0)
                {
                    foreach (DataRow dr in _anchorNodes.Rows)
                    {
                        phStyleRID = Convert.ToInt32(dr["PhStyleRID"], CultureInfo.CurrentUICulture);
                        oldAnchorRID = Convert.ToInt32(dr["PhOldAnchorRID"], CultureInfo.CurrentUICulture);
                        newAnchorRID = Convert.ToInt32(dr["PhNewAnchorRID"], CultureInfo.CurrentUICulture);
                        _hierMaint.MovePlaceholderStyleAnchorNode(phStyleRID, oldAnchorRID, newAnchorRID);
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void ReloadProfileToGrid(int aHdrRID)
        {
            try
            {
				// Begin TT#1079 - MD - stodd - status not refreshing on content grid - 
                ugDetails.BeginUpdate();
                ugDetails.SuspendRowSynchronization();
				// End TT#1079 - MD - stodd - status not refreshing on content grid - 
				
                AllocationProfile ap = (AllocationProfile)this._allocProfileList.FindKey(aHdrRID);
                if (ap == null)
                {
                    AllocationHeaderProfile ahp = _sab.HeaderServerSession.GetHeaderData(aHdrRID, true, true, true);
                    ap = new AllocationProfile(_transaction, ahp.HeaderID, ahp.Key, _sab.ClientServerSession);
                    _allocProfileList.Add(ap);
                }

                //ap.ReReadHeader();
                //ap.ReReadHeaderWithStores();	// TT#1110 - MD - stodd - incorrect style on group allocation header - 

                // Begin TT#799 - MD - stodd - matrix and content screen doesn't match. Rereading header causes ShipToDate to revert back to current week.
                //AssortmentProfile asp = (AssortmentProfile)_asrtCubeGroup.DefaultAllocationProfile;
                //if (asp != null)
                //{
                //    asp.ShipToDay = asp.AssortmentApplyToDate.Date;
                //    ap.ShipToDay = asp.AssortmentApplyToDate.Date;
                //}
                // End TT#799 - MD - stodd - matrix and content screen doesn't match. Rereading header causes ShipToDate to revert back to current week.

                // Begin TT#952 - MD - stodd - add matrix to Group Allocation Review
                //==========================================================================================================
                // I've removed some old, commented out code below, so the new commented out code will be more noticable.
                // I don't know why the assortment profile was being removed and then added back.
                // the code was originally placed there by this TT:
                // BEGIN TT#629, TT#638, TT#694 -MD - Stodd - Assortment vs interactive velocity Assortment member
                //=========================================================================================================
                //AllocationProfile allocProf = _transaction.GetAssortmentMemberProfile(ap.Key);
                //if (allocProf != null)
                //{
                //    _transaction.RemoveAssortmentMemberProfile(allocProf);
                //}
                //_transaction.AddAssortmentMemberProfile(ap);


                AllocationHeaderProfile ahp2 = (AllocationHeaderProfile)_headerList.FindKey(aHdrRID);
                if (ahp2 != null)
                {
                    _headerList.Remove(ahp2);
                }
                ahp2 = _sab.HeaderServerSession.GetHeaderData(aHdrRID, true, true, true);
                if (ahp2.AsrtRID != Include.NoRID || ahp2.Assortment)
                {
                    _headerList.Add(ahp2);
                }

                WorkflowBaseData workflowData = new WorkflowBaseData();
                string workflowMethodStr = string.Empty;
                int masterRID = Include.NoRID;
                int subordRID = Include.NoRID;

                string masterID = String.Empty;
                string subordID = String.Empty;
                string msgMasterSubord = String.Empty;

                if (ap.WorkflowRID > Include.UndefinedWorkflowRID)
                {
                    workflowMethodStr = workflowData.GetWorkflowName(ap.WorkflowRID);
                }
                else
                {
                    ApplicationBaseMethod abm = (ApplicationBaseMethod)_getMethods.GetUnknownMethod(ap.MethodRID, false);
                    if (abm.Key > Include.UndefinedMethodRID)
                    {
                        workflowMethodStr = abm.Name;
                    }
                }

                // begin MID Track 4554 AnF Enhancement API Workflow
                string APIworkflowMethodStr = string.Empty;
                if (ap.API_WorkflowRID > Include.UndefinedWorkflowRID)
                {
                    APIworkflowMethodStr = (string)_workflowNameHash[ap.API_WorkflowRID];
                    if (APIworkflowMethodStr == null)
                    {
                        APIworkflowMethodStr = workflowData.GetWorkflowName(ap.API_WorkflowRID);
                        _workflowNameHash.Add(ap.API_WorkflowRID, APIworkflowMethodStr);
                    }
                }
                // end MID Track 4554 AnF Enhancement API Workflow

                subordRID = ap.SubordinateRID;

                if (subordRID != Include.NoRID)
                {
                    subordID = ap.SubordinateID;
                    if (subordID != null && subordID != string.Empty)
                    {
                        msgMasterSubord = ap.HeaderID + " / " + subordID;
                    }
                }
                else
                {
                    masterRID = ap.MasterRID;
                    if (masterRID != Include.NoRID)
                    {
                        masterID = ap.MasterID;
                        if (masterID != null && masterID != string.Empty)
                        {
                            msgMasterSubord = masterID + " / " + ap.HeaderID;
                        }
                    }
                }

                DataRow dr = _dsDetails.Tables["Header"].Rows.Find(aHdrRID);
                if (dr != null)
                {
                    dr["Type"] = Convert.ToInt32(ap.HeaderType, CultureInfo.CurrentUICulture);
                    dr["Status"] = Convert.ToInt32(ap.HeaderAllocationStatus, CultureInfo.CurrentUICulture);
                    dr["Intransit"] = Convert.ToInt32(ap.HeaderIntransitStatus, CultureInfo.CurrentUICulture);
                    dr["ShipStatus"] = Convert.ToInt32(ap.HeaderShipStatus, CultureInfo.CurrentUICulture);
                    dr["HdrQuantity"] = ap.TotalUnitsToAllocate;
                    dr["UnitRetail"] = ap.UnitRetail;
                    dr["UnitCost"] = ap.UnitCost;
                    dr["Multiple"] = ap.AllocationMultiple;
                    dr["PO"] = ap.PurchaseOrder;
                    dr["Vendor"] = ap.Vendor;
                    dr["Workflow"] = workflowMethodStr;
                    dr["APIWorkflow"] = APIworkflowMethodStr; // MID Track 4554 AnF Enhancement API Workflow
                    dr["DC"] = ap.DistributionCenter;
                    if (ap.ReleaseDate == Include.UndefinedDate)
                    {
                        dr["Release"] = string.Empty;
                    }
                    else
                    {
                        dr["Release"] = ap.ReleaseDate.ToShortDateString();
                    }
                    dr["Master"] = msgMasterSubord;

                    //BEGIN TT#573-MD - stodd -  Header not fully allocated after drag unto placeholder  
                    //dr["AllocatedUnits"] = ap.AllocatedUnits;
					// Begin TT#1575-MD - stodd - Group Allocation Content tab units allocated should always match the total units from the Matrix screen.  
                    //dr["AllocatedUnits"] = ap.TotalUnitsAllocated;
                    dr["AllocatedUnits"] = TotalUnitsAllocated(ap);
					// End TT#1575-MD - stodd - Group Allocation Content tab units allocated should always match the total units from the Matrix screen.  
                    //END TT#573-MD - stodd -  Header not fully allocated after drag unto placeholder  

                    dr["OrigAllocatedUnits"] = ap.OrigAllocatedUnits;
                    dr["RsvAllocatedUnits"] = ap.RsvAllocatedUnits;

                    if ((!ap.MultiHeader) && (ap.Packs.Count > 0 || ap.BulkColors.Count > 0))
                    {
                        UpdateDataRowSizeKeys(ap.Key, ap);	// TT#854 - MD - stodd - enqueue error 
                    }

                    if (ap.WorkUpTotalBuy || ap.Placeholder)	//TT#211-MD - stodd - size information not refreshing after size need is run on placeholder
                    {
                        int hdrChildTotal = 0;
                        // Begin TT#1516-MD - stodd - Decreasing the Quantity on a header attached to an Assortment causes a "Quantity to allocate cannot be less than zero" error 
                        // Unrelated issue. Added check for bulk color count > 0. Otherwise balance would be filled in with total.
                        if ((ap.BulkColors != null && ap.BulkColors.Count > 0) || (ap.Packs != null && ap.Packs.Count > 0))
                        // End TT#1516-MD - stodd - Decreasing the Quantity on a header attached to an Assortment causes a "Quantity to allocate cannot be less than zero" error 
                        {
                            ReloadWorkUpTotalBuy(ap, ref hdrChildTotal);
                            dr["ChildTotal"] = hdrChildTotal;
                            int hdrQty = Convert.ToInt32(dr["HdrQuantity"]);
                            dr["Balance"] = Convert.ToInt32(dr["HdrQuantity"], CultureInfo.CurrentUICulture) - hdrChildTotal;
                        }
                    }

                }

                _dsDetails.Tables["Header"].AcceptChanges();	// TT#1079 - MD - stodd - status not refreshing on content grid - 
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
			// Begin TT#1079 - MD - stodd - status not refreshing on content grid - 
            finally
            {
                this.ugDetails.ResumeRowSynchronization();
                this.ugDetails.EndUpdate();
            }
			// End TT#1079 - MD - stodd - status not refreshing on content grid - 
        }

        private void ReloadWorkUpTotalBuy(AllocationProfile aAP, ref int hdrChildTotal)  
        {
            int aHeaderRID = aAP.HeaderRID;
            hdrChildTotal = 0;
            try
            {
                object[] Keys = new object[2];
                if (aAP.Packs != null && aAP.Packs.Count > 0)
                {
                    Hashtable packs = aAP.Packs;
                    Keys[0] = aHeaderRID;
                    int packColorTotal;
                    int packSizeTotal;
                    DataTable packTable = _dsDetails.Tables["Pack"];
                    DataTable packColorTable;
                    DataTable packSizeTable;  
                    object[] packColorKeys = new object[3];
                    packColorKeys[0] = aHeaderRID;
                    foreach (PackHdr aPack in packs.Values)
                    {
                        Keys[1] = aPack.PackName;
                        packColorKeys[1] = aPack.PackRID;
                        hdrChildTotal += aPack.UnitsToAllocate;
                        packColorTotal = 0;
                        DataRow packRow = packTable.Rows.Find(Keys);
                        // begin TT#612 BP not refreshing WUB after apply
                        if (packRow == null)
                        {
                            int packType;
                            if (aPack.GenericPack)
                            {
                                packType = (int)eAllocationType.GenericType;
                            }
                            else
                            {
                                packType = (int)eAllocationType.DetailType;
                            }
                            packRow = packTable.Rows.Add(new object[] { aAP.HeaderRID, aPack.PackRID, Include.NoRID,
                                                          aPack.PackName, packType, aPack.PacksToAllocate,
                                                          aPack.PackMultiple, aPack.UnitsToAllocate, 
                                                          aPack.AssociatedPackRID, aPack.Sequence});
                        }
                        if (aPack.PackColors != null && aPack.PackColors.Count > 0)
                        {
                            packColorTable = _dsDetails.Tables["PackColor"];
                            foreach (PackColorSize aColor in aPack.PackColors.Values)
                            {
                                packColorTotal += aColor.ColorUnitsInPack;
                                packSizeTotal = 0;
                                packColorKeys[2] = aColor.ColorCodeRID;
                                DataRow colorRow = packColorTable.Rows.Find(packColorKeys);
                                ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(aColor.ColorCodeRID);
                                if (colorRow == null)
                                {
                                    string packColorDescription = string.Empty;
                                    string colorID = string.Empty;

                                    if (ccp.VirtualInd)
                                    {
                                        colorID = aColor.ColorName;
										// Begin TT#795-MD - stodd - Build Packs not working on a Placeholder in an assortment.
                                        if (colorID == null)
                                        {
                                            colorID = ccp.ColorCodeID;
                                        }
                                        packColorDescription = aColor.ColorDescription;
                                        if (packColorDescription == null)
                                        {
                                            packColorDescription = GetColorDescription(GetNodeData(aAP.StyleHnRID), ccp);
                                        }
										// End TT#795-MD - stodd - Build Packs not working on a Placeholder in an assortment.
                                    }
                                    else
                                    {
                                        colorID = ccp.ColorCodeID;
                                        packColorDescription = GetColorDescription(GetNodeData(aAP.StyleHnRID), ccp);
                                    }
                                    if (aColor.ColorCodeRID != Include.DummyColorRID)
                                    {
                                        colorRow = packColorTable.Rows.Add(new object[] { aAP.HeaderRID, aPack.PackRID,
                                                                      aColor.HdrPCRID, aColor.ColorCodeRID, 
                                                                      colorID, packColorDescription, 
                                                                      aColor.ColorUnitsInPack, aColor.ColorSequenceInPack, aColor.ColorName });
                                    }
                                }
                                if (aColor.ColorSizes != null && aColor.ColorSizes.Count > 0)
                                {
                                    string dtSizeNamePrefix = aColor.ColorCodeRID == Include.DummyColorRID ? "PackSize" : "PackColorSize";
                                    string sizeTableName = dtSizeNamePrefix
                                        + "~" + aAP.HeaderRID.ToString(CultureInfo.CurrentUICulture)
                                        + "~" + aPack.PackRID.ToString(CultureInfo.CurrentUICulture)
                                        + "~" + aColor.HdrPCRID.ToString(CultureInfo.CurrentUICulture);
                                    packSizeTable = _dsDetails.Tables[sizeTableName];
                                    if (packSizeTable == null)
                                    {
                                        DataTable dtSizes = FormatPackSizeTable(aColor, aAP.SizeGroupRID, aAP.HeaderRID, aPack.PackRID, aColor.HdrPCRID, ccp.ColorCodeID, sizeTableName, ref packSizeTotal);
                                        if (dtSizes != null)
                                        {
                                            _dsDetails.Tables.Add(dtSizes);
                                            if (aColor.ColorCodeRID == Include.DummyColorRID)
                                            {
                                                _dsDetails.Relations.Add(sizeTableName,
                                                    new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                                                    new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyP"] }, true);
                                                packRow["ChildTotal"] = packSizeTotal;
                                                packRow["Balance"] = Convert.ToInt32(packRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - packSizeTotal;

                                            }
                                            else
                                            {
                                                _dsDetails.Relations.Add(sizeTableName,
                                                    new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"], _dsDetails.Tables["PackColor"].Columns["KeyC"] },
                                                    new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyP"], _dsDetails.Tables[sizeTableName].Columns["KeyC"] }, true);
												// Begin TT#936 - MD - Prevent the saving of empty Group Allocations	
                                                if (colorRow != null)
                                                {
                                                    colorRow["ChildTotal"] = packSizeTotal;
                                                    colorRow["Balance"] = Convert.ToInt32(colorRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - packSizeTotal;
                                                }
												// End TT#936 - MD - Prevent the saving of empty Group Allocations
                                            }
                                        }
                                    }
                                    else
                                    {
                                        foreach (PackContentBin aSize in aColor.ColorSizes.Values)
                                        {
                                            packSizeTotal += aSize.ContentUnits;
                                        }
                                    }
                                }
								// Begin TT#936 - MD - Prevent the saving of empty Group Allocations
                                if (colorRow != null)
                                {
                                    colorRow["ChildTotal"] = packSizeTotal;
                                    colorRow["Balance"] = Convert.ToInt32(colorRow["QuantityPerPack"], CultureInfo.CurrentCulture) - packSizeTotal;
                                }
								// End TT#936 - MD - Prevent the saving of empty Group Allocations
                                if (aColor.ColorCodeRID == Include.DummyColorRID)
                                {
                                    packColorTotal = packSizeTotal;
                                }
                            }
                            packRow["ChildTotal"] = packColorTotal;
                            packRow["Balance"] = Convert.ToInt32(packRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - packColorTotal;
                        }

                    }
                    _dsDetails.AcceptChanges();
                }
                if (aAP.BulkColors != null && aAP.BulkColors.Count > 0)
                {
                    Hashtable aBulkColors = aAP.BulkColors;
                    foreach (HdrColorBin aColor in aBulkColors.Values)
                    {
                        Keys[0] = aHeaderRID;
                        Keys[1] = aColor.ColorCodeRID;

                        DataRow drColor = _dsDetails.Tables["BulkColor"].Rows.Find(Keys);
                        drColor["Quantity"] = aColor.ColorUnitsToAllocate;
                        hdrChildTotal += aColor.ColorUnitsToAllocate;

                        int sizeKey, rowTotal, childTotal = 0;
                        string primary, secondary;

                        if (aColor.ColorSizes != null && aColor.ColorSizes.Count > 0)
                        {
                            string sizeTableName = "BulkSize" + "~"
                                + aHeaderRID.ToString(CultureInfo.CurrentUICulture) + "~"
                                + aColor.HdrBCRID.ToString(CultureInfo.CurrentUICulture);

                            DataTable dtBulkSize = _dsDetails.Tables[sizeTableName];

                            if (dtBulkSize == null)
                            {
                                bool addSizeTable = false;
                                IEnumerable enumerator = ugDetails.DisplayLayout.Bands["BulkColor"].GetRowEnumerator(GridRowType.DataRow);
                                foreach (UltraGridRow row in enumerator)
                                {
                                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aHeaderRID
                                      && Convert.ToInt32(row.Cells["KeyC"].Value, CultureInfo.CurrentUICulture) == aColor.HdrBCRID)
                                    {
                                        this.ugDetails.ActiveRow = row;
                                        addSizeTable = true;
                                        break;
                                    }
                                }
                                if (addSizeTable)
                                {
                                    cmsInsertBulkSize_Click(cmsInsertBulkSize, null);
                                    dtBulkSize = _dsDetails.Tables[sizeTableName];
                                }
                            }
                            foreach (DataRow dRow in dtBulkSize.Rows)
                            {
                                rowTotal = 0;
                                secondary = Convert.ToString(dRow[3], CultureInfo.CurrentUICulture);
                                for (int i = 7; i < dtBulkSize.Columns.Count; i++)
                                {
                                    DataColumn dCol = dtBulkSize.Columns[i];
                                    primary = dCol.ColumnName;
                                    sizeKey = Convert.ToInt32(dCol.ExtendedProperties[primary + "~" + secondary], CultureInfo.CurrentUICulture);

                                    if (aColor.ColorSizes.ContainsKey(sizeKey))
                                    {
                                        HdrSizeBin aSize = (HdrSizeBin)aColor.ColorSizes[sizeKey];
                                        dRow[i] = aSize.SizeUnitsToAllocate;
                                        rowTotal += aSize.SizeUnitsToAllocate;
                                    }
                                }
                                dRow["TotalQuantity"] = rowTotal;
                                childTotal += rowTotal;
                            }
                            drColor["ChildTotal"] = childTotal;
                            int hdrQty = Convert.ToInt32(drColor["Quantity"]);
                            drColor["Balance"] = Convert.ToInt32(drColor["Quantity"], CultureInfo.CurrentUICulture) - childTotal;
                        }
                    }
                }  
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void UpdateHeaderCharacteristics(UltraGridRow aRow)
        {
            try
            {
                int hdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                ArrayList charArrayList = new ArrayList();
                DataRow dr = _dsDetails.Tables["Header"].Rows.Find(hdrRID);

                for (int i = _nonCharColCount; i < _dsDetails.Tables["Header"].Columns.Count; i++)
                {
                    DataColumn col = (DataColumn)_dsDetails.Tables["Header"].Columns[i];
                    if (col.ExtendedProperties.ContainsKey("IsChar"))
                    {
                        if (dr[i] != System.DBNull.Value && dr[i].ToString() != string.Empty)
                        {
                            int charRID = 0;
                            HeaderCharGroupProfile hcgp = (HeaderCharGroupProfile)col.ExtendedProperties["IsChar"];
                            if (hcgp.ListInd)
                            {
                                charRID = (int)dr[i];
                            }
                            else
                            {
                                string charString = hcgp.Key.ToString() + "~" + Convert.ToString(dr[i], CultureInfo.CurrentUICulture);
                                charRID = (int)col.ExtendedProperties[charString];
                            }
                            charArrayList.Add(charRID);
                        }
                    }
                }
                _sab.HeaderServerSession.RefreshHeaderCharacteristics(hdrRID, charArrayList);
                aRow.Cells["CharUpdated"].Value = false;
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        #endregion

        #region Public Methods for External Access
        public bool IsHeaderUpdateable(int aKey)
        {
            try
            {
                DataRow dRow = _dsDetails.Tables["Header"].Rows.Find(aKey);
                eSecurityType styleSecurity = (eSecurityType)Convert.ToInt32(dRow["StyleSecurity"], CultureInfo.CurrentUICulture);
                if (styleSecurity == eSecurityType.Update)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            catch
            {
                throw;
            }
        }

        public void ReloadUpdatedHeaders(int[] aHdrList)
        {
            int key;
            try
            {
                if (_allocProfileList == null || _allocProfileList.Count == 0)
                {
                    return;
                }
                for (int i = 0; i < aHdrList.Length; i++)
                {
                    key = aHdrList[i];
                    ReloadProfileToGrid(key);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		// BEGIN TT#529-MD - stodd -  Status not updated on workspace After running Balance Proportional 
		/// <summary>
		/// This checks for allocation headers in the assortment.
		/// Used when deciding if the allocation 
		/// </summary>
		/// <param name="aKeys"></param>
		public bool CheckForAllocationHeaders(int[] aKeys)
		{
			bool headerFound = false;
			try
			{
				// Begin TT#1079 - md - stodd - status not updating - 
                if (IsGroupAllocation)
                {
                    headerFound = true;
                }
                else
                {
                    int key;
                    for (int i = 0; i < aKeys.Length; i++)
                    {
                        key = aKeys[i];
                        if (_headerList.Contains(key))
                        {
                            AllocationHeaderProfile ahp = (AllocationHeaderProfile)_headerList.FindKey(key);
                            if (ahp.HeaderType != eHeaderType.Assortment && ahp.HeaderType != eHeaderType.Placeholder)
                            {
                                headerFound = true;
                                break;
                            }
                        }
                    }
                }
				// End TT#1079 - md - stodd - status not updating - 
				return headerFound;
			}
			catch
			{
				throw;
			}
		}
		// END TT#529-MD - stodd -  Status not updated on workspace After running Balance Proportional 

        /// <summary>
        /// this is called by WorkflowMethodFormBase
        /// </summary>
        /// <param name="headerKeys"></param>
        public void CheckHeaderListForUpdate(int[] headerKeys, bool updateOtherViews)	// TT#1197-MD - stodd - header status not getting updated correctly - 
        {
            SelectedHeaderList shpl = new SelectedHeaderList(eProfileType.SelectedHeader);
            foreach (int aKey in headerKeys)
            {
                if (_headerList.Contains(aKey))
                {
                    AllocationHeaderProfile ahp = (AllocationHeaderProfile)_headerList.FindKey(aKey);
                    SelectedHeaderProfile shp = new SelectedHeaderProfile(aKey);
                    shp.HeaderType = ahp.HeaderType;
                    shpl.Add(shp);
                }

            }

            CheckHeaderListForUpdate(shpl, updateOtherViews);	// TT#1197-MD - stodd - header status not getting updated correctly - 
        }

        // Begin TT#1465 - RMatelic - Methods/workflows need to update Assortment Review
		// Begin TT#1087 - MD - stodd - size review showing extra headers - 
        public void CheckHeaderListForUpdate(SelectedHeaderList shpl, bool updateOtherViews)	// TT#1197-MD - stodd - header status not getting updated correctly - 
        {
            try
            {
                int key;
                bool headerFound = false;
                bool allAssortmentTypeHeaders = true;
                for (int i = 0; i < shpl.ArrayList.Count; i++)
                {
                    SelectedHeaderProfile shp = (SelectedHeaderProfile)shpl[i]; 
                    //key = aKeys[i];
                    if (_headerList.Contains(shp.Key))
                    {
                        headerFound = true;
                        //break;
                    }
                    //==========================================================================
                    // We want to know if all the headers in the list are assortment headers
                    //==========================================================================
                    if (shp.HeaderType != eHeaderType.Assortment)
                    {
                        allAssortmentTypeHeaders = false;
                    }
                    //============================================================================================
                    // We know we can stop looping if we found a header and if we know that not all headers are 
                    // assortment headers
                    //============================================================================================
                    if (headerFound && !allAssortmentTypeHeaders)
                    {
                        break;
                    }
                }
				// End TT#1087 - MD - stodd - size review showing extra headers - 
                if (headerFound)
                {
					//_asrtCubeGroup.ReReadHeaders();	TT#1110 - MD - stodd - incorrect style on group allocation header - 
					//BEGIN TT#545-MD - stodd -  Processing cancel allocation action on header attached to placeholder does not adjust placeholder value 
					CloseAndReOpenCubeGroup();
					//END TT#545-MD - stodd -  Processing cancel allocation action on header attached to placeholder does not adjust placeholder value 
					//CloseAndReOpenCubeGroup(); TT#501 - MD - DOConnell - On matrix tab, grade quantities revert to 0 when store attribute is changed

                    UpdateData(true);
					LoadSurroundingPages();
					//_buildDetailsGrid = true;
					//_buildProductCharsGrid = true;
					//LoadProductCharGrid();
					// Begin TT#1087 - MD - stodd - size review showing extra headers - 
                    //===================================================================================
                    // Changed this to use only the header keys of the headers processed - stodd
                    // causes Size and Style review to include extra headers in the view after processing 
                    // an action.
                    //====================================================================================
                    int[] hdrList = null;
                    int i = 0;

                    // Begin TT#4819 - stodd - Alloc U on header showing incorrectly
                    // Removed: processing by header (when headers have packs and bulk) causes the wrong allocated units to appear in other headers
                    //================================================================================================
                    // If only the assortment header(s) are in the list, we want to refresh all of their members
                    //================================================================================================
                    //if (allAssortmentTypeHeaders)
                    //{
                        hdrList = new int[_headerList.Count];
                        foreach (AllocationHeaderProfile ahp in _headerList) 
                        {
                            //if (_headerList.Contains(shp.Key))
                            //{
                                hdrList[i] = ahp.Key;
                                i++;
                            //}
                        }
                    //}
                    //else
                    //{
                    //    //int [] hdrList = new int[_headerList.Count];
                    //    hdrList = new int[shpl.Count];
                    //    //int i = 0;
                    //    //foreach (AllocationHeaderProfile ahp in _headerList) 
                    //    foreach (SelectedHeaderProfile shp in shpl.ArrayList)
                    //    {
                    //        if (_headerList.Contains(shp.Key))
                    //        {
                    //            hdrList[i] = shp.Key;
                    //            //hdrList[i] = ahp.Key;
                    //            i++;
                    //        }
                    //    }
                    //}
                    // End TT#4819 - stodd - Alloc U on header showing incorrectly
					// End TT#1087 - MD - stodd - size review showing extra headers - 
					ReloadUpdatedHeaders(hdrList);
					// Begin TT#1197-MD - stodd - header status not getting updated correctly - 
                    if (updateOtherViews)
                    {
                        UpdateOtherViews();
                    }
					// End TT#1197-MD - stodd - header status not getting updated correctly - 
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        // End TT#1465
        #endregion

        #region Initialize & Load Product Characteristics Grid
        public void LoadProductCharGrid()	// TT#795-MD - stodd - Build Packs not working on a Placeholder in an assortment.
        {
            try
            {   
                LoadContentGrid();
                if (_buildProductCharsGrid)
                {
                    GetProductCharacteristics();
                    BuildProductCharDataSet();
                    LoadProductCharGridData();
                    BindCharacteristicsGrid();
                    //ExpandCollapseGrid(true);		// TT#3750 - stodd - "Total %" not locking
                    SetProductCharGridEditMode();
                    this.ugCharacteristics.CreationFilter = new ToolTipItemCreationFilter();
                    _buildProductCharsGrid = false;
					//BEGIN TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment
                    _characteristicsChanged = true; //TT#416 - MD - DOConnell - Characteristics do not appear in the Column Chooser unless you save the assortment, close the application, and go back in.  Should update automatically.
                    SaveProductCharacteristics();
					//END TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment
                }
                //SetExpandCollapseButtonText();		// TT#488-MD - Stodd - Group Allocation
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void BindCharacteristicsGrid()
        {
            try
            {
                _dsProductCharacteristics.AcceptChanges();
                BindingSource bsCharacteristics = new BindingSource(_dsProductCharacteristics, "");
                this.ugCharacteristics.DataSource = bsCharacteristics;
                this.ugCharacteristics.DisplayLayout.MaxBandDepth = 2;
            }
            catch
            {
                throw;
            }
        }


        #endregion

        #region Build Product Characteristics Grid Data Set
        private void GetProductCharacteristics()
        {
            int styleHnRID;
            try
            {
                _productCharProfileList = SAB.HierarchyServerSession.GetProductCharacteristics();
                _nodeCharacteristics.Clear();
                _colorNodesForStyle.Clear();
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Assortment)
                    {
                        continue;
                    }
                    else
                    {
                        styleHnRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                        AddToNodeCharacteristicsHash(styleHnRID);
                        if (row.HasChild(false))
                        {
                            CheckForColorNode(styleHnRID, row); 
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CheckForColorNode(int aStyleHnRID, UltraGridRow aRow)
        {
            try
            {
                UltraGridRow cRow = aRow.GetChild(ChildRow.First);
                while (cRow != null)
                {
                    switch (cRow.Band.Key)
                    {
                        case "Pack":
                            if (cRow.HasChild(false))
                            {
                                CheckForColorNode(aStyleHnRID, cRow);
                            }
                            break;

                        case "BulkColor":
                        case "PackColor":
                            LoadColorNodeCharacteristics(aStyleHnRID, cRow);
                            break;

                        default:
                            break;
                    }
                    cRow = cRow.GetSibling(SiblingRow.Next, true, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void LoadColorNodeCharacteristics(int aStyleHnRID, UltraGridRow aRow)
        {
            try
            {
                int colorHnRID = Include.NoRID;
                int colorCodeRID =  Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                ColorCodeProfile ccp = _sab.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);

                HierarchyNodeProfile hnp_style = _sab.HierarchyServerSession.GetNodeData(aStyleHnRID);
                if (_sab.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
                {
                    AddToNodeCharacteristicsHash(colorHnRID);
                    AddToColorNodesForStyleHash(aStyleHnRID, colorCodeRID, colorHnRID);
                }
            }
            catch
            {
                throw;
            }
        }

        private void AddToNodeCharacteristicsHash(int aNodeRID)
        {
            try
            {
                if (!_nodeCharacteristics.ContainsKey(aNodeRID))
                {
                    NodeCharProfileList nodeCharProfileList = _sab.HierarchyServerSession.GetProductCharacteristics(aNodeRID, true);
                    if (nodeCharProfileList.Count > 0)
                    {
                        _nodeCharacteristics.Add(aNodeRID, nodeCharProfileList);
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void AddToColorNodesForStyleHash(int aStyleHnRID, int aColorCodeRID, int aColorHnRID)
        {
            try
            {
                Hashtable colorNodes;
                if (_colorNodesForStyle.ContainsKey(aStyleHnRID))
                {
                    colorNodes = (Hashtable)_colorNodesForStyle[aStyleHnRID];
                    if (!colorNodes.ContainsKey(aColorCodeRID))
                    {
                        colorNodes.Add(aColorCodeRID, aColorHnRID);
                    }
                }
                else
                {
                    colorNodes = new Hashtable();
                    colorNodes.Add(aColorCodeRID, aColorHnRID);
                    _colorNodesForStyle.Add(aStyleHnRID, colorNodes);
                }
            }
            catch
            {
                throw;
            }
        }

        private void BuildProductCharDataSet()
        {
            try
            {
                _dtStyleNodeChars = MIDEnvironment.CreateDataTable("StyleNodeChars");
                _dtStyleNodeChars.Columns.Add("StyleHnRID", System.Type.GetType("System.Int32"));
                _dtStyleNodeChars.Columns.Add("Style");
                _dtStyleNodeChars.Columns.Add("StyleSecurity", System.Type.GetType("System.Int32"));
                _dtStyleNodeChars.Columns.Add("Description");
                _dtStyleNodeChars.PrimaryKey = new DataColumn[] { _dtStyleNodeChars.Columns["StyleHnRID"] };

                _charStyleNodeColCount = _dtStyleNodeChars.Columns.Count;
          
                _dtColorNodeChars = MIDEnvironment.CreateDataTable("ColorNodeChars");
                _dtColorNodeChars.Columns.Add("StyleHnRID", System.Type.GetType("System.Int32"));
                _dtColorNodeChars.Columns.Add("ColorHnRID", System.Type.GetType("System.Int32"));
                _dtColorNodeChars.Columns.Add("ColorCodeRID", System.Type.GetType("System.Int32"));
                _dtColorNodeChars.Columns.Add("ColorID");
                _dtColorNodeChars.Columns.Add("Description");
                _dtColorNodeChars.PrimaryKey = new DataColumn[] { _dtColorNodeChars.Columns["ColorHnRID"] };

                _charColorNodeColCount = _dtColorNodeChars.Columns.Count;

                // Add hierarchy ancestor levels for style  
                for (int level = 1; level <= _mainHp.HierarchyLevels.Count; level++)
                {
                    HierarchyLevelProfile hlp = (HierarchyLevelProfile)_mainHp.HierarchyLevels[level];
                    if (hlp.LevelType == eHierarchyLevelType.Style)
                    {
                        break;
                    }
                    else
                    {
                        _dtStyleNodeChars.Columns.Add(hlp.LevelID);
                        _dtStyleNodeChars.Columns[hlp.LevelID].ExtendedProperties.Add("Level", hlp.Level);
                    }
                }

                // Add existing product characteristic columns
                foreach (int nodeRID in _nodeCharacteristics.Keys)
                {
                    HierarchyNodeProfile hnp = SAB.HierarchyServerSession.GetNodeData(nodeRID);
                    NodeCharProfileList nodeCharProfileList = (NodeCharProfileList)_nodeCharacteristics[nodeRID];
                    foreach (NodeCharProfile ncp in nodeCharProfileList)
                    {
                        if (hnp.LevelType == eHierarchyLevelType.Style)
                        {
                            if (!_dtStyleNodeChars.Columns.Contains(ncp.ProductCharID))
                            {
                                _dtStyleNodeChars.Columns.Add(ncp.ProductCharID);
                                _dtStyleNodeChars.Columns[ncp.ProductCharID].ExtendedProperties.Add("IsChar", ncp.Key);
                                GetProductCharValueList(ncp.ProductCharID);
                            }
                        }
                        else
                        {
                            if (!_dtColorNodeChars.Columns.Contains(ncp.ProductCharID))
                            {
                                _dtColorNodeChars.Columns.Add(ncp.ProductCharID);
                                _dtColorNodeChars.Columns[ncp.ProductCharID].ExtendedProperties.Add("IsChar", ncp.Key);
                                GetProductCharValueList(ncp.ProductCharID);
                            }
                        }
                    }
                }
                
                _dsProductCharacteristics = MIDEnvironment.CreateDataSet();
                _dsProductCharacteristics.Tables.Add(_dtStyleNodeChars);
                _dsProductCharacteristics.Tables.Add(_dtColorNodeChars);
                _dsProductCharacteristics.Relations.Add("ColorNodeChars", _dsProductCharacteristics.Tables["StyleNodeChars"].Columns["StyleHnRID"], _dsProductCharacteristics.Tables["ColorNodeChars"].Columns["StyleHnRID"]);

                _dsProductCharacteristics.AcceptChanges();
            }
            catch
            {
                throw;
            }
        }

        private void GetProductCharValueList(string aProductCharID)
        {
            try
            {
                if (_productCharValueLists.ContainsKey(aProductCharID))
                {
                    return;
                }
                
                ValueList valueList = new ValueList();
                valueList.SortStyle = ValueListSortStyle.Ascending;
                valueList.Key = aProductCharID;

                foreach (ProductCharProfile pcp in _productCharProfileList)
                {
                    if (pcp.ProductCharID == aProductCharID)
                    {
                        valueList.ValueListItems.Add(0, _lblNone);
                        foreach (ProductCharValueProfile prodCharValueProf in pcp.ProductCharValues)
                        {
                            valueList.ValueListItems.Add(prodCharValueProf.Key, prodCharValueProf.ProductCharValue);
                        }
                        break;
                    }
                }
                _productCharValueLists.Add(aProductCharID, valueList);
            }
            catch
            {
                throw;
            }
        }

        private void LoadProductCharGridData()
        {
            int styleHnRID;
            try
            {
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Assortment)
                    {
                        continue;
                    }
                    else
                    {
                        styleHnRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                        if (!_dtStyleNodeChars.Rows.Contains(styleHnRID))
                        {
                            AddStyleToGridDataTable(row, styleHnRID);
                        }
                       
                        if (row.HasChild(false))
                        {
                            CheckForGridColorNode(styleHnRID, row);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void AddStyleToGridDataTable(UltraGridRow aRow, int aStyleHnRID)
        {
            try
            {
                DataRow styleRow = _dtStyleNodeChars.Rows.Add(new object[] 
                                      { aRow.Cells["StyleHnRID"].Value, aRow.Cells["Style"].Value, 
                                        aRow.Cells["StyleSecurity"].Value, aRow.Cells["Description"].Value });
             
                // Add ancestor path values
                NodeAncestorList nal = GetNodeAncestorList(aStyleHnRID);
                foreach (NodeAncestorProfile nap in nal)
                {
                    HierarchyNodeProfile hnp = SAB.HierarchyServerSession.GetNodeData(nap.Key);
                    if (hnp.Key == aStyleHnRID)
                    {
                        continue;
                    }
                    else if (hnp.HomeHierarchyLevel > 0)
                    {
                        for (int i = _charStyleNodeColCount; i < _dtStyleNodeChars.Columns.Count; i++)
                        {
                            DataColumn col = (DataColumn)_dtStyleNodeChars.Columns[i];
                            if (col.ExtendedProperties.ContainsKey("Level"))
                            {
                                int level = (int)col.ExtendedProperties["Level"];
                                if (level == hnp.HomeHierarchyLevel)
                                {
                                    styleRow[col.ColumnName] = hnp.LevelText;
                                    break;
                                }
                            }
                        }
                    }
                }

                AddNodeCharacteristicValues(styleRow, aStyleHnRID);
            }
            catch
            {
                throw;
            }
        }

        private void AddNodeCharacteristicValues(DataRow aDataRow, int aNodeRID)
        {
            try
            {
                if (_nodeCharacteristics.ContainsKey(aNodeRID))
                {
                    NodeCharProfileList nodeCharProfileList = (NodeCharProfileList)_nodeCharacteristics[aNodeRID];
                    foreach (NodeCharProfile ncp in nodeCharProfileList)
                    {
                        if (ncp.ProductCharValueRID > 0)
                        {
							// Begin TT#2029 - stodd - argument exception
							if (aDataRow.Table.Columns.Contains(ncp.ProductCharID))
								aDataRow[ncp.ProductCharID] = ncp.ProductCharValueRID;
							// End TT#2029 - stodd - argument exception
                        }
                    }
                }
            }
            catch
            {
                throw;
            }    
        }

        private void CheckForGridColorNode(int aStyleHnRID, UltraGridRow aRow)
        {
            try
            {
                UltraGridRow cRow = aRow.GetChild(ChildRow.First);
                while (cRow != null)
                {
                    switch (cRow.Band.Key)
                    {
                        case "Pack":
                            if (cRow.HasChild(false))
                            {
                                CheckForGridColorNode(aStyleHnRID, cRow);
                            }
                            break;

                        case "BulkColor":
                        case "PackColor":
                            AddColorToGridDataTable(aStyleHnRID, cRow);
                            break;

                        default:
                            break;
                    }
                    cRow = cRow.GetSibling(SiblingRow.Next, true, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void AddColorToGridDataTable(int aStyleHnRID, UltraGridRow aRow)
        {
            try
            {
                if (_colorNodesForStyle.ContainsKey(aStyleHnRID))
                {
                    int colorCodeRID =  Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                    string colorID = string.Empty; 

                    switch (aRow.Band.Key)
                    {
                        case "BulkColor":
                            colorID = Convert.ToString(aRow.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture);
                            break;

                        case "PackColor":
                            colorID = Convert.ToString(aRow.Cells["PackColor"].Value, CultureInfo.CurrentUICulture);
                            break;
                    }
                     
                    Hashtable colorNodes = (Hashtable)_colorNodesForStyle[aStyleHnRID];
                    if (colorNodes.ContainsKey(colorCodeRID))
                    {
                        int colorHnRID = (int)colorNodes[colorCodeRID];
                        if (!_dtColorNodeChars.Rows.Contains(colorHnRID))
                        {
                            DataRow colorNodeRow = _dtColorNodeChars.Rows.Add(new object[] 
                                      { aStyleHnRID, colorHnRID, aRow.Cells["ColorCodeRID"].Value, 
                                        colorID, aRow.Cells["Description"].Value });

                            AddNodeCharacteristicValues(colorNodeRow, colorHnRID);
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private NodeAncestorList GetNodeAncestorList(int aStyleHnRID)
        {
            NodeAncestorList nal = null;
            try
            {
                if (_nodeAncestorList.ContainsKey(aStyleHnRID))
                {
                    nal = (NodeAncestorList)_nodeAncestorList[aStyleHnRID];
                }
                else
                {
                    HierarchyNodeProfile hnp = SAB.HierarchyServerSession.GetNodeData(aStyleHnRID);
                    nal = _sab.HierarchyServerSession.GetNodeAncestorList(aStyleHnRID, hnp.HomeHierarchyRID, eHierarchySearchType.HomeHierarchyOnly);
                    _nodeAncestorList.Add(aStyleHnRID, nal);
                }
                return nal;
            }
            catch
            {
                throw;
            }
        }    
        #endregion

        #region ugCharacteristics Grid Events & Methods

        private void ugCharacteristics_InitializeLayout(object sender, Infragistics.Win.UltraWinGrid.InitializeLayoutEventArgs e)
        {
            try
            {
                MIDRetail.Windows.Controls.UltraGridLayoutDefaults ugld = new MIDRetail.Windows.Controls.UltraGridLayoutDefaults();
                ugld.ApplyDefaults(e);

                e.Layout.MaxRowScrollRegions = 1;
                e.Layout.Override.RowAlternateAppearance.BackColor = Color.Snow; //.BlanchedAlmond;

                foreach (UltraGridBand band in e.Layout.Bands)
                {
                    band.Override.ExpansionIndicator = Infragistics.Win.UltraWinGrid.ShowExpansionIndicator.CheckOnDisplay;
                    band.Columns["StyleHnRID"].Hidden = true;

                    switch (band.Key)
                    {
                        case "StyleNodeChars":
                            InitializeStyleNodeCharsLayout(band);
                            break;

                        case "ColorNodeChars":
                            InitializeColorNodeCharsLayout(band);
                            break;
                    }
                }

            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private void InitializeStyleNodeCharsLayout(UltraGridBand aBand)
        {
            try
            {
                aBand.Columns["StyleSecurity"].Hidden = true;
               
                aBand.Columns["Style"].Header.Caption = _hlpStyle.LevelID;
                aBand.Columns["Description"].Header.Caption = _lblDescription;
                aBand.Columns["Style"].CellActivation = Activation.NoEdit;
                aBand.Columns["Description"].CellActivation = Activation.NoEdit;
                foreach (UltraGridColumn column in aBand.Columns)
                {
                    if (!column.Hidden)
                    {
                        if (_dtStyleNodeChars.Columns[column.Key].ExtendedProperties.ContainsKey("Level"))
                        {
                            column.CellActivation = Activation.NoEdit;
                        }
                    }        
                }    
                 
                AssignCharValueLists(aBand);
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private void InitializeColorNodeCharsLayout(UltraGridBand aBand)
        {
            try
            {
                aBand.Columns["ColorHnRID"].Hidden = true;
                aBand.Columns["ColorCodeRID"].Hidden = true;
                aBand.Columns["ColorID"].Header.Caption = _lblColor;
                aBand.Columns["Description"].Header.Caption = _lblDescription;

                aBand.Columns["ColorID"].CellActivation = Activation.NoEdit;
                aBand.Columns["Description"].CellActivation = Activation.NoEdit;

                AssignCharValueLists(aBand);
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private void AssignCharValueLists(UltraGridBand aBand)
        {
            try
            {
                if (_productCharValueLists.Count > 0)
                {
                    foreach (string productCharID in _productCharValueLists.Keys)
                    {
                        AssignCharValueList(aBand, productCharID);
                    }
                }
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }    
        }

        private void AssignCharValueList(UltraGridBand aBand, string aProductCharID)
        {
            try
            {
                ValueList valueList = (ValueList)_productCharValueLists[aProductCharID];
                if (!ugCharacteristics.DisplayLayout.ValueLists.Contains(valueList))
                {
                    ugCharacteristics.DisplayLayout.ValueLists.Add(valueList);
                }
                if (aBand.Columns.Exists(aProductCharID))
                {
                    aBand.Columns[aProductCharID].ValueList = valueList;
                    aBand.Columns[aProductCharID].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                } 
            }
            catch
            {
                throw;
            }    
        }
        
        private void SetProductCharGridEditMode()
        {
            try
            {
                ugCharacteristics.DisplayLayout.Override.CellClickAction = Infragistics.Win.UltraWinGrid.CellClickAction.EditAndSelectText;
                foreach (UltraGridRow uRow in ugCharacteristics.Rows)
                {
                    SetCharEditActivation(uRow);
                    if (uRow.HasChild(false))
                    {
                        UltraGridRow cRow = uRow.GetChild(ChildRow.First);
                        while (cRow != null)
                        {
                            SetCharEditActivation(cRow);
                            cRow = cRow.GetSibling(SiblingRow.Next, true, false);
                        }
                    }    
                }
                ugCharacteristics.Selected.Rows.Clear(); 
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private void SetCharEditActivation(UltraGridRow aRow)
        {
            try
            {
                int nodeRID = GetRowNodeRID(aRow);
                DataRowView drv = (DataRowView)aRow.ListObject;
                
                for (int i = 0; i < drv.DataView.Table.Columns.Count; i++)
                {
                    DataColumn dCol = drv.DataView.Table.Columns[i];
                    if (dCol.ExtendedProperties.ContainsKey("IsChar"))
                    {
                        int productCharGroupRID = (int)dCol.ExtendedProperties["IsChar"];
                        NodeCharProfile ncp = GetNodeCharProfile(nodeRID, productCharGroupRID);

                        if (ncp == null)
                        {
                            continue;
                        }
                        else if (ncp != null && ncp.InheritedFrom != nodeRID && ncp.TypeInherited == eInheritedFrom.Node)
                        {
                            HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(ncp.InheritedFrom);
                            string inheritMsg = _txtInheritedFrom + hnp.Text;
                            aRow.Cells[ncp.ProductCharID].Appearance.Image = InheritanceImage;
                            aRow.Cells[ncp.ProductCharID].Tag = inheritMsg;
                        }
                        else
                        {
                            aRow.Cells[ncp.ProductCharID].Appearance.Image = null;
                            aRow.Cells[ncp.ProductCharID].Tag = null;
                        }
                    }
                }

                if (_assortReviewCharacteristicSecurity.IsReadOnly || GetCharStyleSecurity(aRow) == eSecurityType.View)
                {
                    aRow.Activation = Activation.NoEdit;
                }
            }
            catch  
            {
                throw;
            }
        }

        private eSecurityType GetCharStyleSecurity(UltraGridRow aRow)
        {
            eSecurityType styleSecurity = eSecurityType.View;
            try
            {
                switch (aRow.Band.Key)
                {
                    case "StyleNodeChars":
                        styleSecurity = (eSecurityType)Convert.ToInt32(aRow.Cells["StyleSecurity"].Value, CultureInfo.CurrentUICulture);
                        break;

                    case "ColorNodeChars":
                        styleSecurity = (eSecurityType)Convert.ToInt32(aRow.ParentRow.Cells["StyleSecurity"].Value, CultureInfo.CurrentUICulture); 
                        break;
                }
                return styleSecurity;
            }
            catch
            {
                throw;
            }
        }

        private int GetRowNodeRID(UltraGridRow aRow)
        {
            int nodeRID = Include.NoRID;
            try
            {
                switch (aRow.Band.Key)
                {
                    case "StyleNodeChars":
                        nodeRID = Convert.ToInt32(aRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                        break;

                    case "ColorNodeChars":
                        nodeRID = Convert.ToInt32(aRow.Cells["ColorHnRID"].Value, CultureInfo.CurrentUICulture);
                        break;
                }
                return nodeRID;
            }
            catch
            {
                throw;
            }
        }

        private NodeCharProfile GetNodeCharProfile(int aProductCharGroupRID, UltraGridRow aRow)
        {
            try
            {
                return GetNodeCharProfile(GetRowNodeRID(aRow), aProductCharGroupRID);
            }
            catch
            {
                throw;
            }
        }    

        private NodeCharProfile GetNodeCharProfile(int aNodeRID, int aProductCharGroupRID)
        {
            try
            {
                NodeCharProfileList nodeCharProfileList = (NodeCharProfileList)_nodeCharacteristics[aNodeRID];
                if (nodeCharProfileList == null)
                {
                    nodeCharProfileList = new NodeCharProfileList(eProfileType.ProductCharacteristic);
                    _nodeCharacteristics.Add(aNodeRID, nodeCharProfileList);
                }
                NodeCharProfile ncp = (NodeCharProfile)nodeCharProfileList.FindKey(aProductCharGroupRID);
                if (ncp == null)
                { 
                    ProductCharProfile pcp = (ProductCharProfile)_productCharProfileList.FindKey(aProductCharGroupRID);
                    ncp = new NodeCharProfile(aProductCharGroupRID);
                    ncp.ProductCharID = pcp.ProductCharID;
                    nodeCharProfileList.Add(ncp);
                }
                return ncp;
            }
            catch
            {
                throw;
            }
        }    

        private void ugCharacteristics_CellChange(object sender, Infragistics.Win.UltraWinGrid.CellEventArgs e)
        {
            bool applyToLowerLevel = false;
            DialogResult dialogResult;
            try
            {
                int valueRID = (int)ugCharacteristics.ActiveCell.ValueListResolved.GetValue(ugCharacteristics.ActiveCell.ValueListResolved.SelectedItemIndex);
                string valueID = ugCharacteristics.ActiveCell.ValueListResolved.GetText(ugCharacteristics.ActiveCell.ValueListResolved.SelectedItemIndex);
                ugCharacteristics.ActiveCell.Appearance.Image = null;
                ugCharacteristics.ActiveCell.Tag = null;
                DataRowView drv = (DataRowView)e.Cell.Row.ListObject;
                DataColumn dCol = drv.DataView.Table.Columns[e.Cell.Column.Key];

                int nodeRID = GetRowNodeRID(e.Cell.Row);
                int productCharGroupRID = (int)dCol.ExtendedProperties["IsChar"];
                NodeCharProfile ncp = GetNodeCharProfile(nodeRID, productCharGroupRID);
                 
                ncp.ProductCharValueRID = valueRID;
                ncp.ProductCharValue = valueID;
                ncp.InheritedFrom = Include.NoRID;
                ncp.TypeInherited = eInheritedFrom.None;
                _characteristicsChanged = true;

                if (e.Cell.Band.Key == "StyleNodeChars" && e.Cell.Row.HasChild(false))
                {
                    dialogResult = CheckForLowerLevelApply(e.Cell.Row, ncp.ProductCharID, ncp.ProductCharValueRID);

                    if (dialogResult == DialogResult.Cancel)
                    {
                        e.Cell.Value = e.Cell.OriginalValue;
                        return;
                    }
                    else
                    {
                        switch (dialogResult)
                        {
                            case DialogResult.Yes:
                            case DialogResult.None:
                                applyToLowerLevel = true;
                                break;

                            case DialogResult.No:
                                applyToLowerLevel = false;
                                break;
                        }
                    }

                    ApplyCharacteristic(ncp.Key, valueRID, e.Cell.Row, applyToLowerLevel);

                    // Begin TT#1278 - RMatelic - Assortment When selecting Save no hour glass appears and the user cannot tell if somethingis saved or not.  Selecting the X in the right had corner does not give a message asking if the user wants to save or not.
                    if (_assortReviewCharacteristicSecurity.AllowUpdate)
                    {
                        ChangePending = true;
                    }
                    // End TT#1278 
                }
                // Begin TT#1790 - RMatelic - ASST Product Characteristics if change or add new you have to Save-Close and Reopen assortment to appear 
                else
                {
                    ApplyCharacteristic(ncp.Key, valueRID, e.Cell.Row, applyToLowerLevel);
                }
                // End TT#1790
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }
        
        private void ugCharacteristics_MouseDown(object sender, MouseEventArgs e)
        {
            try
            {
                //UltraGridCell mouseCell;
                Infragistics.Win.UIElement mouseUIElement;
                //Infragistics.Win.UIElement headerUIElement;
                //HeaderUIElement headerUI = null;
                Point point = new Point(e.X, e.Y);

                //UltraGrid grid = (UltraGrid)sender;
                //_rClickGrid = grid;

                mouseUIElement = ugCharacteristics.DisplayLayout.UIElement.ElementFromPoint(point);

                if (mouseUIElement == null)
                {
                    return;
                }
                if (e.Button == MouseButtons.Right)
                {
                    // retrieve the UIElement from the location of the mouse 

                    //headerUIElement = mouseUIElement.GetAncestor(typeof(HeaderUIElement));
                    //if (null == headerUIElement)
                    //{
                    //    // retrieve the Cell from the UIElement 
                    //    mouseCell = (Infragistics.Win.UltraWinGrid.UltraGridCell)mouseUIElement.GetContext(typeof(Infragistics.Win.UltraWinGrid.UltraGridCell));

                    //    // if there is a cell object reference, set to active cell and edit
                    //    if (mouseCell != null)
                    //    {
                    //        _gridCol = mouseCell.Column;
                    //        _gridBand = mouseCell.Band;
                    //    }
                    //}
                    //else if (headerUIElement.GetType() == typeof(HeaderUIElement))
                    //{
                    //    headerUI = (HeaderUIElement)headerUIElement;
                    //    Infragistics.Win.UltraWinGrid.ColumnHeader colHeader = null;
                    //    _gridCol = null;
                    //    colHeader = (Infragistics.Win.UltraWinGrid.ColumnHeader)headerUI.SelectableItem;
                    //    _gridCol = colHeader.Column;
                    //    if (_gridCol == null)
                    //    {
                    //        return;
                    //    }
                    //    _gridBand = colHeader.Band;
                    //}
                    _rClickRowChar = (UltraGridRow)mouseUIElement.GetContext(typeof(UltraGridRow));
                }
                //_rClickRowChar = (UltraGridRow)mouseUIElement.GetContext(typeof(UltraGridRow));
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private void ugCharacteristics_MouseEnterElement(object sender, UIElementEventArgs e)
        {
            try
            {
                ShowUltraGridToolTip(ugCharacteristics, e);
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private void ugCharacteristics_DragEnter(object sender, DragEventArgs e)
        {
            try
            {
                Image_DragEnter(sender, e);
                if (e.Data.GetDataPresent(typeof(ProductCharacteristicClipboardList)))
                {
                    e.Effect = DragDropEffects.All;
                }
                else
                {
                    ObjectDragEnter(e);
                }
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private void ugCharacteristics_DragLeave(object sender, EventArgs e)
        {
            Image_DragLeave(sender, e);
        }

        private void ugCharacteristics_DragOver(object sender, DragEventArgs e)
        {
            try
            {
                if (_assortReviewCharacteristicSecurity.IsReadOnly)
                {
                    e.Effect = DragDropEffects.None;
                    return;
                }
                             
                Image_DragOver(sender, e);

                Infragistics.Win.UIElement aUIElement;

                Point realPoint = ugCharacteristics.PointToClient(new Point(e.X, e.Y));
                aUIElement = ugCharacteristics.DisplayLayout.UIElement.ElementFromPoint(realPoint);

                if (aUIElement == null ||  (!e.Data.GetDataPresent(typeof(TreeNodeClipboardList)) &&
                    !e.Data.GetDataPresent(typeof(ProductCharacteristicClipboardList)))) 
                {
                    e.Effect = DragDropEffects.None;
                    return;
                }

                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                bool validDrag = false;
                if (row == null)
                {
                    // check all rows; if any row has styleSecurity Update, continue; if all rows are View, disallow drop
                    eSecurityType securityType = eSecurityType.View;
                    foreach (UltraGridRow sRow in this.ugCharacteristics.Rows)  
                    {
                        securityType = GetCharStyleSecurity(sRow);
                        if (securityType == eSecurityType.Update)
                        {
                            validDrag = true;
                            break;
                        }
                    }
                    if (securityType == eSecurityType.View)
                    {
                        e.Effect = DragDropEffects.None;
                        return;
                    }
                }
                else
                {
                    if (GetCharStyleSecurity(row) == eSecurityType.View)
                    {
                        e.Effect = DragDropEffects.None;
                        return;
                    }

                    switch (row.Band.Key)
                    {
                        case "StyleNodeChars":
                            //validDrag = DragOverStyle(sender, aUIElement, ref e);
                            validDrag = true;
                            break;

                        case "ColorNodeChars":
                            //validDrag = DragOverColor(sender, aUIElement, ref e);
                            validDrag = true;
                            break;

                        default:
                            break;
                    }
                }
                if (e.Data.GetDataPresent(typeof(ProductCharacteristicClipboardList)))
                {
                    ProductCharacteristicClipboardList pcList = (ProductCharacteristicClipboardList)e.Data.GetData(typeof(ProductCharacteristicClipboardList));
                    foreach (ProductCharacteristicClipboardProfile item in pcList.ClipboardItems)
                    {
                        if (item.ProductCharGroupKey == Include.NoRID)
                        {
                            validDrag = false;
                            break;
                        }
                    }
                }
                if (validDrag)
                {
                    e.Effect = DragDropEffects.All;
                }
                else
                {
                    e.Effect = DragDropEffects.None;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugCharacteristics_DragDrop(object sender, DragEventArgs e)
        {
            TreeNodeClipboardList cbList;
            HierarchyNodeClipboardList hnList;
            ProductCharacteristicClipboardList pcList;
            NodeCharProfileList nodeCharProfileList;
            bool applyToLowerLevel = false;
            DialogResult dialogResult;
			try
			{
                Infragistics.Win.UIElement aUIElement;

                Point realPoint = ugCharacteristics.PointToClient(new Point(e.X, e.Y));
                aUIElement = ugCharacteristics.DisplayLayout.UIElement.ElementFromPoint(realPoint);

                UltraGridRow dropRow = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                //UltraGridCell dropCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));

                if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)) ||
                    e.Data.GetDataPresent(typeof(ProductCharacteristicClipboardList)))
                {
                    dialogResult = CheckForLowerLevelApply(dropRow, "", 0);

                    if (dialogResult == DialogResult.Cancel)
                    {
                        return;
                    }
                    else
                    {
                        switch (dialogResult)
                        {
                            case DialogResult.Yes:
                            case DialogResult.None:
                                applyToLowerLevel = true;
                                break;

                            case DialogResult.No:
                            //case DialogResult.None:
                                applyToLowerLevel = false;
                                break;
                        }
                    }
                }
                
                if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                {
                    cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));
                    if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                    {
                        nodeCharProfileList = _sab.HierarchyServerSession.GetProductCharacteristics(cbList.ClipboardProfile.Key, true);
                        foreach (NodeCharProfile ncp in nodeCharProfileList)
                        {
                            ApplyCharacteristic(ncp.Key, ncp.ProductCharValueRID, dropRow, applyToLowerLevel);
                            if (dropRow != null)
                            {
                                RemoveInheritanceProperties(ncp.Key, dropRow);
                            }            
                        }
                        _characteristicsChanged = true;
                        // Begin TT#1278 - RMatelic - Assortment When selecting Save no hour glass appears and the user cannot tell if somethingis saved or not.  Selecting the X in the right had corner does not give a message asking if the user wants to save or not.
                        if (_assortReviewCharacteristicSecurity.AllowUpdate)
                        {
                            ChangePending = true;
                        }
                        // End TT#1278 
                    }

                }
                else if (e.Data.GetDataPresent(typeof(ProductCharacteristicClipboardList)))
                {
                    pcList = (ProductCharacteristicClipboardList)e.Data.GetData(typeof(ProductCharacteristicClipboardList));
                    foreach (ProductCharacteristicClipboardProfile item in pcList.ClipboardItems)
                    {
                        ApplyCharacteristic(item.ProductCharGroupKey, item.Key, dropRow, applyToLowerLevel);
                        if (dropRow != null)
                        {
                            RemoveInheritanceProperties(item.ProductCharGroupKey, dropRow);
                        }   
                    }
                    _characteristicsChanged = true;
                    // Begin TT#1278 - RMatelic - Assortment When selecting Save no hour glass appears and the user cannot tell if somethingis saved or not.  Selecting the X in the right had corner does not give a message asking if the user wants to save or not.
                    if (_assortReviewCharacteristicSecurity.AllowUpdate)
                    {
                        ChangePending = true;
                    }
                    // End TT#1278 
                }
            }
            catch (BadDataInClipboardException)
            {
                MessageBox.Show(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_BadDataInClipboard),
                    this.Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private DialogResult CheckForLowerLevelApply(UltraGridRow aRow, string aProductCharID, int aValueRID)
        {
            DialogResult dialogResult = DialogResult.None;
            bool askQuestion = false;
            int nodeRID = 0;
            try
            {
                if (aRow == null)
                {
                    if (_dtColorNodeChars.Rows.Count > 0)
                    {
                        askQuestion = true;
                    }
                }
                else if (aRow.HasChild(this.ugCharacteristics.DisplayLayout.Bands["ColorNodeChars"], false))
                {
                    nodeRID = GetRowNodeRID(aRow);
                    UltraGridRow cRow = aRow.GetChild(ChildRow.First);
                    while (cRow != null)
                    {
                        DataRowView drv = (DataRowView)cRow.ListObject;
                        DataColumn dCol = drv.DataView.Table.Columns[aProductCharID];
                        if (dCol == null)
                        {
                            askQuestion = true;
                            break;
                        }    
                        else if (dCol.ExtendedProperties.ContainsKey("IsChar"))
                        {
                            int productCharGroupRID = (int)dCol.ExtendedProperties["IsChar"];
                            int childNodeRID = GetRowNodeRID(cRow);
                            NodeCharProfile ncp = GetNodeCharProfile(childNodeRID, productCharGroupRID);
                            if (ncp.InheritedFrom != nodeRID)
                            {
                                askQuestion = true;
                                break;
                            } 
                        }
                        else
                        {
                            askQuestion = true;
                            break;
                        } 

                        cRow = cRow.GetSibling(SiblingRow.Next, true, false);
                    }
                }
                if (askQuestion)
                {
                    string message = MIDText.GetTextOnly(eMIDTextCode.msg_as_ApplyCharsToLowerLevels);

                    dialogResult = MessageBox.Show(message, this.Text, MessageBoxButtons.YesNoCancel,
                                   MessageBoxIcon.Question, MessageBoxDefaultButton.Button1);
                }

                return dialogResult;
            }
            catch
            {
                throw;
            }          
        }

        private void ApplyCharacteristic(int aProductCharGroupRID, int aValueRID, UltraGridRow aRow, bool aApplyToLowerLevel)
        {
            try
            {
                ProductCharProfile pcp = (ProductCharProfile)_productCharProfileList.FindKey(aProductCharGroupRID);
                if (pcp == null)
                {
                    return;
                }
                if (aRow == null)   // apply to all style rows
                {
                    foreach (UltraGridRow row in this.ugCharacteristics.Rows)
                    {    
                         if (GetCharStyleSecurity(row) == eSecurityType.Update)
                         {
                             ApplyCharacteristic(pcp, aValueRID, row, aApplyToLowerLevel);
                         }
                    }
                }
                else
                {
                    ApplyCharacteristic(pcp, aValueRID, aRow, aApplyToLowerLevel);
                }
                SaveAndUpdateAssortmentTab(); //TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private void ApplyCharacteristic(ProductCharProfile aPcp, int aValueRID, UltraGridRow aRow, bool aApplyToLowerLevel)
        {
            try
            {
                // if apply to lower level is false, we still need to update the currently inherited cells, so if characteristic is inherited, proceed; otherwise, exit
                if (aRow.Band.Key == "ColorNodeChars")
                {
                    if (!aApplyToLowerLevel) 
                    {
                        if (aRow.Cells.Exists(aPcp.ProductCharID))
                        {
                            NodeCharProfile ncp = GetNodeCharProfile(aPcp.Key, aRow);
                            if (ncp.InheritedFrom != Convert.ToInt32(aRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture))
                            {
                                _applyInheritance = false;
                                return; // not inherited and  apply to lower level = false
                            }
                        }
                        else
                        {
                            _applyInheritance = false;
                            return;
                        }
                    }
                }

                ApplyCharacteristicProperties(aPcp, aValueRID, aRow);

                aRow.Cells[aPcp.ProductCharID].Value = aValueRID;
                
                if (aRow.HasChild(false))
                {
                    UltraGridRow cRow = aRow.GetChild(ChildRow.First);
                    while (cRow != null)
                    {
                        _applyInheritance = true;
                        ApplyCharacteristic(aPcp, aValueRID, cRow, aApplyToLowerLevel);
                        if (_applyInheritance)
                        {
                            ApplyInheritanceProperties(aPcp, aValueRID, cRow, aApplyToLowerLevel);
                        }
                        
                        cRow = cRow.GetSibling(SiblingRow.Next, true, false);
                    }
                }
                // Begin TT#1790 - RMatelic - ASST Product Characteristics if change or add new you have to Save-Close and Reopen assortment to appear 
                if (aRow.Band.Key == "StyleNodeChars")
                {
                    int styleHnRID = Convert.ToInt32(aRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                    UpdateAssortmentTabCharacteristic(styleHnRID, aPcp, aValueRID);
                }
                // End TT#1790
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        // Begin TT#1790 - RMatelic - ASST Product Characteristics if change or add new you have to Save-Close and Reopen assortment to appear 
        private void UpdateAssortmentTabCharacteristic(int aStyleHnRID, ProductCharProfile aPcp, int aNewCharValueRID)
        {
            try
            {
                string CharColumnName = "CHARACTERISTIC" + aPcp.Key.ToString();
                string RIDColumnName = CharColumnName + "_RID";
                DataColumn dColumn = _dtHeaders.Columns[RIDColumnName];
                if (dColumn == null)
                {
                    //Begin TT#1811 - DOConnell - New Characteristic did not appear in Column Chooser until after save/exit
                    dColumn = AddAssortmentCharacteristic(aPcp, CharColumnName, RIDColumnName);
					//Begin TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
                    //if (dColumn == null)
                    //{
                        return;
                    //}
					//End TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
                    //End TT#1811 - DOConnell - New Characteristic did not appear in Column Chooser until after save/exit
                }
                string newCharValueID = string.Empty;
                if (aNewCharValueRID == 0)
                {
                    newCharValueID = _lblNone + aPcp.ProductCharID;
                }
                else
                {
                    foreach (ProductCharValueProfile pcvp in aPcp.ProductCharValues)
                    {
                        if (pcvp.Key == aNewCharValueRID)
                        {   
                            newCharValueID = pcvp.ProductCharValue;
                            break;
                        }
                    }
                }
                for (int i = 0; i < _dtHeaders.Rows.Count; i++)
                {
                    DataRow row = _dtHeaders.Rows[i];
                   
                    if (aStyleHnRID == Convert.ToInt32(row["PLANLEVEL_RID"], CultureInfo.CurrentUICulture))
                    {
                        int phRID = Convert.ToInt32(row["PLACEHOLDER_RID"], CultureInfo.CurrentUICulture);
                        string oldCharValueID = Convert.ToString(row[CharColumnName], CultureInfo.CurrentUICulture);
                        int oldCharValueRID = Convert.ToInt32(row[RIDColumnName], CultureInfo.CurrentUICulture);
                        row[RIDColumnName] = aNewCharValueRID;
                        row[CharColumnName] = newCharValueID;
                        bool colFound = false;
                        
                        int charCol = 0;
                        for (int gCol = 0; gCol < g4.Cols.Count; gCol++)
                        {
                            if (g4.Cols[gCol].Caption.Contains(aPcp.ProductCharID))
                            {
                                charCol = gCol;
                                colFound = true;
                                break;
                            }
                        }
                        if (colFound)
                        {   
                            int charProfileKey = (int)eProfileType.ProductCharacteristic + aPcp.Key;
                            PagingGridTag gridTag = (PagingGridTag)g4.Tag;
                            for (int gRow = 0; gRow < g4.Rows.Count; gRow++)
                            {
                                string dataDisplay = g4.GetDataDisplay(gRow, charCol);
                                if (dataDisplay == oldCharValueID)
                                {
                                    RowHeaderTag rowTag = (RowHeaderTag)gridTag.RowHeaderGrid.Rows[gRow].UserData;
                                    if (rowTag.CubeWaferCoorList != null && rowTag.CubeWaferCoorList.Count > 0)
                                    {
                                        bool phFound = false;
                                        bool charFound = false;
                                        foreach (CubeWaferCoordinate waferCoord in rowTag.CubeWaferCoorList)
                                        {
                                            int profileType = (int)waferCoord.WaferCoordinateType;
                                            if (profileType == (int)eProfileType.PlaceholderHeader)
                                            {
                                                if (!phFound)
                                                {
                                                    if (waferCoord.Key == phRID)
                                                    {
                                                        phFound = true;
                                                    }
                                                }
                                            }
                                            if (profileType == charProfileKey)
                                            {
                                                charFound = true;
                                            }
                                        }
                                        if (phFound && charFound)
                                        {
                                            g4[gRow, charCol] = newCharValueID;
                                            g4.AutoSizeCol(charCol);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                _characteristicsChanged = true;
                SaveProductCharacteristics();

                StopPageLoadThreads();
                SaveDetailCubeGroup();

                UpdateData(true);
                LoadSurroundingPages();

                _buildDetailsGrid = true;
                _buildProductCharsGrid = true;
                LoadProductCharGrid();

                UpdateOtherViews();

                ResizeCol1();

                FormatCol1Grids(false);
                
                spcVLevel1_DoubleClick(spcVLevel1, null);
                SaveChanges();
            }
            catch
            {
                throw;
            }
        }
        // End TT#1790

        //Begin TT#1811 - DOConnell - New Characteristic did not appear in Column Chooser until after save/exit
        private DataColumn AddAssortmentCharacteristic(ProductCharProfile aPcp, string CharColumnName, string RIDColumnName)
        {
            try
            {
			//Begin TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
                AssortmentComponentVariableProfile ACVP = new AssortmentComponentVariableProfile(
                (int)eAssortmentComponentVariables.Characteristic + aPcp.Key,
                (eProfileType)((int)eProfileType.ProductCharacteristic + aPcp.Key),
                aPcp.ProductCharID,
                CharColumnName,
                false,
                false);

                if (!_componentVariables.VariableProfileList.Contains(ACVP.Key))
                {
                    _componentVariables.AddVariableProfile(ACVP);

                    //_componentVariables.AddVariableProfile(
                    //    new AssortmentComponentVariableProfile(
                    //        (int)eAssortmentComponentVariables.Characteristic + aPcp.Key,
                    //        (eProfileType)((int)eProfileType.ProductCharacteristic + aPcp.Key),
                    //        aPcp.ProductCharID,
                    //        CharColumnName,
                    //        false,
                    //        false));
                }
                _componentColumnProfileList.Clear();
                _componentColumnProfileList = (ProfileList)_componentVariables.VariableProfileList.Clone();

                //UpdateSelectableComponentList(true); //TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment

                _characteristicsChanged = true;
                SaveProductCharacteristics();
                
                UpdateData(false);
                SaveChanges();
                FormatCol1Grids(false);
                UpdateSelectableComponentList(true); //TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment
                DataColumn dColumn = _dtHeaders.Columns[RIDColumnName];

                return dColumn;
            }
            catch
            {
                throw;
            }
        }
        //End TT#1811 - DOConnell - New Characteristic did not appear in Column Chooser until after save/exit

        //Begin TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
        private void UpdateSelectableComponentList(bool addNew)
        {
            DataRow viewRow;
            Hashtable varKeyHash;
            AssortmentComponentVariableProfile compVarProf;
            varKeyHash = new Hashtable();
            try
            {
				//BEGIN TT#416 - MD - DOConnell - Characteristics do not appear in the Column Chooser unless you save the assortment, close the application, and go back in.  Should update automatically.
                if (addNew)
                {
                    _componentColumnProfileList = (ProfileList)_asrtCubeGroup.AssortmentComponentVariables.VariableProfileList.Clone();
                }
                else
                {
                    _componentColumnProfileList = (ProfileList)_componentVariables.VariableProfileList.Clone();
                }
				//END TT#416 - MD - DOConnell - Characteristics do not appear in the Column Chooser unless you save the assortment, close the application, and go back in.  Should update automatically.
                _selectableComponentColumnHeaders.Clear();

                foreach (DataRow row in _assrtViewDetail.Rows)
                {
                    if (Convert.ToInt32(row["AXIS"], CultureInfo.CurrentUICulture) == (int)eAssortmentViewAxis.Component)
                    {
                        compVarProf = (AssortmentComponentVariableProfile)_componentColumnProfileList.FindKey(Convert.ToInt32(row["PROFILE_KEY"], CultureInfo.CurrentUICulture));
                        if (compVarProf != null)
                        {
                            varKeyHash.Add(compVarProf.Key, row);
							//Begin TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
                            if (addNew && !_asrtCubeGroup.AssortmentComponentVariables.VariableProfileList.Contains(compVarProf.Key))
                                _asrtCubeGroup.AssortmentComponentVariables.AddVariableProfile(compVarProf);
							//End TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
                        }
                    }
                }

                _placeholderSelected = false;

                foreach (AssortmentComponentVariableProfile varProf in _componentColumnProfileList)
                {
                    viewRow = (DataRow)varKeyHash[varProf.Key];
                    if (viewRow != null)
                    {
                        _selectableComponentColumnHeaders.Add(new RowColProfileHeader(varProf.VariableName, true, Include.ConvertCharToBool(Convert.ToChar(viewRow["SUMMARIZED_IND"], CultureInfo.CurrentUICulture)), Convert.ToInt32(viewRow["AXIS_SEQUENCE"], CultureInfo.CurrentUICulture), varProf));
                    }
                    else
                    {
                        _selectableComponentColumnHeaders.Add(new RowColProfileHeader(varProf.VariableName, false, false, -1, varProf));
                    }
					//Begin TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
                    if (addNew && !_asrtCubeGroup.AssortmentComponentVariables.VariableProfileList.Contains(varProf.Key))
                        _asrtCubeGroup.AssortmentComponentVariables.AddVariableProfile(varProf);
					//End TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
                }
                _sortedComponentColumnHeaders.Clear();

                CreateSortedList(_selectableComponentColumnHeaders, _sortedComponentColumnHeaders);
            }
            catch
            {
                throw;
            }
        }
        //End TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
        
        private void ApplyInheritanceProperties(ProductCharProfile aPcp, int aValueRID, UltraGridRow aRow, bool aApplyToLowerLevel)
        {
            try
            {
                int nodeRID = GetRowNodeRID(aRow);
                DataRowView drv = (DataRowView)aRow.ListObject;
                DataColumn dCol = drv.DataView.Table.Columns[aPcp.ProductCharID];
                if (dCol.ExtendedProperties.ContainsKey("IsChar"))
                {
                    int productCharGroupRID = (int)dCol.ExtendedProperties["IsChar"];
                    NodeCharProfile ncp = GetNodeCharProfile(nodeRID, productCharGroupRID); //check this

                    if (!aApplyToLowerLevel)
                    {
                        if (ncp.InheritedFrom != Convert.ToInt32(aRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture))
                        {
                            return; // not inherited and apply to lower level = false
                        }
                    }    
                    
                    ncp.ProductCharValueRID = aValueRID;
                    if (ncp.ProductCharValueRID > 0)
                    {
                        ncp.InheritedFrom = Convert.ToInt32(aRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                        ncp.TypeInherited = eInheritedFrom.Node;
                        ncp.ProductCharChangeType = eChangeType.add;
                        HierarchyNodeProfile hnp = _sab.HierarchyServerSession.GetNodeData(ncp.InheritedFrom);
                        string inheritMsg = _txtInheritedFrom + hnp.Text;
                        aRow.Cells[ncp.ProductCharID].Appearance.Image = InheritanceImage;
                        aRow.Cells[ncp.ProductCharID].Tag = inheritMsg;
                    }
                    else
                    {
                        ncp.InheritedFrom = Include.NoRID;
                        ncp.TypeInherited = eInheritedFrom.None;
                        ncp.ProductCharChangeType = eChangeType.delete;
                        aRow.Cells[ncp.ProductCharID].Appearance.Image = null;
                        aRow.Cells[ncp.ProductCharID].Tag = null;
                    }
                }    
            }
            catch
            {
                throw;
            }
       }

        private void RemoveInheritanceProperties(int aProductCharGroupRID, UltraGridRow aRow)
        {
            try
            {
                NodeCharProfile ncp = GetNodeCharProfile(aProductCharGroupRID, aRow);
                ncp.InheritedFrom = Include.NoRID;
                ncp.TypeInherited = eInheritedFrom.None;
                ncp.ProductCharChangeType = eChangeType.update;
                aRow.Cells[ncp.ProductCharID].Appearance.Image = null;
                aRow.Cells[ncp.ProductCharID].Tag = null;
            }
            catch
            {
                throw;
            }
        }

        private void ApplyCharacteristicProperties(ProductCharProfile aPcp, int aValueRID, UltraGridRow aRow)
        {
            try
            {
                NodeCharProfileList nodeCharProfileList;
                NodeCharProfile ncp;
                int nodeRID = GetRowNodeRID(aRow);
                
                if (!_nodeCharacteristics.ContainsKey(nodeRID))
                {
                    nodeCharProfileList = new NodeCharProfileList(eProfileType.ProductCharacteristic);
                    _nodeCharacteristics.Add(nodeRID, nodeCharProfileList);
                }
                else
                {
                    nodeCharProfileList = (NodeCharProfileList)_nodeCharacteristics[nodeRID];
                }
                if (nodeCharProfileList.Contains(aPcp.Key))
                {
                    ncp = (NodeCharProfile)nodeCharProfileList.FindKey(aPcp.Key);
                }
                else
                {
                    ncp = new NodeCharProfile(aPcp.Key);
                    nodeCharProfileList.Add(ncp);
                }

                ncp.ProductCharID = aPcp.ProductCharID;
                ncp.ProductCharValueRID = aValueRID;
                foreach (ProductCharValueProfile prodCharValueProf in aPcp.ProductCharValues)
                {
                    if (prodCharValueProf.Key == aValueRID)
                    {
                        ncp.ProductCharValue = prodCharValueProf.ProductCharValue;
                        break;
                    }
                }
                ncp.ProductCharChangeType = eChangeType.add;
                

                switch (aRow.Band.Key)
                {
                    case "StyleNodeChars":
                        if (!_dtStyleNodeChars.Columns.Contains(ncp.ProductCharID))
                        {
                            _dtStyleNodeChars.Columns.Add(ncp.ProductCharID);
                            _dtStyleNodeChars.Columns[ncp.ProductCharID].ExtendedProperties.Add("IsChar", ncp.Key);
                            
                        }  
                        break;

                    case "ColorNodeChars":
                        if (!_dtColorNodeChars.Columns.Contains(ncp.ProductCharID))
                        {
                            _dtColorNodeChars.Columns.Add(ncp.ProductCharID);
                            _dtColorNodeChars.Columns[ncp.ProductCharID].ExtendedProperties.Add("IsChar", ncp.Key);
                        };
                        break;
                }

                GetProductCharValueList(ncp.ProductCharID);
                AssignCharValueList(aRow.Band, ncp.ProductCharID);
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }
        #endregion

        #region Characteristic Grid Context Menu Options
        private void cmsCharGrid_Opening(object sender, CancelEventArgs e)
        {
            try
            {
                if (_assortReviewCharacteristicSecurity.IsReadOnly)
                {
                    e.Cancel = true;
                    return;
                }  

                if (ugCharacteristics == null || ugCharacteristics.Rows.Count == 0)
                {
                    e.Cancel = true;
                    return;
                }

                if (_rClickRowChar == null)
                {
                    if ((ugCharacteristics.Selected.Rows.Count > 0))
                    {
                        _rClickRowChar = ugCharacteristics.Selected.Rows[0];
                    }
                    else
                    {
                        e.Cancel = true;
                        return;
                    }
                }
                else
                {
                    if (ugCharacteristics.Selected.Rows.Count == 0)
                    {
                        _rClickRowChar.Selected = true;
                    }
                }
              
                if (GetCharStyleSecurity(_rClickRowChar) == eSecurityType.View)
                {
                    e.Cancel = true;
                    return;
                }

                switch (_rClickRowChar.Band.Key)
                {
                    case "StyleNodeChars":
                        if (_rClickRowChar.HasChild(false) && StyleCharacteristicsExist(_rClickRowChar)) 
                        {
                            cmsApplyToLowerLevels.Visible = true;
                            cmsInheritFromHigherLevel.Visible = false;
                        }
                        else
                        {
                            e.Cancel = true;
                        }
                        break;

                    case "ColorNodeChars":
                        if (StyleCharacteristicsExist(_rClickRowChar.ParentRow))
                        {
                             cmsApplyToLowerLevels.Visible = false;
                             cmsInheritFromHigherLevel.Visible = true;
                        }
                        else
                        {
                            e.Cancel = true;
                        }   
                        break;
                }
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private bool StyleCharacteristicsExist(UltraGridRow aRow)
        {
            bool styleCharExists = false;
            try
            {
                 DataRowView drv = (DataRowView)aRow.ListObject;
                 for (int i = 0; i < drv.DataView.Table.Columns.Count; i++)
                 {
                     DataColumn dCol = drv.DataView.Table.Columns[i];
                     if (dCol.ExtendedProperties.ContainsKey("IsChar"))
                     {
                         styleCharExists = true;
                         break;
                     }
                 }
                return styleCharExists;
            }
            catch
            {
                throw;
            }
        }

        private void cmsApplyToLowerLevels_Click(object sender, EventArgs e)
        {
            try
            {
                foreach (UltraGridRow selRow in this.ugCharacteristics.Selected.Rows)
                {
                    int nodeRID = GetRowNodeRID(selRow);  
                    DataRowView drv = (DataRowView)selRow.ListObject;
                    for (int i = 0; i < drv.DataView.Table.Columns.Count; i++)
                    {
                        DataColumn dCol = drv.DataView.Table.Columns[i];
                        if (dCol.ExtendedProperties.ContainsKey("IsChar"))
                        {
                            int productCharGroupRID = (int)dCol.ExtendedProperties["IsChar"];
                            NodeCharProfile ncp = GetNodeCharProfile(nodeRID, productCharGroupRID);
                            ProductCharProfile pcp = (ProductCharProfile)_productCharProfileList.FindKey(ncp.Key);
                            ApplyCharacteristic(pcp, ncp.ProductCharValueRID, selRow, true);
                            _characteristicsChanged = true;
                            // Begin TT#1278 - RMatelic - Assortment When selecting Save no hour glass appears and the user cannot tell if somethingis saved or not.  Selecting the X in the right had corner does not give a message asking if the user wants to save or not.
                            if (_assortReviewCharacteristicSecurity.AllowUpdate)
                            {
                                ChangePending = true;
                            }
                            // End TT#1278 
                        }
                    }
                }
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private void cmsInheritFromHigherLevel_Click(object sender, EventArgs e)
        {
            try
            {
                foreach (UltraGridRow selRow in this.ugCharacteristics.Selected.Rows)
                {
                    UltraGridRow parentRow = selRow.ParentRow;
                    int nodeRID = GetRowNodeRID(parentRow);
                    
                    DataRowView drv = (DataRowView)parentRow.ListObject;
                    for (int i = 0; i < drv.DataView.Table.Columns.Count; i++)
                    {
                        DataColumn dCol = drv.DataView.Table.Columns[i];
                        if (dCol.ExtendedProperties.ContainsKey("IsChar"))
                        {
                            int productCharGroupRID = (int)dCol.ExtendedProperties["IsChar"];
                            NodeCharProfile ncp = GetNodeCharProfile(nodeRID, productCharGroupRID);
                            ProductCharProfile pcp = (ProductCharProfile)_productCharProfileList.FindKey(ncp.Key);
                            ApplyCharacteristic(pcp, ncp.ProductCharValueRID, selRow, true);    // Apply characteristics of parent row to selected row
                            ApplyInheritanceProperties(pcp, ncp.ProductCharValueRID, selRow, true);
                            _characteristicsChanged = true;
                            // Begin TT#1278 - RMatelic - Assortment When selecting Save no hour glass appears and the user cannot tell if somethingis saved or not.  Selecting the X in the right had corner does not give a message asking if the user wants to save or not.
                            if (_assortReviewCharacteristicSecurity.AllowUpdate)
                            {
                                ChangePending = true;
                            }
                            // End TT#1278 
                        }
                    }
                }
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        #endregion

        #region Save Product Characteristic Data
		//Begin TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
        private void SaveProductCharacteristics()
        {
            int charDeletedCount = 0;

            try
            {
                if (_characteristicsChanged)
                {
                    if (_nodeCharacteristics.Count > 0)
                    {
                        foreach (int nodeRID in _nodeCharacteristics.Keys)
                        {
                            charDeletedCount = 0; //TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment
                            NodeCharProfileList nodeCharProfileList = (NodeCharProfileList)_nodeCharacteristics[nodeRID];
                            for (int i = nodeCharProfileList.Count - 1; i >= 0; i--)
                            {
                                NodeCharProfile ncp = (NodeCharProfile)nodeCharProfileList.ArrayList[i];
                                if (ncp.InheritedFrom > 0 || ncp.ProductCharValueRID == 0)
                                {
                                    ncp.ProductCharChangeType = eChangeType.delete; // setting to delete causes the hierarchy service to not add the characteristics
                                }
                                if (ncp.ProductCharValueRID == 0)
                                    charDeletedCount = charDeletedCount + 1;
                                if (_nodeCharacteristics.Keys.Count == charDeletedCount)
                                {
                                    string CharColumnName = "CHARACTERISTIC" + ncp.Key.ToString();
                                    AssortmentComponentVariableProfile ACVP = new AssortmentComponentVariableProfile(
                                    (int)eAssortmentComponentVariables.Characteristic + ncp.Key,
                                    (eProfileType)((int)eProfileType.ProductCharacteristic + ncp.Key),
                                    ncp.ProductCharID,
                                    CharColumnName,
                                    false,
                                    false);

                                    _asrtCubeGroup.AssortmentComponentVariables.RemoveVariableProfile(ACVP);
                                    UpdateSelectableComponentList(false);
                                    charDeletedCount = 0;
                                }
                            }

                            _sab.HierarchyServerSession.UpdateProductCharacteristics(nodeRID, nodeCharProfileList);
                        }
                    }
                    UpdateSelectableComponentList(true); //TT#674 - MD - DOConnell - Argument Exception error received when adding characteristics to an Assortment
                    _characteristicsChanged = false;
                }   
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }
		//End TT#1939 - DOConnell - Add colors to the 1st Placeholder no issue. (Added Blank row and typed in the color code) Go to the Next header and try to add a color and receive a Null Reference Exception.
  
        private void CheckForGridDescriptionUpdate(int aStyleHnRID, string aDescription, int aHeaderRID)
        {
            try
            {
                // update description on Content grid
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (row.Cells["AsrtRID"].Value != DBNull.Value
                     && Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture) == aStyleHnRID
                     && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != aHeaderRID)
                    {
                        row.Cells["Description"].Value = aDescription;
                    }
                }
                ugDetails.UpdateData();

                // update description on Characteristic grid
                if (_dtStyleNodeChars != null && _dtStyleNodeChars.Rows.Count > 0)
                {
                    DataRow styleRow = _dtStyleNodeChars.Rows.Find(aStyleHnRID);
                    if (styleRow != null)
                    {
                        styleRow["Description"] = aDescription;
                        _dtStyleNodeChars.AcceptChanges();
                        // Begin TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, does not change the style
                        //     and Placeholder ID on the Assortment and Characteristics tab unless you save and close the Assorment and go back in to the Assortment 
                        UltraGridBand band = this.ugCharacteristics.DisplayLayout.Bands["StyleNodeChars"];
                        if (band != null)
                        {
                            band.Columns["Description"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
                        }
                        // End TT#1613
                    }
                }
            }
            catch
            {
                throw;
            }
        }

		// BEGIN TT#1996 - stodd - Rtl and Cost do not update on Assortment tab dynamically
		private void UpdateAssortmentTabUnitRetail(int aPlaceHolderRID, double unitRetail, int hdrQty)
		{
			try
			{
				string sUnitRetail = unitRetail.ToString("#,###,##0.00");
				for (int i = 0; i < _dtHeaders.Rows.Count; i++)
				{
					DataRow row = _dtHeaders.Rows[i];

					if (aPlaceHolderRID == Convert.ToInt32(row["PLACEHOLDER_RID"], CultureInfo.CurrentUICulture) &&
						Convert.ToInt32(row["HEADER_RID"], CultureInfo.CurrentUICulture) == int.MaxValue)
					{
						string phText = Convert.ToString(row["PLACEHOLDER"], CultureInfo.CurrentUICulture);
						string data = string.Empty;
						bool unitRetailFound = false;
						int unitRetailCol = 0;
						// BEGIN TT#2089 - stodd - Total cost and total retail not calcing
						//bool totalUnitsFound = false;
						//int totalUnitsCol = 0;
						bool totalRetailFound = false;
						int totalRetailCol = 0;
						// END TT#2089 - stodd - Total cost and total retail not calcing
						
						// BEGIN TT#2051 - stodd - Rtl and Cost do not update on Assortment tab 
						//=======================================
						// Search g5 grid for Unit Retail Column
						//=======================================
                        // Begin TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
                        //unitRetailFound = isColumnOnTotalGrid("Unit Retail", ref unitRetailCol);
                        unitRetailFound = isColumnOnTotalGrid(_lblUnitRetail, ref unitRetailCol);
                        // End TT#1498-MD
						// BEGIN TT#2089 - stodd - Total cost and total retail not calcing
						//totalUnitsFound = isColumnOnTotalGrid("Total Units", ref totalUnitsCol);
                        //totalRetailFound = isColumnOnTotalGrid("Total Retail", ref totalRetailCol);  // TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
						// END TT#2089 - stodd - Total cost and total retail not calcing

						//=======================================================================
						// If column found, search through g4 grid to find Placeholder row,
						// Then update g5 with Unit Retail amount
						//=======================================================================
						if (unitRetailFound)
						{
							// BEGIN TT#2089 - stodd - Total cost and total retail not calcing
							UpdateTotalColumnValue(aPlaceHolderRID, unitRetailCol, sUnitRetail);
                            // Begin TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
                            //if (totalRetailFound)
                            //{
                            //    double tRetail = hdrQty * unitRetail;
                            //    string stRetail = tRetail.ToString("#,###,##0.00");
                            //    UpdateTotalColumnValue(aPlaceHolderRID, totalRetailCol, stRetail);
                            //}
                            // End TT#1498-MD
							// END TT#2089 - stodd - Total cost and total retail not calcing
						}

						//=======================================
						// Search g6 grid for Unit Retail Column
						//=======================================
						List<int> unitRetailColList = new List<int>();
                        // Begin TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
                        //unitRetailFound = isColumnOnDetailGrid("Unit Retail", ref unitRetailColList);
                        unitRetailFound = isColumnOnDetailGrid(_lblUnitRetail, ref unitRetailColList);
                        // End TT#1498-MD

						//=======================================================================
						// If column found, search through g4 grid to find Placeholder row,
						// Then update g6 with Unit Retail amount
						//=======================================================================
						if (unitRetailFound)
						{
							UpdateDetailColumnValue(aPlaceHolderRID, unitRetailColList, sUnitRetail);
						}
						// END TT#2051 - stodd - Rtl and Cost do not update on Assortment tab 

						break;
					}
				}
				_dtHeaders.AcceptChanges();
				spcVLevel1_DoubleClick(spcVLevel1, null);
			}
			catch
			{
				throw;
			}
		}

		private void UpdateAssortmentTabUnitCost(int aPlaceHolderRID, double unitCost, int hdrQty)
		{
			try
			{
				string sUnitCost = unitCost.ToString("#,###,##0.00");
				for (int i = 0; i < _dtHeaders.Rows.Count; i++)
				{
					DataRow row = _dtHeaders.Rows[i];

					if (aPlaceHolderRID == Convert.ToInt32(row["PLACEHOLDER_RID"], CultureInfo.CurrentUICulture) &&
						Convert.ToInt32(row["HEADER_RID"], CultureInfo.CurrentUICulture) == int.MaxValue)
					{
						string phText = Convert.ToString(row["PLACEHOLDER"], CultureInfo.CurrentUICulture);
						string data = string.Empty;
						bool colFound = false;
						int unitCostCol = 0;
						// BEGIN TT#2089 - stodd - Total cost and total retail not calcing
						//bool totalUnitsFound = false;
						//int totalUnitsCol = 0;
						bool totalCostFound = false;
						int totalCostCol = 0;
						// END TT#2089 - stodd - Total cost and total retail not calcing

						// BEGIN TT#2051 - stodd - Rtl and Cost do not update on Assortment tab 
						//===================================================
						// Search g5 grid (Total Grid) for Unit Cost Column
						//===================================================
                        // Begin TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
                        //colFound = isColumnOnTotalGrid("Unit Cost", ref unitCostCol);
                        colFound = isColumnOnTotalGrid(_lblUnitCost, ref unitCostCol);
                        // End TT#1498-MD
						// BEGIN TT#2089 - stodd - Total cost and total retail not calcing
						//totalUnitsFound = isColumnOnTotalGrid("Total Units", ref totalUnitsCol);
                        //totalCostFound = isColumnOnTotalGrid("Total Cost", ref totalCostCol);  // TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
						// END TT#2089 - stodd - Total cost and total retail not calcing

						//=======================================================================
						// If column found, search through g4 grid to find Placeholder row,
						// Then update g5 with Unit Cost amount
						//=======================================================================
						if (colFound)
						{
							UpdateTotalColumnValue(aPlaceHolderRID, unitCostCol, sUnitCost);
							// BEGIN TT#2089 - stodd - Total cost and total retail not calcing
                            // Begin TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
                            //if (totalCostFound)
                            //{
                            //    double tCost = hdrQty * unitCost;
                            //    string stCost = tCost.ToString("#,###,##0.00");
                            //    UpdateTotalColumnValue(aPlaceHolderRID, totalCostCol, stCost);
                            //}
                            // End TT#1498-MD
							// END TT#2089 - stodd - Total cost and total retail not calcing
						}

						//=======================================
						// Search g6 grid for Unit Cost Column
						//=======================================
						List<int> unitCostColList = new List<int>();
                        // Begin TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
                        //colFound = isColumnOnDetailGrid("Unit Cost", ref unitCostColList);
                        colFound = isColumnOnDetailGrid(_lblUnitCost, ref unitCostColList);
                        // End TT#1498-MD

						//=======================================================================
						// If column found, search through g4 grid to find Placeholder row,
						// Then update g6 with Unit Retail amount
						//=======================================================================
						if (colFound)
						{
							UpdateDetailColumnValue(aPlaceHolderRID, unitCostColList, sUnitCost);
						}

						break;
						// END TT#2051 - stodd - Rtl and Cost do not update on Assortment tab 
					}
				}
				_dtHeaders.AcceptChanges();
				spcVLevel1_DoubleClick(spcVLevel1, null);
			}
			catch
			{
				throw;
			}
		}
		// END TT#1996 - stodd - Rtl and Cost do not update on Assortment tab dynamically

		// BEGIN TT#2051 - stodd - Rtl and Cost do not update on Assortment tab 
		/// <summary>
		///  Updates a value for a g5 column (total grid)
		/// </summary>
		/// <param name="aPlaceHolderRID"></param>
		/// <param name="aColumn"></param>
		/// <param name="aColValue"></param>
		private void UpdateTotalColumnValue(int aPlaceHolderRID, int aColumn, string aColValue)
		{
			try
			{
				PagingGridTag gridTag = (PagingGridTag)g4.Tag;
				for (int gRow = 0; gRow < g4.Rows.Count; gRow++)
				{
					RowHeaderTag rowTag = (RowHeaderTag)gridTag.RowHeaderGrid.Rows[gRow].UserData;
					CubeWaferCoordinate phCoord = (CubeWaferCoordinate)((RowHeaderTag)rowTag).CubeWaferCoorList.FindCoordinateType(eProfileType.PlaceholderHeader);
					//BEGIN TT#441-MD - stodd - unit cost /retail cost for placeholder updating header on matrix
					CubeWaferCoordinate hdrCoord = (CubeWaferCoordinate)((RowHeaderTag)rowTag).CubeWaferCoorList.FindCoordinateType(eProfileType.AllocationHeader);
					//END TT#441-MD - stodd - unit cost /retail cost for placeholder updating header on matrix
					if (phCoord != null && phCoord.Key == aPlaceHolderRID)
					{
						//==========================================================
						// Note: grid change here from g4 to g5 is intentional
						//==========================================================
						if (g5.GetDataDisplay(gRow, aColumn) == "" || g5.GetDataDisplay(gRow, aColumn) == " ")
						{
							// skip
						}
						else
						{
							//BEGIN TT#441-MD - stodd - unit cost /retail cost for placeholder updating header on matrix
							if (hdrCoord == null || hdrCoord.Key == int.MaxValue)
							{
								g5[gRow, aColumn] = aColValue;
								_ignoreDisplayOnly = true;
								//SetCellForReinit(g5, gRow, unitRetailCol);	// not implemented
								this.GridAfterEdit(g5, new RowColEventArgs(gRow, aColumn));
								_ignoreDisplayOnly = false;
							}
							//END TT#441-MD - stodd - unit cost /retail cost for placeholder updating header on matrix
						}
					}
				}
                // Begin TT#1498-MD - RMatelic - ASST - MU% not calcing on the fly for the Detail section
                RecomputePlanCubes();
                LoadCurrentPages();
                LoadSurroundingPages();
                // End TT#1498-MD
			}
			catch
			{
				throw;
			}
		}

		private string GetTotalColumnValue(int aPlaceHolderRID, int aColumn)
		{
			string colValue = string.Empty;
			try
			{
				PagingGridTag gridTag = (PagingGridTag)g4.Tag;
				for (int gRow = 0; gRow < g4.Rows.Count; gRow++)
				{
					RowHeaderTag rowTag = (RowHeaderTag)gridTag.RowHeaderGrid.Rows[gRow].UserData;
					CubeWaferCoordinate phCoord = (CubeWaferCoordinate)((RowHeaderTag)rowTag).CubeWaferCoorList.FindCoordinateType(eProfileType.PlaceholderHeader);
					if (phCoord != null && phCoord.Key == aPlaceHolderRID)
					{
						//==========================================================
						// Note: grid change here from g4 to g5 is intentional
						//==========================================================
						if (g5.GetDataDisplay(gRow, aColumn) == "" || g5.GetDataDisplay(gRow, aColumn) == " ")
						{
							// skip
						}
						else
						{
							colValue = g5[gRow, aColumn].ToString();
						}
					}
				}
				return colValue;
			}
			catch
			{
				throw;
			}
		}

		/// <summary>
		///  Updates a value for a g6 column (detail grid)
		/// </summary>
		/// <param name="aPlaceHolderRID"></param>
		/// <param name="aColumn"></param>
		/// <param name="aColValue"></param>
		private void UpdateDetailColumnValue(int aPlaceHolderRID, List<int> aColumnList, string aColValue)
		{
			try
			{
				PagingGridTag gridTag = (PagingGridTag)g4.Tag;
				for (int gRow = 0; gRow < g4.Rows.Count; gRow++)
				{
					RowHeaderTag rowTag = (RowHeaderTag)gridTag.RowHeaderGrid.Rows[gRow].UserData;
					CubeWaferCoordinate phCoord = (CubeWaferCoordinate)((RowHeaderTag)rowTag).CubeWaferCoorList.FindCoordinateType(eProfileType.PlaceholderHeader);
					//BEGIN TT#441-MD - stodd - unit cost /retail cost for placeholder updating header on matrix
					CubeWaferCoordinate hdrCoord = (CubeWaferCoordinate)((RowHeaderTag)rowTag).CubeWaferCoorList.FindCoordinateType(eProfileType.AllocationHeader);
					//END TT#441-MD - stodd - unit cost /retail cost for placeholder updating header on matrix
					if (phCoord != null && phCoord.Key == aPlaceHolderRID)
					{
						foreach (int aColumn in aColumnList)
						{
							//==========================================================
							// Note: grid change here from g4 to g6 is intentional
							//==========================================================
							if (g6.GetDataDisplay(gRow, aColumn) == "" || g6.GetDataDisplay(gRow, aColumn) == " ")
							{
								// skip
							}
							else
							{
								//BEGIN TT#441-MD - stodd - unit cost /retail cost for placeholder updating header on matrix
								if (hdrCoord == null || hdrCoord.Key == int.MaxValue)
								{
									g6[gRow, aColumn] = aColValue;
									_ignoreDisplayOnly = true;
									//SetCellForReinit(g6, gRow, unitRetailCol);	// not implemented
									this.GridAfterEdit(g6, new RowColEventArgs(gRow, aColumn));
									_ignoreDisplayOnly = false;
								}
								//END TT#441-MD - stodd - unit cost /retail cost for placeholder updating header on matrix
							}
						}
					}
				}
			}
			catch
			{
				throw;
			}
		}

		/// <summary>
		/// Used to find specific column posistions on the Total Grid (g5).
		/// </summary>
		/// <param name="colCaption"></param>
		/// <param name="aColumn"></param>
		/// <returns></returns>
		private bool isColumnOnTotalGrid(string colCaption, ref int aColumn)
		{
			bool colFound = false;
			try
			{
				for (int gCol = 0; gCol < g5.Cols.Count; gCol++)
				{
					if (g5.Cols[gCol].Caption == colCaption)
					{
						aColumn = gCol;
						colFound = true;
					}
					if (colFound)
						break;
				}
				return colFound;
			}
			catch
			{
				throw;
			}
		}

		/// <summary>
		/// Used to find specific column posistions on the Detail Grid (g6).
		/// </summary>
		/// <param name="colCaption"></param>
		/// <param name="aColumnList"></param>
		/// <returns></returns>
		private bool isColumnOnDetailGrid(string colCaption, ref List<int> aColumnList)
		{
			bool colFound = false;
			try
			{
				for (int gCol = 0; gCol < g6.Cols.Count; gCol++)
				{
					if (g6.Cols[gCol].Caption == colCaption)
					{
						aColumnList.Add(gCol);
						colFound = true;
					}
				}
				return colFound;
			}
			catch
			{
				throw;
			}
		}
		// END TT#2051 - stodd - Rtl and Cost do not update on Assortment tab 


        // Begin TT#1613 - RMatelic -Dragging a Style to the PlaceHolder Style/Sku field on the Content Tab, does not change the style
        //     and Placeholder ID on the Assortment and Characteristics tab unless you save and close the Assorment and go back in to the Assortment 
        private void UpdateAssortmentTabStyle(int aOldStyleHnRID, int aNewStyleHnRID, int aPlaceHolderRID, string aLevelText)
        {
            try
            {
                for (int i = 0; i < _dtHeaders.Rows.Count; i++)
                {
                    DataRow row = _dtHeaders.Rows[i];

                    if (aPlaceHolderRID == Convert.ToInt32(row["PLACEHOLDER_RID"], CultureInfo.CurrentUICulture) &&
                        Convert.ToInt32(row["HEADER_RID"], CultureInfo.CurrentUICulture) == int.MaxValue)
                    {
                        string oldText =  Convert.ToString(row["PLACEHOLDER"], CultureInfo.CurrentUICulture); 
                        row["PLACEHOLDER"] = aLevelText;
                        row["PLANLEVEL_RID"] = aNewStyleHnRID;
                        row["PLANLEVEL"] = aLevelText;
                        string data = string.Empty;
                        bool colFound = false;
                        for (int gRow = 0; gRow < g4.Rows.Count; gRow++)
                        {
                            for (int gCol = 0; gCol < g4.Cols.Count; gCol++)
                            {
                                if (g4.GetDataDisplay(gRow, gCol) == oldText)
                                {
                                    colFound = true;
                                    g4[gRow, gCol] = aLevelText;
                                    g4.AutoSizeCol(gCol);
                                    break;
                                }
                            }
                            if (colFound)
                            {
                                break;
                            }
                        }
                        break;
                    }
                }
                _dtHeaders.AcceptChanges();
                ResizeCol1();
                spcVLevel1_DoubleClick(spcVLevel1, null);
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAssortmentTabColor(int aPlaceHolderRID, int aStyleHnRID, int aOldColorCodeRID, int aNewColorCodeRID, string aNewDescription)
        {
            try
            {
                for (int i = 0; i < _dtHeaders.Rows.Count; i++)
                {
                    DataRow row = _dtHeaders.Rows[i];

                    int placeHolderRID = Convert.ToInt32(row["PLACEHOLDER_RID"], CultureInfo.CurrentUICulture);
                    int planLevelRID = Convert.ToInt32(row["PLANLEVEL_RID"], CultureInfo.CurrentUICulture);
                    int headerRID = Convert.ToInt32(row["HEADER_RID"], CultureInfo.CurrentUICulture);
                    int packRID = Convert.ToInt32(row["PACK_RID"], CultureInfo.CurrentUICulture);
                    int colorCodeRID = Convert.ToInt32(row["COLOR_RID"], CultureInfo.CurrentUICulture);

                    if (placeHolderRID == aPlaceHolderRID &&
                        headerRID == int.MaxValue &&
                        planLevelRID == aStyleHnRID && 
                        packRID == int.MaxValue && 
                        colorCodeRID == aOldColorCodeRID)
                    {
                        string oldDescription = Convert.ToString(row["COLOR"], CultureInfo.CurrentUICulture);
                        row["COLOR"] = aNewDescription;
                        row["COLOR_RID"] = aNewColorCodeRID;
                        string data = string.Empty;
                        bool colFound = false;
                        for (int gRow = 0; gRow < g4.Rows.Count; gRow++)
                        {
                            for (int gCol = 0; gCol < g4.Cols.Count; gCol++)
                            {
                                if (g4.GetDataDisplay(gRow, gCol) == oldDescription)
                                {
                                    colFound = true;
                                    g4[gRow, gCol] = aNewDescription;
                                    g4.AutoSizeCol(gCol);
                                    break;
                                }
                            }
                            if (colFound)
                            {
                                break;
                            }
                        }
                        break;
                    }
                }
                _dtHeaders.AcceptChanges();
                ResizeCol1();
                spcVLevel1_DoubleClick(spcVLevel1, null);
            }
            catch
            {
                throw;
            }
        }

        private void UpdateCharacteristicColorDescription(int aStyleHnRID, int aColorCodeRID, string aNewDescription)
        {
			try
			{
				// update description on Characteristic grid
				if (_dtColorNodeChars != null && _dtColorNodeChars.Rows.Count > 0)
				{
					Hashtable colorNodes = (Hashtable)_colorNodesForStyle[aStyleHnRID];
					// BEGIN TT#1809 - stodd - color browser error
					if (colorNodes != null)
					{
						if (colorNodes.ContainsKey(aColorCodeRID))
						{
							int colorHnRID = (int)colorNodes[aColorCodeRID];
							DataRow colorRow = _dtColorNodeChars.Rows.Find(colorHnRID);

							if (colorRow != null)
							{
								colorRow["Description"] = aNewDescription;
								_dtColorNodeChars.AcceptChanges();
								UltraGridBand band = this.ugCharacteristics.DisplayLayout.Bands["ColorNodeChars"];
								if (band != null)
								{
									band.Columns["Description"].PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
								}
							}
						}
					}
					// END TT#1809 - stodd - color browser error
				}
			}
			catch
			{
				throw;
			}
        }
        // End TT#1613
        #endregion
    }
}
