using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;  // TT#1185 - Verify ENQ before Update
using System.ComponentModel;
using System.Globalization;	
using System.Drawing;
using System.Data;
using System.Windows.Forms;
using System.Configuration;
using System.Diagnostics;
using System.Threading;

using Infragistics.Win;
using Infragistics.Win.UltraWinGrid;
using Infragistics.Win.UltraWinMaskedEdit;
using Infragistics.Documents.Excel;
using Infragistics.Win.UltraWinGrid.ExcelExport;

using MIDRetail.DataCommon;
using MIDRetail.Data;
using MIDRetail.Common;
using MIDRetail.Business;
using MIDRetail.Business.Allocation;
using MIDRetail.Windows.Controls;

namespace MIDRetail.Windows
{
	public partial class AllocationWorkspaceExplorer : MIDRetail.Windows.ExplorerBase
	{
        #region Variable Declarations

        private BindingSource _bindSourceHeader;

        private DataSet _dsCopySizes;
		private DataSet _dsMultiSizes;	
		private DataSet _dsDetails;
        private DataSet _dsDetailsSaved;
        private DataTable _anchorNodes;
        private DataTable _assortments;
        private DataTable _assortmentsSaved;
		private DataTable _dtHeader;	
		private DataTable _dtDetailHeader;
		private DataTable _dtBulkColor;
        private DataTable _dtPack;
		private DataTable _dtPackColor;
        private DataTable _dtView;
		private DataTable _multiHeaders;
        private DataTable _multiHeadersSaved;
        private DataTable _placeHolders;
        private DataTable _placeHoldersSaved;
        private DataTable dtActions = null; //TT#1313-MD -jsobek -Header Filters -performance

        private AllocationProfileList _allocProfileList;
        private AllocationHeaderProfileList _headerList;
        //private AllocationWorkspaceFilterProfile _allocWorkFilterProfile;  //TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS
        //private ApplicationSessionTransaction _trans;  // TT#1185 - Verify ENQ before Update
        private ColorBrowser _frmColorBrowser;
        //private ComponentMatch _frmComponentMatch;
        private DialogResult _diagResult;
		private frmUltraGridSearchReplace _frmUltraGridSearchReplace;

        //private AllocationWorkspaceFilterData _allocWorkFilterData;  //TT#1313-MD -jsobek -Header Filters
        private GetMethods _getMethods;
        private GridViewData _gridViewData;
        private HeaderCharGroupProfileList _headerCharGroupProfileList;
        //private HeaderEnqueue _headerEnqueue = null; // TT#1185 - Verify ENQ before Update (part 2)
        private HierarchyLevelProfile _hlpStyle;
        private HierarchyLevelProfile _hlpProduct;
        private HierarchyMaintenance _hierMaint;
        private HierarchyNodeProfile _nodeDataHashLastValue;
		private HierarchyProfile _mainHp;
        private PlaceholderComponentLinks _phCompLinks;
                
        private KeyEventArgs _gridKeyEvent = null;
        private MemoryStream _layoutStream; 
	    private SessionAddressBlock _SAB;
		private SizeGroupProfile _sizeGroupHashLastValue;
        private UserGridView _userGridView;
        private FilterData _filterData; //TT#1313-MD -jsobek -Header Filters
        private int _headerFilterRID = Include.NoRID; //TT#1313-MD -jsobek -Header Filters

		private FunctionSecurityProfile _allocationNonInterfacedHeadersSecurity;
        private FunctionSecurityProfile _allocationInterfacedHeadersSecurity;
        private FunctionSecurityProfile _allocationInterfacedComponentSecurity; // TT#254 - RMatelic - Add Header Component security to interfaced headers
		private FunctionSecurityProfile _allocationReviewStyleSecurity;
		private FunctionSecurityProfile _allocationReviewSummarySecurity;
		private FunctionSecurityProfile _allocationReviewSizeSecurity;
		private FunctionSecurityProfile _allocationReviewGroupAllocationSecurity;	// TT#488-MD - STodd - Group Allocation - 
        private FunctionSecurityProfile _allocationViewsSecurity;
        private FunctionSecurityProfile _assortmentSecurity;
		private FunctionSecurityProfile _groupAllocationSecurity;

        private UltraGrid _rClickGrid = null;
		private UltraGridColumn _gridCol;
		private UltraGridBand _gridBand;
      
        private UltraGridRow _colorSelectRow = null;
        private UltraGridRow _firstNewRow = null;
        private UltraGridRow _multiHdrRow;
        private UltraGridRow _rClickRow = null;
		
		private UltraGridCell _invalidCell = null;
       
        private ValueList _assortmentValueList;
        private ValueList _headerIntransitValueList;
        private ValueList _headerShipStatusValueList;
        private ValueList _headerStatusValueList;
        private ValueList _headerTypeValueList;
        private ValueList _multiHeaderValueList;
        private ValueList _packTypeValueList;
        private ValueList _placeHolderValueList;
        private ValueList _sizeGroupValueList;
		private ValueList _adjustVSWValueList;
        
        private ArrayList _deletedMultiBands = new ArrayList(); 
        private ArrayList _hdrsInGroups = new ArrayList();
        private ArrayList _headerEditColumns;           // TT#863 - RMatelic - Allocation Workspace-cannot add header, fields appear to be locked from entry
        private ArrayList _headerProfileArrayList;
        private ArrayList _headersInGroupBy;
		private ArrayList _masterKeyList;
        // Begin TT#3311 - JSmith - Create a WUB header when select SAVE receive a null reference exception
        //private ArrayList _removeAndReselectHeaders;   // TT#705 - RMatelic - WUB when Cancel a WUB header the total quantity goes to 0 but the components do not
        private ArrayList _removeAndReselectHeaders = new ArrayList();   // TT#705 - RMatelic - WUB when Cancel a WUB header the total quantity goes to 0 but the components do not
        // End TT#3311 - JSmith - Create a WUB header when select SAVE receive a null reference exception
        private ArrayList _removedAsrtHeaders = new ArrayList();
        private ArrayList _selectedAsrtList = new ArrayList();         // TT#2 - RMatelic - Assortment Planning        
        private ArrayList _selectedComponentList;
        private ArrayList _selectedHeaderKeyList;
        private ArrayList _selectedAssortmentKeyList; // TT#488 - MD - Jellis - Group Allocation
        private ArrayList _selectedRowsSequence = new ArrayList();   // MID TRack #6264 - Headers out of priority sequence
        private ArrayList _userRIDList; 
        private ArrayList _asrtProfileArrayList = new ArrayList();   //TT#403 - MD - DOConnell - Assortment ID is not displaying correctly in the Allocation Workspace
     
        private Hashtable _addedColorSizeHash = new Hashtable();
        private Hashtable _assortmentGroups = new Hashtable();
        private Hashtable _charByGroupAndID = new Hashtable();
        private Hashtable _charValueListsHash;
        private Hashtable _colorsForStyle = new Hashtable();
        private Hashtable _deletedAssortmentStyles = new Hashtable();
        private Hashtable _deletedHeaderRows = new Hashtable();
        private Hashtable _deletedPlaceholderStyles = new Hashtable();
        private Hashtable _headersAddedToMulti;
        private Hashtable _headersRemovedFromMulti;
        //private Hashtable _methodHash = new Hashtable();	//TT#1313-MD -jsobek -Header Filters -unused hash table
		private Hashtable _multiHeaderColor = new Hashtable();
        private Hashtable _multiHeaderColorIds = new Hashtable();   // MID Track #6127, (#6164 - change from ArrayList to Hashtable)
	    private Hashtable _multiHeaderGroups = new Hashtable();
        //private Hashtable _multiGroupsIncludeAfterDateFilter = new Hashtable();      // MID Track #6239 - Multi should not be split up //TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS 
        //private Hashtable _multiGroupsIncludeAfterStyleFilter = new Hashtable();     // MID Track #6239 - Multi should not be split up //TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS 
        private Hashtable _nodeDataHash = new Hashtable();
        private Hashtable _sizeGroupHash = new Hashtable();
        private Hashtable _workflowNameHash = new Hashtable();
        private CustomWindowsRoutines _customWindowsRoutines;  // MID Track #6394 - update custom charactersitic

        private bool _addingSizes = false;
        private bool _bindingView;
		private bool _canAddHeader;
        private bool _canAddInterfacedComponent;        // TT#254 - RMatelic - Add Header Component security to interfaced headers
        private bool _cancelSelectEvent = false;        // MID Track #6407
      	private bool _canDeleteHeader;
        private bool _canDeleteInterfacedComponent;     // TT#254 - RMatelic - Add Header Component security to interfaced headers
        private bool _changesPending = false;
        private bool _controlKeyPressedUpperGrid = false;  // TT#1107 - RMatelic Once headers are selected, cannot apply a second rule without applying to all 3 headers
        private bool _creatingAssortment = false;
        private bool _creatingMulti = false;
        private bool _deleteKeyPressed = false;
        private bool _deleteKeyPressedUpperGrid = false;
        private bool _detailsShown;
        private bool _excludedHeadersRemoved = false;               // MID Track #6239 - Multi should not be split up 
        //private bool _expandAll = false;               // Begin TT#2682 - RMatelic - Show Details of a header  
        private bool _expandAll = true;                  // End TT#2682
        private bool _fromCellButton = false;
        private bool _fromFilterWindow = false;
        private bool _filterChangedAfterView = false;  // TT#1712-MD - JSmith - Cannot select Headers from Allocation Workspace Explorer
        private bool _fromHeaderGrid = false;
        private bool _fromLoadEvent;
        private bool _fromRightClick = false;
        private bool _fromSaveAs = false;
        private bool _groupByReload = false;
        private bool _headerAdded = false;
        private bool _inEditMode = false;
        private bool _leftMouseDown = false;       // TT#1106 - RMatelic - Unable to drag highlight headers in workspace
        private bool _multiHdrRowFound = false;
        private bool _phColorAutoAdd = false;
        private bool _processingAction = false;     // TT#705 - RMatelic - WUB when Cancel a WUB header the total quantity goes to 0 but the components do not
        private bool _processComponent = false;
        private bool _rebuildSizes = false;
        private bool _removingAssortment = false;
        private bool _removingMulti = false;
        private bool _replacingSizes = false;
        private bool _rowDeleted = false;
        private bool _shiftPlusArrowKeyPressed = false;  // TT#1237 - RMatelic - Selecting headers using Shift + Arrow Keys
        private bool _sizesAutoAdded = false;
        private bool _skipAnchorEdit = false;
        private bool _skipBeforeCellUpdate = false;
        private bool _skipEdit = false;
        private bool _skipHeaderEdit = false;
        private bool _skipInitialize = false;
        private bool _skipProductEdit = false;
        private bool _skipQtyUpdate = false;  // TT#304 - RMatelic - Multi Header - made the multiple 10 received message "multiple cannot exceed units to allocate
        private bool _skipRowUpdate = false;
        private bool _skipStyleEdit = false;
        private bool _skipSelectChange = false;  // MID Track #6407
        private bool _unGrouping = false;        // MID Track #6407
        private bool _unGrouping2 = false;       // MID Track #6407
        private bool _viewSaved = false;         // MID Track #6407
        private bool _checkForExportSelected = false; // TT#1135 - AGallagher - Export headers from allocation workspace
        private bool _refreshingGrid = false; // Begin TT#1705 - JSmith - Reset Header with Piggybacking
        private bool _inClearDetails = false;  // TT#1434 - JSmith - Slow Header Selection + Memory Issue?
		// Begin TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
        private bool _clearSelectedList = true;
		// End TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
      
        private bool _allowHeaderDelete = true;  //TT#547 - MD - Should not be able to delete multi header - RBeck
        private string _dupSizeNameSeparator;    // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
		private string _errors;
        private string _lblAssortment;
        private string _lblColumnChooser;
        private string _lblDeleteRow;
        private string _lblDescription;         // TT#1324 - RMatelic - When adding a new Style, the description does not update.
        private string _lblHierarchyNode;
        private string _lblHeaderNotes;
        private string _lblPhStyle;
        private string _lblPlaceholder;
        private string _lblSelectAction;
		//private string _lblSelected;
        private string _lblSummary;
		//private string _lblTotal;
		private string _lblQuantity;
        private string _lblUser;
		private string _noSizeDimensionLbl;
        private string _thisTitle;

        private int _clientThreadID;         // TT#1185 - JEllis - Verify ENQ before Update (part 2)
        private int _clientUserRID;          // TT#1185 - JEllis - Verify ENQ before Update (part 2)
        private int _lastAsrtSortSeq;
        private int _lastMultiSortSeq;
        private int _lastSelectedViewRID;
     	private int _maxBandDepth = 6;
        private int _nodeDataHashLastKey = 0;
        private int _nonCharColCount = 0;
        private int _showP2Height;
        private int _sizeGroupHashLastKey = 0;
        private int? maxCharSize = null; //TT#1313-MD -jsobek -Header Filters -performance
        // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
        private int _ugHeadersBeginUpdateCnt = 0;
        private int _ugHeadersSuspendRowSynchronizationCnt = 0;
        private int _ugDetailsBeginUpdateCnt = 0;
        private int _ugDetailsSuspendRowSynchronizationCnt = 0;
        // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls

        // Begin TT#1038 - JSmith - Out of memory when right click and filter
        private object _sender;
        private Infragistics.Win.UltraWinGrid.AfterSelectChangeEventArgs _afterSelectChangeEventArgs;
        // End TT#1038 - JSmith - Out of memory when right click and filter
        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
        private Type _ultraGridRowSelectedType = null;
        // End TT#1434
		private bool _continueProcess = true;	// TT#488-MD - STodd - Group Allocation - 

		#endregion
	
		#region Constructor 
		public AllocationWorkspaceExplorer(SessionAddressBlock aSAB, ExplorerAddressBlock aEAB, Form aMainMDIForm)
			: base(aSAB, aEAB, aMainMDIForm)
        {
			aEAB.AllocationWorkspaceExplorer = this;

            _customWindowsRoutines = new CustomWindowsRoutines(aSAB);  // MID Track #6394 - update custom charactersitic

			this.AllowDrop = true;
            _SAB = aSAB;
            _mainHp = _SAB.HierarchyServerSession.GetMainHierarchyData();
            //_trans = _SAB.ApplicationServerSession.CreateTransaction(); // Verify ENQ before Update
            _headerList = new AllocationHeaderProfileList(eProfileType.AllocationHeader);

            _getMethods = new GetMethods(_SAB);
            _gridViewData = new GridViewData();
            _userGridView = new UserGridView();
            _filterData = new FilterData(); //TT#1313-MD -jsobek -Header Filters
            //_allocWorkFilterData = new AllocationWorkspaceFilterData(); //TT#1313-MD -jsobek -Header Filters

            // get hierarchy profiles for style and product (parent of style)
            _hlpStyle = null;
            _hlpProduct = null;
            for (int level = 1; level <= _mainHp.HierarchyLevels.Count; level++)
            {
                _hlpProduct = _hlpStyle;
                _hlpStyle = (HierarchyLevelProfile)_mainHp.HierarchyLevels[level];
                if (_hlpStyle.LevelType == eHierarchyLevelType.Style)
                {
                    break;
                }
            }
            if (_hlpStyle == null)
            {
                _hlpStyle = new HierarchyLevelProfile(0);
                _hlpStyle.LevelID = "Style";
            }
            if (_hlpProduct == null)
            {
                _hlpProduct = new HierarchyLevelProfile(1);
                _hlpProduct.LevelID = "Product";
            }

            // This call is required by the Windows Form Designer.
            InitializeComponent();
           
            SetText();

            _clientThreadID = _SAB.ClientServerSession.ThreadID;
            _clientUserRID = _SAB.ClientServerSession.UserRID;
        }
		#endregion

		/// <summary>
		/// Virtual method that is called to initialize the ExplorerBase TreeView
		/// </summary>

		override protected void InitializeTreeView()
		{
			try
			{
				//TODO: Implement Base TreeView
			}
			catch (Exception exc)
			{
				string message = exc.ToString();
				throw;
			}
		}

		/// <summary>
		/// Virtual method that is called to perform Form Load tasks
		/// </summary>

		override protected void ExplorerLoad()
		{
			try
			{
				//TODO: Implement Base TreeView
			}
			catch (Exception exc)
			{
				string message = exc.ToString();
				throw;
			}
		}

		/// <summary>
		/// Virtual method that is called to build the ExplorerBase TreeView
		/// </summary>

		override protected void BuildTreeView()
		{
			try
			{
				//TODO: Implement Base TreeView
			}
			catch (Exception exc)
			{
				string message = exc.ToString();
				throw;
			}
		}

        ///// <summary>
        ///// Virtual method that is called after a label has been updated
        ///// </summary>
        ///// <returns>
        ///// A boolean indicating if post-processing was successful
        ///// </returns>

        //override protected bool AfterLabelUpdate(MIDTreeNode aNode, string aNewName)
        //{
        //    try
        //    {
        //        //TODO: Implement Base TreeView
        //        return false;
        //    }
        //    catch (Exception exc)
        //    {
        //        string message = exc.ToString();
        //        throw;
        //    }
        //}

        ///// <summary>
        ///// Virtual method used to create a shortcut in the Favorites folder
        ///// </summary>
        ///// <param name="aFromNode">
        ///// The MIDTreeNode being copied
        ///// </param>
        ///// <param name="aToNode">
        ///// The MIDTreeNode where new node is being copied to
        ///// </param>

        //override protected void CreateFavoriteShortcut(MIDTreeNode aFromNode, MIDTreeNode aToNode)
        //{
        //    try
        //    {
        //        //TODO: Implement Base TreeView
        //    }
        //    catch (Exception exc)
        //    {
        //        string message = exc.ToString();
        //        throw;
        //    }
        //}

        ///// <summary>
        ///// Virtual method used to move a MIDTreeNode from one place to another
        ///// </summary>
        ///// <param name="aFromNode">
        ///// The MIDTreeNode being moved
        ///// </param>
        ///// <param name="aToNode">
        ///// The MIDTreeNode where new node is being move to
        ///// </param>

        //override protected void MoveNode(MIDTreeNode aFromNode, MIDTreeNode aToNode)
        //{
        //    try
        //    {
        //        //TODO: Implement Base TreeView
        //    }
        //    catch (Exception exc)
        //    {
        //        string message = exc.ToString();
        //        throw;
        //    }
        //}

        ///// <summary>
        ///// Virtual method used to copy a MIDTreeNode from one place to another
        ///// </summary>
        ///// <param name="aFromNode">
        ///// The MIDTreeNode being copied
        ///// </param>
        ///// <param name="aToNode">
        ///// The MIDTreeNode where new node is being copied to
        ///// </param>
        ///// <param name="aFindUniqueName">
        ///// A boolean indicating if the procedure should insure create a unique name in case of a duplicate
        ///// </param>

        //override protected void CopyNode(MIDTreeNode aFromNode, MIDTreeNode aToNode, bool aFindUniqueName)
        //{
        //    try
        //    {
        //        //TODO: Implement Base TreeView
        //    }
        //    catch (Exception exc)
        //    {
        //        string message = exc.ToString();
        //        throw;
        //    }
        //}

        ///// <summary>
        ///// Virtual method used to delete a MIDTreeNode
        ///// </summary>
        ///// <param name="aNode">
        ///// The MIDTreeNode being deleted
        ///// </param>

        //override protected void DeleteNode(MIDTreeNode aNode)
        //{
        //    try
        //    {
        //        //TODO: Implement Base TreeView
        //    }
        //    catch (Exception exc)
        //    {
        //        string message = exc.ToString();
        //        throw;
        //    }
        //}

        ///// <summary>
        ///// Virtual method used to edit a MIDTreeNode
        ///// </summary>
        ///// <param name="aNode">
        ///// The MIDTreeNode being edited
        ///// </param>

        //override protected void EditNode(MIDTreeNode aNode)
        //{
        //    try
        //    {
        //        //TODO: Implement Base TreeView
        //    }
        //    catch (Exception exc)
        //    {
        //        string message = exc.ToString();
        //        throw;
        //    }
        //}

		#region Exit routine
        private void CheckSaveLayout()
        {
            if (FormLoaded)
            {
                SaveLayout();
                //if (_inEditMode)       // BEGIN MID Track #5501 - add 'Save Changes?' message
                //{
                //    CancelEdit();
                //}                      // END MID Track #5501
                // begin TT#1185 Verify ENQ before Update
                //if (_trans != null)
                //{
                //    _trans.Dispose();
                //}
                // end TT#1185 - Verify ENQ before Update
            }
        }
        // BEGIN MID Track #5501 - add 'Save Changes?' message
        public bool OkToClose()
        {
            bool okToClose = true;
            try
            {
                if (_inEditMode)
                {
                    if (_changesPending)
                    {
                        if (MessageBox.Show(SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SavePendingChanges), _thisTitle,
                                        MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes)
                        {
                            if (AllDataValid())
                            {
                                ISave();
                            }
                            else
                            {
                                okToClose = false;
                            }
                        }
                        else
                        {
                            CancelEdit();
                        }
                    }
                    else
                    {
                        CancelEdit();
                    }
                }
            }
            catch
            {
                throw;
            }
            return okToClose;
        }
        // END MID Track #5501
        #endregion

        #region Load and Format
        private void AllocationWorkspaceExplorer_Load(object sender, System.EventArgs e)
		{
			try 
			{
                // Begin TT#2 - JSmith - Assortment Security
                if (_SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.ExplorersAllocationWorkspace).AccessDenied)
                {
                    return;
                }
                // End TT#2


                // check for saved toolbar manager layout
                InfragisticsLayoutData layoutData = new InfragisticsLayoutData();
                InfragisticsLayout toolbarManagerLayout = layoutData.InfragisticsLayout_Read(SAB.ClientServerSession.UserRID, eLayoutID.allocationWorkspaceToolbars);
                if (toolbarManagerLayout.LayoutLength > 0)
                {
                        //toolbarManagerLayout.LayoutStream.Position = 0;
                      
                        this.headerToolbarsManager.LoadFromBinary(toolbarManagerLayout.LayoutStream);
                        ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"]).Text = string.Empty;
                        ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["headerSelectedTextBox"]).Text = string.Empty;
                        ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["headerTotalTextBox"]).Text = string.Empty;
                        ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["quantityAllocateSelectedTextBox"]).Text = string.Empty;
                        ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["quantityAllocateTotalTextBox"]).Text = string.Empty;
                }
				// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                //Infragistics.Win.UltraWinToolbars.ComboBoxTool cbo = (Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["actionComboBox"];
                //if (cbo.ValueList.ValueListItems.Count > 0)
                //{
                //    cbo.SelectedIndex = 0;
                //}
				// Ed TT#4071 - stodd - Matrix does not allow search for attribute - 

                _allocationNonInterfacedHeadersSecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AllocationHeadersNonInterfaced);
                // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
                //_allocationInterfacedHeadersSecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AllocationHeadersInterfaced);
                _allocationInterfacedHeadersSecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AllocationHeadersInterfacedHeader);
                _allocationInterfacedComponentSecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AllocationHeadersInterfacedComponent); 
                // End TT#254 
                _allocationReviewStyleSecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AllocationReviewStyle);
				_allocationReviewSummarySecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AllocationReviewSummary);
				_allocationReviewSizeSecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AllocationReviewSize);
				_allocationReviewGroupAllocationSecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.GroupAllocationReview);	// TT#488-MD - STodd - Group Allocation - 
                _allocationViewsSecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AllocationViews);
                _assortmentSecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.Assortment);
                _groupAllocationSecurity = _SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.GroupAllocation);	// TT#1007 - md - stodd - change group allocation security - 

            //Begin TT#547 - MD - Should not be able to delete multi header - RBeck  
                if (!_allocationNonInterfacedHeadersSecurity.AllowDelete &&
                    !_allocationInterfacedHeadersSecurity.AllowDelete)
                {
                    _allowHeaderDelete = false;
                }
            //Ens  TT#547 - MD - Should not be able to delete multi header - RBeck
			   
                if (_allocationNonInterfacedHeadersSecurity.AccessDenied &&
                    _allocationInterfacedHeadersSecurity.AccessDenied)
				{
					// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
					//gbxHeaderCount.Visible = false;
					//lblHeaderCount.Visible = false;
					//lblHeaderTotal.Visible = false;
					//gbxTotalQty.Visible = false;
					//lblSelQty.Visible = false;
					//lblTotQty.Visible = false;
				
					//btnProcess.Visible = false;
				
					//cboActionList.Visible = false;
				    EAB.Explorer.RemoveMenuOption(Include.btRestoreLayout); // Workspace Usability Enhancement
                    //cboView.Visible = false;
					this.headerToolbarsManager.Toolbars["quantityAllocateToolbar"].Visible = false;
					this.headerToolbarsManager.Toolbars["headerToolbar"].Visible = false;
					this.headerToolbarsManager.Toolbars["Action Toolbar"].Visible = false;
					this.headerToolbarsManager.Toolbars["View Toolbar"].Visible = false;                    
					// END TT#767-MD - Stodd - remove old controls from allocation workspace
				}
				else
				{
                    Cursor.Current = Cursors.WaitCursor;

                    _skipInitialize = false; //TT#214 - MD - DOConnell - drag/drop Reciept Header to assortment and Assortment ID is incorrect

					// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                    _fromLoadEvent = true;
					//gbxHeaderCount.Visible = true;
					//lblHeaderCount.Visible = true;
					//lblHeaderTotal.Visible = true;
					//gbxTotalQty.Visible = true;
					//lblSelQty.Visible = true;
					//lblTotQty.Visible = true;
					
                    //BEGIN TT#6-MD-VStuart - Single Store Select
                    //Begin TT#316 - MD - DOConnell - Replace all Windows Combobox controls with new enhanced control
                    //this.cboView.SelectionChangeCommitted += new System.EventHandler(this.cboView_SelectionChangeCommitted);
                    //End TT#316 - MD - DOConnell - Replace all Windows Combobox controls with new enhanced control
					//btnProcess.Visible = true;
					//cboActionList.Visible = true;
					EAB.Explorer.AddMenuOption(Include.btRestoreLayout);    // Workspace Usability Enhancement
                    //cboView.Visible = true;
                    //END TT#6-MD-VStuart - Single Store Select
					this.headerToolbarsManager.Toolbars["quantityAllocateToolbar"].Visible = true;
					this.headerToolbarsManager.Toolbars["headerToolbar"].Visible = true;
					this.headerToolbarsManager.Toolbars["Action Toolbar"].Visible = true;
					this.headerToolbarsManager.Toolbars["View Toolbar"].Visible = true;
					// END TT#767-MD - Stodd - remove old controls from allocation workspace

                    //Begin TT#1313-MD -jsobek -Header Filters -performance
                    int viewRID = _userGridView.UserGridView_Read(_SAB.ClientServerSession.UserRID, eLayoutID.allocationWorkspaceGrid);
                    //if (viewRID != Include.NoRID && !_fromFilterWindow)
                    //{
                    //    if (_gridViewData.GridViewFilterExists(viewRID)) // apply View filter to User Workspace FIlter 
                    //    {
                    //        ApplyViewToUserFilter(viewRID, _SAB.ClientServerSession.UserRID);
                    //    }
                    //}                   
                    bool useViewWorkspaceFilter = false;
                    bool useFilterSorting = false;
                    // Begin TT#1712-MD - JSmith - Cannot select Headers from Allocation Workspace Explorer
                    //if (viewRID != Include.NoRID && !_fromFilterWindow)
                    if (viewRID != Include.NoRID && !(_fromFilterWindow || _filterChangedAfterView))
                    // End TT#1712-MD - JSmith - Cannot select Headers from Allocation Workspace Explorer
                    {
                        
                        int workspaceFilterRID = _gridViewData.GridViewReadWorkspaceFilterRID(viewRID, ref useFilterSorting);
                        if (workspaceFilterRID != Include.NoRID)
                        {
                            useViewWorkspaceFilter = true;
                            this._headerFilterRID = workspaceFilterRID;
                        }
                    }

                    if (useViewWorkspaceFilter == false) // use the current user workspace filter
                    {
                        this._headerFilterRID = _filterData.WorkspaceCurrentFilter_Read(_SAB.ClientServerSession.UserRID, eWorkspaceType.AllocationWorkspace);
                    }
                    LoadHeadersOnGrid();
					
                    ForceToolbarContainerControls();	// TT#1507-MD - stodd - null reference accessing toolbar control within a control container
                    
                    BindActionCombo();
                    BindViewCombo();
                    BindFilterComboBox();
                    SetUserView(viewRID, useFilterSorting);
                    SetViewComboEnabled();
                    //End TT#1313-MD -jsobek -Header Filters -performance
                   
                    if (!_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled) 
					{
						this.cmsAddBulkSize.Visible = false;
						this.cmsAddPackSize.Visible = false;
                        this.cmsReviewSize.Visible = false;
					}

                    if (_allocationNonInterfacedHeadersSecurity.IsReadOnly &&
                        _allocationInterfacedHeadersSecurity.IsReadOnly)
					{
						SetControlReadOnly(this, true);
					}
					
					
					// Assign a CreationFilter to the grid. 
					// The CreationFilter will trap the ColumnChooserButtonUIElement in the grid
					// and set the tooltip information. 
					this.ugHeaders.CreationFilter = new ToolTipItemCreationFilter();
					this.ugDetails.CreationFilter = new ToolTipItemCreationFilter();
				
                    _showP2Height = 600;
                    // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
                    //Begin TT#2019 - JSmith - received Systme Null Reference when clicking on Edit button in Show Detail section of Allocation Workspace
                    //btnEditSave.Enabled = false;
                    //End TT#2019

                    //this.btnCancel.Enabled = false;     // Usability Enhancement
                    this.btnExpandCollapse.Visible = false;
                    this.btnEditSave.Visible = false;               // Remove old buttons and replace with toolbar items
                    this.btnCancel.Visible = false;
                    this.btnHideDetails.Visible = false;
                   
                    ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnEditSave"]).SharedProps.Enabled = false;
                    ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnCancel"]).SharedProps.Enabled = false;
                    // Begin TT#1159-MD - RMatelic -Hide Details is not active until Edit/Cancel with new Details Controls
                    //((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnHideDetails"]).SharedProps.Enabled = false;
                    // End TT#1159-MD
                    // End TT#1126-MD  

                    if (_detailsShown)
                    {
                        ShowDetails();
                    }
                    else
                    {
                        HideDetails();
                    }

                    //cmsAutoSelectGroup.Checked = true;  // MID Track 6180 Auto Select Group default should be false
                    cmsAutoSelectGroup.Checked = false;   // MID Track 6180 Auto Select Group default should be false
					
					//Begin TT#1313-MD -jsobek -Header Filters -performance
                    //if (ugHeaders.Rows.Count > 0)
                    //{
                    //    ugHeaders.ActiveRow = ugHeaders.Rows[0];
                    //}
					//End TT#1313-MD -jsobek -Header Filters -performance

                    // Begin TT#1007-MD - Stodd - Group Allocation security
                    CheckSecurityFromGroupAllocation();
                    // END TT#1007-MD - Stodd - Group Allocation security

					// BEGIN TT#724-MD - Stodd - unhide Group Allocation
					// BEGIN TT#488-MD - Stodd - Group Allocation 
					// Hide these in 5.3 base
					//Infragistics.Win.UltraWinToolbars.TextBoxTool tbt = (Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"];
					//tbt.SharedProps.Visible = false;
					//Infragistics.Win.UltraWinToolbars.ButtonTool bt = (Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["groupAllocationCreate"];
					//bt.SharedProps.Visible = false;
					// END TT#488-MD - Stodd - Group Allocation 
					// END TT#724-MD - Stodd - unhide Group Allocation

                    _fromLoadEvent = false; 
				}
                // Begin TT#4174 - stodd - Allocation Workspace Tool Bars if you double click on the word the tool bar moves to the Allocation Workspace
                this.headerToolbarsManager.ToolbarSettings.AllowFloating =  DefaultableBoolean.False;
                this.detailToolbarsManager.ToolbarSettings.AllowFloating = DefaultableBoolean.False;
                // End TT#4174 - stodd - Allocation Workspace Tool Bars if you double click on the word the tool bar moves to the Allocation Workspace
			}
			catch (Exception ex) 
			{			
				HandleException(ex);
			}
			finally
			{   
				Cursor.Current = Cursors.Default;
			}

			// Format for XP, if applicable
            if (Environment.OSVersion.Version.Major > 4 && Environment.OSVersion.Version.Minor > 0 &&
                System.IO.File.Exists(Application.ExecutablePath + ".manifest"))
            {
                FormatForXP(this);
            }
		}

		// Begin TT#1507-MD - stodd - null reference accessing toolbar control within a control container
        /// <summary>
        /// Tries to prevent the layout corruption where the controls do not get loaded into the control containers.
        /// </summary>
        private void ForceToolbarContainerControls()
        {
            GetViewComboBoxControl();
            GetActionComboBoxControl();
            GetFilterComboBoxControl();

            //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
            //if (cct.Control == null)
            //{
            //    cct.Control = midComboBoxView;
            //}
            //cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerAction"];
            //if (cct.Control == null)
            //{
            //    cct.Control = midComboBoxAction;
            //}
            //cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerFilter"];
            //if (cct.Control == null)
            //{
            //    cct.Control = midComboBoxFilter;
            //}
        }
		// End TT#1507-MD - stodd - null reference accessing toolbar control within a control container

        private MIDComboBoxEnh.MyComboBox GetViewComboBoxControl()
        {
            Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
            if (cct.Control == null)
            {
                cct.Control = midComboBoxView;
            }
            return (MIDComboBoxEnh.MyComboBox)cct.Control;
        }

        private MIDComboBoxEnh.MyComboBox GetActionComboBoxControl()
        {
            Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerAction"];
            if (cct.Control == null)
            {
                cct.Control = midComboBoxAction;
            }
            return (MIDComboBoxEnh.MyComboBox)cct.Control;
        }

        private MIDComboBoxEnh.MyComboBox GetFilterComboBoxControl()
        {
            Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerFilter"];
            if (cct.Control == null)
            {
                cct.Control = midComboBoxFilter;
            }
            return (MIDComboBoxEnh.MyComboBox)cct.Control;
        }

        //BETGIN TT#3978 - DOConnell - Allocation Workspace does not open sized/spaced correctly.
        public void Adjust()
        {
            int height = splitContainer.Height;
            int width = splitContainer.Width;
            this.splitContainer.Size = new System.Drawing.Size(width, height + 1);
            this.splitContainer.Size = new System.Drawing.Size(width, height);
        }
        //END TT#3978 - DOConnell - Allocation Workspace does not open sized/spaced correctly.

        //Begin TT#1313-MD -jsobek -Header Filters -performance
        private void LoadHeadersOnGrid()
        {
            try
            {
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
            
                if (_allocProfileList != null)
                {
                    _allocProfileList.Clear();
                    _allocProfileList = null;
                }
                if (_headerProfileArrayList != null)
                {
                    _headerProfileArrayList.Clear();
                    _headerProfileArrayList = null;
                }
                if (_headerCharGroupProfileList != null)
                {
                    _headerCharGroupProfileList.Clear();
                    _headerCharGroupProfileList = null;
                }
                // End TT#1434

              

                _allocProfileList = new AllocationProfileList(eProfileType.Allocation);

          

                FilterHeaderOptions headerFilterOptions = new FilterHeaderOptions();
                headerFilterOptions.USE_WORKSPACE_FIELDS = true;
                headerFilterOptions.filterType = filterTypes.HeaderFilter;
                _headerProfileArrayList = _SAB.HeaderServerSession.GetHeadersForWorkspace(this._headerFilterRID, headerFilterOptions);
                //End TT#1313-MD -jsobek -Header Filters

                //BEGIN TT#403 - MD - DOConnell - Assortment ID is not displaying correctly in the Allocation Workspace
                // the previous statement cleared out the Assortment headers in the HeaderServerSession so reget them
                //if (_SAB.ClientServerSession.GlobalOptions.AppConfig.AssortmentInstalled)
                //{
                //    //Begin  TT#403 - MD - DOConnell - Assortment ID is not displaying correctly in the Allocation Workspace
                //    // _SAB.HeaderServerSession.GetAssortmentHeadersForUser(_SAB.ClientServerSession.UserRID);
                //    _asrtProfileArrayList = _SAB.HeaderServerSession.GetAssortmentHeadersForUser(_SAB.ClientServerSession.UserRID);

                //    for (int i = 0; i < _asrtProfileArrayList.Count; i++)
                //    {
                //if (!_headerProfileArrayList.Contains(_asrtProfileArrayList[i]))
                //{
                //        _headerProfileArrayList.Add(_asrtProfileArrayList[i]);
                //}
                //    }
                //    //End TT#403 - MD - DOConnell - Assortment ID is not displaying correctly in the Allocation Workspace
                //}
                //END TT#403 - MD - DOConnell - Assortment ID is not displaying correctly in the Allocation Workspace

                //_allocWorkFilterProfile = new AllocationWorkspaceFilterProfile(_SAB.ClientServerSession.UserRID);   // MID Track #5935 //TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS

                _hierMaint = new HierarchyMaintenance(_SAB);

                _masterKeyList = new ArrayList();
                _headersAddedToMulti = new Hashtable();
                _headersRemovedFromMulti = new Hashtable();

                _headerCharGroupProfileList = _SAB.HeaderServerSession.GetHeaderCharGroups();

                _selectedHeaderKeyList = new ArrayList();
                _selectedAssortmentKeyList = new ArrayList();  // TT#488 - MD - Jellis - Group Allocation
                _selectedComponentList = new ArrayList();
                _selectedRowsSequence.Clear();      // MID TRack #6264 - Headers out of priority sequence

                BuildDataSets();
                LoadHeaders();
                LoadGridValueLists();

                BuildHeaderEditColumnList();    // TT#863 - RMatelic - Allocation Workspace-cannot add header, fields appear to be locked from entry

                ugHeaders.DisplayLayout.MaxBandDepth = 1;
                ugDetails.DisplayLayout.MaxBandDepth = _maxBandDepth;

                // Begin TT#386 - RMatelic - On Refresh - very slow response if filter while grouped  
                //      this workaround solution was found on the Infragistics site: 1) bind to empty data source first; 2) then actual data source
                DataSet dsEmpty = ((DataSet)_bindSourceHeader.DataSource).Clone();
                BindingSource emptyBindingSource = new BindingSource(dsEmpty, null);
                ugHeaders.DataSource = emptyBindingSource;
                // End TT#386 

                ugHeaders.DataSource = _bindSourceHeader;
                UpdateSelectedTotals();

        
               // SetViewComboEnabled();

                if (ugHeaders.Rows.Count > 0)
                {
                    ugHeaders.ActiveRow = ugHeaders.Rows[0];
                }


                // Begin TT#3177 - JSmith - Incorrect Multi Header IDs again.
                AssignValueLists(ugHeaders);
                if (_dsDetails != null)
                {
                    AssignValueLists(ugDetails);
                }
                // Begin TT#544-MD - JSmith - Incorrect Multi Header IDs again.
            }
			catch (Exception ex) 
			{			
				HandleException(ex);
			}
        }
        //End TT#1313-MD -jsobek -Header Filters -performance


        // BEGIN TT#1007-MD - Stodd - Group Allocation security
        private void CheckSecurityFromGroupAllocation()
        {
			// Begin TT#1247-MD - stodd - Add Group Allocation as a License Key option -
            if (_SAB.ClientServerSession.GlobalOptions.AppConfig.GroupAllocationInstalled)
            {
			// End TT#1247-MD - stodd - Add Group Allocation as a License Key option -
                Infragistics.Win.UltraWinToolbars.TextBoxTool cboGroupAllocText = (Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"];
                cboGroupAllocText.SharedProps.Enabled = true;
                Infragistics.Win.UltraWinToolbars.ButtonTool cboGroupAllocCreate = (Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["groupAllocationCreate"];
                cboGroupAllocCreate.SharedProps.Enabled = true;
                Infragistics.Win.UltraWinToolbars.ButtonTool cboGroupAllocDelete = (Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["btnDelete"];
                cboGroupAllocDelete.SharedProps.Enabled = true;
                if (_groupAllocationSecurity.AccessDenied || _groupAllocationSecurity.IsReadOnly)
                {
                    cboGroupAllocText.SharedProps.Enabled = false;
                    cboGroupAllocCreate.SharedProps.Enabled = false;
                    cboGroupAllocDelete.SharedProps.Enabled = false;
                }
                else if (!_groupAllocationSecurity.AllowDelete)
                {
                    cboGroupAllocDelete.SharedProps.Enabled = false;
                }
            }
			// Begin TT#1247-MD - stodd - Add Group Allocation as a License Key option -
            else
            {
                Infragistics.Win.UltraWinToolbars.TextBoxTool cboGroupAllocText = (Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"];
                cboGroupAllocText.SharedProps.Visible = false;
                Infragistics.Win.UltraWinToolbars.ButtonTool cboGroupAllocCreate = (Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["groupAllocationCreate"];
                cboGroupAllocCreate.SharedProps.Visible = false;
                Infragistics.Win.UltraWinToolbars.ButtonTool cboGroupAllocDelete = (Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["btnDelete"];
                cboGroupAllocDelete.SharedProps.Visible = false;
            }
			// End TT#1247-MD - stodd - Add Group Allocation as a License Key option -
        }
        // End TT#1007-MD - Stodd - Group Allocation security


		protected void FormatForXP( Control ctl ) 
		{
            foreach (Control c in ctl.Controls)
            {
                FormatForXP(c);
            }

            if (ctl.GetType().BaseType == typeof(ButtonBase))
            {
                ((ButtonBase)ctl).FlatStyle = FlatStyle.System;
            }
		}

        //Begin TT#1313-MD -jsobek -Header Filters
        //private void ApplyViewToUserFilter(int aViewRID, int aUserRID)
        //{
        //    try
        //    {
        //        _allocWorkFilterData.OpenUpdateConnection();
        //        try
        //        {
        //            _allocWorkFilterData.ApplyViewFilterToUserFilter(aViewRID, aUserRID);
        //            _allocWorkFilterData.CommitData();
        //        }
        //        catch (Exception exc)
        //        {
        //            _allocWorkFilterData.Rollback();
        //            string message = exc.ToString();
        //            throw;
        //        }
        //        finally
        //        {
        //            _allocWorkFilterData.CloseUpdateConnection();
        //        }
        //    }
        //    catch (Exception exc) 
        //    {
        //        string message = exc.ToString();
        //        throw;
        //    }
        //}
        //End TT#1313-MD -jsobek -Header Filters

         // Begin TT#863 - RMatelic - Allocation Workspace-cannot add header, fields appear to be locked from entry
        private void BuildHeaderEditColumnList()
        {
            try
            {
                _headerEditColumns = new ArrayList();
                _headerEditColumns.Add("HeaderID");
                _headerEditColumns.Add("Type");
                _headerEditColumns.Add("Date");
                _headerEditColumns.Add("AnchorNode");
                _headerEditColumns.Add("Product");
                _headerEditColumns.Add("Style");
                _headerEditColumns.Add("Description");
                _headerEditColumns.Add("HdrQuantity");
                _headerEditColumns.Add("UnitRetail");
                _headerEditColumns.Add("UnitCost");
                _headerEditColumns.Add("SizeGroup");
                _headerEditColumns.Add("Multiple");
                _headerEditColumns.Add("PO");
                _headerEditColumns.Add("Vendor");
                _headerEditColumns.Add("Workflow");
                _headerEditColumns.Add("DC");
				// BEGIN TT#1401 - stodd - add VSW (IMO)
				_headerEditColumns.Add("ImoId");
				// END TT#1401 - stodd - add VSW (IMO)
                // begin TT#2225 - Jellis - AnF VSW FSWOS Max Enhancement pt 1
                _headerEditColumns.Add("AdjustVSW");
                // end TT#2225 - Jellis - AnF VSW FSWOS Max Enhancement pt 1
            }
            catch 
            {
                throw;
            }
        }
        // End TT#863

		private void BindActionCombo() 
		{
			try 
			{
                // Begin TT#785 - Header Load Interfacing a transaction  trying to Modify a WUB header with a PO type
                //DataTable dtActions = MIDText.GetLabels((int) eAllocationActionType.StyleNeed, (int)eAllocationActionType.ApplyAPI_Workflow);
                // begin TT#843 - new size constraint balance
                //DataTable dtActions = MIDText.GetLabels((int)eAllocationActionType.StyleNeed, (int)eAllocationActionType.ReapplyTotalAllocation);
                // begin TT#794 - New Size Balance for Wet Seal
                //DataTable dtActions = MIDText.GetLabels((int)eAllocationActionType.StyleNeed, (int)eAllocationActionType.BalanceSizeWithConstraints);
                //DataTable dtActions = MIDText.GetLabels((int)eAllocationActionType.StyleNeed, (int)eAllocationActionType.BalanceSizeBilaterally);
                if (dtActions == null) //TT#1313-MD -jsobek -Header Filters -performance
                {
                    //dtActions = MIDText.GetLabels((int)eAllocationActionType.StyleNeed, (int)eAllocationActionType.BreakoutSizesAsReceivedWithConstraints); // TT#1391 - JEllis - Balance Size With Constraint Other Options
                    dtActions = MIDText.GetLabels((int)eAllocationActionType.StyleNeed, (int)eAllocationActionType.BalanceToVSW); // TT#1334-MD - stodd - Balance to VSW Action
                    // end TT#794 - New Size Balance for Wet Seal
                    // end TT#843 - new size constraint balance
                    // End TT#785 
                    DataRow dr;
                    Hashtable removeEntry = new Hashtable();
                    removeEntry.Add(Convert.ToInt32(eAllocationActionType.BackoutDetailPackAllocation), eAllocationActionType.BackoutDetailPackAllocation);
                    removeEntry.Add(Convert.ToInt32(eAllocationActionType.ChargeSizeIntransit), eAllocationActionType.ChargeSizeIntransit);
                    removeEntry.Add(Convert.ToInt32(eAllocationActionType.DeleteHeader), eAllocationActionType.DeleteHeader);
                    if (!_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                    {
                        removeEntry.Add(Convert.ToInt32(eAllocationActionType.BackoutSizeAllocation), eAllocationActionType.BackoutSizeAllocation);
                        removeEntry.Add(Convert.ToInt32(eAllocationActionType.BackoutSizeIntransit), eAllocationActionType.BackoutSizeIntransit);
                        removeEntry.Add(Convert.ToInt32(eAllocationActionType.BalanceSizeNoSubs), eAllocationActionType.BalanceSizeNoSubs);
                        removeEntry.Add(Convert.ToInt32(eAllocationActionType.BalanceSizeWithSubs), eAllocationActionType.BalanceSizeWithSubs);
                        removeEntry.Add(Convert.ToInt32(eAllocationActionType.BreakoutSizesAsReceived), eAllocationActionType.BreakoutSizesAsReceived);
                        removeEntry.Add(Convert.ToInt32(eAllocationActionType.BalanceSizeWithConstraints), eAllocationActionType.BalanceSizeWithConstraints); // TT#843 - New Size Constraint Balance
                        removeEntry.Add(Convert.ToInt32(eAllocationActionType.BalanceSizeWithConstraints), eAllocationActionType.BalanceSizeBilaterally); // TT#794 - New Size Balance for Wet Seal
                        removeEntry.Add(Convert.ToInt32(eAllocationActionType.BalanceSizeWithConstraints), eAllocationActionType.BreakoutSizesAsReceivedWithConstraints); // TT#1391 - JEllis - Balance Size With Constraint Other Options
                    }
                    int codeValue;
                    for (int i = dtActions.Rows.Count - 1; i >= 0; i--)
                    {
                        dr = dtActions.Rows[i];
                        codeValue = Convert.ToInt32(dr["TEXT_CODE"]);
                        if (removeEntry.Contains(codeValue))
                        {
                            dtActions.Rows.Remove(dr);
                        }
                        else if (!Enum.IsDefined(typeof(eAllocationActionType), (eAllocationActionType)codeValue))
                            dtActions.Rows.Remove(dr);
                    }

                    dtActions.Rows.Add(new object[] { Include.NoRID, _lblSelectAction, 0, 0, 0, 0 });

                    CheckSecurityForActions(dtActions);
                }
                LoadActionsOnToolbar(dtActions);
                //BEGIN TT#6-MD-VStuart - Single Store Select
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
				//cboActionList.DisplayMember = "TEXT_VALUE";
				//cboActionList.ValueMember = "TEXT_CODE";
                // begin TT#843 - new size constraint balance - unrelated issue action pull down not in order
                //cboActionList.DataSource = dtActions;
				//DataView dv = new DataView(dtActions);
				//dv.Sort = "TEXT_ORDER";
				//cboActionList.DataSource = dv;
				//cboActionList.SelectedValue = Include.NoRID;       
				//cboActionList.Enabled = false;
				//cboActionList.Tag = "IgnoreMouseWheel";
				//btnProcess.Enabled = false;
                // Begin TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
				//((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["btnAction"]).SharedProps.Enabled = false;
                EnableActions(false);
                // End TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
                //AdjustTextWidthComboBox_DropDown(cboActionList);  // TT#1401 - AGallagher - Reservation Stores
                //END TT#6-MD-VStuart - Single Store Select
            }
			catch (Exception ex) 
			{			
				HandleException(ex);
			}
		}
        private void SaveToolbarLayout()
        {
            InfragisticsLayoutData layoutData = new InfragisticsLayoutData();
            System.IO.MemoryStream toolbarManagerMemoryStream = new System.IO.MemoryStream();
            this.headerToolbarsManager.SaveAsBinary(toolbarManagerMemoryStream, true);
            layoutData.InfragisticsLayout_Save(SAB.ClientServerSession.UserRID, MIDRetail.DataCommon.eLayoutID.allocationWorkspaceToolbars, toolbarManagerMemoryStream);
        }
		private DataTable CheckSecurityForActions(DataTable dtActions)
		{
			try 
			{
                bool allowAction = true;
                FunctionSecurityProfile actionSecurity = null;

				foreach(int action in Enum.GetValues(typeof( eAllocationActionType)))
				{
                    allowAction = true;
                    actionSecurity = _SAB.ClientServerSession.GetMyUserActionSecurityAssignment((eAllocationActionType)action, true);
                    if (actionSecurity.AccessDenied)
                    {
                        allowAction = false;
                    }
                    else
                    {
                        actionSecurity = _SAB.ClientServerSession.GetMyUserActionSecurityAssignment((eAllocationActionType)action, false);
                        if (actionSecurity.AccessDenied)
                        {
                            allowAction = false;
                        }
                    }
                    if (!allowAction)
                    {
                        for (int i = dtActions.Rows.Count - 1; i >= 0; i--)
                        {
                            DataRow dr = dtActions.Rows[i];
                            if (Convert.ToInt32(dr["TEXT_CODE"]) == action)
                            {
                                dtActions.Rows.Remove(dr);
                            }
                        }
                    }
				}
				return dtActions;
			}
			catch (Exception ex) 
			{			
				HandleException(ex);
				throw;
			}
		}

        private void BindViewCombo()
        {
            try
            {
                _bindingView = true;
                // Begin TT#231 - RMatelic - Add Views to Velocity Matrix and Store Detail (and correct LayoutID in _dtView.Rows.Add...)
                //_dtView = _gridViewData.GridView_Read(_userRIDList);
                //_dtView.Rows.Add(new object[] { Include.NoRID, _SAB.ClientServerSession.UserRID, (int)eLayoutID.allocationWorkflowGrid, string.Empty });
                // Begin TT#1117 - JSmith - Global & User Views w/ the same names do not have indicators
                //_dtView = _gridViewData.GridView_Read((int)eLayoutID.allocationWorkspaceGrid, _userRIDList);
                //Begin TT#1313-MD -jsobek -Header Filters -performance
                if (_userRIDList == null)
                {
                    _userRIDList = new ArrayList();
                    _userRIDList.Add(Include.GlobalUserRID);
                    _userRIDList.Add(_SAB.ClientServerSession.UserRID);
                }
                //End TT#1313-MD -jsobek -Header Filters -performance
                _dtView = _gridViewData.GridView_Read((int)eLayoutID.allocationWorkspaceGrid, _userRIDList, true);
                // End TT#1117
				// BEGIN TT#766-MD - Stodd - Add email and export to Assortment Workspace
				//_dtView.Rows.Add(new object[] { Include.NoRID, _SAB.ClientServerSession.UserRID, (int)eLayoutID.allocationWorkspaceGrid, string.Empty });
				_dtView.Rows.Add(new object[] { Include.NoRID, _SAB.ClientServerSession.UserRID, (int)eLayoutID.allocationWorkspaceGrid, "  " });
				// END TT#766-MD - Stodd - Add email and export to Assortment Workspace
                // End TT#231  

				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //BEGIN TT#6-MD-VStuart - Single Store Select
				//cboView.ValueMember = "VIEW_RID";
				//cboView.DisplayMember = "VIEW_ID";
				//cboView.DataSource = _dtView;
				//cboView.SelectedValue = -1;
                //this.cboView_SelectionChangeCommitted(source, new EventArgs()); // TT#294-MD - RBeck - When Opening style review, the view does not open that is selected
				// END TT#767-MD - Stodd - remove old controls from allocation workspace

                LoadViewsOnToolbar(_dtView);
                // Begin TT#938 - MD - stodd - Receive system out of rance exception when saving a view after adding Group Allocation to the allocation workspace header characteristics from the column chooser.
				// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                //((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).Value = Include.NoRID;
                // End TT#938 - MD - stodd - Receive system out of rance exception when saving a view after adding Group Allocation to the allocation workspace header characteristics from the column chooser.
                //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
                //MIDComboBoxEnh.MyComboBox cmbView = (MIDComboBoxEnh.MyComboBox)cct.Control;
                MIDComboBoxEnh.MyComboBox cmbView = GetViewComboBoxControl();
                cmbView.SelectedValue = Include.NoRID;
				// End TT#4071 - stodd - Matrix does not allow search for attribute - 
                _bindingView = false;
                //AdjustTextWidthComboBox_DropDown(cboView);  // TT#1401 - AGallagher - Reservation Stores
                //END TT#6-MD-VStuart - Single Store Select
            }
            catch (Exception exc)
            {
                string message = exc.ToString();
                throw;
            }
        }

        //Begin TT#1313-MD -jsobek -Header Filters
        public void BindFilterComboBox()
        {
            try
            {
                _bindingView = true;
       
                ArrayList userRIDList = new ArrayList();
                userRIDList.Add(Include.GlobalUserRID);
                userRIDList.Add(SAB.ClientServerSession.UserRID);

                DataTable dtHeaderFilters = _filterData.FilterRead(filterTypes.HeaderFilter, eProfileType.FilterHeader, userRIDList);

                LoadHeaderFiltersOnToolbar(dtHeaderFilters);
				// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                //((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["headerFilterComboBox"]).Value = this._headerFilterRID;
                Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerFilter"];
                MIDComboBoxEnh.MyComboBox cmbFilter = (MIDComboBoxEnh.MyComboBox)cct.Control;
                cmbFilter.SelectedValue = this._headerFilterRID;
				// End TT#4071 - stodd - Matrix does not allow search for attribute - 

                _bindingView = false;
            }
            catch (Exception exc)
            {
                string message = exc.ToString();
                throw;
            }
        }
        //End TT#1313-MD -jsobek -Header Filters

		private void SetText()
		{
            try
            {
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //gbxHeaderCount.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Headers);
                //gbxTotalQty.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_QtyToAllocate);
				((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["headerSelectedTextBox"]).Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Headers);
				((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["headerTotalTextBox"]).Text = MIDText.GetTextOnly(eMIDTextCode.lbl_QtyToAllocate);
				// END TT#767-MD - Stodd - remove old controls from allocation workspace

                //_lblSelected = MIDText.GetTextOnly(eMIDTextCode.lbl_Selected);
                //_lblTotal = MIDText.GetTextOnly(eMIDTextCode.lbl_Total);
                _lblQuantity = MIDText.GetTextOnly(eMIDTextCode.lbl_Quantity);

                _lblColumnChooser = MIDText.GetTextOnly(eMIDTextCode.lbl_ColumnChooser); ;
                _lblDeleteRow = MIDText.GetTextOnly(eMIDTextCode.lbl_DeleteRow);
                _lblDescription = MIDText.GetTextOnly(eMIDTextCode.lbl_Description);  // TT#1324 - RMatelic - When adding a new Style, the description does not update.
                _lblHeaderNotes = MIDText.GetTextOnly(eMIDTextCode.lbl_HeaderNotes);
                _lblHierarchyNode = MIDText.GetTextOnly(eMIDTextCode.lbl_HierarchyNode);
                _lblUser = MIDText.GetTextOnly(eMIDTextCode.lbl_User);
                _lblPhStyle = MIDText.GetTextOnly(eMIDTextCode.lbl_PhStyle);

                _lblSelectAction = MIDText.GetTextOnly(eMIDTextCode.lbl_SelectAction);
                _lblSummary = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Summary);

                _lblAssortment = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Assortment);
                _noSizeDimensionLbl = MIDText.GetTextOnly((int)eMIDTextCode.lbl_NoSecondarySize);

				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //btnProcess.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Button_Process);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["btnAction"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Button_Process);
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
                //btnRestoreLayout.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_RestoreLayout);

                // Context Menu text
                this.cmsAdd.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Button_Add);
                this.cmsAddHeader.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Header);
                this.cmsAddPack.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Pack);
                this.cmsAddPackColor.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_PackColor);
                this.cmsAddPackSize.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_PackSize);
                this.cmsAddBulkColor.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_BulkColor);
                this.cmsAddBulkSize.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_BulkSize);
             
                this.cmsAssortment.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Assortment);
                this.cmsAssrtCreate.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Create);
                this.cmsAssrtAddPlaceholder.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_AddPlaceholderStyle);
                this.cmsAssrtAddTo.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_AddTo);
                this.cmsAssrtRemove.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_RemoveFrom);
              
                this.cmsReview.Text = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Review);
                this.cmsReviewSelect.Text = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Select);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["reviewSelectionScreen"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Select);

                this.cmsReviewStyle.Text = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Style);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["reviewStyle"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Style);

                this.cmsReviewSize.Text = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Size);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["reviewSize"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Size);

                this.cmsReviewSummary.Text = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Summary);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["reviewSummary"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.menu_Allocation_Summary);

                
                this.cmsFilter.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Filter);
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["filter"]).SharedProps.Caption = "Edit Filter";// MIDText.GetTextOnly(eMIDTextCode.lbl_Filter);
                this.cmsSearch.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Search);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["searchButton"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Search);
                this.cmsDetails.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_ShowDetails);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["showDetails"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ShowDetails);
                this.cmsRemove.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Remove);
               
                this.cmsMulti.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_MultiHeader);
                this.cmsMultiCreate.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Create);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["multiCreate"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Create);
                this.cmsMultiAddTo.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_AddTo);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["multiAddTo"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AddTo);
                this.cmsMultiRemove.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_RemoveFrom);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["multiRemove"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_RemoveFrom);

               
                this.cmsSaveView.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_SaveView);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["saveView"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_SaveView);
                this.cmsDelete.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Delete);
                this.cmsExpand.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_ExpandAll);
                this.cmsCollapse.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_CollapseAll);
                this.cmsSave.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Edit);
                this.cmsCancel.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Button_Cancel);

                _thisTitle = MIDText.GetTextOnly((int)eMIDTextCode.frm_WorkspaceExplorer);

                //this.toolTip1.SetToolTip(cboView,MIDText.GetTextOnly(eMIDTextCode.lbl_Views));	// TT#767-MD - Stodd - remove old controls from allocation workspace

                // BEGIN Usability Enhancement 
                // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
                //this.btnExpandCollapse.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_ExpandAll);
                //this.btnEditSave.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Edit);
                //this.btnCancel.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Button_Cancel);
                // End TT#1126-MD  
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //this.btnShowDetails.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_ShowDetails);
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["showDetails"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ShowDetails);
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
                // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
                //this.btnHideDetails.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_HideDetails);
                // End TT#1126-MD  
                // END Usability Enhancement
                //this.btnExcel.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Button_Excel);  // TT#1135 - AGallagher - Export headers from allocation workspace
                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                _dupSizeNameSeparator = MIDText.GetTextOnly((int)eMIDTextCode.lbl_DupSizeNameSeparator);
                // End  TT#234 

                // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
                ((Infragistics.Win.UltraWinToolbars.PopupMenuTool)this.detailToolbarsManager.Tools["GridPopup"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Grid);
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnCollapseAll"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_CollapseAll);
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnExpandAll"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ExpandAll);
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnEditSave"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Edit);
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnCancel"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Button_Cancel);
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnHideDetails"]).SharedProps.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_HideDetails);
                // End TT#1126-MD
            }
            catch
            {
                throw;
            }
		}

		#endregion

		#region Build DataSet data 
		private void BuildDataSets()
		{
            _dtHeader = MIDEnvironment.CreateDataTable("Header");

			_colorsForStyle.Clear();
			_nodeDataHash.Clear();
            // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
            _nodeDataHash = null;
            _nodeDataHash = new Hashtable();
            // End TT#1434

			_nodeDataHashLastKey = 0;
			_sizeGroupHashLastKey = 0; 
			try 
			{	// MultiHeader
				_multiHeaders  = MIDEnvironment.CreateDataTable("MultiHeaders"); 
				_multiHeaders.Columns.Add("HdrRID",System.Type.GetType("System.Int32"));	
				_multiHeaders.Columns.Add("HeaderID");

                // Assortment
                _assortments = MIDEnvironment.CreateDataTable("Assortments");
                _assortments.Columns.Add("AsrtRID",System.Type.GetType("System.Int32"));
                _assortments.Columns.Add("AssortmentID");
                _assortments.Columns.Add("AsrtType", System.Type.GetType("System.Int32"));	// TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                _assortments.PrimaryKey = new DataColumn[] { _assortments.Columns["AsrtRID"] }; // TT#2 - RMatelic - Assortment Planning

                // Placeholders
                _placeHolders = MIDEnvironment.CreateDataTable("PlaceHolders");
                _placeHolders.Columns.Add("PlaceHolderRID",System.Type.GetType("System.Int32"));
                _placeHolders.Columns.Add("PlaceHolderID");

                // AnchorNodes
                _anchorNodes = MIDEnvironment.CreateDataTable("AnchorNodes");
                _anchorNodes.Columns.Add("PhStyleRID", System.Type.GetType("System.Int32"));
                _anchorNodes.Columns.Add("PhOldAnchorRID", System.Type.GetType("System.Int32"));
                _anchorNodes.Columns.Add("PhNewAnchorRID", System.Type.GetType("System.Int32"));
                _anchorNodes.PrimaryKey = new DataColumn[] { _anchorNodes.Columns["PhStyleRID"] };

				_dtHeader.Columns.Add("KeyH",System.Type.GetType("System.Int32"));		 
				_dtHeader.Columns.Add("KeyP",System.Type.GetType("System.Int32"));
				_dtHeader.Columns.Add("KeyC",System.Type.GetType("System.Int32"));
				_dtHeader.Columns.Add("HeaderID");
				 
				_dtHeader.Columns.Add("HdrGroupRID",System.Type.GetType("System.Int32"));
				
                // Begin TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                // Note: There really aren't two separate rids, one for assortment and one for group allocation.
                //       They are split out here so the IDs for the two can show up in separate columns when
                //       assortment is installed.
                // End TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                _dtHeader.Columns.Add("AsrtRID",System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("GroupAllocRID", System.Type.GetType("System.Int32"));        // TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                _dtHeader.Columns.Add("PlaceHolderRID",System.Type.GetType("System.Int32"));
				_dtHeader.Columns.Add("FunctionSecurity");

                _dtHeader.Columns.Add("Type",System.Type.GetType("System.Int32"));
				_dtHeader.Columns.Add("Date",System.Type.GetType("System.DateTime"));
                _dtHeader.Columns.Add("Status",System.Type.GetType("System.Int32"));

                _dtHeader.Columns.Add("AnchorHnRID", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("AnchorNode");
				_dtHeader.Columns.Add("ProductRID",System.Type.GetType("System.Int32"));
             	_dtHeader.Columns.Add("Product");
			    _dtHeader.Columns.Add("StyleHnRID",System.Type.GetType("System.Int32")); 
                _dtHeader.Columns.Add("Style");
				 
				_dtHeader.Columns.Add("StyleSecurity",System.Type.GetType("System.Int32"));
			 
				_dtHeader.Columns.Add("Description");
				_dtHeader.Columns.Add("HdrQuantity",System.Type.GetType("System.Int32"));
				 
				_dtHeader.Columns.Add("Balance",System.Type.GetType("System.Int32"));

                //BEGIN TT#154 – Add # of stores variable to Allocation workspace - apicchetti
                _dtHeader.Columns.Add("NumberOfStores", System.Type.GetType("System.Int32"));
                //END TT#154 – Add # of stores variable to Allocation workspace - apicchetti
                // BEGIN Workspace Usability Enhancement - Ron Matelic
                _dtHeader.Columns.Add("NumPacks", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("NumBulkColors", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("NumBulkSizes", System.Type.GetType("System.Int32"));
                // END Workspace Usability Enhancement 
				 
				_dtHeader.Columns.Add("UnitRetail",System.Type.GetType("System.Double"));
				_dtHeader.Columns.Add("UnitCost",System.Type.GetType("System.Double"));
                _dtHeader.Columns.Add("UnitsPerCarton", System.Type.GetType("System.Int32")); // TT#1652-MD - RMatelic - DC Carton Roundng
				_dtHeader.Columns.Add("SizeGroup",System.Type.GetType("System.Int32"));
				_dtHeader.Columns.Add("Multiple",System.Type.GetType("System.Int32"));
				_dtHeader.Columns.Add("PO");
				_dtHeader.Columns.Add("Vendor");
				_dtHeader.Columns.Add("Workflow");
				_dtHeader.Columns.Add("APIWorkflow");
				_dtHeader.Columns.Add("DC");

                _dtHeader.Columns.Add("Intransit",System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("ShipStatus",System.Type.GetType("System.Int32"));
				_dtHeader.Columns.Add("Release",System.Type.GetType("System.String"));
				
				_dtHeader.Columns.Add("Notes");
				_dtHeader.Columns.Add("Interfaced",System.Type.GetType("System.Boolean"));
				_dtHeader.Columns.Add("ChildTotal",System.Type.GetType("System.Int32"));
			    _dtHeader.Columns.Add("MultiSortSeq",System.Type.GetType("System.Int32"));
			    _dtHeader.Columns.Add("Master");
				_dtHeader.Columns.Add("AllocatedUnits",System.Type.GetType("System.Int32"));
				_dtHeader.Columns.Add("OrigAllocatedUnits",System.Type.GetType("System.Int32"));
				_dtHeader.Columns.Add("RsvAllocatedUnits",System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("AsrtType", System.Type.GetType("System.Int32"));
                _dtHeader.Columns.Add("AsrtSortSeq",System.Type.GetType("System.Int32"));
                // Begin TT#1401 - RMatelic - Reservation Stores
                _dtHeader.Columns.Add("ImoId", System.Type.GetType("System.String"));
				// BEGIN TT1401 - stodd - TEMP removal of these fields from displaying on Alloc workspace
                // BEGIN TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
				_dtHeader.Columns.Add("ItemUnitsAllocated", System.Type.GetType("System.Int32"));
				_dtHeader.Columns.Add("ItemOrigUnitsAllocated", System.Type.GetType("System.Int32"));
                // END TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
				// END TT1401 - TEMP removal of these fields from displaying on Alloc workspace
                // End TT#1401 
                // begin TT#2225 - Jellis - AnF VSW FSWOS Max Enhancement pt 1
				// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
                _dtHeader.Columns.Add("AdjustVSW", System.Type.GetType("System.Int32"));
				// END TT#2225 - stodd - VSW ANF Enhancement (IMO)
                // end TT#2225 - Jellis - AnF VSW FSWOS Max Enhancement pt 1

                // Begin TT#457-MD - RMatelic - Add additional Header information to the Allocation Workspace
                _dtHeader.Columns.Add("PlanHnRID", System.Type.GetType("System.String"));
                _dtHeader.Columns.Add("OnHandHnRID", System.Type.GetType("System.String"));
                _dtHeader.Columns.Add("GradeInvHnRID", System.Type.GetType("System.String"));
                // End TT#457-MD 

                _dtHeader.Columns.Add("CharUpdated", System.Type.GetType("System.Boolean"));
                _dtHeader.Columns.Add("HeaderRow",System.Type.GetType("System.Object"));

                //Begin TT#1313-MD -jsobek -Header Filters -performance
                // Begin TT#310 - JSmith - HeaderCharacteristic length error in workspace
                if (maxCharSize == null)
                {
                    HeaderCharacteristicsData headerCharacteristicsData = new HeaderCharacteristicsData();
                    maxCharSize = headerCharacteristicsData.GetColumnSize("HEADER_CHAR", "TEXT_VALUE");
                }
                // End TT#310
                //End TT#1313-MD -jsobek -Header Filters -performance

                // save column count before characteristics are added for characteristic processing 
                _nonCharColCount = _dtHeader.Columns.Count; 

                foreach (HeaderCharGroupProfile hcgp in _headerCharGroupProfileList)
                {
                 //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                    string hcgpRID = hcgp.Key.ToString();
                    _dtHeader.Columns.Add(hcgpRID);
                    _dtHeader.Columns[hcgpRID].ExtendedProperties.Add("IsChar", hcgp);

                    if (hcgp.ListInd)   // uses a drop down list
                    {
                        _dtHeader.Columns[hcgpRID].DataType = System.Type.GetType("System.Int32");                  
                    }
                    else
                    {
                        switch (hcgp.Type)
                        {
                            // Begin TT#267 - RMatelic - Remove warning message when adding Header Characteristics; set max length to database length
                            case eHeaderCharType.text:
                                _dtHeader.Columns[hcgpRID].MaxLength = (int)maxCharSize; //TT#1313-MD -jsobek -Header Filters -performance
                                break;
                            // End TT#267 

                            case eHeaderCharType.date:
                                _dtHeader.Columns[hcgpRID].DataType = System.Type.GetType("System.DateTime");
                                break;
                        
                            case eHeaderCharType.number:    
                            case eHeaderCharType.dollar:
                                _dtHeader.Columns[hcgpRID].DataType = System.Type.GetType("System.Double");
                                break;
                        }
                    }

                }
         
				// header defaults and constraints
				_dtHeader.Columns["HeaderID"].AllowDBNull = false;
				_dtHeader.Columns["HeaderID"].Unique = true;
                _dtHeader.Columns["Product"].AllowDBNull = true;            // allow nulls because of Assortment
                _dtHeader.Columns["Description"].AllowDBNull = true;        // allow nulls because of Assortment
                _dtHeader.Columns["HdrGroupRID"].AllowDBNull = true;
                _dtHeader.Columns["AsrtRID"].AllowDBNull = true;
                _dtHeader.Columns["PlaceHolderRID"].AllowDBNull = true;
                _dtHeader.Columns["MultiSortSeq"].AllowDBNull = true;
                _dtHeader.Columns["AsrtSortSeq"].AllowDBNull = true;

                _dtHeader.Columns["UnitsPerCarton"].AllowDBNull = true;     // TT#1652-MD - RMatelic - DC Carton Rounding
                _dtHeader.Columns["KeyH"].DefaultValue = 0;
				_dtHeader.Columns["KeyP"].DefaultValue = 0;
				_dtHeader.Columns["KeyC"].DefaultValue = 0;
			    _dtHeader.Columns["Type"].DefaultValue =  (int)eHeaderType.Receipt ;  
				_dtHeader.Columns["Date"].DefaultValue = DateTime.Today;
				_dtHeader.Columns["Multiple"].DefaultValue = Include.DefaultUnitMultiple;
				_dtHeader.Columns["SizeGroup"].DefaultValue = Include.UndefinedSizeGroupRID;
				_dtHeader.Columns["Release"].DefaultValue = String.Empty;
				_dtHeader.Columns["Interfaced"].DefaultValue = false;
				_dtHeader.Columns["Master"].DefaultValue = String.Empty;
				// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
				_dtHeader.Columns["AdjustVSW"].DefaultValue = Include.NoRID; // TT#2225 - JEllis - AnF VSW FWOS Enhancement pt 1
				// END TT#2225 - stodd - VSW ANF Enhancement (IMO)
                _dtHeader.Columns["CharUpdated"].DefaultValue = false;
                _dtHeader.PrimaryKey = new DataColumn[] { _dtHeader.Columns["KeyH"] };

                DataSet ds = MIDEnvironment.CreateDataSet();
                ds.Tables.Add(_dtHeader);
                //ds.Relations.Add("Placeholder", ds.Tables["Header"].Columns["KeyH"], ds.Tables["Header"].Columns["AsrtRID"], false);

                _bindSourceHeader = new BindingSource(ds, "Header");
              
			    // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                //CreateDetailDataSet();
				// End TT#1434
			}
			catch(Exception ex) 
			{
				HandleException(ex);
			}
		}
		private void CreateDetailDataSet()
		{
            try
            {
                _dsDetails = MIDEnvironment.CreateDataSet();

                _dtDetailHeader = _dtHeader.Clone();
                _dsDetails.Tables.Add(_dtDetailHeader);

                // Begin TT#375/TT#376 - RMatelic - Unrelated - used for max column entry length
                Header headerData = new Header();    
                _dtDetailHeader.Columns["HeaderID"].MaxLength = headerData.GetColumnSize("HEADER", "HDR_ID");
                // End TT#375/TT#376

                // pack definition
                _dtPack = MIDEnvironment.CreateDataTable("Pack");

                _dtPack.Columns.Add("KeyH", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("KeyP", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("KeyC", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("Pack");
                _dtPack.Columns.Add("PackType", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("TotalPacks", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("QuantityPerPack", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("TotalQuantity", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("AssociatedPackRID", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("Sequence", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("Balance", System.Type.GetType("System.Int32"));
                _dtPack.Columns.Add("ChildTotal", System.Type.GetType("System.Int32"));

                // pack defaults and constraints
                _dtPack.Columns["Pack"].AllowDBNull = false;
                _dtPack.Columns["KeyP"].DefaultValue = 0;
                _dtPack.Columns["KeyC"].DefaultValue = 0;
                _dtPack.Columns["PackType"].DefaultValue = (int)eAllocationType.GenericType;
                _dtPack.Columns["TotalPacks"].DefaultValue = 1;
                _dtPack.Columns["QuantityPerPack"].DefaultValue = 1;
                _dtPack.Columns["TotalQuantity"].DefaultValue = 1;

                _dtPack.PrimaryKey = new DataColumn[] {_dtPack.Columns["KeyH"], 
													  _dtPack.Columns["Pack"]};
                _dtPack.Columns["Pack"].MaxLength = headerData.GetColumnSize("HEADER_PACK", "HDR_PACK_NAME"); // TT#375/TT#376 - Unrelated - used for max column entry length
                _dsDetails.Tables.Add(_dtPack);

                // pack color definition
                _dtPackColor = MIDEnvironment.CreateDataTable("PackColor");

                _dtPackColor.Columns.Add("KeyH", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("KeyP", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("KeyC", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("ColorCodeRID", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("PackColor");
                _dtPackColor.Columns.Add("Description");
                _dtPackColor.Columns.Add("QuantityPerPack", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("Sequence", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("Name");
                _dtPackColor.Columns.Add("Balance", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("ChildTotal", System.Type.GetType("System.Int32"));
                _dtPackColor.Columns.Add("IsNewColor", System.Type.GetType("System.Boolean"));
                _dtPackColor.Columns.Add("IsVirtual", System.Type.GetType("System.Boolean"));
   
                // pack color defaults and constraints
                _dtPackColor.Columns["PackColor"].AllowDBNull = false;
                _dtPackColor.Columns["QuantityPerPack"].DefaultValue = 1;
                _dtPackColor.Columns["IsNewColor"].DefaultValue = false;
                _dtPackColor.Columns["IsVirtual"].DefaultValue = false;

                _dtPackColor.PrimaryKey = new DataColumn[] {_dtPackColor.Columns["KeyH"],  
                                                            _dtPackColor.Columns["KeyP"],
                                                            _dtPackColor.Columns["ColorCodeRID"]};
                _dsDetails.Tables.Add(_dtPackColor);

                // bulk color definition
                _dtBulkColor = MIDEnvironment.CreateDataTable("BulkColor");

                _dtBulkColor.Columns.Add("KeyH", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("KeyP", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("KeyC", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("ColorCodeRID", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("BulkColor");
                _dtBulkColor.Columns.Add("Description");
                _dtBulkColor.Columns.Add("Quantity", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("Sequence", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("Name");
                _dtBulkColor.Columns.Add("AsrtBCRID", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("Balance", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("ChildTotal", System.Type.GetType("System.Int32"));
                _dtBulkColor.Columns.Add("IsNewColor", System.Type.GetType("System.Boolean"));
                _dtBulkColor.Columns.Add("IsVirtual", System.Type.GetType("System.Boolean"));
  
                // bulk color defaults and constraints
                _dtBulkColor.Columns["KeyP"].DefaultValue = 0;
                _dtBulkColor.Columns["Quantity"].DefaultValue = 0;
                _dtBulkColor.Columns["ChildTotal"].DefaultValue = 0;
                _dtBulkColor.Columns["IsNewColor"].DefaultValue = false;
                _dtBulkColor.Columns["IsVirtual"].DefaultValue = false;
               
                _dtBulkColor.PrimaryKey = new DataColumn[] {_dtBulkColor.Columns["KeyH"], 
                                                            _dtBulkColor.Columns["ColorCodeRID"]};
                _dsDetails.Tables.Add(_dtBulkColor);
            }
            catch
            {
                throw;
            }
		}

        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
        private void ClearDetails()
        {
            try
            {
                _inClearDetails = true;
                ArrayList alDataTables = null;

                ugDetails.DataSource = null;
                if (_dsDetails != null)
                {
                    alDataTables = new ArrayList();
                    _dsDetails.Clear();
                    _dsDetails.Relations.Clear();
                    RemoveTablesFromDataset(_dsDetails, GetTablesFromDataset(_dsDetails, "PackSize"));
                    RemoveTablesFromDataset(_dsDetails, GetTablesFromDataset(_dsDetails, "PackColor"));
                    RemoveTablesFromDataset(_dsDetails, GetTablesFromDataset(_dsDetails, "Pack"));
                    RemoveTablesFromDataset(_dsDetails, GetTablesFromDataset(_dsDetails, "BulkSize"));
                    RemoveTablesFromDataset(_dsDetails, GetTablesFromDataset(_dsDetails, "BulkColor"));
                    RemoveTablesFromDataset(_dsDetails, GetTablesFromDataset(_dsDetails, "Header"));

                    _dtBulkColor.Dispose();
                    _dtBulkColor = null;
                    _dtPackColor.Dispose();
                    _dtPackColor = null;
                    _dtPack.Dispose();
                    _dtPack = null;
                    _dtDetailHeader.Dispose();
                    _dtDetailHeader = null;

                    _dsDetails.Dispose();
                    _dsDetails = null;

                    ClearSavedDetails();

                }
                // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
                //Begin TT#2019 - JSmith - received Systme Null Reference when clicking on Edit button in Show Detail section of Allocation Workspace
                //btnEditSave.Enabled = false;
                //End TT#2019
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnEditSave"]).SharedProps.Enabled = false;
                // Edn TT#1126-MD
            }
            catch
            {
                throw;
            }
            finally
            {
                _inClearDetails = false;
            }
        }

        private void ClearSavedDetails()
        {
            try
            {
                ArrayList alDataTables = null;

                if (_dsDetailsSaved != null)
                {
                    alDataTables = new ArrayList();
                    _dsDetailsSaved.Clear();
                    _dsDetailsSaved.Relations.Clear();
                    RemoveTablesFromDataset(_dsDetailsSaved, GetTablesFromDataset(_dsDetailsSaved, "PackSize"));
                    RemoveTablesFromDataset(_dsDetailsSaved, GetTablesFromDataset(_dsDetailsSaved, "PackColor"));
                    RemoveTablesFromDataset(_dsDetailsSaved, GetTablesFromDataset(_dsDetailsSaved, "Pack"));
                    RemoveTablesFromDataset(_dsDetailsSaved, GetTablesFromDataset(_dsDetailsSaved, "BulkSize"));
                    RemoveTablesFromDataset(_dsDetailsSaved, GetTablesFromDataset(_dsDetailsSaved, "BulkColor"));
                    RemoveTablesFromDataset(_dsDetailsSaved, GetTablesFromDataset(_dsDetailsSaved, "Header"));

                    _dsDetailsSaved.Dispose();
                    _dsDetailsSaved = null;
                }
            }
            catch
            {
                throw;
            }
        }

        private ArrayList GetTablesFromDataset(DataSet aDataSet, string aTableNameMask)
        {
            ArrayList al = new ArrayList();
            foreach (DataTable dt in aDataSet.Tables)
            {
                if (dt.TableName.Contains(aTableNameMask))
                {
                    dt.Clear();
                    al.Add(dt);
                }
            }
            return al;
        }

        private void RemoveTablesFromDataset(DataSet aDataSet, ArrayList alDataTables)
        {
            foreach (DataTable dt in alDataTables)
            {
                dt.PrimaryKey = null;
                dt.Clear();
                dt.Rows.Clear();
                RemoveConstraintsFromDataTable(dt, GetConstraintFromDataTable(dt));
                if (aDataSet.Tables.CanRemove(dt))
                {
                    aDataSet.Tables.Remove(dt);
                }
            }
        }

        private ArrayList GetConstraintFromDataTable(DataTable aDataTable)
        {
            ArrayList al = new ArrayList();
            foreach (Constraint constraint in aDataTable.Constraints)
            {
                al.Add(constraint);
            }
            return al;
        }

        private void RemoveConstraintsFromDataTable(DataTable aDataTable, ArrayList alConstraints)
        {
            foreach (Constraint constraint in alConstraints)
            {
                if (aDataTable.Constraints.CanRemove(constraint))
                {
                    aDataTable.Constraints.Remove(constraint);
                }
            }
        }

        // End TT#1434

        private void LoadHeaders()
		{
			try
			{
                int headerType, headerStatus, intransitStatus, shipStatus;
                object groupRID, asrtRID, phRID, multiSortSeq, asrtSortSeq, groupAllocRid;	// TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                //object numberOfStores;
                object packCount, bulkColorCount, bulkColorSizeCount; // Workspace Usability Enhancement 
                object unitsPerCarton; // T#1652-MD- RMatelic - DC Carton Rounding
                HierarchyNodeSecurityProfile securityNode;
                eSecurityType styleSecurity;

                // Begin TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
                _multiHeaderGroups = new Hashtable();
                _assortmentGroups = new Hashtable();
                // End TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception

				//WorkflowBaseData workflowData = new WorkflowBaseData(); //TT#1313-MD -jsobek -Header Filters -performance
                eSecurityLevel securityLevel = eSecurityLevel.Allow;
            	string releaseDate = string.Empty;
				string headerDay = string.Empty;

                bool canView, canUpdate;
                _charByGroupAndID.Clear();
                _lastMultiSortSeq = 0;
                _lastAsrtSortSeq = 0;
                // Header headerData = new Header(); // TT#457-MD
                eAssortmentType asrtType = eAssortmentType.Undefined;	// TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                foreach (AllocationHeaderProfile ahp in _headerProfileArrayList) //this list comes from here: _SAB.HeaderServerSession.GetHeadersForWorkspace
				{	
	                headerType = Convert.ToInt32(ahp.HeaderType, CultureInfo.CurrentUICulture);
					headerStatus =  Convert.ToInt32(ahp.HeaderAllocationStatus, CultureInfo.CurrentUICulture);
                    intransitStatus = Convert.ToInt32(ahp.HeaderIntransitStatus, CultureInfo.CurrentUICulture);
                    shipStatus = Convert.ToInt32(ahp.HeaderShipStatus, CultureInfo.CurrentUICulture);
                    asrtType = (eAssortmentType)ahp.AsrtType;	// TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                    canView = false;
                    canUpdate = false;

                    switch ((eHeaderType)headerType)
                    {
                        case eHeaderType.Assortment:
                        case eHeaderType.Placeholder:
                            canUpdate = _assortmentSecurity.AllowUpdate;
                            canView = _assortmentSecurity.AllowView;
                            break;

                        default:
                            securityNode = _SAB.ClientServerSession.GetMyUserNodeSecurityAssignment(ahp.StyleHnRID, (int)eSecurityTypes.Allocation);
                            canUpdate = securityNode.AllowUpdate;
                            canView = securityNode.AllowView;
                            break;
                    }
                    if (canUpdate || canView)
                    {
                        if (canUpdate)
                        {
                            styleSecurity = eSecurityType.Update;
                        }
                        else
                        {
                            styleSecurity = eSecurityType.View;
                        }
                                  
						// check for size group in hash; if not found read it
						SizeGroupProfile sgp = (SizeGroupProfile)_sizeGroupHash[ahp.SizeGroupRID];
						if (sgp == null)
						{
							sgp = new SizeGroupProfile(ahp.SizeGroupRID);
							_sizeGroupHash.Add(ahp.SizeGroupRID, sgp);
						}
                        //Begin TT#1313-MD -jsobek -Header Filters -performance
						string workflowMethodStr = string.Empty;
						// check for workflow name in hash; if not found read it
                        if (ahp.WorkflowRID > Include.UndefinedWorkflowRID)
                        {
                            workflowMethodStr = (string)_workflowNameHash[ahp.WorkflowRID];
                            if (workflowMethodStr == null)
                            {
                                workflowMethodStr = ahp.WorkflowName; //workflowData.GetWorkflowName(ahp.WorkflowRID);

                                // BEGIN MID Track #6336 - KJohnson - Header Load API Enhancement
                                workflowMethodStr = setGeneratedWorkflowName(ahp.HeaderID, workflowMethodStr);
                                // END MID Track #6336
                                _workflowNameHash.Add(ahp.WorkflowRID, workflowMethodStr);
                            }
                            // BEGIN MID Track #6336 - KJohnson - Header Load API Enhancement
                            workflowMethodStr = setGeneratedWorkflowName(ahp.HeaderID, workflowMethodStr);
                            // END MID Track #6336
                        }
                        else if (ahp.MethodRID > Include.UndefinedMethodRID)
                        {
                            // check for method in hash; if not found read it
                            //ApplicationBaseMethod abm = (ApplicationBaseMethod)_methodHash[ahp.MethodRID];
                            //if (abm == null)
                            //{
                            //    abm = (ApplicationBaseMethod)_getMethods.GetUnknownMethod(ahp.MethodRID, false);
                            //    _methodHash.Add(ahp.MethodRID, abm);
                            //}
                            //workflowMethodStr = abm.Name;
                            // BEGIN MID Track #6336 - KJohnson - Header Load API Enhancement
                            workflowMethodStr = ahp.HeaderMethodName; 
                            workflowMethodStr = setGeneratedWorkflowName(ahp.HeaderID, workflowMethodStr);
                            // END MID Track #6336
                        }
                        //End TT#1313-MD -jsobek -Header Filters -performance

						string APIworkflowMethodStr = string.Empty;
						// check for workflow name in hash; if not found read it
						if (ahp.API_WorkflowRID > Include.UndefinedWorkflowRID) 
						{
							APIworkflowMethodStr = (string)_workflowNameHash[ahp.API_WorkflowRID];
							if (APIworkflowMethodStr == null)
							{
                                //Begin TT#1313-MD -jsobek -Header Filters -performance
								//APIworkflowMethodStr = workflowData.GetWorkflowName(ahp.API_WorkflowRID);
                                APIworkflowMethodStr = ahp.APIWorkflowName;
                                //End TT#1313-MD -jsobek -Header Filters -performance



                                // BEGIN MID Track #6336 - KJohnson - Header Load API Enhancement
                                APIworkflowMethodStr = setGeneratedWorkflowName(ahp.HeaderID, APIworkflowMethodStr);
                                // END MID Track #6336
                                _workflowNameHash.Add(ahp.API_WorkflowRID, APIworkflowMethodStr);
							}
                            // BEGIN MID Track #6336 - KJohnson - Header Load API Enhancement
                            APIworkflowMethodStr = setGeneratedWorkflowName(ahp.HeaderID, APIworkflowMethodStr);
                            // END MID Track #6336
						}

                        // Begin TT#1966-MD - DC Fulfillment
                        //int masterRID = Include.NoRID;
                        //int subordRID = Include.NoRID;
                        // End TT#1966-MD - DC Fulfillment

						string masterID = String.Empty;
						string subordID = String.Empty;
						string msgMasterSubord = String.Empty;

                        // Begin TT#1966-MD - DC Fulfillment
                        //subordRID = ahp.SubordinateRID;
                        //if (subordRID != Include.NoRID) 
                        //{
                        //    subordID = ahp.SubordinateID;                      
                        //    if (subordID != null && subordID != string.Empty)
                        //    {
                        //        msgMasterSubord = ahp.HeaderID + " / " + subordID;
                        //    }
                        //}
                        //else
                        //{
                        //    masterRID = ahp.MasterRID;                               
                        //    if (masterRID != Include.NoRID)
                        //    {
                        //        masterID = ahp.MasterID;
                        //        if (masterID != null && masterID != string.Empty)
                        //        {
                        //            msgMasterSubord = masterID + " / " + ahp.HeaderID;	
                        //        }
                        //    }
                        //}
                        if (ahp.IsMasterHeader)
                        {
                            msgMasterSubord = ahp.HeaderID;
                        }
                        else if (ahp.IsSubordinateHeader)
                        {
                            msgMasterSubord = ahp.MasterID;
                        }
                        // End TT#1966-MD - DC Fulfillment
				 
			    		if (ahp.ReleaseDate == Include.UndefinedDate)
						{
							releaseDate = string.Empty;
						}
						else
						{
                            // Begin TT#5072 - JSmith - Release date field not recognized as date?
                            //releaseDate = ahp.ReleaseDate.ToShortDateString();
                            releaseDate = ahp.ReleaseDate.ToString("MM/dd/yyyy");
                            // End TT#5072 - JSmith - Release date field not recognized as date?
						}

						//use first parent ID if multiple parents
						string parentID = string.Empty;
						int parentRID = 0;
						
						HierarchyNodeProfile hnp_style = this.GetNodeData(ahp.StyleHnRID);
						parentRID = Convert.ToInt32(hnp_style.Parents[0], CultureInfo.CurrentUICulture);
						
						HierarchyNodeProfile hnpProduct = this.GetNodeData(parentRID); 
						parentID = hnpProduct.LevelText; 

						// MultiHeader && Assortment
                        switch (headerType)
                        {
                            case (int)eHeaderType.MultiHeader:
                                _multiHeaders.Rows.Add(new object[] { ahp.Key, ahp.HeaderID });
                                break;
							//BEGIN TT#403 - MD - DOConnell - Assortment ID is not displaying correctly in the Allocation Workspace
                            //case (int)eHeaderType.Assortment:
                            //    _assortments.Rows.Add(new object[] { ahp.Key, ahp.HeaderID });
                            //    break;
							//END TT#403 - MD - DOConnell - Assortment ID is not displaying correctly in the Allocation Workspace
                            case (int)eHeaderType.Placeholder:
                                _placeHolders.Rows.Add(new object[] { ahp.Key, ahp.HeaderID });
                                break;

                        }
						//BEGIN TT#403 - MD - DOConnell - Assortment ID is not displaying correctly in the Allocation Workspace
                        if (ahp.AsrtRID != Include.NoRID && ahp.AssortmentID != " ")
                        {
                            if (!_assortments.Rows.Contains(ahp.AsrtRID))
                            {
                                _assortments.Rows.Add(new object[] { ahp.AsrtRID, ahp.AssortmentID, ahp.AsrtTypeForParentAsrt });	// TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                            }
                        }
                        //END TT#403 - MD - DOConnell - Assortment ID is not displaying correctly in the Allocation Workspace
						
						// MultiHeader
						if ( ahp.HeaderGroupRID == Include.UndefinedHeaderGroupRID)
							if (ahp.MultiHeader)
							{	
								groupRID = ahp.Key;
                                multiSortSeq = 0;
							}
							else
							{
                                groupRID = System.DBNull.Value;
                                multiSortSeq = System.DBNull.Value;
							}
						else
						{
							groupRID = ahp.HeaderGroupRID;
							_lastMultiSortSeq++;
                            multiSortSeq = _lastMultiSortSeq;
						}
                       
                        phRID = System.DBNull.Value;
                        asrtRID = System.DBNull.Value;
                        asrtSortSeq = System.DBNull.Value;
						// Begin TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                        groupAllocRid = System.DBNull.Value;
                        if (headerType == (int)eHeaderType.Assortment)
                        {
                            if (asrtType == eAssortmentType.GroupAllocation)
                            {
                                groupAllocRid = ahp.Key;
                            }
                            else
                            {
                                asrtRID = ahp.Key;
                                asrtSortSeq = 0;
                            }
                        }
                        else if (headerType == (int)eHeaderType.Placeholder)
                        {
                            phRID = ahp.Key;
                            asrtRID = ahp.AsrtRID;
                            asrtSortSeq = 0;
                        }
                        else if (ahp.AsrtRID != Include.NoRID)  // headers attached to an assortment
                        {
                            DataRow[] asrtRows = _assortments.Select("AsrtRID = " + ahp.AsrtRID);
                            if (asrtRows.Length > 0)
                            {
                                if (asrtRows[0]["AsrtType"] != DBNull.Value)
                                {
                                    asrtType = (eAssortmentType)int.Parse(asrtRows[0]["AsrtType"].ToString());
                                }
                            }
                            else
                            {
                                asrtType = eAssortmentType.Undefined;
                            }
                            if (asrtType == eAssortmentType.GroupAllocation)
                            {
                                groupAllocRid = ahp.AsrtRID;
                            }
                            else
                            {
                                asrtRID = ahp.AsrtRID;
                                _lastAsrtSortSeq++;
                                asrtSortSeq = _lastAsrtSortSeq;
                            }
                            if (ahp.PlaceHolderRID != Include.NoRID)
                            {
                                phRID = ahp.PlaceHolderRID;
                            }
                        }
						// End TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace

                        object anchorHnRID = System.DBNull.Value;
                        string anchorNode = null;
                        if (headerType == (int)eHeaderType.Assortment  || headerType == (int)eHeaderType.Placeholder)
                        {
                            HierarchyNodeProfile anchorHnp = _hierMaint.GetAnchorNode(ahp.StyleHnRID);
                            if (anchorHnp.Key != Include.NoRID)
                            {
                                anchorHnRID = anchorHnp.Key;
                                anchorNode = anchorHnp.LevelText;
                            }
                        }

                        // BEGIN Workspace Usability Enhancement - Ron Matelic
                        packCount = System.DBNull.Value;
                        bulkColorCount = System.DBNull.Value;
                        bulkColorSizeCount = System.DBNull.Value;
                        if (ahp.PackCount > 0)
                        {
                            packCount = ahp.PackCount;
                        }
                        if (ahp.BulkColorCount > 0)
                        {
                            bulkColorCount = ahp.BulkColorCount;
                        }
                        if (ahp.BulkColorSizeCount > 0)
                        {
                            bulkColorSizeCount = ahp.BulkColorSizeCount;
                        }
                        // END Workspace  Usability Enhancement

						// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
						int adjustVSW = Include.NoRID;
						if (ahp.AdjustVSW_OnHand)
						{
							adjustVSW = (int)eAdjustVSW.Adjust;
						}
						else
						{
							if (headerType == (int)eHeaderType.IMO)
							{
								adjustVSW = (int)eAdjustVSW.Replace;
							}
						}
						// END TT#2225 - stodd - VSW ANF Enhancement (IMO)

                        //Begin TT#1313-MD -jsobek -Header Filters - Get Node display fields from the datatable rather than making a trip to the database
                        // Begin TT#457-MD - RMatelic - Add additional Header information to the Allocation Workspace
                        string otsForecast = string.Empty;
                        if (ahp.PlanHnRID != Include.DefaultPlanHnRID)
                        {
                            otsForecast = ahp.NodeDisplayForOtsForecast; //headerData.GetNodeDisplay(ahp.PlanHnRID);
                        }
                        
                        string onHand = string.Empty;
                        if (ahp.OnHandHnRID != Include.DefaultOnHandHnRID)
                        {
                            onHand = ahp.NodeDisplayForOnHand; //headerData.GetNodeDisplay(ahp.OnHandHnRID);
                        }

                        string gradeInvBasis = string.Empty;
                        if (ahp.GradeInventoryBasisHnRID > 0)
                        {
                            gradeInvBasis = ahp.NodeDisplayForGradeInvBasis; //headerData.GetNodeDisplay(ahp.GradeInventoryBasisHnRID);
                        }
                        // End TT#457-MD 
                        //End TT#1313-MD -jsobek -Header Filters - Get Node display fields from the datatable rather than making a trip to the database

                        // Begin T#1652-MD- RMatelic - DC Carton Rounding
                        unitsPerCarton = System.DBNull.Value;
                        if (ahp.UnitsPerCarton > 0)
                        {
                            unitsPerCarton = ahp.UnitsPerCarton;
                        }
                        // End TT#1652-md


                        if (headerType != (int)eHeaderType.Assortment && headerType != (int)eHeaderType.Placeholder)
                        {
                            // BEGIN TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
                            int storetot = 0;
                            int vSWtot = 0;
                            storetot = ahp.TotalItemUnitsAllocated - ahp.RsvAllocatedUnits;
                            vSWtot = ahp.AllocatedUnits - storetot;
                            // END TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
                            DataRow headerRow;
                            headerRow = _dtHeader.Rows.Add(new object[] 
                                          { ahp.Key, Include.NoRID, Include.NoRID, ahp.HeaderID, groupRID, 
                                            asrtRID, groupAllocRid, phRID, (int)securityLevel, headerType, ahp.HeaderDay,	// TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                                            headerStatus, anchorHnRID, anchorNode, parentRID, parentID, ahp.StyleHnRID, 
                                            hnp_style.LevelText, (int)styleSecurity, ahp.HeaderDescription,
                                            ahp.TotalUnitsToAllocate, System.DBNull.Value, 
                                            ahp.StoresWithAllocationCount,                 //TT#154 – Add # of stores variable to Allocation workspace
                                            packCount, bulkColorCount, bulkColorSizeCount,  // Workspace Usability Enhancement
                                            ahp.UnitRetail, ahp.UnitCost,
                                            unitsPerCarton, // T#1652-MD- RMatelic - DC Carton Rounding
                                            ahp.SizeGroupRID, ahp.AllocationMultipleDsply, ahp.PurchaseOrder, ahp.Vendor, // MID Track 5761 Allocation Multiple not saved on DB 
                                            workflowMethodStr, APIworkflowMethodStr, ahp.DistributionCenter, 
                                            intransitStatus, shipStatus, releaseDate, ahp.AllocationNotes,
                                            ahp.IsInterfaced, 0, multiSortSeq, msgMasterSubord, 
                                            ahp.AllocatedUnits, ahp.OrigAllocatedUnits,
                                            // Begin TT#1401 - RMatelic - Resevation Stores
                                            //ahp.RsvAllocatedUnits, ahp.AsrtType, asrtSortSeq });
                                            // begin TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1d
                                            //ahp.RsvAllocatedUnits, ahp.AsrtType, asrtSortSeq, ahp.ImoID, ahp.TotalItemUnitsAllocated, ahp.TotalItemOrigUnitsAllocate });  
											// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
                                         
                                            // Begin TT#457-MD - RMatelic - Add additional Header information to the Allocation Workspace >>> remove last 2 fields in next line  
                                            //ahp.RsvAllocatedUnits, ahp.AsrtType, asrtSortSeq, ahp.ImoID, adjustVSW, ahp.TotalItemUnitsAllocated, ahp.TotalItemOrigUnitsAllocated });
                                            // BEGIN TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
                                            // ahp.RsvAllocatedUnits, ahp.AsrtType, asrtSortSeq, ahp.ImoID, adjustVSW, otsForecast, onHand, gradeInvBasis });
                                            ahp.RsvAllocatedUnits, ahp.AsrtType, asrtSortSeq, ahp.ImoID, storetot, vSWtot, adjustVSW, otsForecast, onHand, gradeInvBasis });
                                            // END TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
                                            // End TT#457-MD
                            
                            // END TT#2225 - stodd - VSW ANF Enhancement (IMO)
                            // end TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                            // End TT#1401

                            AddCharacteristicsToHeader(headerRow, ahp.Characteristics, false);
                        }
                    }
				}
			}
			catch(Exception ex) 
			{
				HandleException(ex);
			}
		}

        private void AddCharacteristicsToHeader(DataRow aHeaderRow, HeaderCharProfileList aCharList, bool aUseDetailData)
        {
            try
            {
                DataTable dtHeader;
                if (aUseDetailData)
                {
                    dtHeader = _dtDetailHeader;
                }
                else
                {
                    dtHeader = _dtHeader;
                }    
                for (int i = _nonCharColCount; i < dtHeader.Columns.Count; i++)
                {
                    DataColumn col = (DataColumn)dtHeader.Columns[i];
                    if (col.ExtendedProperties.ContainsKey("IsChar"))
                    {
                        HeaderCharGroupProfile hcgp = (HeaderCharGroupProfile)col.ExtendedProperties["IsChar"];
                        HeaderCharProfile hcp = (HeaderCharProfile)aCharList.FindKey(hcgp.Key);
                        
                        aHeaderRow[col.ColumnName] = System.DBNull.Value;    
                        if (hcp.Text != null)
                        {
                            if (hcgp.ListInd) // uses a drop down list
                            {
                                //aHeaderRow[col.ColumnName] = hcp.Key;         // BEGIN MID Track #5488
                                aHeaderRow[col.ColumnName] = hcp.CharRID;       // END MID Track #5488    
                            }
                            else
                            {
                                aHeaderRow[col.ColumnName] = hcp.Text;
                                // need to save the char RID for update routine
                                // BEGIN MID Track #5488
                                string charString = string.Empty;               
                                if (hcp.HeaderCharType == eHeaderCharType.date)
                                {
                                    charString = hcgp.Key.ToString() + "~" + hcp.DateValue.ToString();
                                }
                                else
                                {
                                    charString = hcgp.Key.ToString() + "~" + hcp.Text;
                                }
                                if (!col.ExtendedProperties.ContainsKey(charString))
                                {
                                   // col.ExtendedProperties.Add(charString, hcp.Key);  // Track 5488
                                    col.ExtendedProperties.Add(charString, hcp.CharRID);
                                }
                            }   // END MID Track #5488
                        }
                    }
                } 
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        
		private HierarchyNodeProfile GetNodeData(int aHnRID)
		{
            try
            {
                if (_nodeDataHashLastKey != aHnRID)
                {
                    _nodeDataHashLastKey = aHnRID;
                    if (_nodeDataHash == null)
                    {
                        _nodeDataHash = new Hashtable();
                    }
                    if (_nodeDataHash.Contains(aHnRID))
                    {
                        _nodeDataHashLastValue = (HierarchyNodeProfile)_nodeDataHash[aHnRID];
                    }
                    else
                    {
                        _nodeDataHashLastValue = _SAB.HierarchyServerSession.GetNodeData(aHnRID, false);
                        _nodeDataHash.Add(aHnRID, _nodeDataHashLastValue);
                    }
                }
                return _nodeDataHashLastValue;
            }
            catch
            {
                throw;
            }
		}

        private void LoadGridValueLists()
        {
            try
            {
                // Multi Headers
                _multiHeaderValueList = new ValueList();
                _multiHeaderValueList.Key = "MultiHeader";

                foreach (DataRow dr in _multiHeaders.Rows)
                {
                    _multiHeaderValueList.ValueListItems.Add(Convert.ToInt32(dr["HdrRID"], CultureInfo.CurrentUICulture), dr["HeaderID"].ToString());
                }

                // Assortments
                _assortmentValueList = new ValueList();
                _assortmentValueList.Key = "AssortmentID";

                foreach (DataRow dr in _assortments.Rows)
                {
                    _assortmentValueList.ValueListItems.Add(Convert.ToInt32(dr["AsrtRID"], CultureInfo.CurrentUICulture), dr["AssortmentID"].ToString());
                }

                // PlaceHolders
                _placeHolderValueList = new ValueList();
                _placeHolderValueList.Key = "PlaceHolderID";

                foreach (DataRow dr in _placeHolders.Rows)
                {
                    _placeHolderValueList.ValueListItems.Add(Convert.ToInt32(dr["PlaceHolderRID"], CultureInfo.CurrentUICulture), dr["PlaceHolderID"].ToString());
                }

				// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
				// adjustVSW
                if (_adjustVSWValueList == null) //TT#1313-MD -jsobek -Header Filters -performance
                {
                    _adjustVSWValueList = LoadMIDTextValueList("AdjustVSW", eMIDTextType.eAdjustVSW, eMIDTextOrderBy.TextCode);
                    _adjustVSWValueList.ValueListItems.Add(Include.NoRID, "None");
                }
				// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)

                // Header Type
                // BEGIN TT#1966-MD - AGallagher - DC Fulfillment
                if (_headerTypeValueList == null) //TT#1313-MD -jsobek -Header Filters -performance
                {
                    _headerTypeValueList = LoadMIDTextValueList("HeaderType", eMIDTextType.eHeaderType, eMIDTextOrderBy.TextCode);
                    bool phRemoved = false, asrtRemoved = false; bool masterRemoved = false;
                    for (int i = _headerTypeValueList.ValueListItems.Count - 1; i >= 0; i--)
                    {
                        ValueListItem vli = _headerTypeValueList.ValueListItems[i];
                        int value = Convert.ToInt32(vli.DataValue, CultureInfo.CurrentUICulture);
                        if (value == Convert.ToInt32(eHeaderType.Master, CultureInfo.CurrentUICulture))
                        {
                            _headerTypeValueList.ValueListItems.Remove(vli);
                            masterRemoved = true;
                        }
							if (!_SAB.ClientServerSession.GlobalOptions.AppConfig.AssortmentInstalled)
							{
								if (value == Convert.ToInt32(eHeaderType.Assortment, CultureInfo.CurrentUICulture))
								{
									_headerTypeValueList.ValueListItems.Remove(vli);
									asrtRemoved = true;
								}
								else if (value == Convert.ToInt32(eHeaderType.Placeholder, CultureInfo.CurrentUICulture))
								{
									_headerTypeValueList.ValueListItems.Remove(vli);
									phRemoved = true;
								}
							}
                        if (asrtRemoved && phRemoved && masterRemoved)
                        {
                            break;
                        }
                    }
                }
                // END TT#1966-MD - AGallagher - DC Fulfillment
 
                // Header Status
                if (_headerStatusValueList == null) //TT#1313-MD -jsobek -Header Filters -performance
                {
                    _headerStatusValueList = LoadMIDTextValueList("Status", eMIDTextType.eHeaderAllocationStatus, eMIDTextOrderBy.TextCode);
                }
                
                // Header Intransit
                if (_headerIntransitValueList == null) //TT#1313-MD -jsobek -Header Filters -performance
                {
                    _headerIntransitValueList = LoadMIDTextValueList("Intransit", eMIDTextType.eHeaderIntransitStatus, eMIDTextOrderBy.TextCode);
                }
               
                // Header Ship Status
                if (_headerShipStatusValueList == null) //TT#1313-MD -jsobek -Header Filters -performance
                {
                    _headerShipStatusValueList = LoadMIDTextValueList("ShipStatus", eMIDTextType.eHeaderShipStatus, eMIDTextOrderBy.TextCode);
                }
               
                // Size Groups
                if (_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                {
                    _sizeGroupValueList = new ValueList();
                    _sizeGroupValueList.Key = "SizeGroup";
                    SizeGroupList sgl = new SizeGroupList(eProfileType.SizeGroup);
                    sgl.LoadAll(IncludeUndefinedGroup: true, doReadSizeCodeListFromDatabase: false); //TT#1313-MD -jsobek -Header Filters -performance
                    foreach (SizeGroupProfile sgp in sgl.ArrayList)
                    {
                        _sizeGroupValueList.ValueListItems.Add(sgp.Key, sgp.SizeGroupName);
                    }
                }
                
                // Pack Type
                if (_packTypeValueList == null) //TT#1313-MD -jsobek -Header Filters -performance
                {
                    _packTypeValueList = LoadMIDTextValueList("PackType", eMIDTextType.ePackType, eMIDTextOrderBy.TextCode);
                }
               
                // Characteristics
                // Begin TT#2726 - JSmith - Header Characteristic showing HC_RID instead of text in Header
                BuildCharacteristicValueLists();
                //_charValueListsHash  = new Hashtable();

                //foreach (HeaderCharGroupProfile hcgp in _headerCharGroupProfileList)
                //{
                //    if (hcgp.Characteristics.Count > 0)
                //    {
                //        ValueList charValueList = new ValueList();
                //        charValueList.Key = hcgp.ID;
                //        charValueList.ValueListItems.Add(Include.NoRID, Include.NoneText);
                //        foreach (HeaderCharInfo hci in hcgp.Characteristics.Values)
                //        {
                //            string value = GetCharacteristicValue(hci, hcgp.Type);
                //            charValueList.ValueListItems.Add(hci.RID, value);
                //        }
                //        _charValueListsHash.Add(hcgp.ID, charValueList);
                //    }    
                //}
                // End TT#2726 - JSmith - Header Characteristic showing HC_RID instead of text in Header

            }
            catch (Exception ex) 
			{
				HandleException(ex);
			}	
        }

        // Begin TT#2726 - JSmith - Header Characteristic showing HC_RID instead of text in Header
        private void BuildCharacteristicValueLists()
        {
            // Characteristics
            _charValueListsHash = new Hashtable();

            foreach (HeaderCharGroupProfile hcgp in _headerCharGroupProfileList)
            {
                if (hcgp.Characteristics.Count > 0)
                {
                    ValueList charValueList = new ValueList();
                    //charValueList.SortStyle = ValueListSortStyle.AscendingByValue; // TT#1910-MD - JSmith - Header characteristic values are in a different order in the maintenance function and the Allocation Workspace.
                    charValueList.Key = hcgp.Key.ToString(); //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                    // Begin TT#1910-MD - JSmith - Header characteristic values are in a different order in the maintenance function and the Allocation Workspace.
                    //charValueList.ValueListItems.Add(Include.NoRID, Include.NoneText);
                    //foreach (HeaderCharInfo hci in hcgp.Characteristics.Values)
                    //{
                    //    string value = GetCharacteristicValue(hci, hcgp.Type);
                    //    charValueList.ValueListItems.Add(hci.RID, value);
                    //}
                    SortedList sl = new SortedList();
                    foreach (HeaderCharInfo hci in hcgp.Characteristics.Values)
                    {
                        string value = GetCharacteristicValue(hci, hcgp.Type);
                        sl.Add(value, hci.RID);
                    }
                    foreach (DictionaryEntry de in sl)
                    {
                        charValueList.ValueListItems.Add(Convert.ToInt32(de.Value), Convert.ToString(de.Key));
                    }
                    charValueList.ValueListItems.Insert(0, Include.NoRID, Include.NoneText);
                    // End TT#1910-MD - JSmith - Header characteristic values are in a different order in the maintenance function and the Allocation Workspace.
                    _charValueListsHash.Add(hcgp.Key.ToString(), charValueList);
                }
            }
        }
        // End TT#2726 - JSmith - Header Characteristic showing HC_RID instead of text in Header

        private ValueList LoadMIDTextValueList(string aKey, eMIDTextType aMIDTextType, eMIDTextOrderBy aMIDTextOrderBy)
        {
            ValueList valueList = new ValueList();
            valueList.Key = aKey;
            try
            {
                DataTable dataTable = MIDText.GetTextType(aMIDTextType, aMIDTextOrderBy);

                foreach (DataRow dr in dataTable.Rows)
                {
                    valueList.ValueListItems.Add(Convert.ToInt32(dr["TEXT_CODE"], CultureInfo.CurrentUICulture), dr["TEXT_VALUE"].ToString());
                    if (Convert.ToInt32(dr["TEXT_CODE"], CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                    {
                        _lblPlaceholder = dr["TEXT_VALUE"].ToString();
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }

            return valueList;
        }

        private string GetCharacteristicValue(HeaderCharInfo aCharInfo, eHeaderCharType aCharType) 
        {
            string value = null; 
            try
            {
                switch (aCharType)
                {
                    case eHeaderCharType.text:
                        value = aCharInfo.TextValue;
                        break;

                    case eHeaderCharType.dollar:
                        value = Convert.ToString(aCharInfo.DollarValue, CultureInfo.CurrentUICulture);
                        break;

                    case eHeaderCharType.number:
                        value = Convert.ToString(aCharInfo.NumberValue, CultureInfo.CurrentUICulture);
                        break;

                    case eHeaderCharType.date:
                        value = Convert.ToString(aCharInfo.DateValue, CultureInfo.CurrentUICulture);
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }

            return value;
        }


        #endregion

		#region ugHeaders grid events and methods
		private void ugHeaders_InitializeLayout(object sender, Infragistics.Win.UltraWinGrid.InitializeLayoutEventArgs e)
		{
			try
			{
				if (_skipInitialize ||
                    (_allocationNonInterfacedHeadersSecurity.AccessDenied &&
                     _allocationInterfacedHeadersSecurity.AccessDenied))
				{
					return;
				}
                
                _multiHeaderGroups.Clear();
                _assortmentGroups.Clear();

				// check for saved layout
				InfragisticsLayoutData layoutData = new InfragisticsLayoutData();
				InfragisticsLayout layout = layoutData.InfragisticsLayout_Read(_SAB.ClientServerSession.UserRID, eLayoutID.allocationWorkspaceGrid);
				if (layout.LayoutLength > 0) 
				{
					ugHeaders.DisplayLayout.Load(layout.LayoutStream);
                    layoutData.InfragisticsLayout_Delete(_SAB.ClientServerSession.UserRID, eLayoutID.allocationWorkspaceGrid);
				}

				e.Layout.MaxRowScrollRegions = 1;
                e.Layout.MaxBandDepth = 1;

                // Begin TT#1680 - RMatelic - Allocation WS Highlight >>> move next line to after the ApplyDefaults which sets CellClickAction 
                //e.Layout.Override.CellClickAction = Infragistics.Win.UltraWinGrid.CellClickAction.RowSelect;
                // End TT#1680

                e.Layout.Override.HeaderClickAction = HeaderClickAction.SortMulti;
                //Begin TT#169 - JSmith - enter max of 1000 and receive 'must be integer'
                //MIDRetail.Windows.Controls.UltraGridLayoutDefaults ugld = new MIDRetail.Windows.Controls.UltraGridLayoutDefaults();
                //ugld.ApplyDefaults(e);
                MIDRetail.Windows.Controls.UltraGridLayoutDefaults ugld = new MIDRetail.Windows.Controls.UltraGridLayoutDefaults(ErrorImage);
                ugld.ApplyDefaults((Infragistics.Win.UltraWinGrid.UltraGrid)sender, e, false, 0, false);
                //End TT#169

                // Begin TT#1680 - RMatelic - Allocation WS Highlight >>> moved next from above 
                e.Layout.Override.CellClickAction = Infragistics.Win.UltraWinGrid.CellClickAction.RowSelect;
                // End TT#1680

                e.Layout.Grid.DrawFilter = new NoFocusRect(); // TT#3832 - RMatelic - When a row in a grid is unselected, remove the focus rectangle from the row

                // BEGIN MID Track #5467 - Override Default; display Column Chooser
                e.Layout.Override.RowSelectorHeaderStyle = RowSelectorHeaderStyle.ColumnChooserButton;
                // END MID Track #5467 
				e.Layout.Override.SelectTypeGroupByRow = SelectType.Extended;
				e.Layout.UseFixedHeaders = true;
                // Begin TT#305 - RMatelic - Multi Header received error message "Not Supported Exception Message"  
                e.Layout.Bands[0].Override.AllowAddNew = AllowAddNew.Yes;
                // End TT#305   
				e.Layout.Bands[0].Columns["HeaderID"].Header.Fixed = true;
				e.Layout.Bands[0].Columns["HeaderID"].Style  = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
				e.Layout.Bands[0].Columns["HeaderID"].ButtonDisplayStyle = Infragistics.Win.UltraWinGrid.ButtonDisplayStyle.Always;
				
				e.Layout.Bands[0].Columns["KeyH"].Hidden = true;
				e.Layout.Bands[0].Columns["KeyP"].Hidden = true;
				e.Layout.Bands[0].Columns["KeyC"].Hidden = true;
                e.Layout.Bands[0].Columns["PlaceHolderRID"].Hidden = true;
          		e.Layout.Bands[0].Columns["FunctionSecurity"].Hidden = true;
				e.Layout.Bands[0].Columns["StyleSecurity"].Hidden = true;
				e.Layout.Bands[0].Columns["Notes"].Hidden = true;
                e.Layout.Bands[0].Columns["Interfaced"].Hidden = true;
                e.Layout.Bands[0].Columns["AnchorHnRID"].Hidden = true;
				e.Layout.Bands[0].Columns["ProductRID"].Hidden = true;
                e.Layout.Bands[0].Columns["StyleHnRID"].Hidden = true;
				e.Layout.Bands[0].Columns["ChildTotal"].Hidden = true;
				e.Layout.Bands[0].Columns["MultiSortSeq"].Hidden = true;
                e.Layout.Bands[0].Columns["AsrtType"].Hidden = true;
                e.Layout.Bands[0].Columns["AsrtSortSeq"].Hidden = true;
				e.Layout.Bands[0].Columns["CharUpdated"].Hidden = true;
				e.Layout.Bands[0].Columns["HeaderRow"].Hidden = true; 

				if (!this._SAB.ClientServerSession.GlobalOptions.AppConfig.MasterAllocationInstalled)
				{
					e.Layout.Bands[0].Columns["Master"].Hidden = true;
                    // BEGIN TT#678 - AGallagher - Alloc Workspace - Allocated Units, Original Allocated Units, and Reserve Allocated Units displaying "0" for allocated headers
                    //e.Layout.Bands[0].Columns["AllocatedUnits"].Hidden = true;
                    //e.Layout.Bands[0].Columns["OrigAllocatedUnits"].Hidden = true;
                    //e.Layout.Bands[0].Columns["RsvAllocatedUnits"].Hidden = true;
                    // END TT#678 - AGallagher - Alloc Workspace - Allocated Units, Original Allocated Units, and Reserve Allocated Units displaying "0" for allocated headers
					e.Layout.Bands[0].Columns["Master"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                    // BEGIN TT#678 - AGallagher - Alloc Workspace - Allocated Units, Original Allocated Units, and Reserve Allocated Units displaying "0" for allocated headers
                    //e.Layout.Bands[0].Columns["AllocatedUnits"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; 
                    //e.Layout.Bands[0].Columns["OrigAllocatedUnits"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; 
                    //e.Layout.Bands[0].Columns["RsvAllocatedUnits"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                    // END TT#678 - AGallagher - Alloc Workspace - Allocated Units, Original Allocated Units, and Reserve Allocated Units displaying "0" for allocated headers
				}

				// BEGIN TT#488-MD - Stodd - Group Allocation
				// We want the Assortment column to display for group allocation
                //if (!_SAB.ClientServerSession.GlobalOptions.AppConfig.AssortmentInstalled)
                //{
                    //e.Layout.Bands[0].Columns["AsrtRID"].Hidden = true;
                    // Begin TT#2 - RMatelic - Assortment Planning
                    //e.Layout.Bands[0].Columns["AnchorNode"].Hidden = true;
                    // End TT#2
                   // e.Layout.Bands[0].Columns["AsrtRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                    // Begin TT#2 - RMatelic - Assortment Planning
                    //e.Layout.Bands[0].Columns["AnchorNode"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; 
                    // End TT#2
                //}
				// END TT#488-MD - Stodd - Group Allocation

                // Begin TT#2 - RMatelic - Assortment Planning
                e.Layout.Bands[0].Columns["AnchorNode"].Hidden = true;
                e.Layout.Bands[0].Columns["AnchorNode"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                // End TT#2 
				e.Layout.Bands[0].Columns["KeyH"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; 
				e.Layout.Bands[0].Columns["KeyP"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; 
				e.Layout.Bands[0].Columns["KeyC"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; ;
				e.Layout.Bands[0].Columns["FunctionSecurity"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                e.Layout.Bands[0].Columns["HeaderID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                e.Layout.Bands[0].Columns["PlaceHolderRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; 
				e.Layout.Bands[0].Columns["StyleSecurity"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; 
				e.Layout.Bands[0].Columns["Notes"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;

                e.Layout.Bands[0].Columns["Status"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                e.Layout.Bands[0].Columns["Style"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                e.Layout.Bands[0].Columns["HdrQuantity"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;

                e.Layout.Bands[0].Columns["Interfaced"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                e.Layout.Bands[0].Columns["AnchorHnRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
				e.Layout.Bands[0].Columns["ProductRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                e.Layout.Bands[0].Columns["StyleHnRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; 
				e.Layout.Bands[0].Columns["ChildTotal"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; 
				e.Layout.Bands[0].Columns["MultiSortSeq"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                e.Layout.Bands[0].Columns["AsrtType"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                e.Layout.Bands[0].Columns["AsrtSortSeq"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
				e.Layout.Bands[0].Columns["CharUpdated"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True; 
				e.Layout.Bands[0].Columns["HeaderRow"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;

                // Begin TT#963 - MD - stodd - exclude "AssortmentID" when assortment not installed
                if (_SAB.ClientServerSession.GlobalOptions.AppConfig.AssortmentInstalled)
                {
                    e.Layout.Bands[0].Columns["AsrtRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.False;
                }
                else
                {
                    e.Layout.Bands[0].Columns["AsrtRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                }
                // End TT#963 - MD - stodd - exclude "AssortmentID" when assortment not installed


                if (!_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                {
                    e.Layout.Bands[0].Columns["SizeGroup"].Hidden = true;
                }
				e.Layout.Bands[0].Columns["HeaderID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_HeaderID);
			    e.Layout.Bands[0].Columns["HdrGroupRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_MultiHeaderID);
				// BEGIN TT#488-MD - Stodd - Group Allocation
                // BEGIN TT#893-MD - Stodd - add group allocation ID column
                if (_SAB.ClientServerSession.GlobalOptions.AppConfig.AssortmentInstalled)
                {
                    e.Layout.Bands[0].Columns["AsrtRID"].Hidden = false;
                }
                else
                {
                    e.Layout.Bands[0].Columns["AsrtRID"].Hidden = true;

                }
				// Begin TT#1247-MD - stodd - Add Group Allocation as a License Key option -
                if (_SAB.ClientServerSession.GlobalOptions.AppConfig.GroupAllocationInstalled)
                {
                    e.Layout.Bands[0].Columns["GroupAllocRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.False;
                    e.Layout.Bands[0].Columns["GroupAllocRID"].Hidden = false;
                }
                else
                {
                    e.Layout.Bands[0].Columns["GroupAllocRID"].ExcludeFromColumnChooser = ExcludeFromColumnChooser.True;
                    e.Layout.Bands[0].Columns["GroupAllocRID"].Hidden = true;
                }
				// End TT#1247-MD - stodd - Add Group Allocation as a License Key option -
				e.Layout.Bands[0].Columns["AsrtRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AssortmentID);
				e.Layout.Bands[0].Columns["GroupAllocRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_GroupAllocationID);
                // END TT#893-MD - Stodd - add group allocation ID column
				// END TT#488-MD - Stodd - Group Allocation
                //e.Layout.Bands[0].Columns["PlaceHolderRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_PlaceholderID);
			    e.Layout.Bands[0].Columns["Type"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Type);
				e.Layout.Bands[0].Columns["Date"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Date);
				e.Layout.Bands[0].Columns["Status"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_HeaderStatus);
                e.Layout.Bands[0].Columns["AnchorNode"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AnchorNode);
				e.Layout.Bands[0].Columns["Product"].Header.Caption = _hlpProduct.LevelID;
				e.Layout.Bands[0].Columns["Style"].Header.Caption = _hlpStyle.LevelID;
				e.Layout.Bands[0].Columns["Description"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_WorkspaceDescription);
				e.Layout.Bands[0].Columns["HdrQuantity"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Quantity);
				e.Layout.Bands[0].Columns["Balance"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Balance);
				e.Layout.Bands[0].Columns["UnitRetail"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_UnitRetail);
				e.Layout.Bands[0].Columns["UnitCost"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_UnitCost);
				e.Layout.Bands[0].Columns["SizeGroup"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_SizeGroup);
				e.Layout.Bands[0].Columns["Multiple"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Multiple);
				e.Layout.Bands[0].Columns["PO"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_PurchaseOrder);
				e.Layout.Bands[0].Columns["Vendor"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Vendor);
				e.Layout.Bands[0].Columns["Workflow"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Workflow);
				e.Layout.Bands[0].Columns["APIWorkflow"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_APIWorkflow);
				e.Layout.Bands[0].Columns["DC"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_DistCenter);
				e.Layout.Bands[0].Columns["Intransit"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Intransit);
				e.Layout.Bands[0].Columns["ShipStatus"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ShipStatus);
				e.Layout.Bands[0].Columns["Release"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Release);
				e.Layout.Bands[0].Columns["ChildTotal"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ChildTotal);
    			e.Layout.Bands[0].Columns["Master"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_MasterSubord);
				e.Layout.Bands[0].Columns["AllocatedUnits"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AllocatedUnits);
				e.Layout.Bands[0].Columns["OrigAllocatedUnits"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_OrigAllocatedUnits);
				e.Layout.Bands[0].Columns["RsvAllocatedUnits"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_RsvAllocatedUnits);

                //BEGIN TT#154 – Add # of stores variable to Allocation workspace - apicchetti
                e.Layout.Bands[0].Columns["NumberOfStores"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_NumberOfStores);
                //END TT#154 – Add # of stores variable to Allocation workspace - apicchetti
                // BEGIN Workspace Usability Enhancement - Ron Matelic
                e.Layout.Bands[0].Columns["NumPacks"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_NumPacks);
                e.Layout.Bands[0].Columns["NumBulkColors"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_NumBulkColors);
                e.Layout.Bands[0].Columns["NumBulkSizes"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_NumBulkSizes);
                // END Workspace Usability Enhancement 
                
                // Begin TT#1401 - RMatelic - Reservation Stores
                e.Layout.Bands[0].Columns["ImoId"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_IMO_ID);
				// BEGIN TT1401 - stodd - TEMP removal of these fields from displaying on Alloc workspace
                // BEGIN TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
				e.Layout.Bands[0].Columns["ItemUnitsAllocated"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ItemUnitsAllocated);
				e.Layout.Bands[0].Columns["ItemOrigUnitsAllocated"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ItemOrigUnitsAllocated);
                // END TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
				// END TT1401 - stodd - TEMP removal of these fields from displaying on Alloc workspace
                // End TT#1401
                e.Layout.Bands[0].Columns["AdjustVSW"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AdjustVSW_OnHand); // TT#2225 - JEllis - AnF VSW FWOS Enhancement pt 1

                // Begin TT#457-MD - RMatelic - Add additional Header information to the Allocation Workspace
                e.Layout.Bands[0].Columns["PlanHnRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_OTSPlan);
                e.Layout.Bands[0].Columns["OnHandHnRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_OnHand);
                e.Layout.Bands[0].Columns["GradeInvHnRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_InventoryBasis);  
                // End TT#457-MD 
                // Begin TT#1652-MD - RMatelic - DC Carton Roundng
                e.Layout.Bands[0].Columns["UnitsPerCarton"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_UnitsPerCarton);  
                // End TT#1652-MD
                e.Layout.Bands[0].Columns["HeaderID"].Width = 150;
				e.Layout.Bands[0].Columns["HdrGroupRID"].Width = 150;
				
                e.Layout.Bands[0].Columns["Type"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                e.Layout.Bands[0].Columns["SizeGroup"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                e.Layout.Bands[0].Columns["HdrGroupRID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
				// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
				e.Layout.Bands[0].Columns["AdjustVSW"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
				// END TT#2225 - stodd - VSW ANF Enhancement (IMO)
               
                AssignValueLists(ugHeaders);
                           
                FormatColumns(ugHeaders);
                
                CheckSortedColumn(e.Layout.Bands[0].SortedColumns, "HdrGroupRID", true);
                e.Layout.Bands[0].SortedColumns.Add("MultiSortSeq", false, false);
                CheckSortedColumn(e.Layout.Bands[0].SortedColumns, "AsrtRID", true);
                CheckSortedColumn(e.Layout.Bands[0].SortedColumns, "PlaceHolderRID", false);
                e.Layout.Bands[0].SortedColumns.Add("AsrtSortSeq", false, false);

                _skipInitialize = true;
			}
			catch
			{
				throw;
			}
		}

        private void CheckSortedColumn(SortedColumnsCollection sortedColumns, string colName, bool sortDescending)
        {
            try
            {
                if (!sortedColumns.Exists(colName))
                {
                    sortedColumns.Add(colName, sortDescending, false);
                }
                else if (!sortedColumns[colName].IsGroupByColumn)
                {
                    sortedColumns.Add(colName, sortDescending, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void ugHeaders_InitializeRow(object sender, InitializeRowEventArgs e)
        {
            try
            {
                if (e.Row.IsGroupByRow)
                {
                    LoopGroupByRow(e.Row);
                }
                else
                {
                    SetHeaderRowInfo(e.Row);
                }
            }
            catch
            {
                throw;
            }
        }

		private void LoopGroupByRow(UltraGridRow aGroupByRow)
		{
            try
            {    
			    UltraGridRow childRow = aGroupByRow.GetChild(ChildRow.First);
			    while (childRow != null)
			    { 
				    if (childRow.IsGroupByRow) 
				    {
					    LoopGroupByRow(childRow);
				    }
				    else
				    {
                        SetHeaderRowInfo(childRow);
				    }
				    childRow = childRow.GetSibling( SiblingRow.Next, false, false );
			    }
            }
            catch
            {
                throw;
            }
		}

        private void SetHeaderRowInfo(UltraGridRow aRow)
        {
            eHeaderType headerType;
            eHeaderAllocationStatus headerStatus;
            try
            {
                // Begin TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0
                if (aRow.IsGroupByRow)
                {
                    return;
                }

                // Begin TT#1238 - RMatelic - Data Error when clicking into the Status Header Characteristic
                //aRow.Activation = Activation.ActivateOnly;
                aRow.Activation = Activation.NoEdit;
                //End TT#1238
                SetNotesCellButton(aRow);
                headerType = (eHeaderType)Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
               
                switch (headerType)
                {
                    case eHeaderType.MultiHeader:
                        CheckMultiHeaderHash(aRow);
                        break;

                    case eHeaderType.Assortment:
                        CheckAssortHeaderHash(aRow);
                        aRow.Hidden = true; // TT#2 - Assortment Planning
                        break;

                    case eHeaderType.Placeholder:
                        CheckAssortHeaderHash(aRow);
                        eAssortmentType asrtType = GetAssortmentTypeForHeaderGrid(aRow);
                        //if (asrtType == eAssortmentType.PostReceipt)
                        //{
                               aRow.Hidden = true;
                        //}
                        //else
                        //{
                        //    aRow.Cells["HeaderID"].Appearance.ForeColor = aRow.Band.Layout.Override.FixedCellAppearance.BackColor;
                        //    aRow.Cells["HeaderID"].SelectedAppearance.ForeColor = System.Drawing.SystemColors.Highlight;
                        //}
                        break;

                    default:
                        if (aRow.Cells["Status"].Value != DBNull.Value)   // null status occurs when a new header is first saved
                        {
                            headerStatus = (eHeaderAllocationStatus)Convert.ToInt32(aRow.Cells["Status"].Value, CultureInfo.CurrentUICulture);

                            switch (headerStatus)
                            {
                                case eHeaderAllocationStatus.InUseByMultiHeader:
                                    CheckMultiHeaderHash(aRow);
                                    break;

                                default:
                                    if (aRow.Cells["AsrtRID"].Value != DBNull.Value)
                                    {
                                        CheckAssortHeaderHash(aRow);
                                    }
                                    break;
                            }
                        }    
                        break;
                }
            }
            catch
            {
                throw;
            }
        }

        private void SetNotesCellButton(UltraGridRow aRow)
        {
            try
            {
                // Begin TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0
                if (aRow.IsGroupByRow)
                {
                    return;
                }
                // End TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0

                string notes = Convert.ToString(aRow.Cells["Notes"].Value, CultureInfo.CurrentUICulture);
                if (notes != null && notes.Trim() != string.Empty)
                {
                    aRow.Cells["HeaderID"].ButtonAppearance.Image = NotesImage;
                }
                else if (_inEditMode)
                {   // Begin TT#2 - Ron Matelic Assortment Planning
                    //if (Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                    if (aRow.Cells["AsrtRID"].Value != System.DBNull.Value)
                    // Begin TT#2
                    { 
                        // change the cell style so the edit button doesn't show
                        aRow.Cells["HeaderID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.Edit;
                    }
                    else
                    {
                        aRow.Cells["HeaderID"].ButtonAppearance.Image = null;
                    } 
                }
                else
                {   // change the cell style so the edit button doesn't show
                    aRow.Cells["HeaderID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.Edit;
                }
            }
            catch
            {
                throw;
            }
        }

        private void CheckMultiHeaderHash(UltraGridRow aRow)
        {
            int hdrGroupRID, hdrRID;
            Hashtable multiHeaderListHash;
            eHeaderType headerType;
            try
            {
                headerType = (eHeaderType)Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                hdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                hdrGroupRID = Convert.ToInt32(aRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);

                // Begin TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0
                if (hdrGroupRID == Include.NoRID)
                {
                    return;
                }
                // End TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0

                switch (headerType)
                {
                    case eHeaderType.MultiHeader:
                        if (!_multiHeaderGroups.ContainsKey(hdrRID))
                        {
                            multiHeaderListHash = new Hashtable();
                            multiHeaderListHash.Add(hdrRID, aRow);
                            _multiHeaderGroups.Add(hdrRID, multiHeaderListHash);
                        }
                        else
                        {
                            multiHeaderListHash = (Hashtable)_multiHeaderGroups[hdrRID];
                            UltraGridRow row = (UltraGridRow)multiHeaderListHash[hdrRID];
                            if (row == null)
                            {
                                multiHeaderListHash[hdrRID] = aRow;
                            }
                        }
                        break;

                    default: // the "InUseByMulti" headers 
                        if (!_multiHeaderGroups.ContainsKey(hdrGroupRID))
                        {
                            multiHeaderListHash = new Hashtable();
                            multiHeaderListHash.Add(hdrGroupRID, null);
                            _multiHeaderGroups.Add(hdrGroupRID, multiHeaderListHash);
                        }
                        multiHeaderListHash = (Hashtable)_multiHeaderGroups[hdrGroupRID];

                        if (!multiHeaderListHash.ContainsKey(hdrRID))
                        {
                            multiHeaderListHash.Add(hdrRID, aRow);
                        }
                        break;
                }
            }
            catch
            {
                throw;
            }
        }

        private void CheckAssortHeaderHash(UltraGridRow aRow)
        {
            int asrtRID, hdrRID;
            Hashtable asrtHeaderListHash;
            eHeaderType headerType;
            try
            {
                headerType = (eHeaderType)Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                hdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
       
                switch (headerType)
                {
                    case eHeaderType.Assortment:
                        if (!_assortmentGroups.ContainsKey(hdrRID))
                        {
                            asrtHeaderListHash = new Hashtable();
                            asrtHeaderListHash.Add(hdrRID, aRow);
                            _assortmentGroups.Add(hdrRID,asrtHeaderListHash);
                        }
                        else
                        {
                            asrtHeaderListHash = (Hashtable)_assortmentGroups[hdrRID];
                            UltraGridRow row = (UltraGridRow)asrtHeaderListHash[hdrRID];
                            if (row == null)
                            {
                                asrtHeaderListHash[hdrRID] = aRow;
                            }
                        }
                        break;

                    default: // the other headers
                        asrtRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                        if (!_assortmentGroups.ContainsKey(asrtRID))
                        {
                            asrtHeaderListHash = new Hashtable();
                            asrtHeaderListHash.Add(asrtRID, null);
                            _assortmentGroups.Add(asrtRID, asrtHeaderListHash);
                        }
                        asrtHeaderListHash = (Hashtable)_assortmentGroups[asrtRID];

                        if (!asrtHeaderListHash.ContainsKey(hdrRID))
                        {
                            asrtHeaderListHash.Add(hdrRID, aRow);
                        }
                        break;
                }
            }
            catch
            {
                throw;
            }
        }
       
        private eAssortmentType GetAssortmentTypeForHeaderGrid(UltraGridRow aRow)
        {
			// Begin TT#911 - MD - stodd - double click to open assortment
            //DebugGridRow(aRow);
            eAssortmentType asrtType = eAssortmentType.Undefined;
            try
            {
                int asrtRID;
                DebugGridRow(aRow);
                if (int.TryParse(aRow.Cells["AsrtRID"].Value.ToString(), out asrtRID))
                {
                    // Found Assortment
                }
                else if (int.TryParse(aRow.Cells["GroupAllocRID"].Value.ToString(), out asrtRID))
                {
                    // FOund Group Allocation
                }

                if (asrtRID > 0)
                {
                    //int asrtRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                    AllocationHeaderProfile ahp = SAB.HeaderServerSession.GetHeaderData(asrtRID,false,false,true);
                    asrtType = (eAssortmentType)ahp.AsrtType;
                    //DataRow dr = _dtHeader.Rows.Find(asrtRID);
                    //if (dr != null)
                    //{
                    //    asrtType = (eAssortmentType)dr["AsrtType"];
                    //}
                }
				// End TT#911 - MD - stodd - double click to open assortment
            }
            catch
            {
                throw;
            }
            return asrtType;
        }

		// Begin TT#911 - MD - stodd - double click to open assortment
        private void DebugGridRow(UltraGridRow aRow)
        {
            foreach (UltraGridCell aCell in aRow.Cells)
            {
                Debug.WriteLine(aCell.Column.Key + " " + aCell.Value);
            }
        }
		// End TT#911 - MD - stodd - double click to open assortment

		private void ugHeaders_BeforeColumnChooserDisplayed(object sender, Infragistics.Win.UltraWinGrid.BeforeColumnChooserDisplayedEventArgs e)
		{
			try
			{
               	e.Dialog.Text = _lblColumnChooser;
                e.Dialog.ColumnChooserControl.ColumnDisplayOrder  = ColumnDisplayOrder.SameAsGrid;
                e.Dialog.ColumnChooserControl.ContextMenuStrip = cmsColumnChooser;
                e.Dialog.DisposeOnClose = DefaultableBoolean.True; // this causes the Chooser to match the grid order on subsequent opens
			}
			catch
			{
				throw;
			}
		}

		private void ugHeaders_AfterColPosChanged(object sender, Infragistics.Win.UltraWinGrid.AfterColPosChangedEventArgs e)
		{	
			// This is fired when the ColumnChooser is maintained; we need to sync the ugDetails grid
			try
			{
                if (ugDetails.DisplayLayout.Bands[0].Columns.Count > 0)
                {
                    foreach (Infragistics.Win.UltraWinGrid.ColumnHeader colHeader in e.ColumnHeaders)
                    {
                        switch (e.PosChanged)
                        {
                            case PosChanged.HiddenStateChanged:
                                ugDetails.DisplayLayout.Bands[0].Columns[colHeader.Column.Key].Hidden = colHeader.Column.Hidden;
                                break;

                            case PosChanged.Moved:
                                ugDetails.DisplayLayout.Bands[0].Columns[colHeader.Column.Key].Header.VisiblePosition = colHeader.VisiblePosition;
                                break;

                            case PosChanged.Sized:
                                ugDetails.DisplayLayout.Bands[0].Columns[colHeader.Column.Key].Width = colHeader.Column.Width;
                                break;

                            default:
                                break;
                        }
                    }
                }
            }
			catch( Exception ex) 
			{
				HandleException(ex);
			}
		}

        private void ugHeaders_BeforeSelectChange(object sender, BeforeSelectChangeEventArgs e)
        {
            try
            {
                // Begin TT#727 -  RMatelic -Error on Allocation Workspace Filter
                if (_fromFilterWindow)
                {
                    e.Cancel = true;
                    return;
                }
                // End TT#727

                // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
                // this is firing when ungrouping(sometimes) which is the reason for the _unGrouping switches.
                // unsure of the true cause since this event should be shut off by the BeforeSort event 
                // and why it enters here twice when there are 3 grouped columns and 1 is removed is a mystery
                if (_cancelSelectEvent)
                {
                    _cancelSelectEvent = false;
                    e.Cancel = true;
                }
                else if (typeof(UltraGridGroupByRow) == e.Type && _unGrouping)
                {
                    _unGrouping = false;
                    e.Cancel = true;
                }
                else if (typeof(UltraGridGroupByRow) == e.Type && _unGrouping2) // this one is hokey (for 3 Groups)
                {
                    _unGrouping2 = false;
                    e.Cancel = true;
                }
                // END MID Track #6407    
                else if (typeof(UltraGridRow) == e.Type)
                {
                    if (ugHeaders.Selected.Rows.Count > 0)
                    {
                        foreach (UltraGridRow prevSelRow in ugHeaders.Selected.Rows)
                        {
                            // Begin TT#606-MD - JSmith - Allocation Workspace receive error after creating a multi with filter for reserve and receipt headers only.
                            if (prevSelRow.Disposed || prevSelRow.IsDeleted)
                            {
                                continue;
                            }
                            // End TT#606-MD - JSmith - Allocation Workspace receive error after creating a multi with filter for reserve and receipt headers only.
                            if (!prevSelRow.IsGroupByRow  && Convert.ToInt32(prevSelRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                            {
                                prevSelRow.Cells["HeaderID"].Appearance.ForeColor = prevSelRow.Band.Layout.Override.FixedCellAppearance.BackColor;
                            }
                        }
                    }
                }
                // Begin TT#1000 - RMatelic - WUB Header and Cancelled the Allocation the header goes to received in balance and the qty is 0.  However the components still remain and are populated with values.
                //                 Remove TT#955 addition
                // Begin TT#955 - RMatelic - System Out of Memory Exception >> clear out the Allocation Profiles previously selected
                //_allocProfileList = null;
                //System.GC.Collect();
                //_allocProfileList = new AllocationProfileList(eProfileType.Allocation);
                // End TT#955
                // End TT#1000
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		// BEGIN TT#488-MD - STodd - Group Allocation - 
		private void ugHeaders_DoubleClickRow(object sender, DoubleClickRowEventArgs e)
		{
			if (e.Row.Band.Key == "Header" && e.RowArea == RowArea.RowSelectorArea)
			{
				// Begin TT#911 - MD - stodd - double click to open assortment
                eAssortmentType at = GetAssortmentTypeForHeaderGrid(e.Row);
                if (at == eAssortmentType.GroupAllocation)
                {
                    // Begin TT#1007 - md - stodd - change group allocation security - 
                    if (!_groupAllocationSecurity.AccessDenied)
                    {
                        ShowGroupAllocation();
                    }
                    // End TT#1007 - md - stodd - change group allocation security - 
                }
                else
                {
                    ShowAssortment();
                }
				// End TT#911 - MD - stodd - double click to open assortment
			}

		}

		private void ugHeaders_DoubleClickCell(object sender, DoubleClickCellEventArgs e)
		{
			if (e.Cell.Row.Band.Key == "Header")
			{
				// Begin TT#911 - MD - stodd - double click to open assortment
                eAssortmentType at = GetAssortmentTypeForHeaderGrid(e.Cell.Row);
                if (at == eAssortmentType.GroupAllocation)
                {
                    // Begin TT#1007 - md - stodd - change group allocation security - 
                    if (!_groupAllocationSecurity.AccessDenied)
                    {
                        ShowGroupAllocation();
                    }
                    // End TT#1007 - md - stodd - change group allocation security - 
                }
                else
                {
                    ShowAssortment();
                }
				// End TT#911 - MD - stodd - double click to open assortment
			}

		}
		// END TT#488-MD - STodd - Group Allocation - 

        // Begin  TT#1106 - RMatelic - Unable to drag highlight headers in workspace
        private void ugHeaders_MouseUp(object sender, MouseEventArgs e)
        {
            try
            {
                if (e.Button == MouseButtons.Left)
                {
                    _leftMouseDown = false;
                }
            }
            catch
            {
                throw;
            }
        }
        // End  TT#1106  

        // Begin TT#1038 - JSmith - Out of memory when right click and filter
        private void ugHeaders_AfterSelectChange(object sender, Infragistics.Win.UltraWinGrid.AfterSelectChangeEventArgs e)
        {
            _sender = sender;
            _afterSelectChangeEventArgs = e;

            //Begin  TT#1107 - RMatelic - Once headers are selected, cannot apply a second rule without applying to all 3 headers
            if (_controlKeyPressedUpperGrid)
            {
                _controlKeyPressedUpperGrid = false;
                AfterSelectChange(sender, e);
            }
            // End TT#1107
            // Begin  TT#1106 - RMatelic - Unable to drag highlight headers in workspace
            else if (_leftMouseDown)
            {
                AfterSelectChange(sender, e);
            }
            // End TT#1106
            // Begin TT#1237 - RMatelic - Selecting headers using Shift + Arrow Keys
            else if (_shiftPlusArrowKeyPressed)
            {
                _shiftPlusArrowKeyPressed = false;
                AfterSelectChange(sender, e);
            }
            // End TT#1237 

            // Begin TT#1240 - JSmith - System Memory Error
            System.GC.Collect();
            // End TT#1240
        }
        private void AfterSelectChange(object sender, Infragistics.Win.UltraWinGrid.AfterSelectChangeEventArgs e)
        // End TT#1038
		{
            try
            {
                if (typeof(UltraGridRow) == e.Type || typeof(UltraGridGroupByRow) == e.Type)
                {
                    Cursor.Current = Cursors.WaitCursor;     // TT#521-RMatelic-Workspace performance slow when grouped; add hour glass to let user know something is happening
                    // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    //ugDetails.BeginUpdate();
                    //ugDetails.SuspendRowSynchronization();
                    ugDetailsBeginUpdate();
                    ugDetailsSuspendRowSynchronization();
                    // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    if (_inEditMode)
                    {
                        // disable event firing
                        ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                        if (typeof(UltraGridRow) == e.Type) //MID Track 4449, 4451, 4452
                        {
                            foreach (UltraGridRow selRow in ugHeaders.Selected.Rows)
                            {
                                if (selRow.Cells["HdrGroupRID"].Value != DBNull.Value)
                                {
                                    int hdrGroupRID = Convert.ToInt32(selRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);
                                    if (_multiHeaderGroups.ContainsKey(hdrGroupRID))
                                    {
                                        Hashtable multiHeaderListHash = (Hashtable)_multiHeaderGroups[hdrGroupRID];
                                        foreach (UltraGridRow row in multiHeaderListHash.Values)
                                        {
                                            row.Selected = true;
                                        }
                                    }
                                }
                                else if (selRow.Cells["AsrtRID"].Value != DBNull.Value)
                                {
                                    int asrtRID = Convert.ToInt32(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                                    if (_assortmentGroups.ContainsKey(asrtRID))
                                    {
                                        Hashtable asrtHeaderListHash = (Hashtable)_assortmentGroups[asrtRID];
                                        foreach (UltraGridRow row in asrtHeaderListHash.Values)
                                        {
                                            // Begin TT#386 - JSmith - Allocation Workspace - Created a header type of ASN, put in Edit mode changed to Reciept using the drop down, the type remained ASN but when I selected SAVE it changed to Receipt. Would expect it to change when selected from drop down.
                                            //row.Selected = true;
                                            //if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                                            //{
                                            //    row.Cells["HeaderID"].SelectedAppearance.ForeColor = System.Drawing.SystemColors.Highlight;
                                            //}
                                            if (row != null)
                                            {
                                                row.Selected = true;
                                                if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                                                {
                                                    row.Cells["HeaderID"].SelectedAppearance.ForeColor = System.Drawing.SystemColors.Highlight;
                                                }
                                            }
                                            // End TT#386 - JSmith - Allocation Workspace - Created a header type of ASN, put in Edit mode changed to Reciept using the drop down, the type remained ASN but when I selected SAVE it changed to Receipt. Would expect it to change when selected from drop down.
                                        }
                                    }
                                }
                            }
                        }
                        // re-enable event firing
                        ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                        // Begin TT#386-MD - JSmith - Created a header type of ASN, put in Edit mode changed to Reciept using the drop down, the type remained ASN but when I selected SAVE it changed to Receipt
                        // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                        //ugDetails.ResumeRowSynchronization();
                        //ugDetails.EndUpdate();
                        ugDetailsResumeRowSynchronization();
                        ugDetailsEndUpdate();
                        // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                        // End TT#386-MD - JSmith - Created a header type of ASN, put in Edit mode changed to Reciept using the drop down, the type remained ASN but when I selected SAVE it changed to Receipt
                        return;
                    }

                    bool rowsSelected = false;
                    _fromHeaderGrid = true;
                    // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?

                    //if (_dsDetails != null)
                    //{
                    //    _dsDetails.Clear();
                    //}

                    //ugDetails.ResetLayouts();
                    //ApplyAppearance(ugDetails);
                    //// BEGIN MID Track #6103 - Header selection sequence inconsistent
                    //// BEGIN MID Track #6264 - Headers not in priority order - add global _selectedRowsSequence
                    ////ArrayList selRowsSeq = new ArrayList();
                    //// END MID Track #6103 
                    //_selectedRowsSequence.Clear();
                    //// END MID Track #6264
                    //if (ugHeaders.Selected.Rows.Count > 0)
                    //{
                    //    if (typeof(UltraGridRow) == e.Type)
                    //    {
                    //        _dsDetails = GetSelectedHeaderData();
                    //        // BEGIN MID Track #6103 - Header selection sequence inconsistent
                    //        foreach (UltraGridRow row in ugHeaders.Selected.Rows)
                    //        {
                    //            //selRowsSeq.Add(row);
                    //            _selectedRowsSequence.Add(row);     // MID TRack #6264 - Headers out of priority sequence
                    //        }
                    //        // END MID Track #6103
                    //    }
                    //    else
                    //    {
                    //        ArrayList selrows = new ArrayList();
                    //        foreach (UltraGridRow row in ugHeaders.Selected.Rows)
                    //        {
                    //            selrows.Add(row);
                    //        }
                    //        _dsDetails = GetSelectedGroupByData();
                    //        ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                    //        foreach (UltraGridRow row in selrows)
                    //        {
                    //            row.Selected = true;
                    //            // BEGIN MID Track #6103 - Header selection sequence inconsistent 
                    //            //GetRowsFromGroupByRow(row, ref selRowsSeq);
                    //            // END MID Track #6103 
                    //            GetRowsFromGroupByRow(row); // MID Track #6264
                    //        }   // END MID Track #6103 
                    //        ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                    //    }
                    //    rowsSelected = true;
                    //}
                    //if (rowsSelected)
                    //{
                    //    _dsDetailsSaved = MIDEnvironment.CreateDataSet(); // MID Track #5523
                    //    _dsDetailsSaved = _dsDetails.Copy();
                    //    BindDetailsGrid();
                    //    FormatColumns(ugDetails);
                    //    SetActionListCombo();
                    //    //if (!_detailsShown)   // commented out per request
                    //    //{
                    //    //    ShowDetails();
                    //    //}
                    //    if (_expandAll)
                    //    {
                    //        cmsExpand_Click(cmsExpand, null);
                    //    }
                    //}
                    //else
                    //{
                    //    ugDetails.DataSource = null;
                    //    //_expandAll = false;       // TT#620 - not related to issue; keep current expland indicator
                    //}
                    //// BEGIN MID Track #6103 - Header selection sequence inconsistent
                    //ugDetails.Selected.Rows.Clear();
                    //// MID Track #6264  replace with _selectedRowsSequence
                    //for (int i = 0; i < _selectedRowsSequence.Count; i ++)
                    //{
                    //    UltraGridRow selrowSeq = (UltraGridRow) _selectedRowsSequence[i];
                    //    int hdrRID = Convert.ToInt32(selrowSeq.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    //    IEnumerable enumerator = ugDetails.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
                    //    foreach (UltraGridRow dRow in enumerator)
                    //    {
                    //        if (Convert.ToInt32(dRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == hdrRID)
                    //        {
                    //            dRow.Selected = true;
                    //            break;
                    //        }
                    //    }
                    //}

                    // END MID Track #6103 
                    _fromHeaderGrid = true;

                    _selectedRowsSequence.Clear();
                    if (ugHeaders.Selected.Rows.Count > 0)
                    {
                        _ultraGridRowSelectedType = e.Type;
                        if (typeof(UltraGridRow) == e.Type)
                        {
                            // Begin TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
                            // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                            //_dsDetails = GetSelectedHeaderData(false);
                            DataSet ds = GetSelectedHeaderData(false);
                            // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                            // End TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
                            foreach (UltraGridRow row in ugHeaders.Selected.Rows)
                            {
                                // Begin TT#3147 - JSmith - WUB header-> applied packs from build pack method-> cancel allocation and get Unhandled Exception
                                //_selectedRowsSequence.Add(row);
                                if (row.IsGroupByRow)
                                {
                                    GetRowsFromGroupByRow(row, false);
                                }
                                else
                                {
                                    _selectedRowsSequence.Add(row);
                                }
                                // End TT#3147 - JSmith - WUB header-> applied packs from build pack method-> cancel allocation and get Unhandled Exception
                            }
                        }
                        else
                        {
                            ArrayList selrows = new ArrayList();
                            foreach (UltraGridRow row in ugHeaders.Selected.Rows)
                            {
                                selrows.Add(row);
                            }
                            // Begin TT#2597 - RMatelic - Allocation workspace header selection error
                            ugHeaders.EventManager.SetEnabled(GridEventIds.BeforeSelectChange, false);
                            // End TT#2597 
                            ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                            foreach (UltraGridRow row in selrows)
                            {
                                // Begin TT#2597 - RMatelic - Allocation workspace header selection error
                                row.Selected = true;
                                //if (_detailsShown)
                                //{
                                //    GetRowsFromGroupByRow(row, false);
                                //}
                                //else
                                //{
                                //    GetRowsFromGroupByRow(row, true);
                                //}
                                //row.Selected = true;
                                // Begin TT#2681 - JSmith - Unable to group headers by header characteristic
                                //GetRowsFromGroupByRow(row, true);
                                GetRowsFromGroupByRow(row, false);
                                // End TT#2681 - JSmith - Unable to group headers by header characteristic
                                // End TT#2597 
                            }
                            // Begin TT#2597 - RMatelic - Allocation workspace header selection error
                            // Begin TT#2681 - JSmith - Unable to group headers by header characteristic
                            //_ultraGridRowSelectedType = typeof(UltraGridRow);
                            // End TT#2681 - JSmith - Unable to group headers by header characteristic
                            // End TT#2597 
                            ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                            // Begin TT#2597 - RMatelic - Allocation workspace header selection error
                            ugHeaders.EventManager.SetEnabled(GridEventIds.BeforeSelectChange, true);
                            // End TT#2597 
                        }
                        rowsSelected = true;
                    }
                    if (rowsSelected)
                    {
                        SetActionListCombo();
                    }

                    if (_detailsShown)
                    {
                        // Begin TT#718-MD - JSmith - Unable to select header component in details grid
                        //BuildDetailsGrid();
                        if (_rClickGrid.Name != "ugDetails")
                        {
                            BuildDetailsGrid();
                        }
                        // End TT#718-MD - JSmith - Unable to select header component in details grid
                    }
                    else if (_selectedRowsSequence.Count > 0)
                    {
						// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                       	//btnShowDetails.Enabled = true;
						((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["showDetails"]).SharedProps.Enabled = true;
						// END TT#767-MD - Stodd - remove old controls from allocation workspace
                    }
					// End TT#1434

                    UpdateSelectedTotals();

                    // Begin TT#386-MD - JSmith - Created a header type of ASN, put in Edit mode changed to Reciept using the drop down, the type remained ASN but when I selected SAVE it changed to Receipt
                    // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    //ugDetails.ResumeRowSynchronization();
                    //ugDetails.EndUpdate();
                    ugDetailsResumeRowSynchronization();
                    ugDetailsEndUpdate();
                    // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    // End TT#386-MD - JSmith - Created a header type of ASN, put in Edit mode changed to Reciept using the drop down, the type remained ASN but when I selected SAVE it changed to Receipt

                    _fromHeaderGrid = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally  //MID Track 4449, 4451, 4452 above 'return' statement left the screen suspended
            {
			    // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                //ugDetails.ResumeRowSynchronization();
                //ugDetails.EndUpdate();
				// End TT#1434
                // Begin TT#1038 - JSmith - Out of memory when right click and filter
                _sender = null;
                // Begin TT#2681 - JSmith - Unable to group headers by header characteristic
                //_afterSelectChangeEventArgs = null;
                // End TT#2681 - JSmith - Unable to group headers by header characteristic
                // end TT#1038
                Cursor.Current = Cursors.Default;   // TT#521-RMatelic-Workspace performance slow when grouped
            }
		}

        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
        private void BuildDetailsGrid()
        {
            try
            {
                if (_ultraGridRowSelectedType == null)
                {
                    return;
                }
     			Cursor.Current = Cursors.WaitCursor;
                bool rowsSelected = false;

                // Begin TT#386-MD - JSmith - Created a header type of ASN, put in Edit mode changed to Reciept using the drop down, the type remained ASN but when I selected SAVE it changed to Receipt
                //ugDetails.BeginUpdate();
                //ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#386-MD - JSmith - Created a header type of ASN, put in Edit mode changed to Reciept using the drop down, the type remained ASN but when I selected SAVE it changed to Receipt


                ClearDetails();
               
                ugDetails.ResetLayouts();
                ApplyAppearance(ugDetails);
                if (ugHeaders.Selected.Rows.Count > 0)
                {
                    CreateDetailDataSet();
                    if (typeof(UltraGridRow) == _ultraGridRowSelectedType)
                    {
                        // Begin TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
                        //_dsDetails = GetSelectedHeaderData();
                        _dsDetails = GetSelectedHeaderData(true);
                        // End TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
                    }
                    else
                    {
                        _dsDetails = GetSelectedGroupByData();
                    }
                    rowsSelected = true;
                }
                if (rowsSelected)
                {
                    ClearSavedDetails();
                    _dsDetailsSaved = _dsDetails.Copy();
                    BindDetailsGrid();
                    FormatColumns(ugDetails);
                    if (_expandAll)
                    {
                        cmsExpand_Click(cmsExpand, null);
                    }
                }
                else
                {
                    ClearDetails();
                }

                ugDetails.Selected.Rows.Clear();
				// Begin TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                _clearSelectedList = false;
				// End TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                for (int i = 0; i < _selectedRowsSequence.Count; i++)
                {
                    UltraGridRow selrowSeq = (UltraGridRow)_selectedRowsSequence[i];
                    // Begin TT#3620 - JSmith - Right Click - Add - Header receive system argument exception
                    if (!RowHasKey(selrowSeq, "KeyH") ||
                        !GridHasBand(ugDetails, "Header"))
                    {
                        continue;
                    }
                    // End TT#3620 - JSmith - Right Click - Add - Header receive system argument exception
                    int hdrRID = Convert.ToInt32(selrowSeq.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    IEnumerable enumerator = ugDetails.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
                    foreach (UltraGridRow dRow in enumerator)
                    {
                        if (Convert.ToInt32(dRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == hdrRID)
                        {
                            dRow.Selected = true;
                            break;
                        }
                    }
                }
				// Begin TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                _clearSelectedList = true;
				// End TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0

                // Begin TT#2019 - JSmith - received Systme Null Reference when clicking on Edit button in Show Detail section of Allocation Workspace
                if (_selectedRowsSequence.Count > 0)
                {
                    // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
                    //btnEditSave.Enabled = true;
                    ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnEditSave"]).SharedProps.Enabled = true;
                    // End TT#1126-MD
                }
                //End TT#2019
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally  //MID Track 4449, 4451, 4452 above 'return' statement left the screen suspended
            {
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.ResumeRowSynchronization();
                //ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                // Begin TT#1038 - JSmith - Out of memory when right click and filter
                _sender = null;
                // Begin TT#2681 - JSmith - Unable to group headers by header characteristic
                //_afterSelectChangeEventArgs = null;
                // End TT#2681 - JSmith - Unable to group headers by header characteristic
                // end TT#1038
                Cursor.Current = Cursors.Default;   // TT#521-RMatelic-Workspace performance slow when grouped
            }
        }
        // End TT#1434

        // BEGIN MID Track #6103 - Header selection sequence inconsistent
        //private void GetRowsFromGroupByRow(UltraGridRow aGroupByRow, ref ArrayList aSelRowsSeq)
        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
        //private void GetRowsFromGroupByRow(UltraGridRow aGroupByRow)    // MID Track #6264
        private void GetRowsFromGroupByRow(UltraGridRow aGroupByRow, bool blSelectRow)
        // End TT#1434
        {
            try
            {
                UltraGridRow childRow = aGroupByRow.GetChild(ChildRow.First);
                while (childRow != null)
                {
                    if (childRow.IsGroupByRow)
                    {
                        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                        //GetRowsFromGroupByRow(childRow);
                        GetRowsFromGroupByRow(childRow, blSelectRow);
                        // End TT#1434
                    }
                    // Begin TT#2681 - JSmith - Unable to group headers by header characteristic
                    //else
                    else if (!childRow.Hidden)
                    // End TT#2681 - JSmith - Unable to group headers by header characteristic
                    {
                        //aSelRowsSeq.Add(childRow);            // MID Track #6264
                        _selectedRowsSequence.Add(childRow);    // MID Track #6264
                        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                        if (blSelectRow)
                        {
                            childRow.Selected = true;
                        }
                        // End TT#1434
                    }
                    childRow = childRow.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
        }
        // END MID Track #6103 

        private void BindDetailsGrid()
        {
            try
            {
                BindingSource bsDetails = new BindingSource(_dsDetails, "");
                ugDetails.DataSource = bsDetails;
            }
            catch
            {
                throw;
            }
        }

		private DataSet GetSelectedGroupByData()
		{
            try
            {
                DataSet dsGrid = MIDEnvironment.CreateDataSet();
                foreach (UltraGridRow selRow in ugHeaders.Selected.Rows)
                {
                    LoopThruGroupByRows(selRow, ref dsGrid);
                }
                return dsGrid;
            }
            catch
            {
                throw;
            }
		}

        private void LoopThruGroupByRows(UltraGridRow aGroupByRow, ref DataSet aGridDataSet)
		{
			DataSet ds = MIDEnvironment.CreateDataSet();
            try
            {
                UltraGridRow selRow = aGroupByRow.GetChild(ChildRow.First);
                while (selRow != null)
                {
                    if (selRow.IsGroupByRow)
                    {
                        LoopThruGroupByRows(selRow, ref aGridDataSet);
                    }
                    else if (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader
                          || Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader)
                    {
                        int hdrGroupRID = Convert.ToInt32(selRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);
                        if (_multiHeaderGroups.ContainsKey(hdrGroupRID))
                        {
                            // disable event firing
                            ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                            Hashtable multiHeaderListHash = (Hashtable)_multiHeaderGroups[hdrGroupRID];
                            foreach (UltraGridRow row in multiHeaderListHash.Values)
                            {
                                row.Selected = true;
                            }

                            // enable event firing
                            ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                            // Begin TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
                            //ds = GetSelectedHeaderData();
                            ds = GetSelectedHeaderData(true);
                            // End TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
                        }
                    }
                    else 
                    {
                        ds = BuildComponentData(selRow);
                    }
                    aGridDataSet.Merge(ds, true);

                    selRow = selRow.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
		}

        // Begin TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
        //private DataSet GetSelectedHeaderData()
		private DataSet GetSelectedHeaderData(bool aCreateDataset)
        // End TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
		{
            // Begin TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
            //DataSet dsGrid = MIDEnvironment.CreateDataSet();
            DataSet dsGrid = null;
            if (aCreateDataset)
            {
                dsGrid = MIDEnvironment.CreateDataSet();
            }
            // End TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
            try
            {    // disable event firing
                ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                foreach (UltraGridRow selRow in ugHeaders.Selected.Rows)
                {
                    // Begin TT#2749 - JSmith - Object Reference error in Alloc Workspace
                    if (selRow.IsGroupByRow ||
                        selRow.IsDeleted)
                    {
                        continue;
                    }
                    // End TT#2749 - JSmith - Object Reference error in Alloc Workspace
                    if (selRow.Cells["HdrGroupRID"].Value != DBNull.Value && cmsAutoSelectGroup.Checked)
                    {
                        int hdrGroupRID = Convert.ToInt32(selRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);
                        if (_multiHeaderGroups.ContainsKey(hdrGroupRID))
                        {
                            Hashtable multiHeaderListHash = (Hashtable)_multiHeaderGroups[hdrGroupRID];
                            // Begin TT#213 - RMatelic - Version 3.1 of MID Track #6300; this is no exactly the Track but similar  
                            //foreach (UltraGridRow row in multiHeaderListHash.Values)
                            //{
                            //    row.Selected = true;
                            //}
                            SortedList sl = new SortedList();
                            foreach (UltraGridRow row in multiHeaderListHash.Values)
                            {
                                int sortSeq = Convert.ToInt32(row.Cells["MultiSortSeq"].Value, CultureInfo.CurrentUICulture);
                                sl.Add(sortSeq, row);
                            }
                            foreach (UltraGridRow row in sl.Values)
                            {
                                if (row.Selected)
                                {
                                    row.Selected = false;
                                }
                                row.Selected = true;
                            }
                        }   // End TT#213
                    }
                    else if (selRow.Cells["AsrtRID"].Value != DBNull.Value && cmsAutoSelectGroup.Checked)
                    {
                        int asrtRID = Convert.ToInt32(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                        if (_assortmentGroups.ContainsKey(asrtRID))
                        {
                            Hashtable asrtHeaderListHash = (Hashtable)_assortmentGroups[asrtRID];
                            foreach (UltraGridRow row in asrtHeaderListHash.Values)
                            {
                                // Begin TT#386 - JSmith - Allocation Workspace - Created a header type of ASN, put in Edit mode changed to Reciept using the drop down, the type remained ASN but when I selected SAVE it changed to Receipt. Would expect it to change when selected from drop down.
                                //row.Selected = true;
                                //if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                                //{
                                //    row.Cells["HeaderID"].SelectedAppearance.ForeColor = System.Drawing.SystemColors.Highlight;
                                //}
                                if (row != null)
                                {
                                    row.Selected = true;
                                    if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                                    {
                                        row.Cells["HeaderID"].SelectedAppearance.ForeColor = System.Drawing.SystemColors.Highlight;
                                    }
                                }
                                // End TT#386 - JSmith - Allocation Workspace - Created a header type of ASN, put in Edit mode changed to Reciept using the drop down, the type remained ASN but when I selected SAVE it changed to Receipt. Would expect it to change when selected from drop down.
                            }
                        }
                    }
                }

                // Begin TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
                //DataSet ds = MIDEnvironment.CreateDataSet();

                //foreach (UltraGridRow selRow in ugHeaders.Selected.Rows)
                //{
                //    ds = BuildComponentData(selRow);
                //    dsGrid.Merge(ds, true);
                //}
                if (aCreateDataset)
                {
                    DataSet ds = MIDEnvironment.CreateDataSet();

                    foreach (UltraGridRow selRow in ugHeaders.Selected.Rows)
                    {
                        if (!selRow.IsGroupByRow)
                        {
                            ds = BuildComponentData(selRow);
                            dsGrid.Merge(ds, true);
                        }
                    }
                }
				// Begin TT#1966-MD - JSmith- DC Fulfillment
                else
                {
                    AllocationProfile ap;
                    int hdrRID;
                    foreach (UltraGridRow selRow in ugHeaders.Selected.Rows)
                    {
                        if (!selRow.IsGroupByRow)
                        {
                            hdrRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            if (_allocProfileList.Contains(hdrRID))
                            {
                                ap = (AllocationProfile)_allocProfileList.FindKey(hdrRID);
                            }
                            else
                            {
                                AllocationHeaderProfile ahp = _SAB.HeaderServerSession.GetHeaderData(hdrRID, aIncludeComponents: true, aIncludeCharacteristics: true, blForceGet: true);
                                ap = new AllocationProfile(_SAB, ahp, _SAB.ClientServerSession);
                                _allocProfileList.Add(ap);
                            }
                        }
                    }
                }
				// End TT#1966-MD - JSmith- DC Fulfillment
                // End TT#446-MD - JSmith - Added a header characteristic to a multi header and receive the system argument exception
                // enable event firing
                ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
            }
            catch
            {
                ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                throw;
            }
            return dsGrid;
    	}
       
		private DataSet BuildComponentData(UltraGridRow aSelectedRow)
		{
            try
            {
                int hdrRID, headerTotal = 0;
                string select;
                DataRow[] selectRows;
                DataTable dtHeader = _dtDetailHeader.Clone();
                DataTable dtBulkColor = _dtBulkColor.Clone();
                DataTable dtPack = _dtPack.Clone();
                DataTable dtPackColor = _dtPackColor.Clone();
                DataSet ds = MIDEnvironment.CreateDataSet();

                HierarchyNodeProfile hnp_style;
                AllocationProfile ap;
                DataRow headerRow = null;

                hdrRID = Convert.ToInt32(aSelectedRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                select = "KeyH = " + "'" + hdrRID.ToString() + "'";

                selectRows = _dtHeader.Select(select);
                if (selectRows.Length > 0)
                {
                    foreach (DataRow row in selectRows)
                    {
                        dtHeader.ImportRow(row);
                    }

                    headerRow = dtHeader.Rows[0];
                    headerRow["HeaderRow"] = aSelectedRow;
                }
                else
                {
                    ////error
                }
                ds.Tables.Add(dtHeader);
                ds.Tables.Add(dtPack);
                ds.Tables.Add(dtPackColor);
                ds.Tables.Add(dtBulkColor);
      
                ds.Relations.Add("Pack", ds.Tables["Header"].Columns["KeyH"], ds.Tables["Pack"].Columns["KeyH"]);

                ds.Relations.Add("PackColor", new DataColumn[] { ds.Tables["Pack"].Columns["KeyH"], ds.Tables["Pack"].Columns["KeyP"] },
                    new DataColumn[] { ds.Tables["PackColor"].Columns["KeyH"], ds.Tables["PackColor"].Columns["KeyP"] }, true);

                ds.Relations.Add("BulkColor", ds.Tables["Header"].Columns["KeyH"], ds.Tables["BulkColor"].Columns["KeyH"]);

                if (_allocProfileList.Contains(hdrRID))
                {
                    ap = (AllocationProfile)_allocProfileList.FindKey(hdrRID);
                }
                else
                {
                    // Begin TT#1434-MD - stodd - Allocation Workspace header details does not contain components
                    // After Startup header service only contains headers found in assortment workspace.
                    //AllocationHeaderProfile ahp = _SAB.HeaderServerSession.GetHeaderData(hdrRID, aIncludeComponents: true, aIncludeCharacteristics: true, blForceGet: false);
                    AllocationHeaderProfile ahp = _SAB.HeaderServerSession.GetHeaderData(hdrRID, aIncludeComponents: true, aIncludeCharacteristics: true, blForceGet: true);
                    // End TT#1434-MD - stodd - Allocation Workspace header details does not contain components
                    ap = new AllocationProfile(_SAB, ahp, _SAB.ClientServerSession);
                    _allocProfileList.Add(ap);
                }

                hnp_style = this.GetNodeData(ap.StyleHnRID);

                if (ap.Packs != null && ap.Packs.Count > 0)
                {
                    int packType;
                    foreach (PackHdr aPack in ap.Packs.Values)
                    {
                        if (aPack.GenericPack)
                            packType = (int)eAllocationType.GenericType;
                        else
                            packType = (int)eAllocationType.DetailType;

                        headerTotal += (aPack.PacksToAllocate * aPack.PackMultiple);
                        DataRow packRow = dtPack.Rows.Add(new object[] { ap.HeaderRID, aPack.PackRID, Include.NoRID,
                                                          aPack.PackName, packType, aPack.PacksToAllocate,
                                                          aPack.PackMultiple, aPack.UnitsToAllocate, 
                                                          aPack.AssociatedPackRID, aPack.Sequence});
                        int colorTotal = 0;
                        bool hasDummyColor = false;

                        if (aPack.PackColors != null && aPack.PackColors.Count > 0)
                        {
                            foreach (PackColorSize aColor in aPack.PackColors.Values)
                            {
                                DataRow colorRow = null;
                                ColorCodeProfile ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(aColor.ColorCodeRID);

                                string packColorDescription = string.Empty;
                                string colorID = string.Empty;
                               
                                if (ccp.VirtualInd)
                                {
                                    colorID = aColor.ColorName;
                                    packColorDescription = aColor.ColorDescription;
                                }
                                else
                                {
                                    colorID = ccp.ColorCodeID;
                                    packColorDescription = GetColorDescription(hnp_style, ccp);
                                }    
                                if (aColor.ColorCodeRID != Include.DummyColorRID)
                                {
                                    colorTotal += aColor.ColorUnitsInPack;
                                    colorRow = dtPackColor.Rows.Add(new object[] { ap.HeaderRID, aPack.PackRID,
                                                                  aColor.HdrPCRID, aColor.ColorCodeRID, 
                                                                  colorID, packColorDescription, 
                                                                  aColor.ColorUnitsInPack, aColor.ColorSequenceInPack, aColor.ColorName });
                                }
                                if (ccp.VirtualInd)
                                {
                                    colorRow["IsVirtual"] = true;
                                }                  
                                if (_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                                {
                                    if (aColor.ColorSizes != null && aColor.ColorSizes.Count > 0)
                                    {
                                        string namePrefix = aColor.ColorCodeRID == Include.DummyColorRID ? "PackSize" : "PackColorSize";
                                        string sizeTableName = namePrefix
                                            + "~" + ap.HeaderRID.ToString(CultureInfo.CurrentUICulture)
                                            + "~" + aPack.PackRID.ToString(CultureInfo.CurrentUICulture) 
                                            + "~" + aColor.HdrPCRID.ToString(CultureInfo.CurrentUICulture);
                                        int sizeTotal = 0;

                                        DataTable dtSizes = FormatPackSizeTable(aColor, ap.SizeGroupRID, ap.HeaderRID, aPack.PackRID, aColor.HdrPCRID, ccp.ColorCodeID, sizeTableName, ref sizeTotal);

                                        if (dtSizes != null)
                                        {
                                            ds.Tables.Add(dtSizes);
                                            if (aColor.ColorCodeRID == Include.DummyColorRID)
                                            {
                                                ds.Relations.Add(sizeTableName,
                                                    new DataColumn[] { ds.Tables["Pack"].Columns["KeyH"], ds.Tables["Pack"].Columns["KeyP"] },
                                                    new DataColumn[] { ds.Tables[sizeTableName].Columns["KeyH"], ds.Tables[sizeTableName].Columns["KeyP"] }, true);
                                                hasDummyColor = true;
                                                packRow["ChildTotal"] = sizeTotal;
                                                packRow["Balance"] = Convert.ToInt32(packRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - sizeTotal;

                                            }
                                            else
                                            {
                                                ds.Relations.Add(sizeTableName,
                                                    new DataColumn[] { ds.Tables["PackColor"].Columns["KeyH"], ds.Tables["PackColor"].Columns["KeyP"], ds.Tables["PackColor"].Columns["KeyC"] },
                                                    new DataColumn[] { ds.Tables[sizeTableName].Columns["KeyH"], ds.Tables[sizeTableName].Columns["KeyP"], ds.Tables[sizeTableName].Columns["KeyC"] }, true);
                                                colorRow["ChildTotal"] = sizeTotal;
                                                colorRow["Balance"] = Convert.ToInt32(colorRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - sizeTotal;

                                            }
                                        }
                                    }
                                }
                            }

                            if (aPack.PackColors != null && aPack.PackColors.Count > 0
                                && !hasDummyColor)
                            {
                                packRow["ChildTotal"] = colorTotal;
                                packRow["Balance"] = Convert.ToInt32(packRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - colorTotal;
                            }
                        }
                    }
                }

                if (ap.BulkColors != null && ap.BulkColors.Count > 0)
                {
                    foreach (HdrColorBin aColor in ap.BulkColors.Values)
                    {
                        ColorCodeProfile ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(aColor.ColorCodeRID);

                        string colorID = string.Empty;
                        string description = string.Empty;

                        if (ccp.VirtualInd)
                        {
                            colorID = aColor.ColorName;
                            description = aColor.ColorDescription;
                        }
                        else
                        {
                            colorID = ccp.ColorCodeID;
                            description = GetColorDescription(hnp_style, ccp);
                        }    
                        headerTotal += aColor.ColorUnitsToAllocate;
                        DataRow colorRow = dtBulkColor.Rows.Add(new object[] { ap.HeaderRID, Include.NoRID, 
                                                   aColor.HdrBCRID, aColor.ColorCodeRID, colorID, 
                                                   description, aColor.ColorUnitsToAllocate,
                                                   aColor.ColorSequence, aColor.ColorName, aColor.AsrtBCRID });

                        if (ccp.VirtualInd)
                        {
                            colorRow["IsVirtual"] = true;
                        }
                        if (_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                        {
                            if (aColor.ColorSizes != null && aColor.ColorSizes.Count > 0)
                            {
                                string sizeTableName = "BulkSize"
                                    + "~" + ap.HeaderRID.ToString(CultureInfo.CurrentUICulture)
                                    + "~" + aColor.HdrBCRID.ToString(CultureInfo.CurrentUICulture);

                                int sizeTotal = 0;
                                DataTable dtSizes = FormatBulkSizeTable(aColor, ap.SizeGroupRID, ap.HeaderRID, aColor.HdrBCRID, ccp.ColorCodeID, sizeTableName, ref sizeTotal);

                                if (dtSizes != null)
                                {
                                    colorRow["ChildTotal"] = sizeTotal;
                                    colorRow["Balance"] = Convert.ToInt32(colorRow["Quantity"], CultureInfo.CurrentUICulture) - sizeTotal;

                                    ds.Tables.Add(dtSizes);
                                    ds.Relations.Add(sizeTableName,
                                        new DataColumn[] { ds.Tables["BulkColor"].Columns["KeyH"], ds.Tables["BulkColor"].Columns["KeyC"] },
                                        new DataColumn[] { ds.Tables[sizeTableName].Columns["KeyH"], ds.Tables[sizeTableName].Columns["KeyC"] }, true);
                                }
                            }
                        }
                    }
                }
                if ( (ap.Packs != null && ap.Packs.Count > 0) 
                  || (ap.BulkColors != null && ap.BulkColors.Count > 0))
                {
                    headerRow["ChildTotal"] = headerTotal;
                    headerRow["Balance"] = Convert.ToInt32(headerRow["HdrQuantity"], CultureInfo.CurrentUICulture) - headerTotal;
                }

                 //ds.Relations.Add("Placeholder", ds.Tables["Header"].Columns["KeyH"], ds.Tables["Header"].Columns["AsrtRID"], false);
                 //ds.Relations.Add("PhAsrtHeader", ds.Tables["Header"].Columns["KeyH"], ds.Tables["Header"].Columns["PlaceHolderRID"], false);

                ds.AcceptChanges();
                return ds;
            }
            catch
            {
                throw;
            }
		}	
		
		private string GetColorDescription(HierarchyNodeProfile hnp_style, ColorCodeProfile ccp)
		{	
			int colorHnRID = Include.NoRID;
			string colorDescription = null;
			Hashtable colorHash = null;
			try
			{
				if (_colorsForStyle.ContainsKey(hnp_style.Key))
				{
					colorHash = (Hashtable)_colorsForStyle[hnp_style.Key];
					if (colorHash.ContainsKey(ccp.Key))
					{
						colorDescription = colorHash[ccp.Key].ToString();
					}
					else
					{
						if(_SAB.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
						{
							HierarchyNodeProfile hnp_color = _SAB.HierarchyServerSession.GetNodeData(colorHnRID,false);
							colorDescription = hnp_color.NodeDescription;
						}
						else
						{
							colorDescription = ccp.ColorCodeName;
						}
						colorHash.Add(ccp.Key,colorDescription);
					}
				}
				else
				{
					colorHash = new Hashtable();
					_colorsForStyle.Add(hnp_style.Key,colorHash);
					colorDescription = GetColorDescription(hnp_style,ccp);
				}
			}
			catch(Exception ex) 
			{
				HandleException(ex);
			}
			return colorDescription;
		}

        // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
        private void ugHeaders_BeforeRowExpanded(object sender, CancelableRowEventArgs e)
        {
            _cancelSelectEvent = true;
        }
        // END MID Track #6407  

        // Begin TT#521 - RMatelic - Workspace performance slow when grouped
        private void ugHeaders_BeforeRowCollapsed(object sender, CancelableRowEventArgs e)
        {
            _cancelSelectEvent = true;
        }
        // End TT#521

        private void ugHeaders_BeforeSortChange(object sender, BeforeSortChangeEventArgs e)
        {
            try
            {
                if (_inEditMode)      //BEGIN MID Track 4449, 4451, 4452 Disallow sorting in edit mode. 
                {
                    e.Cancel = true;
                }
                else                 // END MID Track 4449, 4451, 4452
                {
                    _headersInGroupBy = new ArrayList();
                    int hdrRID;

                    // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
                    foreach (UltraGridColumn newSortCol in e.SortedColumns)
                    {
                        if (!e.Band.SortedColumns.Exists(newSortCol.Key))
                        {
                            if (newSortCol.IsGroupByColumn)
                            {
                                _skipSelectChange = true;
                                break;
                            }
                        }
                    }
                    _unGrouping = false;
                    _unGrouping2 = false;
                    if (!_skipSelectChange)
                    {
                        foreach (UltraGridColumn oldSortCol in e.Band.SortedColumns)
                        {
                            if (!e.SortedColumns.Exists(oldSortCol.Key))
                            {
                                if (oldSortCol.IsGroupByColumn)
                                {
                                    _skipSelectChange = true;
                                    _unGrouping = true;
                                    _unGrouping2 = true;
                                    oldSortCol.Hidden = false;
                                }
                            }
                        }
                    }
                    foreach (UltraGridRow row in ugHeaders.Selected.Rows)
                    {
                        if (!row.IsGroupByRow)
                        {
                            hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            if (!_headersInGroupBy.Contains(hdrRID))
                            {
                                _headersInGroupBy.Add(hdrRID);
                            }
                        }
                    }

                    // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
                    if (_skipSelectChange && _headersInGroupBy.Count == 0)
                    {
                        ugHeaders.EventManager.SetEnabled(GridEventIds.BeforeSelectChange, false);
                        ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                    }

                    // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
                    if (_skipSelectChange && _headersInGroupBy.Count == 0)
                    {
                        ugHeaders.EventManager.SetEnabled(GridEventIds.BeforeSelectChange, false);
                        ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                    }
                }   // END MID Track #6407
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }	
        }

		private void ugHeaders_AfterSortChange(object sender, Infragistics.Win.UltraWinGrid.BandEventArgs e)
		{
            ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSortChange, false);
			try
			{
                for (int i = 0; i < e.Band.SortedColumns.Count; i++)
                {
                    UltraGridColumn sortColumn = e.Band.SortedColumns[i];

                    if (sortColumn.Key == "HdrGroupRID")
                    {
                        if (!e.Band.SortedColumns.Exists("MultiSortSeq"))
                        {
                            ugHeaders.EventManager.SetEnabled(GridEventIds.BeforeSortChange, false);
                            e.Band.SortedColumns.Add("MultiSortSeq", false);
                            ugHeaders.EventManager.SetEnabled(GridEventIds.BeforeSortChange, true);
                        }
                        break;
                    }
                }

                // after sort, reset active row to keep in view
                if (ugHeaders.ActiveCell != null)
                {
                    ugHeaders.ActiveRow = ugHeaders.ActiveCell.Row; // MID Track #5656 - null error after sort
                }
                // BEGIN MID Track #3955 - selected rows not persistent when grouping
                else if (_headersInGroupBy != null && _headersInGroupBy.Count > 0)
                {
                    ugHeaders.Selected.Rows.Clear();
                    // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                    //_dsDetails.Clear();
                    //ugDetails.DataSource = null;
                    ClearDetails();
                    // End TT#1434
                     // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
                    //ReselectRows(ugHeaders.GetRow(ChildRow.First));
 					// BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
                    //ReselectRows(ugHeaders.GetRow(ChildRow.First));
                    _cancelSelectEvent = true;
                    UltraGridRow row = ugHeaders.GetRow(ChildRow.First);
                    ReselectRows(row);
                    // END MID Track #6264 
                }   // END MID Track #6407 
                else
                {
                    ugHeaders.Selected.Rows.Clear();
                    // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                    //_dsDetails.Clear();
                    //ugDetails.DataSource = null;
                    ClearDetails();
                    // End TT#1434
                    UpdateSelectedTotals();
                    ugHeaders.ActiveRow = null;
                }
                _headersInGroupBy.Clear();
                // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
                if (_skipSelectChange)
                {
                    ugHeaders.EventManager.SetEnabled(GridEventIds.BeforeSelectChange, true);
                    ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                    _skipSelectChange = false;
                }
			}    // END MID Track #6407
			catch(Exception ex) 
			{
				HandleException(ex);
			}
            finally
            {
                ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSortChange, true);
            }
		}

        // BEGIN MID Track #6264 - Headers not in priority order
        private void ReselectRows(UltraGridRow aRow)
        //private void ReselectRows()
        {
            try
            {
                int hdrRID = 0;
                UltraGridRow row = aRow;
                while (row != null && _headersInGroupBy.Count > 0)
                {
                    if (row.IsGroupByRow)
                    {
                        // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
                        //ReselectRows(row.GetChild(ChildRow.First));
                        _cancelSelectEvent = true;
                        UltraGridRow cRow = row.GetChild(ChildRow.First);
                        ReselectRows(cRow);
                    }   // END MID Track #6407
                    else if (row.Band.Key == "Header")
                    {
                        hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        if (_headersInGroupBy.Contains(hdrRID))
                        {
                            _headersInGroupBy.Remove(hdrRID);
                            row.Activate();
                            _cancelSelectEvent = false;     // MID Track #6407
                            row.Selected = true;
                            
                            // Begin TT#1080 - RMatelic - Created a header and upon saving it is not recognized in the headers Selected Window
                            if (_afterSelectChangeEventArgs != null)
                            {
                                AfterSelectChange(_sender, _afterSelectChangeEventArgs);
                            }
                            // End TT1080

                            ugHeaders.DisplayLayout.RowScrollRegions[0].ScrollRowIntoView(row);     // T#620 - unrelated to issue 
                        }
                    }
                    row = row.GetSibling(SiblingRow.Next, true, false);
                }
				
				
				// NOTE: the change below was commented out during the merge of 3.2 and Assortment
				// BEGIN MID Track #6264 - Headers not in priority order
                //for (int i = 0; i < _headersInGroupBy.Count; i++)
                //{
                //    UltraGridRow row = (UltraGridRow)_headersInGroupBy[i];
                //    row.Activate();
                //    row.Selected = true;
                //}
            }   // END MID Track #6264 
            catch
            {
                throw;
            }
        }	

		private void ugHeaders_ClickCellButton(object sender, Infragistics.Win.UltraWinGrid.CellEventArgs e)
		{
			string title = _lblHeaderNotes + " ";
			try 
			{
				switch (e.Cell.Column.Key) 
				{
					case "HeaderID":
 
						title = title + e.Cell.Text; 
						TextDialog frm = new TextDialog(title, e.Cell.Row.Cells["Notes"].Text);
						frm.ShowDialog();
						frm.Dispose();
 						break;
				}
			}
			catch(Exception ex) 
			{
				HandleException(ex);
			}
		}

		private void AssignValueLists(UltraGrid aGrid) 
		{
            try
            {
                aGrid.DisplayLayout.ResetValueLists();

                aGrid.DisplayLayout.ValueLists.Add(_multiHeaderValueList);
                aGrid.DisplayLayout.Bands[0].Columns["HdrGroupRID"].ValueList = _multiHeaderValueList;
                
                // Assortment
                aGrid.DisplayLayout.ValueLists.Add(_assortmentValueList);
				// Begin TT#1247-MD - stodd - Add Group Allocation as a License Key option -
                if (_SAB.ClientServerSession.GlobalOptions.AppConfig.AssortmentInstalled)
                {
                    aGrid.DisplayLayout.Bands[0].Columns["AsrtRID"].ValueList = _assortmentValueList;
                }

                if (_SAB.ClientServerSession.GlobalOptions.AppConfig.GroupAllocationInstalled)
                {
                    // Begin TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                    // Group Allocation
                    aGrid.DisplayLayout.Bands[0].Columns["GroupAllocRID"].ValueList = _assortmentValueList;
                    // End TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                }
				// End TT#1247-MD - stodd - Add Group Allocation as a License Key option -

                // PlaceHolder
                aGrid.DisplayLayout.ValueLists.Add(_placeHolderValueList);
                aGrid.DisplayLayout.Bands[0].Columns["PlaceHolderRID"].ValueList = _placeHolderValueList;

                // Header Type 
                aGrid.DisplayLayout.ValueLists.Add(_headerTypeValueList);
                aGrid.DisplayLayout.Bands[0].Columns["Type"].ValueList = _headerTypeValueList;

				// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
				// adjustVSW 
				aGrid.DisplayLayout.ValueLists.Add(_adjustVSWValueList);
				aGrid.DisplayLayout.Bands[0].Columns["AdjustVSW"].ValueList = _adjustVSWValueList;
				// END TT#2225 - stodd - VSW ANF Enhancement (IMO)

                // Header Status
                aGrid.DisplayLayout.ValueLists.Add(_headerStatusValueList);
                aGrid.DisplayLayout.Bands[0].Columns["Status"].ValueList = _headerStatusValueList;

                // Size Group
                if (_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                {
                    aGrid.DisplayLayout.ValueLists.Add(_sizeGroupValueList);
                    aGrid.DisplayLayout.Bands[0].Columns["SizeGroup"].ValueList = _sizeGroupValueList;
                }
              
                // Header Intransit
                aGrid.DisplayLayout.ValueLists.Add(_headerIntransitValueList);
                aGrid.DisplayLayout.Bands[0].Columns["Intransit"].ValueList = _headerIntransitValueList;

                // Header Ship Status
                aGrid.DisplayLayout.ValueLists.Add(_headerShipStatusValueList);
                aGrid.DisplayLayout.Bands[0].Columns["ShipStatus"].ValueList = _headerShipStatusValueList;

                // Header Characteristics
                // Begin TT#2726 - JSmith - Header Characteristic showing HC_RID instead of text in Header
                AssignCharacterisicValueLists(aGrid);
                //if (_charValueListsHash.Count > 0)
                //{
                //    foreach (string groupID in _charValueListsHash.Keys) 
                //    {
                //        ValueList valueList = (ValueList)_charValueListsHash[groupID]; 
                //        aGrid.DisplayLayout.ValueLists.Add(valueList);
                //        aGrid.DisplayLayout.Bands[0].Columns[groupID].ValueList = valueList;
                //        aGrid.DisplayLayout.Bands[0].Columns[groupID].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                //    }
                //}
                // End TT#2726 - JSmith - Header Characteristic showing HC_RID instead of text in Header

                foreach (HeaderCharGroupProfile hcgp in _headerCharGroupProfileList)
                {
                //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                    //aGrid.DisplayLayout.Bands[0].Columns[hcgp.ID].Tag = hcgp;
                    aGrid.DisplayLayout.Bands[0].Columns[hcgp.Key.ToString()].Tag = hcgp;
                    aGrid.DisplayLayout.Bands[0].Columns[hcgp.Key.ToString()].Header.Caption = hcgp.ID;
                //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                }        
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
	    }

        // Begin TT#2839 - JSmith - MultiHeader IDs in 5.0
        private void RebuildMultiHeaderValueLists()
        {
            ugHeaders.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Clear();
            foreach (DataRow mRow in _multiHeaders.Rows)
            {
                ugHeaders.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Add(Convert.ToInt32(mRow["HdrRID"], CultureInfo.CurrentUICulture), mRow["HeaderID"].ToString());
            }
            if (ugDetails != null)
            {
                bool valueListExists = false;
                foreach (ValueList vl in ugDetails.DisplayLayout.ValueLists)
                {
                    if ("MultiHeader" == vl.Key)
                    {
                        valueListExists = true;
                        break;
                    }
                }
                if (valueListExists)
                {
                    ugDetails.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Clear();
                }
                else
                {
                    ugDetails.DisplayLayout.ValueLists.Add("MultiHeader");
                }
                foreach (DataRow mRow in _multiHeaders.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Add(Convert.ToInt32(mRow["HdrRID"], CultureInfo.CurrentUICulture), mRow["HeaderID"].ToString());
                }
            }
        }
        // End TT#2839 - JSmith - MultiHeader IDs in 5.0

		// Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
        private void RebuildAssortmentValueLists()
        {
            ugHeaders.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Clear();
            foreach (DataRow mRow in _assortments.Rows)
            {
                ugHeaders.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Add(Convert.ToInt32(mRow["AsrtRID"], CultureInfo.CurrentUICulture), mRow["AssortmentID"].ToString());
            }
            if (ugDetails != null)
            {
                bool valueListExists = false;
                foreach (ValueList vl in ugDetails.DisplayLayout.ValueLists)
                {
                    if ("AssortmentID" == vl.Key)
                    {
                        valueListExists = true;
                        break;
                    }
                }
                if (valueListExists)
                {
                    ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Clear();
                }
                else
                {
                    ugDetails.DisplayLayout.ValueLists.Add("AssortmentID");
                }
                foreach (DataRow mRow in _assortments.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Add(Convert.ToInt32(mRow["AsrtRID"], CultureInfo.CurrentUICulture), mRow["AssortmentID"].ToString());
                }
            }
        }
		// End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces

        // Begin TT#2726 - JSmith - Header Characteristic showing HC_RID instead of text in Header
        private void AssignCharacterisicValueLists(UltraGrid aGrid)
        {
            bool valueListExists = false;
            if (_charValueListsHash.Count > 0)
            {
                foreach (string groupID in _charValueListsHash.Keys)
                {
                    valueListExists = false;
                    ValueList valueList = (ValueList)_charValueListsHash[groupID];
                    // .Contains does not work.  Search yourself
                    foreach (ValueList vl in aGrid.DisplayLayout.ValueLists)
                    {
                        if (valueList.Key == vl.Key)
                        {
                            valueListExists = true;
                            break;
                        }
                    }
                    if (valueListExists)
                    {
                        aGrid.DisplayLayout.ValueLists.Remove(valueList.Key);
                    }
                    aGrid.DisplayLayout.ValueLists.Add(valueList);
                    aGrid.DisplayLayout.Bands[0].Columns[groupID].ValueList = valueList;
                    aGrid.DisplayLayout.Bands[0].Columns[groupID].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                }
            }
        }
        // End TT#2726 - JSmith - Header Characteristic showing HC_RID instead of text in Header

		private void FormatColumns(Infragistics.Win.UltraWinGrid.UltraGrid ultragrid) 
		{
			try
			{
				foreach ( Infragistics.Win.UltraWinGrid.UltraGridBand band in ultragrid.DisplayLayout.Bands ) 
				{
					foreach ( Infragistics.Win.UltraWinGrid.UltraGridColumn column in band.Columns ) 
					{
						switch (column.DataType.ToString()) 
						{
							case "System.Int32":
								column.CellAppearance.TextHAlign = Infragistics.Win.HAlign.Right;
								column.Format = "#,###,##0";
								break;
							case "System.Double":
								column.CellAppearance.TextHAlign = Infragistics.Win.HAlign.Right;
								column.Format = "#,###,###.00";
								break;
						}
					}

					switch (band.Key)
					{
						case "Header":
                        //case "Placeholder":
                            band.Columns["HdrGroupRID"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["AsrtRID"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["GroupAllocRID"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;	// TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                            band.Columns["PlaceHolderRID"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["Type"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["Status"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["SizeGroup"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["Intransit"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
                            band.Columns["ShipStatus"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;

                            foreach (HeaderCharGroupProfile hcgp in _headerCharGroupProfileList)
                            {
                                band.Columns[hcgp.Key.ToString()].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left; //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                            }
                            break;
					
						case "Pack":
							band.Columns["PackType"].CellAppearance.TextHAlign = Infragistics.Win.HAlign.Left;
							break;
					
						default:
							break;
					}
				}
			}
			catch ( Exception ex ) 
			{
				HandleException(ex);
			}
		}

        private void ugHeaders_SelectionDrag(object sender, CancelEventArgs e)
        {
            try
            {
                //if (_inEditMode && ugHeaders.Selected.Rows.Count > 0 && !ugHeaders.Selected.Rows[0].IsGroupByRow)
                if (ugHeaders.Selected.Rows.Count > 0 && !ugHeaders.Selected.Rows[0].IsGroupByRow)
                {
                    int xPos, yPos;
                    int imageHeight, imageWidth, Indent = 0, _spacing = 2;

                    string hdrIDs = string.Empty;
                    foreach (UltraGridRow selRow in ugHeaders.Selected.Rows)
                    { 
                        if (hdrIDs == string.Empty)
                        {
                            hdrIDs = selRow.Cells["HeaderID"].Value.ToString();
                        }
                        else
                        {
                            hdrIDs += ", " + selRow.Cells["HeaderID"].Value.ToString();
                        }
                    }

                    MIDGraphics.BuildDragImage(hdrIDs, imageListDrag, Indent, _spacing,
                               Font, ForeColor, out imageHeight, out imageWidth);

                    xPos = imageWidth / 2;
                    yPos = imageHeight / 2;

                    if (DragHelper.ImageList_BeginDrag(this.imageListDrag.Handle, 0, xPos, yPos))
                    {
                        DragDropEffects dde = ugHeaders.DoDragDrop(ugHeaders.Selected.Rows, DragDropEffects.Move);

                        if (dde == DragDropEffects.None)
                        {   // for some reason the detail grid is in a semi-locked state if no row is dropped
                            // so the EndUpdate() seems to remedy that behavior
                            // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                            //ugDetails.EndUpdate();
                            ugDetailsEndUpdate();
                            // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                        }
                        DragHelper.ImageList_EndDrag();
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugHeaders_DragOver(object sender, DragEventArgs e)
        {
            Image_DragOver(sender, e);
        }

        private void ugHeaders_DragEnter(object sender, DragEventArgs e)
        {
            Image_DragEnter(sender, e);
        }

        // Usability Enhancement
        private void ugHeaders_AfterColRegionScroll(object sender, ColScrollRegionEventArgs e)
        {
            ugDetails.DisplayLayout.ColScrollRegions[0].Position = e.ColScrollRegion.Position;
        }

        // BEGIN MID Track #6231 - Delete key allowed when not in Edit mode
        private void ugHeaders_BeforeRowsDeleted(object sender, BeforeRowsDeletedEventArgs e)
        {
            try
            {
                if (!_inEditMode)
                {
                    if (!_excludedHeadersRemoved)       // MID Track #6239 - Multi should not be split up 
                    {
                        e.Cancel = true;
                    }
                }
                else if (_deleteKeyPressedUpperGrid)
                {
                    _deleteKeyPressedUpperGrid = false;
                    e.Cancel = true;
                }
            }
            catch
            {
                throw;
            }
        }

        private void ugHeaders_KeyDown(object sender, KeyEventArgs e)
        {
            try
            {
                if (e.KeyData == Keys.Delete && _inEditMode)
                {
                    _deleteKeyPressedUpperGrid = true;
                }
                //Begin  TT#1107 - RMatelic - Once headers are selected, cannot apply a second rule without applying to all 3 headers
                else if (e.KeyCode == Keys.ControlKey)
                {
                    _controlKeyPressedUpperGrid = true;
                }
                // End TT#1107
                // Begin TT#1237 - RMatelic - Selecting headers using Shift + Arrow Keys
                else if (e.Shift && (e.KeyCode == Keys.Down || e.KeyCode == Keys.Up || e.KeyCode == Keys.Left || e.KeyCode == Keys.Right))
                {
                    _shiftPlusArrowKeyPressed = true;
                }
                // End TT31237
            }   // End TT#1107
            catch
            {
                throw;
            }
        }
        // END MID Track #6231  
        private void ugHeaders_DragLeave(object sender, EventArgs e)
        {
            Image_DragLeave(sender, e);
        }

        private void panel1_DragEnter(object sender, DragEventArgs e)
        {
            Image_DragEnter(sender, e);
        }

        private void panel1_DragOver(object sender, DragEventArgs e)
        {
            Image_DragOver(sender, e);
        }

        private void panel1_DragLeave(object sender, EventArgs e)
        {
            Image_DragLeave(sender, e);
        }

		#endregion
		
		#region ugDetails grid events and methods
		private void ugDetails_InitializeLayout(object sender, Infragistics.Win.UltraWinGrid.InitializeLayoutEventArgs e)
		{
            try
            {
                
                e.Layout.MaxRowScrollRegions = 1;
                e.Layout.Override.RowAlternateAppearance.BackColor = Color.Snow; //.BlanchedAlmond;
                e.Layout.UseFixedHeaders = true;
                e.Layout.Override.FixedHeaderIndicator = FixedHeaderIndicator.None;
                e.Layout.Override.FixedCellAppearance.BackColor = Color.LightYellow;
                e.Layout.Override.HeaderClickAction = HeaderClickAction.SortMulti;
                e.Layout.MaxBandDepth = _maxBandDepth;

                e.Layout.Grid.DrawFilter = new NoFocusRect(); // TT#3832 - RMatelic - When a row in a grid is unselected, remove the focus rectangle from the row

                e.Layout.Override.AllowColSizing = AllowColSizing.Free; // TT#375 - RMatelic - Component headings truncate 

                foreach (UltraGridBand band in e.Layout.Bands)
                {
                    try
                    {
                    band.Override.ExpansionIndicator = Infragistics.Win.UltraWinGrid.ShowExpansionIndicator.CheckOnDisplay;
                    band.Columns["KeyH"].Hidden = true;
                    band.Columns["KeyP"].Hidden = true;
                    band.Columns["KeyC"].Hidden = true;
                    }
                    catch (Exception ex)
                    {
                        continue;
                        //HandleException(ex);
                    }
                //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
				
                    // Begin TT#805 - RMatelic - System out of memory exception
                    foreach (Infragistics.Win.UltraWinGrid.UltraGridColumn column in band.Columns)
                    {
                        if (!column.Hidden)
                        {
                            column.CellActivation = Activation.NoEdit;
                        }
                    }
                    // End TT#805 

                    string[] bandKeyParts = band.Key.Split(new char[] { '~' });

                    switch (bandKeyParts[0])
                    {
                        case "Header":
                        //case "Placeholder":
                        //case "PhAsrtHeader":
                            
                            InitializeHeaderLayout(band);
                            break;

                        case "BulkColor":
                            InitializeBulkColorLayout(band);
                            break;

                        case "Pack":
                            InitializePackLayout(band);
                            break;

                        case "PackColor":
                            InitializePackColorLayout(band);
                            break;

                        case "PackSize":
                        case "PackColorSize":
                        case "BulkSize":
                            InitializeSizeLayout(band);
                            break;
                    }
                }

                ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    // Begin TT#805 - RMatelic - System out of memory exception
                    //SetRowActivation(row, Activation.NoEdit);
                    // End TT#805 
                    row.Selected = true;
                }
                ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                ugDetails.UpdateMode = UpdateMode.OnRowChange;  // Workspace Usability Enhancement - Ron Matelic
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
	   	}

        private void InitializeHeaderLayout(UltraGridBand band)
		{
			try
			{
                // match the hidden columns with the other grid
                // MID Track #5579 - match other column properties of ugHeaders
                foreach (UltraGridColumn hdrCol in ugHeaders.DisplayLayout.Bands[0].Columns)
                {
                    band.Columns[hdrCol.Key].Hidden = hdrCol.Hidden;
                    band.Columns[hdrCol.Key].Width = hdrCol.Width;
                    band.Columns[hdrCol.Key].Header.VisiblePosition = hdrCol.Header.VisiblePosition;
                    // Begin TT#1401 - RMatelic - Reservation Stores >>> unrelated - no need to get individual captions; these are same as upper grid  
                    band.Columns[hdrCol.Key].Header.Caption = hdrCol.Header.Caption;
                    // End TT#1401
                }
                //display Balance column
                //band.Columns["Balance"].Hidden = false;
             
                band.Columns["HeaderID"].Header.Fixed = true;
			 
				band.Columns["HeaderID"].Style  = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
				band.Columns["HeaderID"].ButtonDisplayStyle = Infragistics.Win.UltraWinGrid.ButtonDisplayStyle.Always;
                //band.Columns["HeaderID"].MaxLength = 32; //   TT#375/TT#376 - Unrelated length set earlier
                band.Columns["HeaderID"].AutoSizeEdit = DefaultableBoolean.True;
                // Begin TT#1401 - RMatelic - Reservation Stores >>> unrelated - no need to get individual captions; these are same as upper grid      
                //band.Columns["HeaderID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_HeaderID);
                //band.Columns["HdrGroupRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_MultiHeaderID);
                //band.Columns["AsrtRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AssortmentID);
                ////band.Columns["PlaceHolderRID"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_PlaceholderID);
                //band.Columns["Type"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Type);
                //band.Columns["Date"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Date);
                //band.Columns["Status"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_HeaderStatus);
                //band.Columns["AnchorNode"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AnchorNode);
                //band.Columns["Product"].Header.Caption = _hlpProduct.LevelID;
                //band.Columns["Style"].Header.Caption = _hlpStyle.LevelID;
                //band.Columns["Description"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_WorkspaceDescription);
                //band.Columns["HdrQuantity"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Quantity);
                //band.Columns["Balance"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Balance);
                //band.Columns["UnitRetail"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_UnitRetail);
                //band.Columns["UnitCost"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_UnitCost);
                //band.Columns["SizeGroup"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_SizeGroup);
                //band.Columns["Multiple"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Multiple);
                //band.Columns["PO"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_PurchaseOrder);
                //band.Columns["Vendor"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Vendor);
                //band.Columns["Workflow"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Workflow);
                //band.Columns["APIWorkflow"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_APIWorkflow);
                //band.Columns["DC"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_DistCenter);
                //band.Columns["Intransit"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Intransit);
                //band.Columns["ShipStatus"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ShipStatus);
                //band.Columns["Release"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_Release);
                //band.Columns["ChildTotal"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_ChildTotal);
                //band.Columns["Master"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_MasterSubord);
                //band.Columns["AllocatedUnits"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_AllocatedUnits);
                //band.Columns["OrigAllocatedUnits"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_OrigAllocatedUnits);
                //band.Columns["RsvAllocatedUnits"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_RsvAllocatedUnits);

                //BEGIN TT#154 – Add number of stores variable to Allocation workspace
                //band.Columns["NumberOfStores"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_NumberOfStores);
                //END TT#154 – Add number of stores variable to Allocation workspace
                // BEGIN Workspace Usability Enhancement - Ron Matelic
                //band.Columns["NumPacks"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_NumPacks);
                //band.Columns["NumBulkColors"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_NumBulkColors);
                //band.Columns["NumBulkSizes"].Header.Caption = MIDText.GetTextOnly(eMIDTextCode.lbl_NumBulkSizes);
                // END Workspace Usability Enhancement 
                //End TT#1401
                // Begin TT#375 - RMatelic - Allocation Workspace Component Headings truncate 
                //band.Columns["HeaderID"].Width = 150;
                //band.Columns["HdrGroupRID"].Width = 150;
                // End TT#375
                band.Columns["HdrGroupRID"].CellActivation = Activation.NoEdit;
                band.Columns["AsrtRID"].CellActivation = Activation.NoEdit;
                band.Columns["PlaceHolderRID"].CellActivation = Activation.NoEdit;
                band.Columns["Status"].CellActivation = Activation.Disabled;
                band.Columns["Intransit"].CellActivation = Activation.Disabled;
                band.Columns["ShipStatus"].CellActivation = Activation.Disabled;
                band.Columns["Release"].CellActivation = Activation.Disabled;
                band.Columns["Interfaced"].CellActivation = Activation.Disabled;
                //band.Columns["Workflow"].CellActivation = Activation.Disabled;
                band.Columns["APIWorkflow"].CellActivation = Activation.Disabled;
				band.Columns["Balance"].CellActivation = Activation.Disabled;
				band.Columns["Notes"].CellActivation = Activation.NoEdit;
                // BEGIN TT#678 - AGallagher - Alloc Workspace - Allocated Units, Original Allocated Units, and Reserve Allocated Units displaying "0" for allocated headers
                band.Columns["AllocatedUnits"].CellActivation = Activation.Disabled;
                band.Columns["OrigAllocatedUnits"].CellActivation = Activation.Disabled;
                band.Columns["RsvAllocatedUnits"].CellActivation = Activation.Disabled;
                // END TT#678 - AGallagher - Alloc Workspace - Allocated Units, Original Allocated Units, and Reserve Allocated Units displaying "0" for allocated headers

                if (this._SAB.ClientServerSession.GlobalOptions.AppConfig.MasterAllocationInstalled)
                {
                    band.Columns["Master"].CellActivation = Activation.Disabled;
                    // BEGIN TT#678 - AGallagher - Alloc Workspace - Allocated Units, Original Allocated Units, and Reserve Allocated Units displaying "0" for allocated headers
                    //band.Columns["AllocatedUnits"].CellActivation = Activation.Disabled;
                    //band.Columns["OrigAllocatedUnits"].CellActivation = Activation.Disabled;
                    //band.Columns["RsvAllocatedUnits"].CellActivation = Activation.Disabled;
                    // END TT#678 - AGallagher - Alloc Workspace - Allocated Units, Original Allocated Units, and Reserve Allocated Units displaying "0" for allocated headers
                }

                band.Columns["Type"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                band.Columns["SizeGroup"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                band.Columns["HdrGroupRID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
				// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
				band.Columns["AdjustVSW"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
				// END TT#2225 - stodd - VSW ANF Enhancement (IMO)

                AssignValueLists(ugDetails);

				foreach (UltraGridRow row in ugDetails.Rows)
				{
					row.Activation = Activation.ActivateOnly;
                    SetNotesCellButton(row);
		    	}

                // BEGIN MID Track #5579 - match other column properties of ugHeaders
                if (ugHeaders.DisplayLayout.Bands[0].SortedColumns.Count > 0)
                {
                    UltraGridBand hBand = ugHeaders.DisplayLayout.Bands[0];
                    bool sortDescending;
                    for (int i = 0; i < hBand.SortedColumns.Count; i++)
                    {
                        UltraGridColumn sortColumn = hBand.SortedColumns[i];
                        switch (sortColumn.SortIndicator)
                        {
                            case SortIndicator.Descending:
                                sortDescending = true;
                                break;
                            default:
                                sortDescending = false;
                                break;
                        }
                        band.SortedColumns.Add(sortColumn.Key, sortDescending);
                    }
                }
                else
                {
                    band.SortedColumns.Add("HdrGroupRID", true);
                    band.SortedColumns.Add("MultiSortSeq", false);
                    band.SortedColumns.Add("AsrtRID", true);
                    band.SortedColumns.Add("PlaceHolderRID", false);
                    band.SortedColumns.Add("AsrtSortSeq", false);
                }
            }  
			catch  
			{
                throw;
			}
		}

        private void InitializeBulkColorLayout(UltraGridBand band)
		{
			try
			{
                band.SortedColumns.Add("Sequence", false);
                band.Columns["Sequence"].Hidden = true;
                band.Columns["ColorCodeRID"].Hidden = true;
                band.Columns["Name"].Hidden = true;
                band.Columns["AsrtBCRID"].Hidden = true;
				band.Columns["ChildTotal"].Hidden = true;
				band.Columns["IsNewColor"].Hidden = true;
                band.Columns["IsVirtual"].Hidden = true;
				if (!_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled) 
				{
					band.Columns["Balance"].Hidden = true;
				}
				else
				{
					band.Columns["Balance"].CellActivation = Activation.Disabled;
				}

                // Begin TT#375 - RMatelic - Allocation Workspace Component Headings truncate
                foreach (UltraGridColumn col in band.Columns)
                {
                    if (!col.Hidden)
                    {
                        col.PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
                    }
                }
                // End TT#375
           	}
	 		catch  
			{
                throw;
			}
		}

        private void InitializePackLayout(UltraGridBand band)
		{
			try
			{
                band.SortedColumns.Add("Sequence", false);
                band.Columns["Sequence"].Hidden = true;
     			band.Columns["ChildTotal"].Hidden = true;
				band.Columns["AssociatedPackRID"].Hidden = true;
                band.Columns["TotalQuantity"].CellActivation = Activation.Disabled; 
				band.Columns["Balance"].CellActivation = Activation.Disabled;

                band.Layout.ValueLists.Add("PackType");
                band.Columns["PackType"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.DropDownList;
                band.Columns["PackType"].ValueList = _packTypeValueList;

                // Begin TT#375 - RMatelic - Allocation Workspace Component Headings truncate
                foreach (UltraGridColumn col in band.Columns)
                {
                    if (!col.Hidden)
                    {
                        col.PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
                    }
                }
                // End TT#375  
			}
	 
			catch  
			{
                throw;
			}
		}

        private void InitializePackColorLayout(UltraGridBand band)
		{
			try
			{
                band.SortedColumns.Add("Sequence", false);
                band.Columns["Sequence"].Hidden = true;
                band.Columns["Name"].Hidden = true;
                band.Columns["ColorCodeRID"].Hidden = true;
				band.Columns["ChildTotal"].Hidden = true;
				band.Columns["IsNewColor"].Hidden = true;
                band.Columns["IsVirtual"].Hidden = true;
				if (!_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled) 
				{
					band.Columns["Balance"].Hidden = true;
				}
				else
				{
					band.Columns["Balance"].CellActivation = Activation.Disabled;
				}

                // Begin TT#375 - RMatelic - Allocation Workspace Component Headings truncate
                foreach (UltraGridColumn col in band.Columns)
                {
                    if (!col.Hidden)
                    {
                        col.PerformAutoResize(Infragistics.Win.UltraWinGrid.PerformAutoSizeType.AllRowsInBand);
                    }
                }
                // End TT#375
			}
	 
			catch  
			{
                throw;
			}
		}

        private void InitializeSizeLayout(UltraGridBand band)
		{
			try
			{
                band.Columns["SecondaryRID"].Hidden = true;  // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                band.Columns["Secondary"].Hidden = true;
				band.Columns[" - "].CellActivation = Activation.NoEdit;
				band.Columns["TotalQuantity"].CellActivation = Activation.Disabled;

                // Begin TT#863 - RMatelic - Allocation Workspace-cannot add header, fields appear to be locked from entry
                IEnumerable enumerator = band.GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow sizeRow in enumerator)
                {
                    SetCellSizeKey(sizeRow);
                }
                // End TT#863  
			}
	 
			catch  
			{
                throw;
			}
		}
		
		private void SetRowActivation(UltraGridRow aRow, Activation aActivation)
		{
			try
			{ 
				if (aRow.Band.Key.StartsWith("BulkSize") || 
                    aRow.Band.Key.StartsWith("PackSize") ||
                    aRow.Band.Key.StartsWith("PackColorSize"))
				{
					SetCellSizeKey(aRow);
				}	

				aRow.Activation = aActivation;

                if (aRow.HasChild(false))
                {
                    UltraGridRow cRow = aRow.GetChild(ChildRow.First);
                    while (cRow != null)
                    {
                        SetRowActivation(cRow, aActivation);
                        cRow = cRow.GetSibling(SiblingRow.Next, true, false);
                    }
                }
			}
	 		catch ( Exception ex ) 
			{
				HandleException(ex);
			}
		}
		
		private void SetCellSizeKey(UltraGridRow aRow)
		{
			try
			{
				string primary, secondary;
				int sizeKey, primaryRID; // primaryRID is the RID for the Size Column 
				DataRowView drv  = (DataRowView)aRow.ListObject;
                secondary = Convert.ToString(drv.Row["Secondary"], CultureInfo.CurrentUICulture);
                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                int secondaryRID = Convert.ToInt32(drv.Row["SecondaryRID"], CultureInfo.CurrentUICulture); 
                aRow.Cells["Secondary"].Tag = secondaryRID;
                // End TT#234
				for(int c = 7; c < drv.DataView.Table.Columns.Count; c++)
				{
					DataColumn dCol = drv.DataView.Table.Columns[c];
                    primary = dCol.ColumnName;
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    //sizeKey = Convert.ToInt32(dCol.ExtendedProperties[primary + "~" + secondary], CultureInfo.CurrentUICulture);
                    //aRow.Cells[primary].Tag = sizeKey;
                    //primaryRID = Convert.ToInt32(dCol.ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                    //if (aRow.Cells[primary].Column.Tag == null)
                    //{
                    //    aRow.Cells[primary].Column.Tag = primaryRID;
                    //}
                    primaryRID = Convert.ToInt32(dCol.ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                    sizeKey = Convert.ToInt32(dCol.ExtendedProperties[primary + "~" + secondaryRID], CultureInfo.CurrentUICulture);
                    aRow.Cells[primary].Tag = sizeKey;
                    if (aRow.Cells[primary].Column.Tag == null)
                    {
                        aRow.Cells[primary].Column.Tag = primaryRID;
                    }
                }   // End TT#234
			}
			catch ( Exception ex ) 
			{
				HandleException(ex);
			}
		}

        private void grid_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            try
            {
                // Begin TT#384 - JSmith - Allocation Workspace - Show details and try to scroll to the right the scroll bar will not move.  Scorll in the top part of the allocation workspace and the top and bottom sections are in sync.
                //// Begin TT#1038 - JSmith - Out of memory when right click and filter
                //if (_afterSelectChangeEventArgs != null)
                //{
                //    if (e.Button == MouseButtons.Left)
                //    {
                //        AfterSelectChange(_sender, _afterSelectChangeEventArgs);
                //    }
                //    // Begin TT#383-MD - JSmith - Allocation Workspace - Right Click >Show Details> receive an system argument exception:  no key found
                //    //else
                //    //{
                //    //    ugHeaders.Selected.Rows.Clear();
                //    //    ugDetails.Selected.Rows.Clear();
                //    //}
                //    // End TT#383-MD - JSmith - Allocation Workspace - Right Click >Show Details> receive an system argument exception:  no key found
                //}
                // End TT#1038
                // End TT#384 - JSmith - Allocation Workspace - Show details and try to scroll to the right the scroll bar will not move.  Scorll in the top part of the allocation workspace and the top and bottom sections are in sync.

                UltraGridCell mouseCell;
                Infragistics.Win.UIElement mouseUIElement;
                Infragistics.Win.UIElement headerUIElement;
                HeaderUIElement headerUI = null;
                Point point = new Point(e.X, e.Y);

                UltraGrid grid = (UltraGrid)sender;
                _rClickGrid = grid;
                if (grid.Name == "ugDetails")
                {
                    mouseUIElement = ugDetails.DisplayLayout.UIElement.ElementFromPoint(point);
                }
                else
                {
                    mouseUIElement = ugHeaders.DisplayLayout.UIElement.ElementFromPoint(point);
                }

                if (mouseUIElement == null)
                {
                    return;
                }

                // Begin TT#384 - JSmith - Allocation Workspace - Show details and try to scroll to the right the scroll bar will not move.  Scorll in the top part of the allocation workspace and the top and bottom sections are in sync.
                // Begin TT#2729 - JSmith - Unable to manually collapse fields in show details
                //if (e.Button == MouseButtons.Left &&
                //    (UltraGridRow)mouseUIElement.GetContext(typeof(UltraGridRow)) != null)
                if (e.Button == MouseButtons.Left &&
                    (UltraGridRow)mouseUIElement.GetContext(typeof(UltraGridRow)) != null &&
                    mouseUIElement.GetType() != typeof(Infragistics.Win.UltraWinGrid.ExpansionIndicatorUIElement))
                // End TT#2729 - JSmith - Unable to manually collapse fields in show details
                {
                    if (_afterSelectChangeEventArgs != null)
                    {

                        AfterSelectChange(_sender, _afterSelectChangeEventArgs);
                        _cancelSelectEvent = false; // TT#3097 - RMatelic - Selecting Headers 
                    }
                }
                else if (e.Button == MouseButtons.Right)
                //if (e.Button == MouseButtons.Right)
                // End TT#384 - JSmith - Allocation Workspace - Show details and try to scroll to the right the scroll bar will not move.  Scorll in the top part of the allocation workspace and the top and bottom sections are in sync.
                {
                    // retrieve the UIElement from the location of the mouse 

                    headerUIElement = mouseUIElement.GetAncestor(typeof(HeaderUIElement));
                    if (null == headerUIElement)
                    {
                        // retrieve the Cell from the UIElement 
                        mouseCell = (Infragistics.Win.UltraWinGrid.UltraGridCell)mouseUIElement.GetContext(typeof(Infragistics.Win.UltraWinGrid.UltraGridCell));

                        // if there is a cell object reference, set to active cell and edit
                        if (mouseCell != null)
                        {
                            _gridCol = mouseCell.Column;
                            _gridBand = mouseCell.Band;
                        }
                    }
                    else if (headerUIElement.GetType() == typeof(HeaderUIElement))
                    {
                        headerUI = (HeaderUIElement)headerUIElement;
                        Infragistics.Win.UltraWinGrid.ColumnHeader colHeader = null;
                        _gridCol = null;
                        colHeader = (Infragistics.Win.UltraWinGrid.ColumnHeader)headerUI.SelectableItem;
                        _gridCol = colHeader.Column;
                        if (_gridCol == null)
                        {
                            return;
                        }
                        _gridBand = colHeader.Band;
                    }
                }
                _rClickRow = (UltraGridRow)mouseUIElement.GetContext(typeof(UltraGridRow));
                //Begin  TT#1106 - RMatelic - Unable to drag highlight headers in workspace
                if (e.Button == MouseButtons.Left)
                {
                    _leftMouseDown = true;
                }
                //End  TT#1106  
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_BeforeRowsDeleted(object sender, BeforeRowsDeletedEventArgs e)
        {
            e.DisplayPromptMsg = false;
            string bandKey, message;
            string[] bandKeyParts;
            try
            {   // BEGIN MID Track #6231 - Delete key allowed when not in Edit mode 
                //if (_removingMulti || _replacingSizes || _removingAssortment)
                if (_removingMulti || _replacingSizes || _removingAssortment || !_inEditMode || !_allowHeaderDelete) //TT#547 - MD - Should not be able to delete multi header - RBeck
                // END MID Track #6231
                {
                    e.Cancel = true;
                    return;
                }
                
                if (_deleteKeyPressed)
                {
                    _deleteKeyPressed = false;
                    if (!HeaderMaintainable(_rClickRow))
                    {
                        e.Cancel = true;
                        return;
                    }
                    else
                    {
                        ugDetails.ActiveRow = _rClickRow;
                    }
                }

                bandKey = _rClickRow.Band.Key;
                // Begin TT#395 - RMatelic - Multi Header - user is able to delete a pack from a multi header on line this should not be allowed 
                if (bandKey != "Header")
                {
                    UltraGridRow hRow = _rClickRow;
                    while (hRow.Band.Key != "Header")
                    {
                        hRow = hRow.ParentRow;
                    }
                    if (Convert.ToInt32(hRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                    {
                        e.Cancel = true;
                        return;
                    }
                }
                // End TT#395
                bandKeyParts = bandKey.Split(new char[] { '~' });

                switch (bandKeyParts[0])
                {
                    case "BulkSize":
                    case "PackColorSize":
                    case "PackSize":
                        message = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_AllSizeRowsToBeDeleted);
                        break;

                    case "Header":
                    //case "Placeholder":    
                        if (ugDetails.Selected.Rows.Count > 1 &&
                            (eHeaderType)Convert.ToInt32(_rClickRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == eHeaderType.MultiHeader)
                        {
                            int headerRID = Convert.ToInt32(_rClickRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            for (int i = ugDetails.Selected.Rows.Count - 1; i >= 0; i--)
                            {
                                UltraGridRow selRow = ugDetails.Selected.Rows[i];
                                if (Convert.ToInt32(selRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture) == headerRID
                                 && Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != headerRID)
                                {
                                    selRow.Selected = false;
                                }
                            }
                        }    
                        message = string.Format(MIDText.GetTextOnly(eMIDTextCode.msg_DeleteRows), ugDetails.Selected.Rows.Count.ToString());
                        break;

                    default:
                        message = string.Format(MIDText.GetTextOnly(eMIDTextCode.msg_DeleteRows), ugDetails.Selected.Rows.Count.ToString());
                        break;
                }
                 
                message += Environment.NewLine + MIDText.GetTextOnly((int)eMIDTextCode.msg_ContinueQuestion);

                DialogResult diagResult = MessageBox.Show(message, _lblDeleteRow, System.Windows.Forms.MessageBoxButtons.YesNo,
                    System.Windows.Forms.MessageBoxIcon.Question);
              
                if (diagResult == System.Windows.Forms.DialogResult.No)
                {
                    e.Cancel = true;
                    return;
                }

                _deletedPlaceholderStyles.Clear();
                _deletedAssortmentStyles.Clear();
                foreach (UltraGridRow delRow in e.Rows)
                {
                    if (!OKToDeleteRow(delRow))
                    {
                        e.Cancel = true;
                        return;
                    }
                }
               
                _rClickRow.Selected = true;
                _rowDeleted = true;
                if (_rClickRow.HasChild())
                {
                    SelectChildRows(_rClickRow);
                }

                // reset field if row deleted
                if (_rowDeleted)
                {
                    _rClickRow = null;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool OKToDeleteRow(UltraGridRow aRow)
        {
            try
            {
                AllocationProfile ap;
              
               // UltraGridRow aRow = ugDetails.ActiveRow;
                UltraGridRow sizeRow = null;
            
                string deleteMessage = MIDText.GetTextOnly(eMIDTextCode.msg_CannotDeleteComponent);
                string packName, colorName;
                int bulkColorCodeRID, packColorCodeRID, headerRID;
                int[] sizeKeys;

                headerRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                ap = (AllocationProfile)_allocProfileList.FindKey(headerRID);
                if (ap == null)
                {
                    return true;
                }

                string bandKey = aRow.Band.Key;
                string[] bandKeyParts = aRow.Band.Key.Split(new char[] { '~' });

                if ((bandKeyParts[0] != "Header") && ap.AllocationStarted)
                {
                    MessageBox.Show(deleteMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return false;
                }

                // BEGIN MID Track #6239 - Multi should not be split up 
                // if all headers in a multi are not in details grid, need to select them
                if ((bandKeyParts[0] == "Header") && ap.MultiHeader)
                {
                    if (!cmsAutoSelectGroup.Checked)
                    {
                        // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                        //ugDetails.BeginUpdate();
                        //ugDetails.SuspendRowSynchronization();
                        ugDetailsBeginUpdate();
                        ugDetailsSuspendRowSynchronization();
                        // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                        ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                        cmsAutoSelectGroup.Checked = true;
                        SetAutoGroupOnToolbar(true);
                        DataSet ds = MIDEnvironment.CreateDataSet();
                        
                        // Begin TT#98 - RMatelic - Duplicate size rows appear after a Multi Header is deleted in some 
                        //if (_multiHeaderGroups.ContainsKey(headerRID))
                        //{
                        //    Hashtable multiHeaderListHash = (Hashtable)_multiHeaderGroups[headerRID];
                        //    foreach (UltraGridRow row in multiHeaderListHash.Values)
                        //    {
                        //        if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != headerRID)
                        //        {
                        //            row.Selected = true;
                        //            ds = BuildComponentData(row);
                        //            _dsDetails.Merge(ds, true);
                        //        }
                        //    }
                        //}
                        //BindDetailsGrid();
                        bool bindGrid = false;
                        // Begin TT#19-MD - RMatelic Multi Header cannot be deleted
                        ArrayList multiMemberRIDs = new ArrayList();
                        if (_multiHeaderGroups.ContainsKey(headerRID))
                        {
                            Hashtable multiHeaderListHash = (Hashtable)_multiHeaderGroups[headerRID];
                            foreach (UltraGridRow row in multiHeaderListHash.Values)
                            {
                                int hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                                if (hdrRID != headerRID)
                                {
                                    DataRow dr = _dsDetails.Tables["Header"].Rows.Find(hdrRID);
                                    if (dr == null) // only add to detail grid if not already there
                                    {
                                        row.Selected = true;
                                        ds = BuildComponentData(row);
                                        _dsDetails.Merge(ds, true);
                                        bindGrid = true;
                                        // Begin TT#19-MD - RMatelic Multi Header cannot be deleted
                                        if (!multiMemberRIDs.Contains(hdrRID))
                                        {
                                            multiMemberRIDs.Add(hdrRID);
                                        }
                                        // End TT#19-MD 
                                    }
                                }
                            }
                        }
                        if (bindGrid)
                        {
                            // Begin TT#19-MD - RMatelic Multi Header cannot be deleted >>> added headers were not enqueued
                            if (!EnqueueHeadersForEdit())   // TT#1185 - Verify ENQ before Update
                            {
                                return false;
                            }
                            else
                            {
                                foreach (int hRID in multiMemberRIDs)
                                {
                                    AllocationProfile apMultiMember = (AllocationProfile)_allocProfileList.FindKey(hRID);
                                    apMultiMember.ReReadHeader();
                                }
                            }
                            // End TT#19-MD
                            BindDetailsGrid();
                        }
                        // End TT#98 

                        cmsAutoSelectGroup.Checked = false;
                        SetAutoGroupOnToolbar(false);
                        ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                        // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                        //ugDetails.ResumeRowSynchronization();
                        //ugDetails.EndUpdate();
                        ugDetailsResumeRowSynchronization();
                        ugDetailsEndUpdate();
                        // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    }
                }
                // END MID Track #6239    

                switch (bandKeyParts[0])
                {
                    case "Header":
                    //case "Placeholder":

                        if (!_deletedHeaderRows.Contains(headerRID))
                        {
                            UltraGridRow hRow = null;
                            if (aRow.Cells["HeaderRow"].Value != System.DBNull.Value)
                            {
                                hRow = (UltraGridRow)aRow.Cells["HeaderRow"].Value;
                            }    
                            _deletedHeaderRows.Add(headerRID,hRow);

                            if (ap.MultiHeader)
                            {
                                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                                while (row != null)
                                {
                                    if (   Convert.ToInt32(row.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader
                                        && Convert.ToInt32(row.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture) == headerRID)
                                    {
                                        row.Cells["HdrGroupRID"].Value = DBNull.Value;
                                        row.Cells["Status"].Value = (int)eHeaderAllocationStatus.ReceivedInBalance;
                                        row.Cells["MultiSortSeq"].Value = DBNull.Value;
                                    }
                                    row = row.GetSibling(SiblingRow.Next, false, false);
                                }
                            }
                            else if (ap.Placeholder)
                            {
                                if (!_deletedPlaceholderStyles.ContainsKey(headerRID))
                                {
                                    _deletedPlaceholderStyles.Add(headerRID,ap.StyleHnRID);
                                }    
                                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                                while (row != null)
                                {
                                    if (row.Cells["PlaceHolderRID"].Value != DBNull.Value
                                     && Convert.ToInt32(row.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == headerRID
                                     && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != headerRID)                            
                                    {
                                        ClearChildAssortmentColumns(row);
                                        row.Cells["AsrtRID"].Value = DBNull.Value;
                                        row.Cells["PlaceHolderRID"].Value = DBNull.Value;
                                        row.Cells["AsrtSortSeq"].Value = DBNull.Value;
                                    }
                                    row = row.GetSibling(SiblingRow.Next, false, false);
                                }
                                CheckForAssortmentTypeUpdate(ap.AsrtRID);
                            }
                            else if (ap.Assortment)
                            {
                                if (!_deletedAssortmentStyles.ContainsKey(headerRID))
                                {
                                    _deletedAssortmentStyles.Add(headerRID, ap.StyleHnRID);
                                } 
                                ArrayList deletedPlaceHolders = new ArrayList(); 
                                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                                while (row != null)
                                {
                                    if (row.Cells["AsrtRID"].Value != DBNull.Value
                                     && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == headerRID   
                                     && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != headerRID)                            
                                    {
                                        if (Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                                        {
                                            int phRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                                            if (!_deletedHeaderRows.Contains(phRID))
                                            {
                                                UltraGridRow phHdrRow = null;
                                                if (row.Cells["HeaderRow"].Value != System.DBNull.Value)
                                                {
                                                    phHdrRow = (UltraGridRow)row.Cells["HeaderRow"].Value;
                                                }
                                                _deletedHeaderRows.Add(phRID, phHdrRow);
                                                 
                                            }
                                            if (!_deletedPlaceholderStyles.ContainsKey(phRID))
                                            {
                                                int styleRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                                _deletedPlaceholderStyles.Add(phRID, styleRID);
                                            }    
                                            if (!deletedPlaceHolders.Contains(phRID))
                                            {
                                                deletedPlaceHolders.Add(phRID);
                                            }
                                        }
                                        else
                                        {
                                            ClearChildAssortmentColumns(row);
                                            row.Cells["AsrtRID"].Value = DBNull.Value;
                                            row.Cells["PlaceHolderRID"].Value = DBNull.Value;
                                            row.Cells["AsrtSortSeq"].Value = DBNull.Value;
                                        }
                                    }
                                    row = row.GetSibling(SiblingRow.Next, false, false);
                                }
                                if (deletedPlaceHolders.Count > 0)
                                {
                                    ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, false);
                                    for (int i = 0; i < deletedPlaceHolders.Count; i++)
                                    {
                                        int delRID = (int)deletedPlaceHolders[i];
                                        for (int j = ugDetails.Rows.Count - 1; j >=0; j--)
                                        {
                                            UltraGridRow delRow = ugDetails.Rows[j];
                                            if (Convert.ToInt32(delRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == delRID)
                                            {
                                                delRow.Delete(false);
                                            }
                                        }
                                    }
                                    ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, true);
                                }
                            }
                            if (ap.Key < 0 && _allocProfileList.Contains(ap.Key))
                            {
                                _allocProfileList.Remove(ap);
                            }    
                        }
                        break;
                 
                    case "Pack":
                        // Begin TT#915 - RMatelic - Selecting more than 1 pack or color to delete results in an error; >> remove loop, process 1 row 
                        //foreach (UltraGridRow row in ugDetails.Selected.Rows)
                        //{
                            packName = aRow.Cells["Pack"].Value.ToString().Trim();
                            if (packName != string.Empty)
                            {
                                ap.RemovePack(packName);
                            }
                            CalculateBalancesFromDelete(aRow);
                        //}
                        // End TT#915
                        break;
                  
                    case "PackColor":
                        // Begin TT#915 - RMatelic - Selecting more than 1 pack or color to delete results in an error; >> remove loop, process 1 row
                        //foreach (UltraGridRow row in ugDetails.Selected.Rows)
                        //{
                            packName = aRow.ParentRow.Cells["Pack"].Value.ToString().Trim();
                            colorName = aRow.Cells["PackColor"].Value.ToString().Trim();
                            if (colorName != string.Empty && aRow.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                            {
                                packColorCodeRID = Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                ap.RemovePackColor(packName, packColorCodeRID);
                            }
                            CalculateBalancesFromDelete(aRow);
                        //}
                        // End TT#915
                        break;
                  
                    case "BulkColor":
                        // Begin TT#915 - RMatelic - Selecting more than 1 pack or color to delete results in an error; >> remove loop, process 1 row
                        //foreach (UltraGridRow row in ugDetails.Selected.Rows)
                        //{
                            colorName = aRow.Cells["BulkColor"].Value.ToString().Trim();
                            if (colorName != string.Empty && aRow.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                            {
                                bulkColorCodeRID = Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                ap.RemoveBulkColor(bulkColorCodeRID);
                            }
                            CalculateBalancesFromDelete(aRow);
                        //}
                        // End TT#915
                        break;
                
                    case "BulkSize":

                        bulkColorCodeRID = Convert.ToInt32(aRow.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                        //sizeKeys = ap.GetBulkColorSizeKeys(bulkColorKey);
                        sizeKeys = ap.GetBulkColorSizeCodeRIDs(bulkColorCodeRID); // Assortment: Color/Size change
                        for (int i = 0; i < sizeKeys.Length; i++)
                        {
                            ap.RemoveBulkColorSize(bulkColorCodeRID, sizeKeys[i]);
                        }
                     
                        sizeRow = aRow.ParentRow.GetChild(ChildRow.First);
                        while (sizeRow != null)
                        {
                            CalculateBalancesFromDelete(sizeRow);
                            sizeRow = sizeRow.GetSibling(Infragistics.Win.UltraWinGrid.SiblingRow.Next, true, false);
                        }
                       
                        break;

                    case "PackColorSize":

                
                        packName = aRow.ParentRow.ParentRow.Cells["Pack"].Value.ToString();
                        packColorCodeRID = Convert.ToInt32(aRow.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                        sizeKeys = ap.GetPackColorSizeKeys(packName, packColorCodeRID);
                        for (int i = 0; i < sizeKeys.Length; i++)
                        {
                            ap.RemovePackColorSize(packName, packColorCodeRID, sizeKeys[i]);
                        }
                         
                        sizeRow = aRow.ParentRow.GetChild(ChildRow.First);
                        while (sizeRow != null)
                        {
                            CalculateBalancesFromDelete(sizeRow);
                            sizeRow = sizeRow.GetSibling(Infragistics.Win.UltraWinGrid.SiblingRow.Next, true, false);
                        }
                        
                        _skipBeforeCellUpdate = true;
                        break;

                    case "PackSize":
                       
                        packName = aRow.ParentRow.Cells["Pack"].Value.ToString();
                        packColorCodeRID = Include.DummyColorRID;

                        sizeKeys = ap.GetPackColorSizeKeys(packName, packColorCodeRID);
                        for (int i = 0; i < sizeKeys.Length; i++)
                        {
                            ap.RemovePackColorSize(packName, packColorCodeRID, sizeKeys[i]);
                        }

                        ap.RemovePackColor(packName, packColorCodeRID);
                         
                        sizeRow = aRow.ParentRow.GetChild(ChildRow.First);
                        while (sizeRow != null)
                        {
                            CalculateBalancesFromDelete(sizeRow);
                            sizeRow = sizeRow.GetSibling(Infragistics.Win.UltraWinGrid.SiblingRow.Next, true, false);
                        }
                        break;
                }
                switch (bandKeyParts[0])
                {
                    case "BulkSize":
                    case "PackSize":
                    case "PackColorSize":

                        _dsDetails.Tables[bandKey].Constraints.Remove(bandKey);
                        _dsDetails.Relations.Remove(bandKey);
                        _dsDetails.Tables.Remove(bandKey);
                        break;
                
                    default:
                        break;
                }

                return true;
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
                return false;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void ClearChildAssortmentColumns(UltraGridRow aRow)
        {
            try
            {
                foreach (UltraGridChildBand childBand in aRow.ChildBands)
                {
                    switch (childBand.Key)
                    {
                        case "BulkColor":
                            foreach (UltraGridRow childRow in childBand.Rows)
                            {
                                childRow.Cells["AsrtBCRID"].Value = Include.NoRID;
                            }
                            break;

                        default:
                       
                            break;
                    } 
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SelectChildRows(UltraGridRow aRow)
        {
            try
            {
                foreach (UltraGridChildBand childBand in aRow.ChildBands)
                {
                    foreach (UltraGridRow childRow in childBand.Rows)
                    {
                        childRow.Selected = true;
                        if (childRow.HasChild())
                        {
                            SelectChildRows(childRow);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ScrollToHeaderRow(int aHeaderRID)
        {
            int index = -1;
            try
            {
                UltraGridRow headerRow = null;
                UltraGridRow gRow;
                for (int i = 0; i < ugDetails.Rows.Count; i++)
                {
                    gRow = ugDetails.Rows[i];
                    if (gRow.Band.Key == "Header" && (int)gRow.Cells["KeyH"].Value == aHeaderRID)
                    {
                        index = i;
                        headerRow = gRow;
                        break;
                    }
                }

                this.ugDetails.ActiveRow = null;
                this.ugDetails.ActiveRow = headerRow;

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.BeginUpdate();
                ugDetailsBeginUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                headerRow.Expanded = true;

                ugDetails.DisplayLayout.RowScrollRegions[0].ScrollRowIntoView(headerRow);
                // Sometimes with the 5.3 grid the following code was going into a loop so 
                // comment out for now
                //while (ugDetails.DisplayLayout.RowScrollRegions[0].VisibleRows[0].Row != headerRow)
                //{
                //	ugDetails.DisplayLayout.RowScrollRegions[0].Scroll(RowScrollAction.LineDown); 
                //}

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.EndUpdate();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }	

        private void ugDetails_AfterRowsDeleted(object sender, System.EventArgs e)
        {
            try
            {
                _dsDetails.AcceptChanges();
                _changesPending = true;    // MID Track #5501 - add 'nag' message
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_BeforeSelectChange(object sender, BeforeSelectChangeEventArgs e)
        {
            try
            {
                if (ugDetails.Selected.Rows.Count > 0)
                {
                    foreach (UltraGridRow prevSelRow in ugDetails.Selected.Rows)
                    {
                        // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                        if (prevSelRow == null ||
                            prevSelRow.Disposed)
                        {
                            continue;
                        }
                        // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                        if (prevSelRow.Band.Key == "Header"
                         && Convert.ToInt32(prevSelRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                        {
                            prevSelRow.Cells["HeaderID"].Appearance.ForeColor = prevSelRow.Band.Layout.Override.FixedCellAppearance.BackColor;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_AfterSelectChange(object sender, Infragistics.Win.UltraWinGrid.AfterSelectChangeEventArgs e)
		{
			try
			{
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                if (_inClearDetails)
                {
                    return;
                }
                // End TT#1434
				if ( typeof( UltraGridRow ) == e.Type ) 
				{
					SetActionListCombo();
					UpdateSelectedTotals();
                    if (_fromHeaderGrid || _inEditMode)
                    {
                        return;
                    }
                    // disable event firing
                    ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                    ugHeaders.EventManager.SetEnabled(GridEventIds.BeforeSelectChange, false);  // MID Track #5935 - Null Reference after creating header
					ugHeaders.Selected.Rows.Clear();
                    ugHeaders.EventManager.SetEnabled(GridEventIds.BeforeSelectChange, true);   // MID Track #5935 - Null Reference after creating header
                    if (_headersInGroupBy != null)
                    {
                        _headersInGroupBy.Clear();
                    }    

                    // BEGIN MID Track #6264 - Headers not in priority order
					// Begin TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                    //if (ugDetails.Selected.Rows.Count > 0)
                    if (ugDetails.Selected.Rows.Count > 0 &&
                        _clearSelectedList)
					// End TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                    {
                        _selectedRowsSequence.Clear();
                    }
                    //foreach (UltraGridRow selDetailRow in ugDetails.Selected.Rows)
                    for (int i = 0; i <  ugDetails.Selected.Rows.Count; i++)
					{
					    //UltraGridRow row = selDetailRow;
                        UltraGridRow row = ugDetails.Selected.Rows[i];
                    // END MID Track #6264 - Headers not in priority order
						while (row.Band.Key != "Header") 
						{
							row = row.ParentRow;
						}

                        // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                        if (row == null ||
                            row.Disposed)
                        {
                            continue;
                        }
                        // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.

                        // Begin TT#620 - RMatelic - Base 3.1 -> Created multi - select SAVE button -> get system argument exception error
                        //if (row.Cells["HeaderRow"].Value != System.DBNull.Value)
                        if (row.Cells["HeaderRow"].Value != null && row.Cells["HeaderRow"].Value != System.DBNull.Value)
                        // End TT#620
						{
							UltraGridRow hdrRow = (UltraGridRow)row.Cells["HeaderRow"].Value;
                            hdrRow.Selected = true;
                            _selectedRowsSequence.Add(hdrRow);      // MID Track #6264 
						}
					}
                    // enable event firing
                    ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
				}
			}
			catch ( Exception ex ) 
			{
				HandleException(ex);
			}
		}

		private void ugDetails_ClickCellButton(object sender, Infragistics.Win.UltraWinGrid.CellEventArgs e)
		{
			string title = _lblHeaderNotes + " ";
			try 
			{
				switch (e.Cell.Column.Key) 
				{
					case "HeaderID":
						AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                        if (ap == null)		// must be a new header
                        {
                            return;
                        }
                        else
                        {
                            TextDialog frm;
                            title = title + e.Cell.Text;
                            if (_inEditMode)
                            {
                                frm = new TextDialog(title, e.Cell.Row.Cells["Notes"].Text, 250, _allocationNonInterfacedHeadersSecurity);
                            }
                            else
                            {
                                frm = new TextDialog(title, e.Cell.Row.Cells["Notes"].Text);
                            }

                            if (frm.ShowDialog() == DialogResult.OK)
                            {
                                e.Cell.Row.Cells["Notes"].Value = frm.TextValue;
                                ap.AllocationNotes = frm.TextValue;
                            }
                            frm.Dispose();
                            if (_inEditMode)
                            {
                                SetNotesCellButton(e.Cell.Row);
                            }
                        }
						break;

                    case "BulkColor":
                    case "PackColor":
                        _fromCellButton = true;
                        _colorSelectRow = e.Cell.Row;
                        ChooseColors(false, null);
                        break;

				}
			}
			catch(Exception ex) 
			{
				HandleException(ex);
			}
		
		}

        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
        private void SetActionListCombo()
		{
            if (_detailsShown)
            {
                SetActionListComboFromDetails();
            }
            else
            {
                SetActionListComboFromHeaders();
            }
        }

        private void SetActionListComboFromDetails()
        {
			try 
			{
                bool allowProcess = true;
                if (!_allocationNonInterfacedHeadersSecurity.AllowUpdate || ugDetails.Selected.Rows.Count == 0 || _inEditMode) 
				{
					allowProcess = false;
				}
				else 
				{
					foreach (UltraGridRow row in ugDetails.Selected.Rows) 
					{
                        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                        // Begin TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                        //if (row.IsGroupByRow)
                        //{
                        //    continue;
                        //}
                        if (row.IsGroupByRow ||
                            row.IsDeleted)
                        {
                            continue;
                        }
                        // End TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                        // End TT#1434

						UltraGridRow selRow = row;
						while (selRow.Band.Key != "Header")
						{
							selRow = selRow.ParentRow;
						}
							
						if (selRow.Cells["StyleSecurity"].Value == System.DBNull.Value)
						{
							allowProcess = false;
							break;
						}
                        // Begin TT#3847 -  RMatelic - Not able to change views in allocation workspace
                        else if (Convert.ToString(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) != "")
                        {
                            allowProcess = false;
                            break;
                        }
                        else if (Convert.ToString(selRow.Cells["GroupAllocRID"].Value, CultureInfo.CurrentUICulture) != "")
                        {
                            allowProcess = false;
                            break;
                        }
                        // End TT#3847
						else
						{
							eSecurityType styleSecurity = (eSecurityType)Convert.ToInt32(selRow.Cells["StyleSecurity"].Value, CultureInfo.CurrentUICulture);
							if (styleSecurity != eSecurityType.Update)
							{
								allowProcess = false;
								break;
							}
						}
					}
				}
				if (!allowProcess)
				{
					// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
					//cboActionList.Enabled = false;
					//btnProcess.Enabled = false;
                    // Begin TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
					//((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["btnAction"]).SharedProps.Enabled = false;
                    //  Begin TT#3847 -  RMatelic - Not able to change views in allocation workspace
                    //((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).SharedProps.Enabled = false;
                    // END TT#767-MD - Stodd - remove old controls from allocation workspace
					// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["actionComboBox"]).SharedProps.Enabled = false;
                    //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerAction"];
                    //MIDComboBoxEnh.MyComboBox cmbActions = (MIDComboBoxEnh.MyComboBox)cct.Control;
                    //cct.SharedProps.Enabled = false;
                    //cmbActions.Enabled = false;
                    EnableActions(false);
                    // End TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
					// End TT#4071 - stodd - Matrix does not allow search for attribute - 
                    // End TT#3847
				}
				else
				{
					// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
					//cboActionList.Enabled = true;
					//btnProcess.Enabled = true;
                    // Begin TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
					//((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["btnAction"]).SharedProps.Enabled = true;
                    //  Begin TT#3847 -  RMatelic - Not able to change views in allocation workspace
                    //((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).SharedProps.Enabled = true;
                    // END TT#767-MD - Stodd - remove old controls from allocation workspace
					// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["actionComboBox"]).SharedProps.Enabled = true;
                    //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerAction"];
                    //MIDComboBoxEnh.MyComboBox cmbActions = (MIDComboBoxEnh.MyComboBox)cct.Control;
                    //cct.SharedProps.Enabled = true;
                    //cmbActions.Enabled = true;
                    EnableActions(true);
                    // End TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
					// End TT#4071 - stodd - Matrix does not allow search for attribute - 
                    // End TT#3847
				}
			}
			catch (Exception ex) 
			{
				HandleException(ex);
			}
		}

        private void SetActionListComboFromHeaders()
        {
            try
            {
                bool allowProcess = true;
                if (!_allocationNonInterfacedHeadersSecurity.AllowUpdate || ugHeaders.Selected.Rows.Count == 0 || _inEditMode)
                {
                    allowProcess = false;
                }
                else
                {
                    foreach (UltraGridRow row in ugHeaders.Selected.Rows)
                    {
                        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                        // Begin TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                        //if (row.IsGroupByRow)
                        //{
                        //    continue;
                        //}
                        if (row.IsGroupByRow ||
                            row.IsDeleted)
                        {
                            continue;
                        }
                        // End TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                        // End TT#1434

                        UltraGridRow selRow = row;
                        while (selRow.Band.Key != "Header")
                        {
                            selRow = selRow.ParentRow;
                        }

                        if (selRow.Cells["StyleSecurity"].Value == System.DBNull.Value)
                        {
                            allowProcess = false;
                            break;
                        }
                        //BEGIN TT#413 - MD - DOConnell - Headers that are in use by an Assortment must be processed (all actions or methods) from the Assortment
                        else if (Convert.ToString(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) != "")
                        { 
                            allowProcess = false;
                            break;
                        }
						// Begin TT#1019 - MD - stodd - prohibit allocation actions against GA - 
                        else if (Convert.ToString(selRow.Cells["GroupAllocRID"].Value, CultureInfo.CurrentUICulture) != "")
                        {
                            //Infragistics.Win.UltraWinToolbars.ButtonTool btn = ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["btnAction"]);
                            //EnhancedToolTip.SetToolTipWhenDisabled(btn, MIDText.GetTextOnly(eMIDTextCode.msg_ProcessProtectedGroupAllocation));
                            allowProcess = false;
                            break;
                        }
						// End TT#1019 - MD - stodd - prohibit allocation actions against GA - 
                        //END TT#413 - MD - DOConnell - Headers that are in use by an Assortment must be processed (all actions or methods) from the Assortment
                        else
                        {
                            eSecurityType styleSecurity = (eSecurityType)Convert.ToInt32(selRow.Cells["StyleSecurity"].Value, CultureInfo.CurrentUICulture);
                            if (styleSecurity != eSecurityType.Update)
                            {
                                allowProcess = false;
                                break;
                            }
                        }
                    }
                }
                if (!allowProcess)
                {
					// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                    //cboActionList.Enabled = false;
                    //btnProcess.Enabled = false;
                    // Begin TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
					//((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["btnAction"]).SharedProps.Enabled = false;
                    //  Begin TT#3847 -  RMatelic - Not able to change views in allocation workspace
					//((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).SharedProps.Enabled = false;
					// END TT#767-MD - Stodd - remove old controls from allocation workspace
                    //((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["actionComboBox"]).SharedProps.Enabled = false;
					// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerAction"];
                    //MIDComboBoxEnh.MyComboBox cmbActions = (MIDComboBoxEnh.MyComboBox)cct.Control;
                    //cct.SharedProps.Enabled = false;
                    //cmbActions.Enabled = false;
                    EnableActions(false);
                    // End TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
					// End TT#4071 - stodd - Matrix does not allow search for attribute - 
                    // End TT#3847
                }
                else
                {
					// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                    //cboActionList.Enabled = true;
                    //btnProcess.Enabled = true;
                    // Begin TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
					//((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["btnAction"]).SharedProps.Enabled = true;
                    //  Begin TT#3847 -  RMatelic - Not able to change views in allocation workspace
                    //((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).SharedProps.Enabled = true;
                    // END TT#767-MD - Stodd - remove old controls from allocation workspace
					// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["actionComboBox"]).SharedProps.Enabled = true;
                    //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerAction"];
                    //MIDComboBoxEnh.MyComboBox cmbActions = (MIDComboBoxEnh.MyComboBox)cct.Control;
                    //cct.SharedProps.Enabled = true;
                    //cmbActions.Enabled = true;
                    EnableActions(true);
                    // End TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
					// End TT#4071 - stodd - Matrix does not allow search for attribute - 
                    // End TT#3847
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        // Begin TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
        private void EnableActions(bool enableList)
        {
            // Process Button
            ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["btnAction"]).SharedProps.Enabled = enableList;
            // Action List
            Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerAction"];
            //MIDComboBoxEnh.MyComboBox cmbActions = (MIDComboBoxEnh.MyComboBox)cct.Control;
            MIDComboBoxEnh.MyComboBox cmbActions = GetActionComboBoxControl();
            cct.SharedProps.Enabled = enableList;
            cmbActions.Enabled = enableList;
        }
        // End TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.

        private void UpdateSelectedTotals()
        {
            if (_creatingMulti)
            {
                return;
            }

            if (_detailsShown)
            {
                UpdateSelectedTotalsFromDetails();
            }
            else
            {
                UpdateSelectedTotalsFromHeaders();
            }
        }

        private void UpdateSelectedTotalsFromDetails() 
		{
			int selHeaders = 0, selUnits = 0, totalUnits = 0;
			string labelText = string.Empty; 
			GeneralComponent aComponent;
			GeneralComponent anotherComponent;

			int colorRID;
			_selectedHeaderKeyList.Clear();
            _selectedAssortmentKeyList.Clear(); // TT#488 - MD - Jellis - Group Allocation
			_selectedComponentList.Clear();
			_SAB.ClientServerSession.ClearSelectedHeaderList();
			_SAB.ClientServerSession.ClearSelectedComponentList();

            try
            {
                if (ugDetails.Selected.Rows.Count > 0)
                {
                    foreach (UltraGridRow row in ugDetails.Selected.Rows)
                    {
                        // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                        //uRow.Cells["HeaderRow"].Value = System.DBNull.Value;
                        if (row == null ||
                            row.Disposed)
                        {
                            continue;
                        }
                        // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                        UltraGridRow selRow = row;

                        string[] bandKeyParts = selRow.Band.Key.Split(new char[] { '~' });
                        int hdrRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                        switch (bandKeyParts[0])
                        {
                            case "Header":
                                // Begin TT#2 - RMatelic - AssortmentPlanning-Phase 2  Assortment and placeholder rows are hidden so skip them   
                                eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                                if (headerType == eHeaderType.Assortment || headerType == eHeaderType.Placeholder)
                                {
                                    continue;
                                }
                                // End TT#2
                                break;

                            case "BulkColor":
                                if (row.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                                {
                                    colorRID = Convert.ToInt32(row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                    aComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorRID);
                                    GeneralComponentWrapper aComponentWrapper = new GeneralComponentWrapper(hdrRID, aComponent);
                                    _selectedComponentList.Add(aComponentWrapper);
                                }
                                selRow = selRow.ParentRow;
                                break;

                            case "BulkSize":
                                UltraGridRow ColorRow = selRow.ParentRow;
                                if (ColorRow.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                                {
                                    colorRID = Convert.ToInt32(ColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                    aComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorRID);
                                    GeneralComponent allSizeComp = new GeneralComponent(eGeneralComponentType.AllSizes);
                                    anotherComponent = new AllocationColorSizeComponent(aComponent, allSizeComp);
                                    GeneralComponentWrapper aComponentWrapper = new GeneralComponentWrapper(hdrRID, anotherComponent);
                                    _selectedComponentList.Add(aComponentWrapper);
                                }
                                selRow = selRow.ParentRow.ParentRow;
                                break;

                            case "Pack":
                                if (row.Cells["Pack"].Value != System.DBNull.Value)
                                {
                                    aComponent = new AllocationPackComponent(row.Cells["Pack"].Value.ToString());
                                    GeneralComponentWrapper aComponentWrapper = new GeneralComponentWrapper(hdrRID, aComponent);
                                    _selectedComponentList.Add(aComponentWrapper);
                                }
                                selRow = selRow.ParentRow;
                                break;

                            case "PackColor":
                                if (row.Cells["ColorCodeRID"].Value != System.DBNull.Value)
                                {
                                    colorRID = Convert.ToInt32(row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                    aComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorRID);
                                    GeneralComponentWrapper aComponentWrapper = new GeneralComponentWrapper(hdrRID, aComponent);
                                    _selectedComponentList.Add(aComponentWrapper);
                                }
                                selRow = selRow.ParentRow.ParentRow;
                                break;

                            case "PackColorSize":
                                selRow = selRow.ParentRow.ParentRow.ParentRow;
                                break;

                            default:
                                selRow = selRow.ParentRow.ParentRow;
                                break;
                        }

                        if (!_selectedHeaderKeyList.Contains(hdrRID)  // TT#488 - MD - Jellis - Group Allocation
                            && !_selectedAssortmentKeyList.Contains(hdrRID)) // TT#488 - MD - Jellis - Group Allocation
                        {
                            string headerID = Convert.ToString(selRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
							// Begin Assortment changes
							eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                            //_selectedHeaderKeyList.Add(hdrRID); // TT#488 - MD - Jellis - Group Allocation
                            // BEGIN MID Track #6022 - Error trying to Process method before saving new header.
                            //                         Solution: don't add new non-saved headers to SelectedHeaderList
                            //_SAB.ClientServerSession.AddSelectedHeaderList(hdrRID, headerID, headerType);
                            int asrtRID;
                            if (selRow.Cells["AsrtRID"].Value == DBNull.Value)
                            {
                                asrtRID = Include.NoRID;
                            }
                            else
                            {
                                asrtRID = Convert.ToInt32(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                            }
                            if (hdrRID > Include.DefaultHeaderRID)
                            {
                                int styleHnRID = Convert.ToInt32(selRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                _SAB.ClientServerSession.AddSelectedHeaderList(hdrRID, headerID, headerType, asrtRID, styleHnRID);
                            }
                            // END MID Track #6022
                            // begin TT#488 - MD - Jellis - Group Allocation
                            if (headerType == eHeaderType.Assortment)
                            {
                                _selectedAssortmentKeyList.Add(hdrRID);
                            }
                            else
                            {
                                _selectedHeaderKeyList.Add(hdrRID);
                            }
							// Begin Assortment changes
                            selHeaders++;
                            if (selRow.Cells["HdrQuantity"].Value != System.DBNull.Value)
                            {
                                selUnits += Convert.ToInt32(selRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                            }
                        }
                    }
                }
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //this.lblHeaderCount.Text = _lblSelected + ": " + selHeaders.ToString("#,###,##0", CultureInfo.CurrentUICulture);

                //labelText = _lblTotal + ":      ";

                //this.lblHeaderTotal.Text = labelText + " " + _dtHeader.Rows.Count.ToString("#,###,##0", CultureInfo.CurrentUICulture);
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
				
                //Begin -jsobek -Toolbar Enhancement
                ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["headerSelectedTextBox"]).Text = selHeaders.ToString("#,###,##0", CultureInfo.CurrentUICulture);
                ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["headerTotalTextBox"]).Text = _dtHeader.Rows.Count.ToString("#,###,##0", CultureInfo.CurrentUICulture);
                //End -jsobek -Toolbar Enhancement

                if (_dtHeader.Rows.Count > 0)
                {
                    foreach (DataRow row in _dtHeader.Rows)
                    {
                        if (row["HdrQuantity"] != System.DBNull.Value)
                        {
                            totalUnits += Convert.ToInt32(row["HdrQuantity"], CultureInfo.CurrentUICulture);
                        }
                    }
                }
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //this.lblSelQty.Text = _lblSelected + ": " + selUnits.ToString("#,###,##0", CultureInfo.CurrentUICulture);
                //this.lblTotQty.Text = labelText + " " + totalUnits.ToString("#,###,##0", CultureInfo.CurrentUICulture);
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
                //Begin -jsobek -Toolbar Enhancement
                ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["quantityAllocateSelectedTextBox"]).Text = selUnits.ToString("#,###,##0", CultureInfo.CurrentUICulture);
                ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["quantityAllocateTotalTextBox"]).Text = totalUnits.ToString("#,###,##0", CultureInfo.CurrentUICulture);
                //End -jsobek -Toolbar Enhancement
                

                if (_selectedComponentList.Count > 0)
                {
                    foreach (GeneralComponentWrapper gcw in _selectedComponentList)
                    {
                        _SAB.ClientServerSession.AddSelectedComponentList(gcw);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
	    }

        private void UpdateSelectedTotalsFromHeaders()
        {
            int selHeaders = 0, selUnits = 0, totalUnits = 0;
            string labelText = string.Empty;

            _selectedHeaderKeyList.Clear();
            _selectedAssortmentKeyList.Clear();  // TT#488 - MD - Jellis - Group Allocation
            _selectedComponentList.Clear();
            _SAB.ClientServerSession.ClearSelectedHeaderList();
            _SAB.ClientServerSession.ClearSelectedComponentList();

            try
            {
                if (ugHeaders.Selected.Rows.Count > 0)
                {
                    // Begin TT#2681 - JSmith - Unable to group headers by header characteristic
                    ArrayList selectedRows = new ArrayList();
                    if (typeof(UltraGridGroupByRow) == _ultraGridRowSelectedType)
                    {
                        foreach (UltraGridRow row in _selectedRowsSequence)
                        {
                            selectedRows.Add(row);
                        }
                    }
                    else
                    {
                        foreach (UltraGridRow row in ugHeaders.Selected.Rows)
                        {
                            selectedRows.Add(row);
                        }
                    }

                    //foreach (UltraGridRow row in ugHeaders.Selected.Rows)
                    foreach (UltraGridRow row in selectedRows)
                    // End TT#2681 - JSmith - Unable to group headers by header characteristic
                    {
                        //Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                        // Begin TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                        //if (row.IsGroupByRow)
                        //{
                        //    continue;
                        //}
                        if (row.IsGroupByRow ||
                            row.IsDeleted)
                        {
                            continue;
                        }
                        // End TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                        //End TT#1434

                        UltraGridRow selRow = row;

                        string[] bandKeyParts = selRow.Band.Key.Split(new char[] { '~' });
                        int hdrRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                        if (!_selectedHeaderKeyList.Contains(hdrRID) // TT#488 - MD - Jellis - Group Allocation
                            && !_selectedAssortmentKeyList.Contains(hdrRID))  // TT#488 - MD - Jellis - Group Allocation
                        {
                            string headerID = Convert.ToString(selRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
							// BEGIN Stodd - 4.0 to 4.1 Manual merge
							int asrtRid = Include.NoRID;
							if (selRow.Cells["AsrtRID"].Value != DBNull.Value)
							{
								asrtRid = Convert.ToInt32(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
							}
							// END Stodd - 4.0 to 4.1 Manual merge
							// Begin TT#964 - MD - stodd - selected header list - 
							// Begin TT#1154-MD - stodd - null reference when opening selection - 
                            //int groupAllocRid = Include.NoRID;
                            if (asrtRid == Include.NoRID && selRow.Cells["GroupAllocRID"].Value != DBNull.Value)
                            {
                                //groupAllocRid = Convert.ToInt32(selRow.Cells["GroupAllocRID"].Value, CultureInfo.CurrentUICulture);
                                asrtRid = Convert.ToInt32(selRow.Cells["GroupAllocRID"].Value, CultureInfo.CurrentUICulture); 
                            }
							// End TT#1154-MD - stodd - null reference when opening selection - 
							// End TT#964 - MD - stodd - selected header list - 
                            						
							int styleRid = Convert.ToInt32(selRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                            // Begin Assortment changes
                            eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                            //_selectedHeaderKeyList.Add(hdrRID); // TT#488 - MD - Jellis - Group Allocation
                            // BEGIN MID Track #6022 - Error trying to Process method before saving new header.
                            //                         Solution: don't add new non-saved headers to SelectedHeaderList
                            //_SAB.ClientServerSession.AddSelectedHeaderList(hdrRID, headerID, headerType);
                            if (hdrRID > Include.DefaultHeaderRID)
                            {
                                _SAB.ClientServerSession.AddSelectedHeaderList(hdrRID, headerID, headerType, asrtRid, styleRid);	
                            }
                            // END MID Track #6022
                            
                            // begin TT#488 - MD - Jellis - Group Allocation
                            if (headerType == eHeaderType.Assortment)
                            {
                                _selectedAssortmentKeyList.Add(hdrRID);
                            }
                            else
                            {
                                _selectedHeaderKeyList.Add(hdrRID);
                            }
                            // end TT#488 - MD - Jellis - Group ALlocation

                            // Begin Assortment changes
                            selHeaders++;
                            if (selRow.Cells["HdrQuantity"].Value != System.DBNull.Value)
                            {
                                selUnits += Convert.ToInt32(selRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                            }
                        }
                    }
                }

				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
               	//this.lblHeaderCount.Text = _lblSelected + ": " + selHeaders.ToString("#,###,##0", CultureInfo.CurrentUICulture);

                //labelText = _lblTotal + ":      ";

                //this.lblHeaderTotal.Text = labelText + " " + _dtHeader.Rows.Count.ToString("#,###,##0", CultureInfo.CurrentUICulture);
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
                //Begin -jsobek -Toolbar Enhancement
                ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["headerSelectedTextBox"]).Text = selHeaders.ToString("#,###,##0", CultureInfo.CurrentUICulture);
                ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["headerTotalTextBox"]).Text = _dtHeader.Rows.Count.ToString("#,###,##0", CultureInfo.CurrentUICulture);
                //End -jsobek -Toolbar Enhancement

                if (_dtHeader.Rows.Count > 0)
                {
                    foreach (DataRow row in _dtHeader.Rows)
                    {
                        if (row["HdrQuantity"] != System.DBNull.Value)
                        {
                            totalUnits += Convert.ToInt32(row["HdrQuantity"], CultureInfo.CurrentUICulture);
                        }
                    }
                }
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //this.lblSelQty.Text = _lblSelected + ": " + selUnits.ToString("#,###,##0", CultureInfo.CurrentUICulture);
                //this.lblTotQty.Text = labelText + " " + totalUnits.ToString("#,###,##0", CultureInfo.CurrentUICulture);
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
                //Begin -jsobek -Toolbar Enhancement
                ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["quantityAllocateSelectedTextBox"]).Text = selUnits.ToString("#,###,##0", CultureInfo.CurrentUICulture);
                ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["quantityAllocateTotalTextBox"]).Text = totalUnits.ToString("#,###,##0", CultureInfo.CurrentUICulture);
                //End -jsobek -Toolbar Enhancement

                if (_selectedComponentList.Count > 0)
                {
                    foreach (GeneralComponentWrapper gcw in _selectedComponentList)
                    {
                        _SAB.ClientServerSession.AddSelectedComponentList(gcw);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        // End TT#1434

        private void ugDetails_BeforeCellUpdate(object sender, BeforeCellUpdateEventArgs e)
        {
            try
            {
                if (_skipBeforeCellUpdate)
                {
                    _skipBeforeCellUpdate = false;
                    return;
                }

                switch (e.Cell.Band.Key)
                {
                    case "Header":
                    //case "Placeholder":
                        CheckHeaderBeforeCellUpdate(ref e);
                        break;

                    case "Pack":
                        CheckPackBeforeCellUpdate(ref e);
                        break;

                    case "PackColor":
                        CheckPackColorBeforeCellUpdate(ref e);
                        break;

                    case "BulkColor":
                        CheckBulkColorBeforeCellUpdate(ref e);
                        break;
                }
                if (e.Cancel)
                {
                    _invalidCell = e.Cell;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
		}

        private void CheckHeaderBeforeCellUpdate(ref BeforeCellUpdateEventArgs e)
        {
            string errorMessage = string.Empty;
            try
            {
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                switch (e.Cell.Column.Key)
                {
                    case "HeaderID": //  needs to use NewValue
                        if (!ValidHeaderID(e.Cell, ref errorMessage, Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture)))
                        {
                            MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            e.Cancel = true;
                            return;
                        }
                        break;

                    case "Type":
                        switch ((eHeaderType)Convert.ToInt32(e.NewValue, CultureInfo.CurrentUICulture))
                        {
                            case eHeaderType.MultiHeader:
                                if (!_creatingMulti)
                                {
                                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_HeaderTypeNotAllowed);
                                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    e.Cancel = true;
                                }
                                break;

                            case eHeaderType.WorkupTotalBuy:
                                if (ap.Packs != null && ap.Packs.Count > 0)
                                {
                                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_InvalidTypeForHeadersWithPacks);
                                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    e.Cancel = true;
                                }
                                break;

                            default:
                                break;
                        }
                        break;

                    case "AnchorNode":
                        if (!_skipAnchorEdit)
                        {
                            string anchorID = Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture);
                            int anchorKey = GetAnchorNodeKey(anchorID);
                            if (anchorKey == -1)
                            {
                                e.Cancel = true;
                            }
                            //else if (!ValidAssortmentLink(e.Cell.Row, anchorKey))
                            //{
                            //    e.Cancel = true;
                            //}    
                        }
                        break;

                    case "Product":
                        if (!_skipProductEdit)
                        {
                            string productID = Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture);
                            int key = GetProductIdKey(productID);
                            if (key == -1)
                            {
                                e.Cancel = true;
                            }
                        }
                        break;

                    case "Style":
                        if (!_skipStyleEdit)
                        {
                            string styleID = Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture);
                            if (styleID.Trim() == string.Empty)
                            {
                                errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_MustBeCorrectLevel), _hlpStyle.LevelID);
                                MessageBox.Show(errorMessage, _thisTitle);
                                e.Cancel = true;
                            }

                            if (!e.Cancel)
                            {   
                                if (!ValidStyle(e.Cell, styleID, ref errorMessage))
                                {
                                    e.Cancel = true;
                                }
                            }  
                        }
                        break;

                    case "SizeGroup":
                        // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                        if (Convert.ToInt32(e.NewValue, CultureInfo.CurrentUICulture) == Include.UndefinedSizeGroupRID && ap.MultiHeader)
                        {
                            break;
                        }
                        // End TT#234 
                        ArrayList keys = new ArrayList();
                        if (ap.BulkColors.Count > 0)
                        {
                            foreach (HdrColorBin aColor in ap.BulkColors.Values)
                            {
                                if (aColor.ColorSizes.Count > 0)
                                {
                                    foreach (HdrSizeBin hsb in aColor.ColorSizes.Values)
                                    {
                                        if (!keys.Contains(hsb.SizeKey))
                                        {
                                            keys.Add(hsb.SizeKey);
                                        }
                                    }
                                }
                            }
                        }

                        if (ap.Packs.Count > 0)
                        {
                            foreach (PackHdr aPack in ap.Packs.Values)
                            {
                                foreach (PackColorSize pcs in aPack.PackColors.Values)
                                {
                                    if (pcs.ColorSizes.Count > 0)
                                    {
                                        foreach (PackContentBin pcb in pcs.ColorSizes.Values)
                                        {
                                            if (!keys.Contains(pcb.ContentCodeRID))
                                            {
                                                keys.Add(pcb.ContentCodeRID);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (keys.Count > 0)
                        {
                            bool allSizesFound = true;
                            int newSizeGroupRID = Convert.ToInt32(e.NewValue, CultureInfo.CurrentUICulture);
                            SizeGroupProfile sgp = new SizeGroupProfile(newSizeGroupRID);
                            SizeCodeList scl = sgp.SizeCodeList;
                            foreach (int sizeKey in keys)
                            {
                                SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(sizeKey);
                                if (scp == null)
                                {	// if an existing size is not in the newly selected group, error  
                                    allSizesFound = false;
                                    break;
                                }
                            }
                            if (!allSizesFound)
                            {
                                errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_DeleteExistingSizes);
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                            else
                            {
                                _rebuildSizes = true;
                            }
                        }
                        break;
                    case "Workflow":
                        string workFlow = Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture).Trim();
                        int workflowRID = Include.UndefinedWorkflowRID;
                        if (workFlow != string.Empty)
                        {
                            if (!_workflowNameHash.ContainsValue(workFlow))
                            {
                                WorkflowBaseData workflowData = new WorkflowBaseData();
                                DataTable dt = workflowData.GetWorkflow(workFlow);
                                if (dt.Rows.Count == 0)
                                {
                                    errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_Data1NotValidData2),
                                                   workFlow, MIDText.GetTextOnly(eMIDTextCode.lbl_Workflow));
                                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    e.Cancel = true;
                                }
                                else
                                {
                                    DataRow row = dt.Rows[0];
                                    workflowRID = Convert.ToInt32(row["WORKFLOW_RID"], CultureInfo.CurrentUICulture);
                                    _workflowNameHash.Add(workflowRID, workFlow);
                                }
                            }
                        }
                        break;
                    
                    // Begin TT#1652-MD - RMatelic - DC Carton Rounding - for now, this edit is commented out
                    case "DC":
                        //if (!ValidDistCenter(e.Cell, ref errorMessage, Convert.ToString(e.NewValue, CultureInfo.CurrentUICulture)))
                        //{
                        //    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        //    e.Cancel = true;
                        //    return;
                        //}              
                        break;
                    // End TT#1652-MD 

                    case "AsrtType":
                    case "CharUpdated":
                    case "ChildTotal":
                    case "Balance":
                    case "StyleHnRID":
                    case "ProductRID":
                    case "AsrtRID":
                    case "AnchorHnRID":
                    case "PlaceHolderRID":
                    case "Multiple":    // TT#1652-MD - RMatelic - DC Carton rounding
                        break;

                    default:
                        if (e.Cell.Column.Tag != null &&
                            e.Cell.Column.Tag.GetType() == typeof(HeaderCharGroupProfile))
                        {
                            CheckCharBeforeCellUpdate(ref e);
                            // Begin TT#1641 - RMatelic - Warning message should be sent when applying a Header Characteristic to a Multi-Header 
                            if (!e.Cancel && ap.MultiHeader)
                            {
                                errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderCharacteristicWarning);
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Warning);
                            }
                            // End TT#1641
                        }
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        
        private void CheckCharBeforeCellUpdate(ref BeforeCellUpdateEventArgs e)
        {
            string errorMessage = string.Empty;
            int charRID = 0;
            try
            {
                HeaderCharGroupProfile hcgp = (HeaderCharGroupProfile)e.Cell.Column.Tag;
                if (!hcgp.ListInd)
                {
                    switch (hcgp.Type)
                    {
                        case eHeaderCharType.text:
                            break;

                        case eHeaderCharType.number:
                        case eHeaderCharType.dollar:
                            if (!ValidCharNumber(ref e, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                            break;

                        case eHeaderCharType.date:
                            if (!ValidCharDate(ref e, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                            break;
                    }

                    if (!e.Cancel && e.NewValue != System.DBNull.Value && e.NewValue.ToString().Trim() != string.Empty)
                    {
                        charRID = _SAB.HeaderServerSession.GetCharForCharGroup(hcgp.Key, e.NewValue);
                        if (charRID == Include.NoRID)
                        {
                            // Begin TT#267 - RMatelic - Remove warning message when adding Header Characteristics
                            //errorMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LevelNotFoundAddQuestion),
                            //         hcgp.ID, e.NewValue.ToString());
                            //DialogResult ret = MessageBox.Show(errorMessage, string.Empty, MessageBoxButtons.YesNo,
                            //                   MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
                            //if (ret == DialogResult.No)
                            //{
                            //    e.Cancel = true;
                            //}
                            //else
                            //{
                            charRID = _SAB.HeaderServerSession.UpdateCharInCharGroup(hcgp.Key, (object)e.NewValue.ToString().Trim());
                            //}
                        }   // End TT#267
                        if (!e.Cancel)
                        {
                            int hdrRID = Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            DataRow dr = _dsDetails.Tables["Header"].Rows.Find(hdrRID);
                            DataColumn col = null;
                            for (int i = _nonCharColCount; i < _dsDetails.Tables["Header"].Columns.Count; i++)
                            {
                                col = _dsDetails.Tables["Header"].Columns[i];
                                // Begin TT#752-MD - RMatelic Adding text in a Header Characteristic and saving causes Object Reference error>>> should have been included in TT#440-MD
                                //if (col.ColumnName == hcgp.ID)
                                if (col.ColumnName == hcgp.Key.ToString())
                                // End TT#752-MD
                                {
                                    break;
                                }
                            }    
                            // need to save the char RID for update routine
                            string charString = hcgp.Key.ToString() + "~" + e.NewValue;
                            if (!col.ExtendedProperties.ContainsKey(charString))
                            {
                                col.ExtendedProperties.Add(charString, charRID);
                            }
                        }    
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
    
        private void CheckPackBeforeCellUpdate(ref BeforeCellUpdateEventArgs e)
        {
            string packName, errorMessage = string.Empty;
            try
            {
                switch (e.Cell.Column.Key) 
				{
				    case "Pack":
					    errorMessage = string.Empty;
					    if (!_creatingMulti && !_fromSaveAs && !_creatingAssortment)
					    {	
						    if (!RequiredFieldEntered(e.Cell, ref errorMessage)) 
						    {
							    MessageBox.Show (errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
							    e.Cancel = true;
						    } 
					    }
                        if (!e.Cancel)                    
                        {
                            packName = e.NewValue.ToString();

                            if (!ValidPackName(e.Cell, packName, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cell.Appearance.Image = null;
                                e.Cell.Tag = null;
                                e.Cancel = true;
                            }
                        }
					    break;

                    default:
                        break;
		        }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CheckPackColorBeforeCellUpdate(ref BeforeCellUpdateEventArgs e)
        {
            string errorMessage = string.Empty;
            try
            {
                switch (e.Cell.Column.Key)
                {
                    case "PackColor":
                        string packColor = e.NewValue.ToString();
                        if (!_creatingMulti && !_creatingAssortment)
                        {
                            if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                            else
                            {
                                ColorCodeProfile ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(packColor);
                                if (ccp.Key != Include.NoRID && ccp.VirtualInd)
                                {
                                    
                                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PlaceholderEntryNotAllowed);
                                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    e.Cancel = true;
                                }
                            }
                        }
                        if (!e.Cancel)
                        {
                            if (!ValidPackColor(e.Cell, packColor, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cell.Appearance.Image = null;
                                e.Cell.Tag = null;
                                e.Cancel = true;
                            }
                        }
                        break;

                    default:
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CheckBulkColorBeforeCellUpdate(ref BeforeCellUpdateEventArgs e)
        {
            string errorMessage = string.Empty;
            try
            {
                switch (e.Cell.Column.Key)
                {
                    case "BulkColor":
                        errorMessage = string.Empty;
                        string bulkColor = e.NewValue.ToString();
                        if (!_creatingMulti)
                        {
                            if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                            {
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                e.Cancel = true;
                            }
                            else
                            {
                                ColorCodeProfile ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(bulkColor);
                                if (ccp.Key != Include.NoRID && ccp.VirtualInd)
                                {
                                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PlaceholderEntryNotAllowed);
                                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    e.Cancel = true;
                                }
                            }
                        }
                        if (!e.Cancel)
                        {
                            if (!_creatingMulti)
                            {
                                if (!ValidBulkColor(e.Cell, bulkColor, ref errorMessage))
                                {
                                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    e.Cell.Appearance.Image = null;
                                    e.Cell.Tag = null;
                                    e.Cancel = true;
                                }
                            }
                        }
                        break;

                    default:
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        // Begin TT#404-MD - RMatelic - Should not be able to select Multi-Header as a Header Type when adding a new Header within the Allocation Workspace
        private void ugDetails_BeforeCellActivate(object sender, CancelableCellEventArgs e)
        {
            try
            {
                if (e.Cell.Row.Band.Key == "Header" && e.Cell.Column.Key == "Type")
                {
                    if ((eHeaderType)e.Cell.Value != eHeaderType.MultiHeader)
                    {
                        ValueList valList = _headerTypeValueList.Clone();
                        for (int i = valList.ValueListItems.Count - 1; i >= 0; i--)
                        {
                            if (valList.ValueListItems[i].DataValue.Equals((int)(eHeaderType.MultiHeader)) ||
                                valList.ValueListItems[i].DataValue.Equals((int)(eHeaderType.Assortment)) ||
                                valList.ValueListItems[i].DataValue.Equals((int)(eHeaderType.Master)) ||   // TT#1966-MD - JSmith - DC Fulfillment
                                valList.ValueListItems[i].DataValue.Equals((int)(eHeaderType.Placeholder)))
                            {
                                valList.ValueListItems.RemoveAt(i);
                            }
                        }
                        e.Cell.ValueList = valList;
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        // End TT#404-MD

        private void ugDetails_BeforeCellDeactivate(object sender, CancelEventArgs e)
        {
            try
            {
                if (_invalidCell != null)
                {
                    e.Cancel = true;
                    ugDetails.ActiveCell = _invalidCell;
                    ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                    _invalidCell = null;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_AfterCellUpdate(object sender, CellEventArgs e)
        {
            try
            {
               	string[] bandKeyParts = e.Cell.Band.Key.Split(new char[] {'~'});

                switch (bandKeyParts[0])
                {
                    case "Header":
                    //case "Placeholder":
                        if (_skipHeaderEdit)
                        {
                            return;
                        }
                        UpdateHeaderData(e);
                        break;

                    case "Pack":
                        UpdatePackData(e);
                        break;
                   
                    case "PackColor":
                        UpdatePackColorData(e);
                        break;

                    case "BulkColor":
                        UpdateBulkColorData(e);
                        break;

                    case "BulkSize":
                        UpdateBulkSizeData(e);
                        break;

                    case "PackSize":
                    case "PackColorSize":
                        UpdatePackSizeData(e);
                        break;

                    default:
                        break;
                }
              
                UpdateSelectedTotals();
                _changesPending = true;    // MID Track #5501 - add 'Save Changes?' message
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void UpdateHeaderData(CellEventArgs e)
        {
            try
            {
                bool updateHeaderID = true;
                string errorMessage;
                HierarchyNodeProfile productHnp;
                int hRID = Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                if (ap == null)
                {	// must be a new header
                    string headerID = e.Cell.Row.Cells["HeaderID"].Value.ToString();
                   
                    int newKey = (_allocProfileList.MinValue > 0) ? -1 : _allocProfileList.MinValue - 1;	// all new keys are negative
                    ap = new AllocationProfile(_SAB, headerID, newKey, _SAB.ClientServerSession);
                  
                    ap.HeaderDay = Convert.ToDateTime(e.Cell.Row.Cells["Date"].Value, CultureInfo.CurrentUICulture);
                    if ((eHeaderType)Convert.ToInt32(e.Cell.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == eHeaderType.Receipt)
                    {
                        // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28B
                        //ap.Receipt = true;
                        MIDException midException;
                        if (!ap.SetHeaderType(eHeaderType.Receipt, out midException))
                        {
                            throw midException;
                        }
                        // end TT#1401 - Jellis - Urban Virtual Store Warehouse pt 28B
                    }

                    // add header to list
                    _allocProfileList.Add(ap);
                    e.Cell.Row.Cells["KeyH"].Value = newKey;

                    updateHeaderID = false;
                }
                switch (e.Cell.Column.Key)
                {
                    case "HeaderID":
                        if (updateHeaderID)
                        {
                            string oldID = Convert.ToString(e.Cell.OriginalValue, CultureInfo.CurrentUICulture);
                            string newID = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                            ap.HeaderID = newID;
                            if (ap.MultiHeader)
                            {
                                UpdateMultiHeaderID(oldID, newID);
                            }
                            else if (ap.Assortment)
                            {
                                UpdateAssortmentID(oldID, newID);
                            }
                            else if (ap.Placeholder)
                            {
                                UpdatePlaceholderID(oldID, newID);
                            }
                        }
                        break;

                    case "Type":
                        // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28B (Standardize edits/setting of Header type -- put in single place
                        ////		first set the flags to false
                        //ap.ASN = false;                  
                        //ap.Assortment = false;
                        //ap.DropShip = false;             
                        //ap.IsDummy = false;              
                        //ap.MultiHeader = false;
                        //ap.Placeholder = false;
                        //ap.IsPurchaseOrder = false;     
                        //ap.Receipt = false;              
                        //ap.Reserve = false;           
                        //ap.WorkUpTotalBuy = false;
                        //// BEGIN TT#1401 - stodd - add VSW (IMO)
                        //ap.IMO = false;
                        //// END TT#1401 - stodd - add VSW (IMO)

                        //// BEGIN MID Track #5977 - WorkUpBuy error
                        //bool protectQty = false;
                        //// END MID Track #5977

                        //switch ((eHeaderType)Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture))
                        //{
                        //    case eHeaderType.ASN:
                        //        ap.ASN = true;
                        //        break;

                        //    case eHeaderType.Assortment:
                        //        ap.Assortment = true;
                        //        break;

                        //    case eHeaderType.DropShip:
                        //        ap.DropShip = true;
                        //        break;
                       
                        //    case eHeaderType.Dummy:
                        //        ap.IsDummy = true;
                        //        break;
                            
                        //    case eHeaderType.MultiHeader:
                        //        ap.MultiHeader = true;
                        //        break;

                        //    case eHeaderType.Placeholder:
                        //        ap.Placeholder = true;
                        //        break;

                        //    case eHeaderType.PurchaseOrder:
                        //        ap.IsPurchaseOrder = true;
                        //        break;

                        //    case eHeaderType.Receipt:
                        //        ap.Receipt = true;
                        //        break;
                       
                        //    case eHeaderType.Reserve:
                        //        ap.Reserve = true;
                        //        break;
                           
                        //    case eHeaderType.WorkupTotalBuy:
                        //        ap.WorkUpTotalBuy = true;
                        //        protectQty = true;
                        //        break;

                        //    // BEGIN TT#1401 - stodd - add VSW (IMO)
                        //    case eHeaderType.IMO:
                        //        ap.IMO = true;
                        //        break;
                        //    // END TT#1401 - stodd - add VSW (IMO)
                        //}
                        //// BEGIN MID Track #5977 - WorkUpBuy error
                        //if (protectQty || (eHeaderType)Convert.ToInt32(e.Cell.OriginalValue, CultureInfo.CurrentUICulture) == eHeaderType.WorkupTotalBuy)
                        //{
                        //    UpdateQuantityActivation(e.Cell.Row, protectQty);
                        //}
                        //// END MID Track #5977

                        //// BEGIN TT#1401 - stodd - add VSW (IMO)
                        //if ((eHeaderType)Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture) == eHeaderType.IMO)
                        //{
                        //    UpdateImoIdActivation(e.Cell.Row, false);	// false = AllowEdit
                        //}
                        //else
                        //{
                        //    e.Cell.Row.Cells["ImoId"].Value = string.Empty;
                        //    UpdateImoIdActivation(e.Cell.Row, true);	// true = NoEdit
                        //}
                        //// END TT#1401 - stodd - add VSW (IMO)

                        MIDException midException;
                        bool protectQty = false;
                        //e.Cell.Row.Cells["ImoId"].Value = string.Empty;
                        UpdateImoIdActivation(e.Cell.Row, true);	// true = NoEdit
                        eHeaderType headerType = (eHeaderType)Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        switch (headerType)
                        {
                            case eHeaderType.IMO:
                                {
                                    UpdateImoIdActivation(e.Cell.Row, false);	// false = AllowEdit
                                    break;
                                }
                            case eHeaderType.ASN:
                            case eHeaderType.Assortment:
                            case eHeaderType.DropShip:
                            case eHeaderType.Dummy:
                            case eHeaderType.MultiHeader:
                            case eHeaderType.Placeholder:
                            case eHeaderType.PurchaseOrder:
                            case eHeaderType.Receipt:
                            case eHeaderType.Reserve:
                                {
                                    if (!ap.SetHeaderType(headerType, out midException))
                                    {
                                        throw midException;
                                    }
                                    break;
                                }
                            case eHeaderType.WorkupTotalBuy:
                                {
                                    if (!ap.SetHeaderType(headerType, out midException))
                                    {
                                        throw midException;
                                    }
                                    protectQty = true;
                                }
                                break;
                            default:
                                {
                                    throw new MIDException(eErrorLevel.severe,
                                        (int)eMIDTextCode.msg_al_unknownHeaderType,
                                        MIDText.GetTextOnly(eMIDTextCode.msg_al_unknownHeaderType, Enum.GetName(typeof(eHeaderType), headerType)));
                                }
                        }
                        if (protectQty || (eHeaderType)Convert.ToInt32(e.Cell.OriginalValue, CultureInfo.CurrentUICulture) == eHeaderType.WorkupTotalBuy)
                        {
                            UpdateQuantityActivation(e.Cell.Row, protectQty);
                        }
                        // end TT#1401 - Jellis - Urban Virtual Store Warehouse pt 28B Standardize edit/setting of header type put in single place

                        break;

                    case "Status":
                        switch ((eHeaderAllocationStatus)Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture))
                        {
                            case eHeaderAllocationStatus.InUseByMultiHeader:
                                //ap.InUseByMulti = true;
                                 break;
                        }
                        break;

                    case "Date":
                        ap.HeaderDay = Convert.ToDateTime(e.Cell.Value, CultureInfo.CurrentUICulture);
                        break;

                    case "AnchorNode":
                        if (_skipAnchorEdit)
                        {
                            _skipAnchorEdit = false;
                            return;
                        }
                        string anchorID = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture);
                        int anchorKey = GetAnchorNodeKey(anchorID);
                        if (anchorKey != -1)
                        {
                            e.Cell.Row.Cells["AnchorHnRID"].Value = anchorKey;

                            HierarchyNodeProfile anchorHnp = _SAB.HierarchyServerSession.GetNodeData(anchorKey);
                            _skipAnchorEdit = true;
                            e.Cell.Value = anchorHnp.LevelText;
                            UpdateAnchorNodeTable(e.Cell.Row); 
                        }
                        break;

                    case "Product":
                        if (_skipProductEdit)
                        {
                            _skipProductEdit = false;
                            return;
                        }
                        string productID = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture);
                        int key = GetProductIdKey(productID);
                        if (key != -1)
                        {
                            e.Cell.Row.Cells["ProductRID"].Value = key;
                           
                            productHnp = _SAB.HierarchyServerSession.GetNodeData(key);
                            _skipProductEdit = true;
                            e.Cell.Value = productHnp.LevelText;
                            e.Cell.Row.Cells["Description"].Value = string.Empty;
                            _skipStyleEdit = true;
                            e.Cell.Row.Cells["Style"].Value = string.Empty;
                            errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_MustBeCorrectLevel), _hlpStyle.LevelID);
                            MessageBox.Show(errorMessage, _thisTitle);
                        }
                        break;

                    case "Style":
                        if (_skipStyleEdit)
                        {
                            _skipStyleEdit = false;
                            return;
                        }
                        string styleID = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture);
                        HierarchyNodeProfile styleHnp = _SAB.HierarchyServerSession.GetNodeData(styleID);
                        e.Cell.Row.Cells["StyleHnRID"].Value = styleHnp.Key;
                        e.Cell.Row.Cells["Description"].Value = styleHnp.NodeDescription;
                      
                        productHnp = _SAB.HierarchyServerSession.GetNodeData(styleHnp.HomeHierarchyParentRID);

                        _skipProductEdit = true;
                        e.Cell.Row.Cells["ProductRID"].Value = productHnp.Key;
                        e.Cell.Row.Cells["Product"].Value = productHnp.LevelText;

                        // Begin TT#2061 - JSmith - Size hierarchy node within Style-Color not found - after Header copied to new Style\Color
                        UpdateAddedSizeRows(e.Cell.Row, true);
                        // End TT#2061
              
                        _skipStyleEdit = true;
                        e.Cell.Value = styleHnp.LevelText;
                        break;
                   
                    case "StyleHnRID":
                        if (ap.Placeholder)
                        {
                            int styleRID = Convert.ToInt32(e.Cell.Row.Cells["StyleHnRID"].OriginalValue, CultureInfo.CurrentUICulture);
                            if (!_deletedPlaceholderStyles.ContainsKey(ap.Key))
                            {
                                _deletedPlaceholderStyles.Add(ap.Key, styleRID);
                            }

                            HierarchyNodeProfile anchorHnp = _hierMaint.GetAnchorNode(Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                            if (anchorHnp.Key != Include.NoRID)
                            {
                                _skipAnchorEdit = true;
                                e.Cell.Row.Cells["AnchorHnRID"].Value = anchorHnp.Key;
                                e.Cell.Row.Cells["AnchorNode"].Value = anchorHnp.LevelText;
                            }
                        }
                        
                        ap.StyleHnRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        break;

                    case "Description":
                        if (e.Cell.Value.ToString().Trim() != string.Empty)
                        {
                            ap.HeaderDescription = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                        }
                        break;

                    case "HdrQuantity":
                        if (e.Cell.Value == System.DBNull.Value || e.Cell.Value.ToString().Trim() == string.Empty)
                        {
                            ap.TotalUnitsToAllocate = 0;
                        }
                        // Begin TT#304 - RMatelic - Multi Header - made the multiple 10 received message "multiple cannot exceed units to allocate
                        //else if (Convert.ToInt32(e.Cell.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.MultiHeader &&
                        //         Convert.ToInt32(e.Cell.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.WorkupTotalBuy)
                        else if (Convert.ToInt32(e.Cell.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.WorkupTotalBuy &&
                                 !_skipQtyUpdate)
                        // End ##304
                        {
                            ap.TotalUnitsToAllocate = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                        if (e.Cell.Row.Cells["AsrtRID"].Value != DBNull.Value)
                        {
                             
                            UpdateAssortmentQuantity(e.Cell.Row);
                        }
                        break;

                    case "UnitRetail":
                        if (e.Cell.Value == System.DBNull.Value || e.Cell.Value.ToString().Trim() == string.Empty)
                        {
                            ap.UnitRetail = 0;
                        }
                        else
                        {
                            ap.UnitRetail = Convert.ToDouble(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
                        break;
                   
                    case "UnitCost":
                        if (e.Cell.Value == System.DBNull.Value || e.Cell.Value.ToString().Trim() == string.Empty)
                        {
                            ap.UnitCost = 0;
                        }
                        else
                        {
                            ap.UnitCost = Convert.ToDouble(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
                        break;
                  
                    case "SizeGroup":
                        
                        int sizeGroupRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        if (_rebuildSizes)
                        {
                            _rebuildSizes = false;
                            ap.SizeGroupRID = sizeGroupRID;
                            //IRefresh();
                            //ScrollToHeaderRow(ap.Key);
                            UltraGridRow headerRow = this.ugDetails.ActiveRow;
                            if (headerRow != null)
                            {
                                headerRow.ExpandAll();
                            }
                            return;
                        }
                        else
                        {
                            ap.SizeGroupRID = sizeGroupRID;
                        }
                        break;
                  
                    case "Multiple":
                        errorMessage = string.Empty;
                        if (e.Cell.Value == System.DBNull.Value || e.Cell.Value.ToString().Trim() == string.Empty)
                        {
                            ap.AllocationMultiple = Include.DefaultUnitMultiple;
                        }
                        else if (!ValidMultiple(e.Cell, ref errorMessage))
                        {
                            // Begin TT#1652-MD - RMatelic - DC Carton Rounding
                            //MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_MultipleCannotBeLessThan1));
                            MessageBox.Show(errorMessage);
                            // End TT#1652-MD 
                            return;
                        }
                        else
                        {
                            ap.AllocationMultiple = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
                        break;
                
                    case "PO":
                        ap.PurchaseOrder = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                        break;

                    case "Vendor":
                        ap.Vendor = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                        break;

                    case "Workflow":
                        string workFlow = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                        int workFlowRID = Include.UndefinedWorkflowRID;
                        if (workFlow != string.Empty)
                        {
                            foreach (int wfRID in _workflowNameHash.Keys)
                            {
                                if (_workflowNameHash[wfRID].ToString() == workFlow)
                                {
                                    workFlowRID = wfRID;
                                    break;
                                }
                            }
                        }
                        ap.WorkflowRID = workFlowRID;
                        break;

                    case "DC":
                        ap.DistributionCenter = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture).Trim();
                        break;

                    case "HdrGroupRID":
                        if (ap.InUseByMulti || Convert.ToInt32(e.Cell.Row.Cells["Status"].Value,  CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader)
                        {
                            if (e.Cell.Value != DBNull.Value)
                            {
                                ap.HeaderGroupRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);

                            }
                            else // this should happen when a header is being removed from the Multiheader
                            {
                                ap.HeaderGroupRID = Include.UndefinedHeaderGroupRID;
                                //ap.InUseByMulti = false;
                                e.Cell.Row.Cells["Status"].Value = (int)ap.GetHeaderAllocationStatus(true);
                                e.Cell.Row.Cells["MultiSortSeq"].Value = DBNull.Value;
                            }
                        }
                        break;

                    case "AsrtRID":
                        if (e.Cell.Value != DBNull.Value)
                        {
                            ap.AsrtRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
                        else
                        {
                            ap.AsrtRID = Include.NoRID;
                        }
                        break;
                  
                    case "PlaceHolderRID":
                        if (e.Cell.Value != DBNull.Value)
                        {
                            ap.PlaceHolderRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        }
                        else
                        {
                            ap.PlaceHolderRID = Include.NoRID;
                        }
                        break;

                    case "AsrtType":
                        ap.AsrtType = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        break;

					// BEGIN TT#1401 - stodd - add VSW (IMO)
					case "ImoId":
                        // begin TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28B
                        //ap.ImoID = Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture);
						// BEGIN TT#1401 - stodd - add VSW (IMO)
						//if (!ap.SetHeaderType(eHeaderType.IMO, Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture), out midException))
						eHeaderType aHeaderType = ap.HeaderType;
                        bool adjustVSW = ap.AdjustVSW_OnHand;
						if (e.Cell.Value != null)
						{
							if (e.Cell.Value.ToString().Trim() != string.Empty)
							{
								aHeaderType = eHeaderType.IMO;
							}
						}
                        if (!ap.SetHeaderType(aHeaderType, Convert.ToString(e.Cell.Value, CultureInfo.CurrentUICulture), adjustVSW, out midException)) // TT#2225 - Jellis - AnF VSW FSWOS Max Enhancement pt 1
						// END TT#1401 - stodd - add VSW (IMO)
                        {
                            throw midException;
                        }
                        // end TT#1401 - JEllis - Urban Virtual Store Warehouse pt 28B
						break;
					// BEGIN TT#1401 - stodd - add VSW (IMO)
                    // begin TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                    case "AdjustVSW":
                        aHeaderType = ap.HeaderType;
                        string vswID = ap.ImoID;
						// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
						if (Convert.ToInt32(e.Cell.Value) == (int)eAdjustVSW.Adjust)
						{
							//adjustVSW = Convert.ToBoolean(e.Cell.Value, CultureInfo.CurrentUICulture);
							adjustVSW = true;
						}
						else
						{
							adjustVSW = false;
						}
						// END TT#2225 - stodd - VSW ANF Enhancement (IMO)
                        if (!ap.SetHeaderType(aHeaderType, vswID, adjustVSW, out midException))
                        
                        {
                            throw midException;
                        }
                        break;

                    // end TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                    // Begin TT#1652-MD - RMatelic - DC Carton Rounding 
                    case "UnitsPerCarton":
                        errorMessage = string.Empty;
                        // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                        if (e.Cell.Value == System.DBNull.Value ||
                            e.Cell.Value.ToString().Trim() == string.Empty)
                        {
                            ap.UnitsPerCarton = 0;
                            SetErrorImage(e.Cell, false, ref errorMessage);
                            SetErrorImage(e.Cell.Row.Cells["Multiple"], false, ref errorMessage);
                        }
                        //if (!ValidUnitsPerCarton(e.Cell, ref errorMessage, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture)))
                        else if (!ValidUnitsPerCarton(e.Cell, ref errorMessage, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture)))
                        // End TT#5047 - jsmith - Units Per Carton / Multiple Check
                        {
                            SetErrorImage(e.Cell, true, ref errorMessage);
                            MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }
                        else
                        {
                            ap.UnitsPerCarton = Convert.ToInt32(e.Cell.Value);  // TT#1691-MD - stodd - DC Carton Rounding: Units Per Carton value changed to 0 on header
                            SetErrorImage(e.Cell, false, ref errorMessage);
                            SetErrorImage(e.Cell.Row.Cells["Multiple"], false, ref errorMessage);
                        }
                        break;
                    // End TT#1652-MD

                    case "KeyH":
                    case "CharUpdated":
                    case "ChildTotal":
                    case "Balance":
                    case "HeaderRow":
                    case "AnchorHnRID":
                        break;

                    default:
                        if (e.Cell.Column.Tag != null &&
                            e.Cell.Column.Tag.GetType() == typeof(HeaderCharGroupProfile))  // Header Characteristic
                        {
                            if (e.Cell.Value != System.DBNull.Value)
                            {
                                if (e.Cell.Value.ToString().Trim() == string.Empty ||
                                    e.Cell.Value.ToString().Trim() == Include.NoRID.ToString())
                                {
                                    // Begin TT#1641 - RMatelic - Warning message should be sent when applying a Header Characteristic to a Multi-Header 
                                    if (ap.MultiHeader)
                                    {
                                        _skipBeforeCellUpdate = true;
                                    }
                                    // End TT#1641
                                    e.Cell.Value = System.DBNull.Value;
                                }
                            }
                            e.Cell.Row.Cells["CharUpdated"].Value = true;
                        }
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch  
            {
                throw;
            }
        }
        // BEGIN MID Track #5977 - WorkupBuy error 
        private void UpdateQuantityActivation(UltraGridRow aRow, bool aProtectQty)
        {
            try
            {
                if (aProtectQty)
                {
                    aRow.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                }
                else
                {
                    aRow.Cells["HdrQuantity"].Activation = Activation.AllowEdit;
                }
                if (aRow.HasChild())
                {
                    UltraGridRow childRow = aRow.GetChild(ChildRow.First);
                    while (childRow != null)
                    {
                        SetChildRowQtyActivation(childRow, aProtectQty);
                        childRow = childRow.GetSibling(SiblingRow.Next, true);
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void SetChildRowQtyActivation(UltraGridRow aRow, bool aProtectQty)
        {

            string bandKey = aRow.Band.Key;
            string[] bandKeyParts = bandKey.Split(new char[] { '~' });
            try
            {
                switch (bandKeyParts[0])
                {

                    case "Pack":
                        
                        break;

                    case "PackColor":
                         
                        break;

                    case "BulkColor":
                        if (aProtectQty)
                        {
                            aRow.Cells["Quantity"].Activation = Activation.NoEdit;
                        }
                        else
                        {
                            aRow.Cells["Quantity"].Activation = Activation.AllowEdit;
                        }
                        break;


                    case "BulkSize":
                    //case "PackSize":
                    //case "PackColorSize":
                        for (int i = 7; i < aRow.Cells.Count; i++)
                        {
                            if (aProtectQty)
                            {
                                aRow.Cells[i].Activation = Activation.NoEdit;
                            }
                            else if (Convert.ToInt32(aRow.Cells[i].Tag, CultureInfo.CurrentUICulture) == Include.NoRID)
                            {
                                aRow.Cells[i].Activation = Activation.Disabled;
                            }
                            else
                            {
                                aRow.Cells[i].Activation = Activation.AllowEdit;
                            }
                        }    
                        break;

                    default:
                        break;
                }

                if (aRow.HasChild(false))
                {
                    UltraGridRow cRow = aRow.GetChild(ChildRow.First);
                    while (cRow != null)
                    {
                        SetChildRowQtyActivation(cRow, aProtectQty);
                        cRow = cRow.GetSibling(SiblingRow.Next, true, false);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        // END MID Track #5977

		// BEGIN TT#1401 - stodd - add VSW (IMO)
		private void UpdateImoIdActivation(UltraGridRow aRow, bool aProtectImoId)
		{
			try
			{
				if (aProtectImoId)
				{
					aRow.Cells["ImoId"].Activation = Activation.NoEdit;
                    aRow.Cells["AdjustVSW"].Activation = Activation.NoEdit; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                }
				else
				{
					aRow.Cells["ImoId"].Activation = Activation.AllowEdit;
                    aRow.Cells["AdjustVSW"].Activation = Activation.AllowEdit; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
				}
			}
			catch
			{
				throw;
			}
		}
		// END TT#1401 - stodd - add VSW (IMO)

        private void UpdateAssortmentQuantity(UltraGridRow aRow)
        {
            try
            {
                int asrtRID, oldQty = 0, newQty = 0;  
                eHeaderType headerType = (eHeaderType)Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                if (headerType == eHeaderType.Assortment)
                {
                    return;
                }
                asrtRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);

                if (aRow.Cells["HdrQuantity"].OriginalValue != DBNull.Value)
                {
                    oldQty = Convert.ToInt32(aRow.Cells["HdrQuantity"].OriginalValue, CultureInfo.CurrentUICulture);
                }
                newQty = Convert.ToInt32(aRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
          
                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == asrtRID)
                    {
                        int qty = Convert.ToInt32(row.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                        row.Cells["HdrQuantity"].Value = qty + (newQty - oldQty);
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch  
            {
                throw;
            }
        }

        private void UpdateAnchorNodeTable(UltraGridRow aRow)  
        {
            try
            {
                int phStyleRID, oldAnchorRID, newAnchorRID;
            
                phStyleRID = Convert.ToInt32(aRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                if (_anchorNodes.Rows.Contains(phStyleRID)) 
                {
                    _anchorNodes.Rows.Remove(_anchorNodes.Rows.Find(phStyleRID));
                }
                
                oldAnchorRID = Convert.ToInt32(aRow.Cells["AnchorHnRID"].OriginalValue, CultureInfo.CurrentUICulture);
                newAnchorRID = Convert.ToInt32(aRow.Cells["AnchorHnRID"].Value, CultureInfo.CurrentUICulture);
                _anchorNodes.Rows.Add(new object[] { phStyleRID, oldAnchorRID,newAnchorRID });
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePackData(CellEventArgs e)
        {
            try
            {
                string errorMessage, packName;
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(Convert.ToInt32(e.Cell.Row.ParentRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
               
                packName = e.Cell.Row.Cells["Pack"].Value.ToString();
                errorMessage = string.Empty;
                if (!_creatingMulti)
                {
                    if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                    {
                        MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }
                }
                switch (e.Cell.Column.Key)
                {
                    case "Pack":
                        
                        if (!ap.PackIsOnHeader(e.Cell.Row.Cells["Pack"].OriginalValue.ToString()))
                        {
                            if (!ap.PackIsOnHeader(packName))
                            {   // BEGIN MID Track #5827 - MultiHeader add error wih packs  
                                if (!ap.MultiHeader)
                                {
                                    ap.AddPack(packName,
                                            (eAllocationType)Convert.ToInt32(e.Cell.Row.Cells["PackType"].Value, CultureInfo.CurrentUICulture),
                                            Convert.ToInt32(e.Cell.Row.Cells["QuantityPerPack"].Value, CultureInfo.CurrentUICulture),
                                            Convert.ToInt32(e.Cell.Row.Cells["TotalPacks"].Value, CultureInfo.CurrentUICulture),
                                            -1);
                                    // set pack key
                                    e.Cell.Row.Cells["KeyP"].Value = ap.Packs.Count * -1;
                                }
                                else
                                {
                                    UltraGridRow row = e.Cell.Row.GetSibling(SiblingRow.First, false);
                                    int packCount = 0;
                                    while (row != null)
                                    {
                                        packCount++;
                                        row = row.GetSibling(SiblingRow.Next, false);
                                    }
                                    // set pack key
                                    e.Cell.Row.Cells["KeyP"].Value = packCount * -1;
                                }
                            }   // END MID Track #5827 
                        }
                        else
                        {
                            ap.SetPackName(e.Cell.OriginalValue.ToString(), packName);
                        }
                        break;
                    
                    case "PackType":
                        if (!PackNameEntered(e.Cell.Row))
                        {
                            return;
                        }
                        else
                        {    // BEGIN MID Track #5827 - MultiHeader add error wih packs 
                            if (!ap.MultiHeader)
                            {
                                ap.SetPackGeneric(packName, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture) == (int)eAllocationType.GenericType);
                            }
                        }    // END MID Track #5827  
                        break;
                    case "TotalPacks":
                        if (_skipEdit)
                        {
                            _skipEdit = false;
                            return;
                        }
                        if (!PackNameEntered(e.Cell.Row))
                        {
                            return;
                        }
                        else
                        {    // BEGIN MID Track #5827 - MultiHeader add error wih packs 
                            if (!ap.MultiHeader)
                            {
                                ap.SetPacksToAllocate(packName, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                            }
                        }    // END MID Track #5827  
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                        break;
                  
                    case "QuantityPerPack":
                        if (_skipEdit)
                        {
                            _skipEdit = false;
                            return;
                        }
                        if (!PackNameEntered(e.Cell.Row))
                        {
                            return;
                        }
                        else
                        {   // BEGIN MID Track #5827 - MultiHeader add error wih packs 
                            if (!ap.MultiHeader)
                            {
                                ap.SetPackMultiple(packName, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                            }
                        }    // END MID Track #5827  
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                        break;
                           
                    case "AssociatedPackRID":
                        // BEGIN MID Track #5827 - MultiHeader add error wih packs 
                        if (!ap.MultiHeader)
                        {
                            ap.SetAssociatedPackRID(packName, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                        }
                        // END MID Track #5827 
                        break;
                                  
                    default:
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch  
            {
                throw;
            }
        }

        private void UpdatePackColorData(CellEventArgs e)
        {
            try
            {
                int colorHnRID, prevColorCodeRID = Include.NoRID;
                ColorCodeProfile ccp;
                ColorCodeProfile ccpOrig;
                EditMsgs em;
                string errorMessage;
                int headerRID = Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(headerRID);

                string packName = Convert.ToString(e.Cell.Row.ParentRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture).Trim();
                string packColor = Convert.ToString(e.Cell.Row.Cells["PackColor"].Value, CultureInfo.CurrentUICulture).Trim();
                string packColorDescription = Convert.ToString(e.Cell.Row.Cells["Description"].Value, CultureInfo.CurrentUICulture).Trim();
                
                if (e.Cell.Row.Cells["ColorCodeRID"].Value != DBNull.Value)
                {
                    prevColorCodeRID = Convert.ToInt32(e.Cell.Row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                }

                ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(packColor);

                switch (e.Cell.Column.Key)
                {
                    case "PackColor":
                        string origValue = e.Cell.Row.Cells["PackColor"].OriginalValue.ToString();

                        if (ccp.Key == Include.NoRID)
                        {
                            // color doesn't exist, need to add it
                            ccp.ColorCodeID = packColor;

                            if (packColorDescription.Trim() != string.Empty)
                            {
                                ccp.ColorCodeName = packColorDescription;
                            }
                            else
                            {
                                ccp.ColorCodeName = packColor;
                                packColorDescription = packColor;
                            }
                            ccp.ColorCodeChangeType = eChangeType.add;
                            ccp = _SAB.HierarchyServerSession.ColorCodeUpdate(ccp);
                            e.Cell.Row.Cells["IsNewColor"].Value = true;
                            e.Cell.Row.Cells["Description"].Value = packColorDescription;
                        }
                        else if (packColorDescription.Trim() == string.Empty || packColor != origValue)
                        {
                            if (!ccp.VirtualInd)
                            {

                                colorHnRID = Include.NoRID;
                                HierarchyNodeProfile hnp_style = _SAB.HierarchyServerSession.GetNodeData(ap.StyleHnRID);
                                if (_SAB.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
                                {
                                    HierarchyNodeProfile hnp_color = _SAB.HierarchyServerSession.GetNodeData(colorHnRID);
                                    packColorDescription = hnp_color.NodeDescription;
                                }
                                else
                                {
                                    packColorDescription = ccp.ColorCodeName;
                                }
                                e.Cell.Row.Cells["Description"].Value = packColorDescription;
                            }
                            else
                            {
                                packColorDescription = ccp.ColorCodeName;
                            }
                        }
                        // now add it to the hierarchy -- probably need to move this to the save
                        if (packColor != string.Empty &&
                            packColorDescription != string.Empty && !ccp.VirtualInd)
                        {
                            em = new EditMsgs();
                            colorHnRID = _hierMaint.QuickAdd(ref em, ap.StyleHnRID, packColor, packColorDescription);
                            if (em.ErrorFound)
                            {
                                DisplayMessages.Show(em, _SAB, Include.MIDAllocationWorkspaceExplorer);
                            }
                        }
                    
                        if (e.Cell.Row.Cells["PackColor"].OriginalValue.ToString() == string.Empty)
                        {
                            // finally, add it to the pack
                            // BEGIN MID Track #5827 - MultiHeader add error wih packs 
                            if (!ap.MultiHeader)
                            {
                                ap.AddColorToPack(packName, ccp.Key,
                                Convert.ToInt32(e.Cell.Row.Cells["QuantityPerPack"].Value, CultureInfo.CurrentUICulture), 0);
                            } 
                            e.Cell.Row.Cells["ColorCodeRID"].Value = ccp.Key;
                            // BEGIN MID Track #5827 - MultiHeader add error wih packs 
                            if (!ap.MultiHeader)
                            {
                                PackHdr aPack = ap.GetPackHdr(packName);
                                e.Cell.Row.Cells["KeyC"].Value = aPack.PackColors.Count * -1;
                            }
                            else
                            {
                                UltraGridRow row = e.Cell.Row.GetSibling(SiblingRow.First, false);
                                int pcCount = 0;
                                while (row != null)
                                {
                                    pcCount++;
                                    row = row.GetSibling(SiblingRow.Next, false);
                                }
                                // set pack key
                                e.Cell.Row.Cells["KeyC"].Value = pcCount * -1;
                            }
                            // END MID Track #5827
                            if (ccp.VirtualInd)
                            {
                                ap.SetPackColorName(packName,ccp.Key, packColor);
                                e.Cell.Row.Cells["Description"].Value = packColorDescription;
                            }
                        }
                        else
                        {
                            if (prevColorCodeRID == Include.NoRID)
                            {
                                ccpOrig = _SAB.HierarchyServerSession.GetColorCodeProfile(e.Cell.OriginalValue.ToString());
                                ap.SetPackColorCodeRID(packName, ccpOrig.Key, ccp.Key);
                            }
                            else
                            {
                                ap.SetPackColorCodeRID(packName, prevColorCodeRID, ccp.Key);
                            }
                            e.Cell.Row.Cells["ColorCodeRID"].Value = ccp.Key;
                            if (!ccp.VirtualInd)
                            {
                                ap.SetPackColorName(packName, ccp.Key, null);
                                ap.SetPackColorDescription(packName, ccp.Key, null);
                            }
                            else
                            {
                                ap.SetPackColorName(packName,ccp.Key,packColor);
                                e.Cell.Row.Cells["Description"].Value = packColorDescription; 
                            }
                        }
                        e.Cell.Row.Cells["IsVirtual"].Value = ccp.VirtualInd;
                        // Begin TT#2061 - JSmith - Size hierarchy node within Style-Color not found - after Header copied to new Style\Color
                        UpdateAddedSizeRows(e.Cell.Row.ParentRow.ParentRow, true);
                        // End TT#2061
                        break;
                   
                    case "Description":
                        if (ccp.Key != Include.NoRID)
                        {
                            if (!ccp.VirtualInd)
                            {
                                em = new EditMsgs();
                                colorHnRID = Include.NoRID;
                                HierarchyNodeProfile hnp_style = _SAB.HierarchyServerSession.GetNodeData(ap.StyleHnRID);
                                if (_SAB.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
                                {
                                    HierarchyNodeProfile hnp_color = _SAB.HierarchyServerSession.GetNodeData(colorHnRID);
                                    hnp_color.NodeDescription = packColorDescription;
                                    hnp_color.NodeChangeType = eChangeType.update;
                                    _hierMaint.ProcessNodeProfileInfo(ref em, hnp_color);
                                }
                                if (Convert.ToBoolean(e.Cell.Row.Cells["IsNewColor"].Value, CultureInfo.CurrentUICulture) == true
                                    && packColorDescription.Trim() != ccp.ColorCodeName)
                                {
                                    ccp.ColorCodeName = packColorDescription;
                                    ccp.ColorCodeChangeType = eChangeType.update;
                                    ccp = _SAB.HierarchyServerSession.ColorCodeUpdate(ccp);
                                    e.Cell.Row.Cells["IsNewColor"].Value = false;
                                }
                            }
                            else       // Placeholder color
                            {
                                ap.SetPackColorDescription(packName, ccp.Key, packColorDescription);
                            }
                        }
                        break;
                 
                    case "QuantityPerPack":
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                        {
                            MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }
                         // BEGIN MID Track #5827 - MultiHeader add error wih packs 
                        if (!ap.MultiHeader)
                        {
                            ap.SetColorUnitsInPack(packName, ccp.Key, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                        }
                        // END MID Track #5827
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                        break;
            
                    default:
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch  
            {
                throw;
            }
        }

        private void UpdateBulkColorData(CellEventArgs e)
        {
            try
            {
                 int colorHnRID;
                ColorCodeProfile ccp;
                ColorCodeProfile ccpOrig;
                EditMsgs em;
                string errorMessage;
                int headerRID, prevColorCodeRID = Include.NoRID;
                headerRID = Convert.ToInt32(e.Cell.Row.ParentRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(headerRID);

                string bulkColor = Convert.ToString(e.Cell.Row.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture).Trim();
                string bulkDescription = Convert.ToString(e.Cell.Row.Cells["Description"].Value, CultureInfo.CurrentUICulture).Trim();

                if (e.Cell.Row.Cells["ColorCodeRID"].Value != DBNull.Value)
                {
                    prevColorCodeRID = Convert.ToInt32(e.Cell.Row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                }

                ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(bulkColor);

                switch (e.Cell.Column.Key)
                {
                    case "BulkColor":
                        string origValue = Convert.ToString(e.Cell.Row.Cells["BulkColor"].OriginalValue, CultureInfo.CurrentUICulture);
                        if (ccp.Key == Include.NoRID)
                        {
                            // color doesn't exist, need to add it
                            ccp.ColorCodeID = bulkColor;
                            ccp.ColorCodeName = bulkColor;
                            bulkDescription = bulkColor;
                            
                            e.Cell.Row.Cells["Description"].Value = bulkDescription;

                            if (!Convert.ToBoolean(e.Cell.Row.Cells["IsVirtual"].Value, CultureInfo.CurrentUICulture))
                            {
                                ccp.ColorCodeChangeType = eChangeType.add;
                                ccp = _SAB.HierarchyServerSession.ColorCodeUpdate(ccp);
                            }
                            e.Cell.Row.Cells["IsNewColor"].Value = true;
                        }
                        else if (bulkDescription.Trim() == string.Empty || bulkColor != origValue)
                        {
                            if (!ccp.VirtualInd)
                            {
                                colorHnRID = Include.NoRID;
                                HierarchyNodeProfile hnp_style = _SAB.HierarchyServerSession.GetNodeData(ap.StyleHnRID);
                                if (_SAB.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
                                {
                                    HierarchyNodeProfile hnp_color = _SAB.HierarchyServerSession.GetNodeData(colorHnRID);
                                    bulkDescription = hnp_color.NodeDescription;
                                }
                                else
                                {
                                    bulkDescription = ccp.ColorCodeName;
                                }
                                e.Cell.Row.Cells["Description"].Value = bulkDescription;
                            }
                            else
                            {
                                bulkDescription = ccp.ColorCodeName;
                            }
                        }
                        // now add it to the hierarchy -- probably need to move this to the save
                        if (bulkColor != string.Empty &&
                            bulkDescription != string.Empty && !ccp.VirtualInd)
                        {
                            em = new EditMsgs();
                            colorHnRID = _hierMaint.QuickAdd(ref em, ap.StyleHnRID, bulkColor, bulkDescription);
                            if (em.ErrorFound)
                            {
                                DisplayMessages.Show(em, _SAB, Include.MIDAllocationWorkspaceExplorer);
                                return;
                            }
                        }

                        if (e.Cell.OriginalValue.ToString() == string.Empty)
                        {
                            // finally, add it to the header
                            ap.AddBulkColor(ccp.Key,
                            Convert.ToInt32(e.Cell.Row.Cells["Quantity"].Value, CultureInfo.CurrentUICulture), 0);
                            e.Cell.Row.Cells["KeyH"].Value = ap.Key;
                            e.Cell.Row.Cells["ColorCodeRID"].Value = ccp.Key;
                            e.Cell.Row.Cells["KeyC"].Value = ap.BulkColors.Count * -1;
                            if (ccp.VirtualInd)
                            {
                                ap.SetBulkColorName(ccp.Key, bulkColor);
                                e.Cell.Row.Cells["Description"].Value = bulkDescription;
                            }
                        }
                        else
                        {
                            if (prevColorCodeRID == Include.NoRID)
                            {
                                ccpOrig = _SAB.HierarchyServerSession.GetColorCodeProfile(e.Cell.OriginalValue.ToString());
                                ap.SetBulkColorCodeRID(ccpOrig.Key, ccp.Key);
                            }
                            else
                            {
                                ap.SetBulkColorCodeRID(prevColorCodeRID, ccp.Key);
                            }
                            e.Cell.Row.Cells["ColorCodeRID"].Value = ccp.Key;
                            if (!ccp.VirtualInd)
                            {
                                ap.SetBulkColorName(ccp.Key, null);
                                ap.SetBulkColorDescription(ccp.Key, null);
                            }
                            else
                            {
                                ap.SetBulkColorName(ccp.Key, bulkColor);
                                e.Cell.Row.Cells["Description"].Value = bulkDescription;
                            }
                        }
                        e.Cell.Row.Cells["IsVirtual"].Value = ccp.VirtualInd;
                        // Begin TT#2061 - JSmith - Size hierarchy node within Style-Color not found - after Header copied to new Style\Color
                        UpdateAddedSizeRows(e.Cell.Row.ParentRow, true);
                        // End TT#2061
                        break;
                   
                    case "Description":
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                        {
                            MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }

                        if (ccp.Key != Include.NoRID)
                        {
                            if (!ccp.VirtualInd)
                            {
                                em = new EditMsgs();
                                colorHnRID = Include.NoRID;
                                HierarchyNodeProfile hnp_style = _SAB.HierarchyServerSession.GetNodeData(ap.StyleHnRID);
                                if (_SAB.HierarchyServerSession.ColorExistsForStyle(hnp_style.HomeHierarchyRID, hnp_style.Key, ccp.ColorCodeID, ref colorHnRID))
                                {
                                    HierarchyNodeProfile hnp_color = _SAB.HierarchyServerSession.GetNodeData(colorHnRID);
                                    hnp_color.NodeDescription = bulkDescription;
                                    hnp_color.NodeChangeType = eChangeType.update;
                                    _hierMaint.ProcessNodeProfileInfo(ref em, hnp_color);
                                }
                                if (Convert.ToBoolean(e.Cell.Row.Cells["IsNewColor"].Value, CultureInfo.CurrentUICulture)
                                 && bulkDescription.Trim() != ccp.ColorCodeName)
                                {
                                    ccp.ColorCodeName = bulkDescription;
                                    ccp.ColorCodeChangeType = eChangeType.update;
                                    ccp = _SAB.HierarchyServerSession.ColorCodeUpdate(ccp);
                                    e.Cell.Row.Cells["IsNewColor"].Value = false;
                                }
                            }
                            else       // Placeholder color
                            {
                                ap.SetBulkColorDescription(ccp.Key, bulkDescription); 
                            }
                        }
                        break;
                
                    case "Quantity":
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(e.Cell, ref errorMessage))
                        {
                            MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }
                        // Multi header totals get calculated in AllocationProfile
                        if (!ap.MultiHeader)
                        {
                            ap.SetColorUnitsToAllocate(ccp.Key, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                        }
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                        break;
                    
                    case "AsrtBCRID":
                        int bcRID = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                        if (bcRID != 0)
                        {
                            ap.SetAsrtBCRID(ccp.Key, Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture));
                        }
                        break;
               
                    default:
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch 
            {
                throw;
            }
        }

        private void UpdateBulkSizeData(CellEventArgs e)
        {
            try
            {
                if (e.Cell.Column.Key != "TotalQuantity")
                {
                    int quantity, originalValue, sizeCodeKey;
                    AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                    int colorCodeKey = Convert.ToInt32(e.Cell.Row.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                  
                    if (e.Cell.Value == System.DBNull.Value)
                    {
                        quantity = 0;
                    }
                    else
                    {
                        quantity = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                    }

                    if (e.Cell.OriginalValue == System.DBNull.Value)
                    {
                        originalValue = 0;
                    }
                    else
                    {
                        originalValue = Convert.ToInt32(e.Cell.OriginalValue, CultureInfo.CurrentUICulture);
                    }

                    if (e.Cell.Tag != System.DBNull.Value)
                    {
                        sizeCodeKey = Convert.ToInt32(e.Cell.Tag, CultureInfo.CurrentUICulture);

                        if (sizeCodeKey != Include.NoRID)
                        {
                            if (!ap.MultiHeader)     // MID Track #5654, #5655, #5657 - MultiHeader errors
                            {
                                if (!ap.SizeIsOnBulkColor(colorCodeKey, sizeCodeKey))
                                {
                                    ap.AddBulkSizeToColor(colorCodeKey, sizeCodeKey, quantity, -1);
                                }
                                else
                                {
                                    ap.SetSizeUnitsToAllocate(colorCodeKey, sizeCodeKey, quantity);
                                }
                            }
                        }
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                    }
                }

            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch  
            {
                throw;
            }
        }

        private void UpdatePackSizeData(CellEventArgs e)
        {
            try
            {
                if (e.Cell.Column.Key != "TotalQuantity")
                {
                    int quantity, originalValue, sizeCodeKey, colorCodeKey;
                    string packName;
                    AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(Convert.ToInt32(e.Cell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                    if (e.Cell.Band.Key.StartsWith("PackSize"))
                    {
                        packName = e.Cell.Row.ParentRow.Cells["Pack"].Value.ToString();
                        colorCodeKey = Include.DummyColorRID;
                    }
                    else
                    {
                        packName = e.Cell.Row.ParentRow.ParentRow.Cells["Pack"].Value.ToString();
                        colorCodeKey = Convert.ToInt32(e.Cell.Row.ParentRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                    }
                               
                    if (e.Cell.Value == System.DBNull.Value)
                    {
                        quantity = 0;
                    }
                    else
                    {
                        quantity = Convert.ToInt32(e.Cell.Value, CultureInfo.CurrentUICulture);
                    }

                    if (e.Cell.OriginalValue == System.DBNull.Value)
                    {
                        originalValue = 0;
                    }
                    else
                    {
                        originalValue = Convert.ToInt32(e.Cell.OriginalValue, CultureInfo.CurrentUICulture);
                    }

                    if (e.Cell.Tag != System.DBNull.Value)
                    {
                        sizeCodeKey = Convert.ToInt32(e.Cell.Tag, CultureInfo.CurrentUICulture);

                        if (sizeCodeKey != Include.NoRID)
                        {
                            if (!ap.MultiHeader)    // MID Tracks 5769, 5827 - multiheader processing errors
                            {
                                if (!ap.SizeIsOnPackColor(packName, colorCodeKey, sizeCodeKey))
                                {
                                    ap.AddSizeToPackColor(packName, colorCodeKey, sizeCodeKey, quantity, -1);
                                }
                                else
                                {
                                    ap.SetPackColorSizeUnits(packName, colorCodeKey, sizeCodeKey, quantity);
                                }
                            }
                        }
                        CalculateBalances(eBalanceAction.ValueChanged, e.Cell);
                    }
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch  
            {
                throw;
            }
        }    

        private void CalculateBalancesFromDelete(UltraGridRow aRow)
        {
            try
            {
                string[] bandKeyParts = aRow.Band.Key.Split(new char[] { '~' });
                switch (bandKeyParts[0])
                {
                    case "Header":
                    //case "Placeholder":
                        break;
             
                    case "Pack":
                    case "PackColor":
                        CalculateBalances(eBalanceAction.RowDeleted, aRow.Cells["QuantityPerPack"]);
                        break;
                
                    case "BulkColor":
                        CalculateBalances(eBalanceAction.RowDeleted, aRow.Cells["Quantity"]);
                        break;
              
                    case "PackSize":
                    case "PackColorSize":
                    case "BulkSize":
                        CalculateBalances(eBalanceAction.RowDeleted, aRow.Cells["TotalQuantity"]);
                        break;
                   
                    default:
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CalculateBalances(eBalanceAction aBalanceAction, UltraGridCell aCell)
        {
            try
            {
                int originalValue = 0;
                int quantity = 0;
                switch (aBalanceAction)
                {
                    case eBalanceAction.RowDeleted:
                       
                        if (aCell.Value == System.DBNull.Value)
                        {
                            quantity = 0;
                        }
                        else
                        {
                            quantity = Convert.ToInt32(aCell.Value, CultureInfo.CurrentUICulture) * -1;
                        }
                        break;
                  
                    case eBalanceAction.RowAdded:
                        
                        if (aCell.Value == System.DBNull.Value ||
                            Convert.ToString(aCell.Value, CultureInfo.CurrentUICulture) == string.Empty)
                        {
                            quantity = 0;
                        }
                        else
                        {
                            quantity = Convert.ToInt32(aCell.Value, CultureInfo.CurrentUICulture);
                        }
                        break;
                
                    default:

                        if (aCell.OriginalValue == System.DBNull.Value)
                            originalValue = 0;
                        else
                            originalValue = Convert.ToInt32(aCell.OriginalValue, CultureInfo.CurrentUICulture);
                      
                        if (aCell.Value == System.DBNull.Value)
                        {
                            quantity = 0;
                        }
                        else
                        {
                            quantity = Convert.ToInt32(aCell.Value, CultureInfo.CurrentUICulture);
                        }
                        break;
                }

                string[] bandKeyParts = aCell.Row.Band.Key.Split(new char[] { '~' });
                switch (bandKeyParts[0])
                {
                    case "Header":
                    //case "Placeholder":
                        if (aBalanceAction != eBalanceAction.RowDeleted)
                        {
                            if (aCell.Row.Cells["ChildTotal"].Value == System.DBNull.Value)
                            {
                                aCell.Row.Cells["ChildTotal"].Value = 0;
                            }
                            if (aCell.Row.HasChild(false))
                            {
                                if (aCell.Row.Cells["Balance"].Value == System.DBNull.Value)
                                {
                                    aCell.Row.Cells["Balance"].Value = 0;
                                } 
                                aCell.Row.Cells["Balance"].Value = Convert.ToInt32(aCell.Value, CultureInfo.CurrentUICulture)
                                    - Convert.ToInt32(aCell.Row.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                            }
                        }
                        break;
                    case "Pack":

                        if (aCell.Row.ParentRow.Cells["HdrQuantity"].Value == System.DBNull.Value)
                        {
                            aCell.Row.ParentRow.Cells["HdrQuantity"].Value = 0;
                        }
                        if (aBalanceAction == eBalanceAction.RowDeleted)
                        {
                            // adjust header balance
                            int packTotal = Convert.ToInt32(aCell.Row.Cells["TotalPacks"].Value) * Convert.ToInt32(aCell.Row.Cells["QuantityPerPack"].Value);
                            if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                            {
                                aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                            }

                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value) - packTotal;
                            if (Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture) == 0)
                            {
                                aCell.Row.ParentRow.Cells["Balance"].Value = System.DBNull.Value;
                            }
                            else
                            {
                                aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["HdrQuantity"].Value)
                                    - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value);
                            }
                        }
                        else
                        {
                            switch (aCell.Column.Key)
                            {
                                case "TotalPacks":
                                    {
                                        if (aBalanceAction != eBalanceAction.RowDeleted)
                                        {
                                            // adjust header balance
                                            int originalPackTotal = originalValue * Convert.ToInt32(aCell.Row.Cells["QuantityPerPack"].Value);
                                            int packTotal = quantity * Convert.ToInt32(aCell.Row.Cells["QuantityPerPack"].Value);
                                            aCell.Row.Cells["TotalQuantity"].Value = packTotal;
                                            if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                                            {
                                                aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                                            }
                                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value) - originalPackTotal + packTotal;
                                            aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["HdrQuantity"].Value)
                                                - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value);
                                        }
                                        break;
                                    }
                                case "QuantityPerPack":
                                    {
                                        // adjust header balance
                                        int originalPackTotal = originalValue * Convert.ToInt32(aCell.Row.Cells["TotalPacks"].Value);
                                        int packTotal = quantity * Convert.ToInt32(aCell.Row.Cells["TotalPacks"].Value);
                                        aCell.Row.Cells["TotalQuantity"].Value = packTotal;
                                        if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                                        {
                                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                                        }
                                        aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value) - originalPackTotal + packTotal;
                                        aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["HdrQuantity"].Value)
                                            - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value);
                                        // adjust pack balance
                                        if (aCell.Row.HasChild(false))
                                        {
                                            if (aCell.Row.Cells["ChildTotal"].Value != System.DBNull.Value)
                                            {
                                                aCell.Row.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.Cells["QuantityPerPack"].Value, CultureInfo.CurrentUICulture)
                                                    - Convert.ToInt32(aCell.Row.Cells["ChildTotal"].Value);
                                            }
                                        }
                                        break;
                                    }
                            }
                        }
                        break;
                    case "PackColor":
                        // adjust pack balance
                        if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                        {
                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                        }
                        aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value) - originalValue + quantity;
                        aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["QuantityPerPack"].Value)
                            - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value);
                        // adjust size balance
                        if (_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                        {
                            if (aBalanceAction != eBalanceAction.RowDeleted)
                            {
                                if (aCell.Row.HasChild(false))
                                {
                                    if (aCell.Row.Cells["ChildTotal"].Value == System.DBNull.Value)
                                    {
                                        aCell.Row.Cells["ChildTotal"].Value = 0;
                                    }
                                    aCell.Row.Cells["Balance"].Value = quantity - Convert.ToInt32(aCell.Row.Cells["ChildTotal"].Value);
                                }
                            }
                        }
                        break;
                    case "BulkColor":
                        // adjust header balance
                        if (aCell.Row.ParentRow.Cells["HdrQuantity"].Value == System.DBNull.Value)
                        {
                            aCell.Row.ParentRow.Cells["HdrQuantity"].Value = 0;
                        }
                        if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                        {
                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                        }
                        aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value) - originalValue + quantity;
                        if (Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture) == 0)
                        {
                            aCell.Row.ParentRow.Cells["Balance"].Value = System.DBNull.Value;
                        }
                        else
                        {
                            aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["HdrQuantity"].Value)
                                - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value);
                        }
                        if (_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                        {
                            if (aBalanceAction != eBalanceAction.RowDeleted)
                            {
                                if (aCell.Row.HasChild(false))
                                {
                                    if (aCell.Row.Cells["ChildTotal"].Value == System.DBNull.Value)
                                    {
                                        aCell.Row.Cells["ChildTotal"].Value = 0;
                                    }
                                    aCell.Row.Cells["Balance"].Value = Convert.ToInt32(aCell.Value, CultureInfo.CurrentUICulture)
                                        - Convert.ToInt32(aCell.Row.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                                }
                            }
                        }
                        break;
                 
                    case "PackSize":
                    case "PackColorSize":
                    case "BulkSize":    
                        if (aBalanceAction != eBalanceAction.RowDeleted)
                        {
                            aCell.Row.Cells["TotalQuantity"].Value = Convert.ToInt32(aCell.Row.Cells["TotalQuantity"].Value, CultureInfo.CurrentUICulture) - originalValue + quantity;
                        }
                        if (aCell.Row.ParentRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                        {
                            aCell.Row.ParentRow.Cells["ChildTotal"].Value = 0;
                        }

                        aCell.Row.ParentRow.Cells["ChildTotal"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture) - originalValue + quantity;

                        string qtyCell = bandKeyParts[0] == "BulkSize" ? "Quantity" : "QuantityPerPack";
                         
                        aCell.Row.ParentRow.Cells["Balance"].Value = Convert.ToInt32(aCell.Row.ParentRow.Cells[qtyCell].Value, CultureInfo.CurrentUICulture)
                            - Convert.ToInt32(aCell.Row.ParentRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                        break;

                    default:
                        break;
                }
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
            }
            catch  
            {
                throw;
            }
        }

        private void ugDetails_BeforeRowDeactivate(object sender, CancelEventArgs e)
        {
            try
            {
                EditMsgs em = new EditMsgs();
                UltraGridRow activeRow = ugDetails.ActiveRow;
                if (activeRow.Cells == null || !_inEditMode)
                {
                    return;
                }
                if (!ValidateSpecificFields(activeRow, ref em))
                {
                    if (em.EditMessages.Count > 0)
                    {
                        _errors = null;
                        for (int i = 0; i < em.EditMessages.Count; i++)
                        {
                            EditMsgs.Message emm = (EditMsgs.Message)em.EditMessages[i];
                            AddErrorMessage(emm);
                        }
                        MessageBox.Show(_errors, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    e.Cancel = true;
                 }
            }
            catch 
            {
                throw;
            }
        }

        private void ugDetails_KeyDown(object sender, KeyEventArgs e)
        {
            try
            {
                _gridKeyEvent = e;
                _deleteKeyPressed = false;
                if (e.KeyData == Keys.Delete && this.ugDetails.ActiveRow != null)
                {
                    _rClickRow = this.ugDetails.ActiveRow;
                    _deleteKeyPressed = true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_Error(object sender, Infragistics.Win.UltraWinGrid.ErrorEventArgs e)
        {
            try
            {
                EditMsgs em = new EditMsgs();
                if (_fromRightClick)
                {
                    _fromRightClick = false;
                    e.Cancel = true;
                }
                else if (e.DataErrorInfo.Row == null)
                {
                    e.Cancel = true;
                }
                else if (!ValidateSpecificFields(e.DataErrorInfo.Row, ref em))
                {
                    if (em.EditMessages.Count > 0)
                    {
                        _errors = null;
                        for (int i = 0; i < em.EditMessages.Count; i++)
                        {
                            EditMsgs.Message emm = (EditMsgs.Message)em.EditMessages[i];
                            AddErrorMessage(emm);
                        }
                        MessageBox.Show(_errors, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    e.Cancel = true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

		private void ugDetails_DragEnter(object sender, DragEventArgs e)
		{
			Image_DragEnter(sender, e);
		}

        private void ugDetails_DragOver(object sender, DragEventArgs e)
        {
            try
            {
                if (!_inEditMode)
                {
                    e.Effect = DragDropEffects.None;
                    return;
                }

				Image_DragOver(sender, e);

                Infragistics.Win.UIElement aUIElement;

                Point pt = PointToClient(new Point(e.X, e.Y));
                // Begin TT#525 - RMatelic - Allocation Workspace drag/drop functionality not working correctly
                //Point realPoint = new Point(pt.X - ugDetails.Location.X, pt.Y - ugDetails.Location.Y - panel1.Height - splitContainer.Panel1.Height);
                Point realPoint = new Point(pt.X - ugDetails.Location.X, pt.Y - ugDetails.Location.Y - panel1.Height - splitContainer.Panel1.Height - splitContainerLower.Panel1.Height);
                // End TT#525

                aUIElement = ugDetails.DisplayLayout.UIElement.ElementFromPoint(realPoint);

                if (aUIElement == null)
                {
                    e.Effect = DragDropEffects.None;
                    return;
                }

                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                bool validDrag = false;
                if (row == null)
                {
                    if (e.Data.GetDataPresent(typeof(SelectedRowsCollection)))
                    {
                        e.Effect = DragDropEffects.All;
                        return;
                    }
                    else
                    {
                        e.Effect = DragDropEffects.None;
                        return;
                    }

                }
                else
                {
                    validDrag = false;
                    switch (row.Band.Key)
                    {
                        case "Header":
                        //case "Placeholder":
                            validDrag = DragOverHeader(sender, aUIElement, ref e);
                            break;

                        case "BulkColor":
                            validDrag = DragOverBulkColor(sender, aUIElement, ref e);
                            break;

                        case "Pack":
                            validDrag = DragOverPack(sender, aUIElement, ref e);
                            break;

                        case "PackColor":
                            validDrag = DragOverPackColor(sender, aUIElement, ref e);
                            break;

                        default:
                            break;
                    }
                }
                if (validDrag)
                {
                    e.Effect = DragDropEffects.All;
                }
                else
                {
                    e.Effect = DragDropEffects.None;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool DragOverHeader(object sender,  Infragistics.Win.UIElement aUIElement, ref DragEventArgs e)
        {
            TreeNodeClipboardList cbList;
            //TreeNodeClipboardProfile cbProf;
            try
            {
                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                UltraGridCell dragOverCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));
              
                //if (dragOverCell == null || dragOverCell.Activation != Activation.AllowEdit)
                if (dragOverCell == null)
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
                
                bool validDrag = true;
                switch (dragOverCell.Column.Key)
                {
                    case "Style":
                    case "Product":
                    case "AnchorNode":

                        if (dragOverCell.Activation != Activation.AllowEdit)
                        {
                            validDrag = false;
                        }
                        else if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                        {
                            cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));

                            //if (cbp.ClipboardDataType == eClipboardDataType.HierarchyNode)
                            if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                            {
                                HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(_mainHp.Key, cbList.ClipboardProfile.Key);
                             
                                if (dragOverCell.Column.Key == "AnchorNode")
                                {
                                    if (hnp.HomeHierarchyLevel >= _hlpStyle.Level) 
                                    {
                                        validDrag = false;
                                    }
                                }    
                                else if (hnp.LevelType != eHierarchyLevelType.Style &&
                                         hnp.HomeHierarchyLevel != _hlpProduct.Level)
                                {
                                    validDrag = false;
                                }
                            }
                            else
                            {
                                validDrag = false;
                            }
                        }
                        break;

                    case "Workflow":

                        if (dragOverCell.Activation != Activation.AllowEdit)
                        {
                            validDrag = false;
                        }
                        else if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                        {
                            cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));

                            //if (cbp.ClipboardDataType != eClipboardDataType.Workflow)
                            if (cbList.ClipboardDataType != eProfileType.Workflow)
                            {
                                validDrag = false;
                            }
                        }
                        break;

                    case "HeaderID":

                        if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                        {
                            if (dragOverCell.Activation != Activation.AllowEdit)
                            {
                                validDrag = false;
                            }
                            else
                            {
                                cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));
                                //if (cbp.ClipboardDataType == eClipboardDataType.HierarchyNode)
                                if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                                {
                                    HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(_mainHp.Key, cbList.ClipboardProfile.Key);
                                    if (hnp.LevelType != eHierarchyLevelType.Color)
                                    {
                                        validDrag = false;
                                    }

                                    //if (cbp.isList)
                                    //{
                                    //    ArrayList colorItems = (ArrayList)cbp.ClipboardData;

                                    //    ClipboardProfile nodeProfile = (ClipboardProfile)colorItems[0];
                                    //    HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(_mainHp.Key, nodeProfile.Key);
                                    //    if (hnp.LevelType != eHierarchyLevelType.Color)
                                    //    {
                                    //        validDrag = false;
                                    //    }
                                    //}
                                    //else
                                    //{
                                    //    HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(_mainHp.Key, cbp.Key);
                                    //    if (hnp.LevelType != eHierarchyLevelType.Color)
                                    //    {
                                    //        validDrag = false;
                                    //    }
                                    //}
                                }
                                //else if (cbp.ClipboardDataType == eClipboardDataType.HierarchyNodeList)
                                //{
                                //    if (cbp.ClipboardData.GetType() != typeof(ArrayList))
                                //    {
                                //        validDrag = false;
                                //    }
                                //    ArrayList colorItems = (ArrayList)cbp.ClipboardData;

                                //    ClipboardProfile nodeProfile = (ClipboardProfile)colorItems[0];
                                //    HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(_mainHp.Key, nodeProfile.Key);
                                //    if (hnp.LevelType != eHierarchyLevelType.Color)
                                //    {
                                //        validDrag = false;
                                //    }
                                //}
                                //else if (cbp.ClipboardDataType != eClipboardDataType.Color &&
                                //         cbp.ClipboardDataType != eClipboardDataType.ColorList)
                                else if (cbList.ClipboardDataType != eProfileType.ColorCode)
                                {
                                    validDrag = false;
                                }
                                else if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                                {
                                    validDrag = false;
                                }
                                else if (ugDetails.ActiveRow != row)
                                {
                                    validDrag = false;
                                }
                            }
                        }
                        else if (e.Data.GetDataPresent(typeof(SelectedRowsCollection)))
                        {
                            int asrtRID = 0;
                            eHeaderType hdrType = (eHeaderType)Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                            if (row.Cells["AsrtRID"].Value != DBNull.Value)
                            {
                                asrtRID = Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                            }
                            SelectedRowsCollection SelRows = (SelectedRowsCollection)e.Data.GetData(typeof(SelectedRowsCollection));
                       
                            switch (hdrType)
                            {
                                case eHeaderType.MultiHeader:
 
                                    foreach (UltraGridRow selRow in SelRows)
                                    {
                                        if (selRow.Cells["AsrtRID"].Value != DBNull.Value
                                         || selRow.Cells["HdrGroupRID"].Value != DBNull.Value)  
                                        {
                                            validDrag = false;
                                            break;
                                        }
                                    }
                                    break;

                                case eHeaderType.Assortment:
                                case eHeaderType.Placeholder:
                                    foreach (UltraGridRow selRow in SelRows)
                                    {
                                        if (selRow.Cells["HdrGroupRID"].Value != DBNull.Value 
                                         || selRow.Cells["AsrtRID"].Value != DBNull.Value)
                                        {
                                            validDrag = false;
                                            break;
                                        }
										//TT#686 - MD - DOConnell - Add Restrictions to what types of headers can be dropped on a placeholder.
                                        //else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance)
                                        else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance ||
                                                (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.WorkupTotalBuy ||
                                                (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)))
                                        {
                                            validDrag = false;
                                            break;
                                        }
                                    }
                                    //if (hdrType == eHeaderType.Assortment)
                                    //{
                                    //    row = row.GetSibling(SiblingRow.First, false);
                                    //    while (row != null)
                                    //    {
                                    //        if (Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == asrtRID
                                    //         && Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                                    //        {
                                    //            validDrag = false;
                                    //            break;
                                    //        }
                                    //        row = row.GetSibling(SiblingRow.Next, false);
                                    //    }    
                                    //}
                                    break;
                                            
                                default:
                                    validDrag = false;
                                    break;
                            }    
                        }
                        else
                        {
                            validDrag = false;
                        }    
                        break;

                    default:
                        validDrag = false;
                        break;
                }
                if (!validDrag)
                {
                    e.Effect = DragDropEffects.None;
                }
                return validDrag; 
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool DragOverBulkColor(object sender, Infragistics.Win.UIElement aUIElement, ref DragEventArgs e)
        {
            TreeNodeClipboardList cbList = null;
            try
            {
                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                UltraGridCell dragOverCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));
                if (dragOverCell == null || dragOverCell.Activation != Activation.AllowEdit)
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
               
                if (dragOverCell != row.Cells["BulkColor"]) 
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
                else if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                {
                    cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));

                    //if (cbp.ClipboardDataType == eClipboardDataType.HierarchyNode)
                    if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                    {
                        HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(_mainHp.Key, cbList.ClipboardProfile.Key);
                        if (hnp.LevelType != eHierarchyLevelType.Color)
                        {
                            e.Effect = DragDropEffects.None;
                            return false;
                        }
                    }
                    //else if (cbp.ClipboardDataType != eClipboardDataType.Color &&
                    //         cbp.ClipboardDataType != eClipboardDataType.ColorList)
                    else if (cbList.ClipboardDataType != eProfileType.ColorCode)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.ActiveRow != row)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                }  
                else
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool DragOverPack(object sender, Infragistics.Win.UIElement aUIElement, ref DragEventArgs e)
        {
            TreeNodeClipboardList cbList;
            //HierarchyNodeClipboardList hnList;
            
            try
            {
                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                UltraGridCell dragOverCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));
                if (dragOverCell == null || dragOverCell.Activation != Activation.AllowEdit)
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }

                if (dragOverCell != row.Cells["Pack"])
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
                else if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                {
                    cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));
                    if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                    {
                        HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(_mainHp.Key, cbList.ClipboardProfile.Key);
                        if (hnp.LevelType != eHierarchyLevelType.Color)
                        {
                            e.Effect = DragDropEffects.None;
                            return false;
                        }
                    }
                    else if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.ActiveRow != row)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                }
                else if (e.Data.GetDataPresent(typeof(ColorCodeClipboardList)))
                {
                    if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.ActiveRow != row)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                }
                else
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
  
                return true;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool DragOverPackColor(object sender, Infragistics.Win.UIElement aUIElement, ref DragEventArgs e)
        {
            TreeNodeClipboardList cbList;
            
            try
            {
                UltraGridRow row = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                UltraGridCell dragOverCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));
                if (dragOverCell == null || dragOverCell.Activation != Activation.AllowEdit)
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
                 
                if (dragOverCell != row.Cells["PackColor"])
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }
                else if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
                {
                    cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));

                    if (cbList.ClipboardDataType == eProfileType.HierarchyNode)
                    {
                        HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(_mainHp.Key, cbList.ClipboardProfile.Key);
                        if (hnp.LevelType != eHierarchyLevelType.Color)
                        {
                            e.Effect = DragDropEffects.None;
                            return false;
                        }
                    }
                    else if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.ActiveRow != row)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                }
                else if (e.Data.GetDataPresent(typeof(ColorCodeClipboardList)))
                {
                    if (ugDetails.Selected.Rows.Count > 0 && !row.Selected)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                    else if (ugDetails.ActiveRow != row)
                    {
                        e.Effect = DragDropEffects.None;
                        return false;
                    }
                }
                else
                {
                    e.Effect = DragDropEffects.None;
                    return false;
                }

                return true;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void ugDetails_DragDrop(object sender, DragEventArgs e)
        {
			try
			{
				Infragistics.Win.UIElement aUIElement;
				SelectedRowsCollection SelRows;
                TreeNodeClipboardList cbList;
                //ColorCodeClipboardList ccList;
			
				Point pt = PointToClient(new Point(e.X, e.Y));
                // Begin TT#525 - RMatelic - Allocation Workspace drag/drop functionality not working correctly
                //Point realPoint = new Point(pt.X - ugDetails.Location.X, pt.Y - ugDetails.Location.Y - panel1.Height - splitContainer.Panel1.Height);
                Point realPoint = new Point(pt.X - ugDetails.Location.X, pt.Y - ugDetails.Location.Y - panel1.Height - splitContainer.Panel1.Height - splitContainerLower.Panel1.Height);
                // End TT#525 

				aUIElement = ugDetails.DisplayLayout.UIElement.ElementFromPoint(realPoint);

				UltraGridRow dropRow = (UltraGridRow)aUIElement.GetContext(typeof(UltraGridRow));
                UltraGridCell dropCell = (UltraGridCell)aUIElement.GetContext(typeof(UltraGridCell));

                if (e.Data.GetDataPresent(typeof(TreeNodeClipboardList)))
				{
                    cbList = (TreeNodeClipboardList)e.Data.GetData(typeof(TreeNodeClipboardList));

                    switch (cbList.ClipboardDataType)
                    {
                        //case eClipboardDataType.HierarchyNode:
                        case eProfileType.HierarchyNode:
                            if (cbList.ClipboardItems.Count == 1)
                            {
                                NodeDragDrop(dropRow, cbList.ClipboardProfile, dropCell);
                            }
                            else
                            {
                                HierNodeListDragDrop(dropRow, cbList);
                            }
                            break;

                        //case eClipboardDataType.HierarchyNodeList:
                        //    HierNodeListDragDrop(dropRow, cbp);
                        //    break;

                        //case eClipboardDataType.ColorList:
                        //    ColorListDragDrop(dropRow, cbp);
                        //    break;
                        //Begin TT#6 - Color Browser object reference error
                        case eProfileType.ColorCode:
                            ColorListDragDrop(dropRow, cbList);
                            break;
                        //End TT#6  
                        //case eClipboardDataType.Workflow:
                        case eProfileType.Workflow:
                            WorkflowDragDrop(dropRow, cbList.ClipboardProfile);
                            break;
        			}
				}
                //else if (e.Data.GetDataPresent(typeof(ColorCodeClipboardList)))
                //{
                //    ccList = (ColorCodeClipboardList)e.Data.GetData(typeof(ColorCodeClipboardList));

                //    ColorListDragDrop(dropRow, ccList);
                             
                //}
				else if (e.Data.GetDataPresent(typeof(SelectedRowsCollection)))
				{
					SelRows = (SelectedRowsCollection)e.Data.GetData(typeof(SelectedRowsCollection));
                    try
                    {
                        HeaderDragDrop(dropRow, SelRows);
                    }
                    catch
                    {
                        ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, false);
                        foreach (UltraGridRow selRow in SelRows)
                        {
                            int hRID1 = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            foreach (UltraGridRow row in ugDetails.Rows)
                            {
                                int hRID2 = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                                if (hRID2 == hRID1)
                                {
                                    row.Delete(false);
                                    break;
                                }
                            }
                        }
                        ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, true);
                    }
				}
				else
                {     
                    MessageBox.Show(MIDText.GetTextOnly(eMIDTextCode.msg_InvalidDataType));
				}
			}
			catch (Exception)
			{
				//string text = string.Format(MIDText.GetTextOnly(eMIDTextCode.msg_MustBeStyleOrProductNode), _hlpStyle.LevelID, _hlpProduct.LevelID);
                string text = MIDText.GetTextOnly(eMIDTextCode.msg_InvalidDataType);
				MessageBox.Show(text);
			}
        }

        private void NodeDragDrop(UltraGridRow aRow, TreeNodeClipboardProfile aCBProfile, UltraGridCell aDropCell)
        {
            string errorMessage = string.Empty;
            try
            {
                TreeNodeClipboardProfile cbp = aCBProfile;
              
				HierarchyNodeSecurityProfile securityNode = _SAB.ClientServerSession.GetMyUserNodeSecurityAssignment(cbp.Key, (int)eSecurityTypes.Allocation);
                if (!securityNode.AllowUpdate)
                {
                    MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_NotAuthorizedForNode));
                }
                else
                {
                    HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(_mainHp.Key, cbp.Key);
                    if (hnp.LevelType == eHierarchyLevelType.Color)
                    {
                         ColorDragDrop(aRow, hnp.ColorOrSizeCodeRID);
                    }
                    else if (aDropCell == aRow.Cells["AnchorNode"])
                    {
                        //TODO  validate ancestor link to assortment anchor node
                        //if (!ValidAssortmentLink(aRow, hnp.Key))
                        //{
                        //    return;
                        //}
                        _skipAnchorEdit = true;
                        int oldNodeRID = Convert.ToInt32(aRow.Cells["AnchorHnRID"].Value, CultureInfo.CurrentUICulture);
                        aRow.Cells["AnchorNode"].Value = hnp.LevelText;
                        aRow.Cells["AnchorHnRID"].Value = hnp.Key;
                        UpdateAnchorNodeTable(aRow);
                    }
                    else if (hnp.LevelType == eHierarchyLevelType.Style)
                    {
                        if (Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                        {
                            if(!ValidPlaceholderStyle(aRow, hnp.Key, ref errorMessage)) 
                            {
                                return;
                            }
                        }
                        _skipStyleEdit = true;
                        aRow.Cells["Style"].Value = hnp.LevelText;
                        aRow.Cells["StyleHnRID"].Value = hnp.Key;
                        aRow.Cells["Description"].Value = hnp.NodeDescription;
                        HierarchyNodeProfile productHnp = _SAB.HierarchyServerSession.GetNodeData(hnp.HomeHierarchyParentRID);

                        _skipProductEdit = true;
                        aRow.Cells["ProductRID"].Value = productHnp.Key;
                        aRow.Cells["Product"].Value = productHnp.LevelText;
                        aRow.Cells["StyleSecurity"].Value = (int)eSecurityType.Update;
                        // Begin TT#2061 - JSmith - Size hierarchy node within Style-Color not found - after Header copied to new Style\Color
                        UpdateAddedSizeRows(aRow, true);
                        // End TT#2061
                    }
                    else if (hnp.HomeHierarchyLevel == _hlpProduct.Level)
                    {
                        _skipProductEdit = true;
                        aRow.Cells["ProductRID"].Value = hnp.Key;
                        aRow.Cells["Product"].Value = hnp.LevelText;
                        aRow.Cells["Description"].Value = string.Empty;

                        _skipStyleEdit = true;
                        aRow.Cells["Style"].Value = string.Empty;
                        aRow.Cells["StyleHnRID"].Value = Include.NoRID;
                        aRow.Cells["StyleSecurity"].Value = (int)eSecurityType.Update;
                        errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_MustBeCorrectLevel), _hlpStyle.LevelID);
                        MessageBox.Show(errorMessage, _thisTitle);
                    }
                    else
                    {
                        throw new Exception();
                    }
                }
            }
            catch  
            {
                throw;
            }
        }

        private void HierNodeListDragDrop(UltraGridRow aRow, TreeNodeClipboardList aCBList)
        {
            try
            {
                // Dropping on a BulkColor or PackColor row replaces the color
                // Dropping on a Header or Pack row adds new color rows

                string errorMessage = string.Empty;
                //TreeNodeClipboardProfile cbp = aCBProfile;
                ColorCodeProfile ccp;

                //if (cbp.ClipboardData.GetType() != typeof(ArrayList))
                //{
                //    return;
                //}
                //ArrayList colorItems = (ArrayList)cbp.ClipboardData;

                // Change profile key from NodeRID to ColorCodeRID  
                foreach (TreeNodeClipboardProfile cbpColor in aCBList.ClipboardItems)
                {
                    HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(_mainHp.Key, cbpColor.Key);
                    cbpColor.Key = hnp.ColorOrSizeCodeRID;
                }    

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.BeginUpdate();
                //ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, false);
                switch (aRow.Band.Key)
                {
                    case "Header":
                    //case "Placeholder":
                    case "Pack":
                        AddColorRowsFromList(aRow, aCBList.ClipboardItems);
                        break;

                    case "BulkColor":
                        //ClipboardProfile bulkColor_cbp = (ClipboardProfile)colorItems[0];
                        ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(aCBList.ClipboardProfile.Key);
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["BulkColor"].Value = ccp.ColorCodeID;
                        break;

                    case "PackColor":
                        //ClipboardProfile packColor_cbp = (ClipboardProfile)colorItems[0];
                        ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(aCBList.ClipboardProfile.Key);
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["PackColor"].Value = ccp.ColorCodeID;
                        break;
                }

                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, true);
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.ResumeRowSynchronization();
                //ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            }
            catch
            {
                throw;
            }
        }

        private void ColorDragDrop(UltraGridRow aRow, int aColorCodeRID)
        {
            try
            {
                // Dropping on a BulkColor or PackColor row replaces the color
                // Dropping on a Header or Pack row adds new color rows
                ColorCodeProfile ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(aColorCodeRID);
                bool okToContinue;
                string errorMessage = string.Empty;
                switch (aRow.Band.Key)
                {
                    case "BulkColor":
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["BulkColor"].Value = ccp.ColorCodeID;
                        break;

                    case "PackColor":
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["PackColor"].Value = ccp.ColorCodeID;
                        break;
                    
                    case "Header":
                    //case "Placeholder":
                        okToContinue = AddBulkColorRow();
                        if (okToContinue)
                        {
                            UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                        }
                        break;

                    case "Pack":
                        _skipRowUpdate = true;
                        okToContinue = AddPackColorRow();
                        if (okToContinue)
                        {
                            UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                        }
                        _skipRowUpdate = false;
                        break;
                }
            }
            catch  
            {
                throw;
            }
            finally
            {
                if (_frmColorBrowser != null)
                {
                    _frmColorBrowser.Dispose();
                }
            }
        }
        //Begin TT#6 - Color Browser object reference error
        //private void ColorListDragDrop(UltraGridRow aRow, ColorCodeClipboardList aCCList)
        private void ColorListDragDrop(UltraGridRow aRow, TreeNodeClipboardList aCCList)
        //End TT#6
        {
            try
            {
                // Dropping on a BulkColor or PackColor row replaces the color with the 1st one selected 
                // Dropping on a Header or Pack row adds new color rows

                string errorMessage = string.Empty;
                //ClipboardProfile cbp = aCBProfile;
                ColorCodeProfile ccp;

                //if (cbp.ClipboardData.GetType() != typeof(ArrayList))
                //{
                //    return;
                //}
                ArrayList colorItems = (ArrayList)aCCList.ClipboardItems;

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.BeginUpdate();
                //ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, false);
                switch (aRow.Band.Key)
                {
                    case "Header":
                    //case "Placeholder":
                    case "Pack":
                        AddColorRowsFromList(aRow, colorItems);
                        break;

                    case "BulkColor":
                        //Begin TT#6 - Color Browser object reference error
                        //ColorCodeClipboardProfile bulkColor_cbp = (ColorCodeClipboardProfile)colorItems[0];
                        //ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(bulkColor_cbp.Key);
                        ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(aCCList.ClipboardProfile.Key);
                        //End TT#6  
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["BulkColor"].Value = ccp.ColorCodeID;
                        break;

                    case "PackColor":
                        //Begin TT#6 - Color Browser object reference error
                        //ColorCodeClipboardProfile packColor_cbp = (ColorCodeClipboardProfile)colorItems[0];
                        //ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(packColor_cbp.Key);
                        ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(aCCList.ClipboardProfile.Key);
                        //End TT#6  
                        _skipBeforeCellUpdate = true;
                        aRow.Cells["PackColor"].Value = ccp.ColorCodeID;
                        break;
                }
              
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, true);
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.ResumeRowSynchronization();
                //ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            }
            catch  
            {
                throw;
            }
            finally
            {
                _frmColorBrowser.Dispose();
            }
        }

        private void AddColorRowsFromList(UltraGridRow aRow, ArrayList aColorItems)
        {
            try
            {
                bool okToContinue = true;
                string errorMessage = string.Empty;
                if (!aRow.Selected)
                {
                    aRow.Selected = true;
                }
                _skipRowUpdate = true;
                foreach (UltraGridRow row in ugDetails.Selected.Rows)
                {
                    foreach (TreeNodeClipboardProfile cbp in aColorItems)
                    {
                        ColorCodeProfile ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(cbp.Key);
                        ugDetails.ActiveRow = row;
                        if (aRow.Band.Key == "Header")
                        {
                            okToContinue = AddBulkColorRow();
                        }
                        else
                        {
                            okToContinue = AddPackColorRow();
                        }
                        if (okToContinue)
                        {
                            okToContinue = UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                        }
                        if (!okToContinue)
                        {
                            break;
                        }
                    }
                    if (!okToContinue)
                    {
                        break;
                    }
                }
                _skipRowUpdate = false;
            }
            catch
            {
                throw;
            }    
        }

        private void WorkflowDragDrop(UltraGridRow aRow, TreeNodeClipboardProfile aCBProfile)
        {
            try
            {

                //MethodClipboardData mcd = (MethodClipboardData)aCBProfile.ClipboardData;
                //aRow.Cells["Workflow"].Value = mcd.MethodName;
                aRow.Cells["Workflow"].Value = ((MIDWorkflowMethodTreeNode)aCBProfile.Node).Name;
            }
            catch
            {
            }
        }

        private void HeaderDragDrop(UltraGridRow aRow, SelectedRowsCollection aSelRows)
        {
            try
            {
                //ArrayList hdrArrayList = new ArrayList(); // TT#1185 - Verify ENQ before Update
                List<int> hdrRidList = new List<int>();     // TT#1185 - Verify ENQ before Update
				// Begin TT#2 - RMatelic - Assortment Planning
                if (!ContinueHeaderDrop(aSelRows))
                {
                    throw new Exception();
                }
                // End TT#2
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.BeginUpdate();
                //ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);

                foreach (UltraGridRow selRow in aSelRows)
                {
                    bool rowAlreadyExists = false;
                    int hRID1 = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    foreach (UltraGridRow row in ugDetails.Rows)
                    {
                        int hRID2 = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        if (hRID2 == hRID1)
                        {
                            rowAlreadyExists = true;
                            break;
                        }
                    }
                    if (!rowAlreadyExists)
                    {
                        DataSet ds = BuildComponentData(selRow);
                        _dsDetails.Merge(ds, true);
                        hdrRidList.Add(hRID1);     // TT#1185 - Verify ENQ before Update
                        //hdrArrayList.Add(hRID1); // TT#1185 - Verify ENQ before Update
                    }
                }
                //if (hdrArrayList.Count == 0)  // TT#1185 - Verify ENQ before Update
                if (hdrRidList.Count == 0)      // TT#1185 - Verify ENQ before Update
                {
                    ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                    return;
                }

               // if (!HeadersAddedEnqueued(hdrArrayList)) // TT#1185 - Verify ENQ before Update
                if (!EnqueueHeadersForEdit(hdrRidList))      // TT#1185 - Verfiry ENQ before Update
                {
                    ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                    return;
                }

                BindDetailsGrid();

                ugDetails.Selected.Rows.Clear();

                if (aRow != null)
                {
                    aRow.Selected = true;
                }
                foreach (UltraGridRow selRow in aSelRows)
                {

                    int hRID1 = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    foreach (UltraGridRow row in ugDetails.Rows)
                    {
                        int hRID2 = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        if (hRID2 == hRID1)
                        {
                            row.Selected = true;
                            // Begin TT#479 - RMatelic  Added expand check unrelated to issue
                            if (_expandAll)
                            {
                                row.ExpandAll();
                            }
                            // End TT#479
                            break;
                        }
                    }
                }

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.ResumeRowSynchronization();
                //ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);

                if (aRow != null)
                {
                    EventArgs args = new EventArgs();
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);

                    switch (headerType)
                    {
                        case eHeaderType.MultiHeader:
                            cmsMultiAddTo_Click(cmsMultiAddTo, args);
                            break;

                        case eHeaderType.Assortment:
                        case eHeaderType.Placeholder:
                            _creatingAssortment = true;
                            AddHeadersToAssortment();
                            _creatingAssortment = false;
                            break;
                    }
                }
                else
                {
                    SetEditActivation();
                }
            }
            catch
            {
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.ResumeRowSynchronization();
                //ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                throw;
            }
        }

        private bool ContinueHeaderDrop(SelectedRowsCollection aSelRows)
        {
            bool continueDrop = true;
            try
            {
                List<int> hdrArrayList = new List<int>();
                foreach (UltraGridRow selRow in aSelRows)
                {
                    bool rowAlreadyExists = false;
                    int hRID1 = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    foreach (UltraGridRow row in ugDetails.Rows)
                    {
                        int hRID2 = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        if (hRID2 == hRID1)
                        {
                            rowAlreadyExists = true;
                            break;
                        }
                    }
                    if (!rowAlreadyExists)
                    {
                        DataSet ds = BuildComponentData(selRow);
                        _dsDetails.Merge(ds, true);
                        hdrArrayList.Add(hRID1);
                    }
                }
                if (hdrArrayList.Count == 0)
                {
                    continueDrop = false;
                }
				//else if (!HeadersAddedEnqueued(hdrArrayList))		stodd - manual merge
				else if (!EnqueueHeadersForEdit(hdrArrayList))
                {
                    continueDrop = false;
                }
            }
            catch
            {
                throw;
            }
            return continueDrop;
        }
        // End TT#2

        private void ugDetails_DragLeave(object sender, EventArgs e)
        {
            Image_DragLeave(sender, e);
        }

        private void ugDetails_MouseEnterElement(object sender, UIElementEventArgs e)
        {
            try
            {
                ShowUltraGridToolTip(ugDetails, e);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_AfterSortChange(object sender, BandEventArgs e)
        {
            try
            {
                for (int i = 0; i < e.Band.SortedColumns.Count; i++)
                {
                    UltraGridColumn sortColumn = e.Band.SortedColumns[i];

                    if (sortColumn.Key == "HdrGroupRID")
                    {
                        if (!e.Band.SortedColumns.Exists("MultiSortSeq"))
                        {
                            e.Band.SortedColumns.Add("MultiSortSeq", false);
                        }
                        break;
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ugDetails_InitializeRow(object sender, InitializeRowEventArgs e)
        {
            try
            {
                string bandKey = e.Row.Band.Key;
                if (e.Row.Band.Key == "Header")
                {
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(e.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    switch (headerType)
                    {
                        case eHeaderType.Assortment:    // safety precaution for Assortments added prior to AsrtType  

                            if (e.Row.Cells["AsrtType"].Value != DBNull.Value &&
                                Convert.ToInt32(e.Row.Cells["AsrtType"].Value, CultureInfo.CurrentUICulture) == (int)eAssortmentType.Undefined)
                            {
                                e.Row.Cells["AsrtType"].Value = (int)eAssortmentType.PreReceipt;
                            }
                            e.Row.Hidden = true;    // TT#2 Assortment Planning
                            break;

                        case eHeaderType.Placeholder:

                            eAssortmentType asrtType = GetAssortmentTypeForDetailsGrid(e.Row);
                            //if (asrtType == eAssortmentType.PostReceipt)
                            //{
                                e.Row.Hidden = true;
                            //}
                            //else
                            //{
                            //    e.Row.Cells["HeaderID"].Appearance.ForeColor = System.Drawing.Color.Transparent;
                            //    e.Row.Cells["HeaderID"].SelectedAppearance.ForeColor = System.Drawing.Color.Transparent; 
                            //}
                            break;

                        default:
                            break;
                    }

                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
    
        private eAssortmentType GetAssortmentTypeForDetailsGrid(UltraGridRow aRow)
        {
            eAssortmentType asrtType = eAssortmentType.Undefined;
            try
            {

                int asrtRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);

                IEnumerable enumerator = aRow.Band.GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == asrtRID)  // the Assortment row
                    {
                        asrtType = (eAssortmentType)Convert.ToInt32(row.Cells["AsrtType"].Value, CultureInfo.CurrentUICulture);
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
            return asrtType;
        }

        // Usability Enhancement
        private void ugDetails_AfterColRegionScroll(object sender, ColScrollRegionEventArgs e)
        {
            ugHeaders.DisplayLayout.ColScrollRegions[0].Position = e.ColScrollRegion.Position;
        }

        // Begin TT#805 - RMatelic - System out of memory exception
        private void ugDetails_AfterRowRegionScroll(object sender, RowScrollRegionEventArgs e)
        {
            try
            {
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.BeginUpdate();
                ugDetailsBeginUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                UltraGridRow row;
                if (_expandAll)
                {
                    for (int i = 0; i < e.RowScrollRegion.VisibleRows.Count; i++)
                    {
                        row = e.RowScrollRegion.VisibleRows[i].Row;

                        // If the row is visible and not expanded, expand it
                        if (null != row && null != row.GetUIElement(e.RowScrollRegion) && !row.Expanded)
                        {
                            row.ExpandAll();
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
            finally
            {
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.EndUpdate();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            }
        }
        // End TT#805 

        /// <summary>
        /// Shows ToolTip to display error message in an UntraGrid cell 
        /// </summary>
        /// <param name="ultraGrid">The UltraGrid where the tool tip is to be displayed</param>
        /// <param name="e">The UIElementEventArgs arguments of the MouseEnterElement event</param>
        protected void ShowUltraGridToolTip(Infragistics.Win.UltraWinGrid.UltraGrid ultraGrid, Infragistics.Win.UIElementEventArgs e)
        {
            try
            {
                if (this.toolTip1 != null && this.toolTip1.Active)
                {
                    this.toolTip1.Active = false; //turn it off 
                }
             
                UltraGridCell gridCell = (UltraGridCell)e.Element.GetContext(typeof(Infragistics.Win.UltraWinGrid.UltraGridCell));
                if (gridCell != null)
                {
                    if (gridCell.Tag != null && gridCell.Tag.GetType() == typeof(System.String))
                    {
                        toolTip1.Active = true;
                        toolTip1.SetToolTip(ultraGrid, (string)gridCell.Tag);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void HandleMIDException(MIDException MIDexc)
        {
            string Title = _thisTitle, errLevel, Msg;
            MessageBoxIcon icon;
            MessageBoxButtons buttons;
            buttons = MessageBoxButtons.OK;
            switch (MIDexc.ErrorLevel)
            {
                case eErrorLevel.severe:
                    icon = MessageBoxIcon.Stop;
                    errLevel = MIDText.GetText(Convert.ToInt32(eMIDMessageLevel.Severe));
                    break;

                case eErrorLevel.information:
                    icon = MessageBoxIcon.Information;
                    errLevel = MIDText.GetText(Convert.ToInt32(eMIDMessageLevel.Information));
                    break;

                case eErrorLevel.warning:
                    icon = MessageBoxIcon.Warning;
                    errLevel = MIDText.GetText(Convert.ToInt32(eMIDMessageLevel.Warning));
                    break;

                //Begin TT#1020 - JScott - Add new Error level to the eErrorLevel enumerator
                case eErrorLevel.error:
                    icon = MessageBoxIcon.Error;
                    errLevel = MIDText.GetText(Convert.ToInt32(eMIDMessageLevel.Error));
                    break;

                //End TT#1020 - JScott - Add new Error level to the eErrorLevel enumerator
                default:
                    icon = MessageBoxIcon.Stop;
                    errLevel = MIDText.GetText(Convert.ToInt32(eMIDMessageLevel.Severe));
                    break;
            }
            Title += " - ";
            if (MIDexc.InnerException != null)
            {
                Title += errLevel + " - " + MIDexc.Message;
                Msg = MIDexc.InnerException.Message;
            }
            else
            {
                Title += errLevel;
                Msg = MIDexc.Message;
            }
            MessageBox.Show(this, Msg, Title, buttons, icon);
        }

        #endregion

		#region Create Size Tables
		private DataTable FormatBulkSizeTable(HdrColorBin aColor, int aSizeGroupRID, int headerRID, int colorRID, string aColorCodeID, string tableName, ref int sizeTotal) 
		{
			ArrayList sizeID = new ArrayList();
			SortedList primarySL = new SortedList(); 
			ArrayList secondaryAL = new ArrayList(); 
			Hashtable bothHash = new Hashtable();
            SortedList sortedList = new SortedList();
            SizeGroupProfile sgp = null;
			sizeTotal = 0;
		
			AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(headerRID);		
			SizeCodeList scl = null;
			// is there a size group?
			if (aSizeGroupRID > Include.UndefinedSizeGroupRID) 
			{
				// load existing group
				sgp = GetSizeGroup(aSizeGroupRID);
				scl = sgp.SizeCodeList;

				LoadSizeArraysFromGroup(scl, ref sizeID, ref primarySL, ref secondaryAL);

				if (aColor != null) 
				{
                    foreach (HdrSizeBin aSize in aColor.ColorSizes.Values)
                    {
                        sortedList.Add(aSize.SizeSequence, aSize);
                    }
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    foreach (HdrSizeBin aSize in sortedList.Values)
                    {
                        if (scl.Contains(aSize.SizeKey))
                        {
                            SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(aSize.SizeKey);
                            if (!bothHash.ContainsKey(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID))
                            {
                                bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                            }
                            else
                            {
                                throw new MIDException(eErrorLevel.severe, 0, _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                            }
                        }
                    }
                    // End TT#234  
                    foreach (HdrSizeBin aSize in sortedList.Values) 
				    {
						SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(aSize.SizeKey);
						if (scp == null) 
						{
							if (!ap.MultiHeader && !ap.Placeholder)	 
							{
								scp = _SAB.HierarchyServerSession.GetSizeCodeProfile(aSize.SizeKey);
								if (scp.Key == Include.NoRID) 
								{
                                    throw new MIDException(eErrorLevel.severe, 0, _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_CantRetrieveSizeCode) + " " + aSize.SizeKey.ToString(CultureInfo.CurrentUICulture));
								}  
								MessageBox.Show(string.Format(MIDText.GetText(eMIDTextCode. msg_SizeCodeNotInGroup),scp.SizeCodeName,scp.SizeCodeID,sgp.SizeGroupName));
                                return null;
							}
							else
							{
                                AddSizesNotInGroup(aSize.SizeKey, ref scp, ref sizeID, ref primarySL, ref secondaryAL, bothHash);
                           	}
                        }
                        // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                        else
                        {
                            continue;
                        }
                        //if (!bothHash.ContainsKey(scp.SizeCodePrimary+"~"+scp.SizeCodeSecondary)) 
                        //{
                        //    bothHash.Add(scp.SizeCodePrimary+"~"+scp.SizeCodeSecondary,aSize);
                        //}
                        if (!bothHash.ContainsKey(scp.SizeCodePrimary  + "~" + scp.SizeCodeSecondaryRID))
                        {
                            bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                        }
                        // End TT#234  
                        else
                        {	// Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                            string newPrimaryBoth = scp.SizeCodePrimary + _dupSizeNameSeparator + scp.SizeCodeID;
                            if (!bothHash.ContainsKey(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID))
                            {
                                bothHash.Add(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID, aSize);
                            }
                            else
                            {
                                throw new MIDException(eErrorLevel.severe, 0, _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                            }
                        }   // End TT#234  
					}
				}
			}
			else 
			{	// no size group  display in SEQ sequence
				foreach(HdrSizeBin aSize in aColor.ColorSizes.Values) 
				{
					sortedList.Add(aSize.SizeSequence,aSize);
				}
                scl = new SizeCodeList(eProfileType.SizeCode);  // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
				foreach(HdrSizeBin aSize in sortedList.Values) 
				{
					SizeCodeProfile scp = _SAB.HierarchyServerSession.GetSizeCodeProfile(aSize.SizeKey);
					if (scp.Key == Include.NoRID) 
					{
						throw new MIDException(eErrorLevel.severe, 0,
                            string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeRetrieveError), aSize.SizeKey.ToString(CultureInfo.CurrentUICulture)));
                    }
                    scl.Add(scp);  // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
					LoadSizeArraysFromHeader(aSize.SizeKey, ref sizeID, ref primarySL, ref secondaryAL);
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    //if (!bothHash.ContainsKey(scp.SizeCodePrimary+"~"+scp.SizeCodeSecondary)) 
                    //{
                    //    bothHash.Add(scp.SizeCodePrimary+"~"+scp.SizeCodeSecondary,aSize);
                    //}
                    if (!bothHash.ContainsKey(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID))
                    {
                        bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                    }
                    // End TT#234     
                	else
					{
                        // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                        AddSizesNotInGroup(aSize.SizeKey, ref scp, ref sizeID, ref primarySL, ref secondaryAL, bothHash);
                        string newPrimaryBoth = scp.SizeCodePrimary + _dupSizeNameSeparator + scp.SizeCodeID;
                        if (!bothHash.ContainsKey(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID))
                        {
                            bothHash.Add(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID, aSize);
                        }
                        else
                        {
                            throw new MIDException(eErrorLevel.severe, 0, _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                        }
                    }   // End TT#234  
				}
			}

			if (_addingSizes)
			{
                UpdateColorSizeHash(ap.StyleHnRID, aColorCodeID, sizeID);
            }

			DataTable dtSizes = InitializeSizeTable(tableName, primarySL);
			BuildSizeTableFromArrays(ref dtSizes, false, scl, headerRID, Include.NoRID, colorRID, secondaryAL, bothHash, ref sizeTotal);
			return (dtSizes);
		}

		private DataTable FormatPackSizeTable(PackColorSize aColor, int sizeGroupRID, int headerRID, int packRID, int colorRID, string aColorCodeID, string tableName, ref int sizeTotal) 
		{
			System.Collections.ArrayList sizeID = new ArrayList();
            System.Collections.SortedList primarySL = new SortedList(); 
			System.Collections.ArrayList secondaryAL = new ArrayList(); 
			System.Collections.Hashtable bothHash = new Hashtable(); 
			SizeGroupProfile sgp = null;
	 		sizeTotal = 0;
			 
			AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(headerRID);		
			SizeCodeList scl = null;
			// is there a size group?
			if (sizeGroupRID > Include.UndefinedSizeGroupRID) 
			{
				// load existing group
				sgp = GetSizeGroup(sizeGroupRID);
				scl = sgp.SizeCodeList;
				 
				LoadSizeArraysFromGroup(scl, ref sizeID, ref primarySL, ref secondaryAL);

				if (aColor != null)
                {    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    foreach (PackContentBin aSize in aColor.ColorSizes.Values)
                    {
                        if (scl.Contains(aSize.ContentCodeRID))
                        {
                            SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(aSize.ContentCodeRID);
                            if (!bothHash.ContainsKey(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID))
                            {
                                bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                            }
                            else
                            {
                                throw new MIDException(eErrorLevel.severe, 0, _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                            }
                        }
                    }
                    // End TT#234  
					foreach(PackContentBin aSize in aColor.ColorSizes.Values) 
					{
						// make sure this size is in the group
						SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(aSize.ContentCodeRID);
                        if (scp == null)
                        {
                            if (!ap.MultiHeader && !ap.Placeholder)
                            {
                                scp = _SAB.HierarchyServerSession.GetSizeCodeProfile(aSize.ContentCodeRID);
                                if (scp.Key == Include.NoRID)
                                {
                                    throw new MIDException(eErrorLevel.severe, 0,
                                          string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeRetrieveError), aSize.ContentCodeRID.ToString(CultureInfo.CurrentUICulture)));
                                }
                                MessageBox.Show(string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeNotInGroup), scp.SizeCodeName, scp.SizeCodeID, sgp.SizeGroupName));
                                return null;
                            }
                            else
                            {
                                AddSizesNotInGroup(aSize.ContentCodeRID, ref scp, ref sizeID, ref primarySL, ref secondaryAL, bothHash);
                            }

                            // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                            //if (! bothHash.ContainsKey(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondary))
                            //{
                            //    bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondary,aSize);
                            //}
                            if (!bothHash.ContainsKey(scp.SizeCodePrimary  + "~" + scp.SizeCodeSecondaryRID))
                            {
                                bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                            }
                            // End TT#234  
                            else
                            {
                                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                string newPrimaryBoth = scp.SizeCodePrimary + _dupSizeNameSeparator + scp.SizeCodeID;
                                if (!bothHash.ContainsKey(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID))
                                {
                                    bothHash.Add(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID, aSize);
                                }
                                else
                                {
                                    throw new MIDException(eErrorLevel.severe, 0, _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                                }
                            }   // End TT#234  
                        }
					}
				}
			}
			else 
			{	// no size group
				SortedList sl = new SortedList();
				foreach(PackContentBin aSize in aColor.ColorSizes.Values) 
				{
					sl.Add(aSize.Sequence,aSize);
				} 
				 
				foreach(PackContentBin aSize in sl.Values)
				{
					SizeCodeProfile scp = _SAB.HierarchyServerSession.GetSizeCodeProfile(aSize.ContentCodeRID);
					if (scp.Key == Include.NoRID) 
					{
                        throw new MIDException(eErrorLevel.severe, 0,
                            string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeRetrieveError), aSize.ContentCodeRID.ToString(CultureInfo.CurrentUICulture)));
					}
					LoadSizeArraysFromHeader(aSize.ContentCodeRID, ref sizeID, ref primarySL, ref secondaryAL);

                    if (!bothHash.ContainsKey(scp.SizeCodePrimary  + "~" + scp.SizeCodeSecondaryRID))
                    {
                        bothHash.Add(scp.SizeCodePrimary + "~" + scp.SizeCodeSecondaryRID, aSize);
                    }
                    else
					{
                        // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                        string newPrimaryBoth = scp.SizeCodePrimary + _dupSizeNameSeparator + scp.SizeCodeID;
                        if (!bothHash.ContainsKey(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID))
                        {
                            bothHash.Add(newPrimaryBoth + "~" + scp.SizeCodeSecondaryRID, aSize);
                        }
                        else
                        {
                            throw new MIDException(eErrorLevel.severe, 0, _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LabelsNotUnique));
                        }
                        // End TT#234  
					}
				}
				//primaryAL.Sort();
			}

            if (_addingSizes)
            {
                UpdateColorSizeHash(ap.StyleHnRID, aColorCodeID, sizeID);
            }
			DataTable dtSizes = InitializeSizeTable(tableName, primarySL);
			BuildSizeTableFromArrays(ref dtSizes, true, scl, headerRID, packRID, colorRID, secondaryAL, bothHash, ref sizeTotal);
			return (dtSizes);
		}

        private void UpdateColorSizeHash(int aStyleHnRID, string aColorCodeID, ArrayList aSizeID)
        {
            try
            {
                ArrayList colorSizeAL;
                Hashtable styleColorHash;
                string addSizeID;
                for (int i = 0; i < aSizeID.Count; i++)
                {
                    addSizeID = Convert.ToString(aSizeID[i], CultureInfo.CurrentUICulture);
                    if (!_addedColorSizeHash.ContainsKey(aStyleHnRID))
                    {
                        styleColorHash = new Hashtable();
                        colorSizeAL = new ArrayList();
                        colorSizeAL.Add(addSizeID);
                        styleColorHash.Add(aColorCodeID, colorSizeAL);
                        _addedColorSizeHash.Add(aStyleHnRID, styleColorHash);
                    }
                    else
                    {
                        styleColorHash = (Hashtable)_addedColorSizeHash[aStyleHnRID];
                        if (!styleColorHash.ContainsKey(aColorCodeID))
                        {
                            colorSizeAL = new ArrayList();
                            colorSizeAL.Add(addSizeID);
                            styleColorHash.Add(aColorCodeID, colorSizeAL);
                        }
                        else
                        {
                            colorSizeAL = (ArrayList)styleColorHash[aColorCodeID];
                            if (!colorSizeAL.Contains(addSizeID))
                            {
                                colorSizeAL.Add(addSizeID);
                            }
                        }
                    }
                }
                _addingSizes = false;
            }
            catch
            {
                throw;
            }
        }

        private DataTable InitializeSizeTable(string aTableName, SortedList aPrimarySL)
		{
			try
			{
                //DataTable dtSizes = MIDEnvironment.CreateDataTable(aTableName);
                DataTable dtSizes = MIDEnvironment.CreateDataTable(aTableName);
				dtSizes.Columns.Add("KeyH",System.Type.GetType("System.Int32"));
				dtSizes.Columns.Add("KeyP",System.Type.GetType("System.Int32"));
				dtSizes.Columns.Add("KeyC",System.Type.GetType("System.Int32"));
                dtSizes.Columns.Add("SecondaryRID", System.Type.GetType("System.Int32"));   // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                dtSizes.Columns.Add("Secondary");
				dtSizes.Columns.Add(" - ");
				dtSizes.Columns.Add("TotalQuantity",System.Type.GetType("System.Int32"));
				
				foreach(int seq in aPrimarySL.Keys) 
				{
                    string[] sizeParts = aPrimarySL[seq].ToString().Split(new char[] { '~' });
                    string colName = sizeParts[0];
                    int primaryRID = Convert.ToInt32(sizeParts[1], CultureInfo.CurrentUICulture);
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    if (dtSizes.Columns.Contains(colName))
                    {
                        colName += _dupSizeNameSeparator + Convert.ToString(sizeParts[2], CultureInfo.CurrentUICulture);
                    }
                    // End TT#234  
                    dtSizes.Columns.Add(colName);
                    dtSizes.Columns[colName].DataType = System.Type.GetType("System.Int32");
                    dtSizes.Columns[colName].ExtendedProperties.Add("PrimaryRID", primaryRID);
				}
				return dtSizes;
 			}
			catch (Exception ex) 
			{
				HandleException(ex);
				return null;
			}
		}
		
		private void BuildSizeTableFromArrays(ref DataTable dtSizes, bool aPackSizes, SizeCodeList aSizeCodeList, int aHeaderRID, int aPackRID, int aColorRID, ArrayList aSecondaryAL, Hashtable aBothHash, ref int aSizeTotal)
		{
			try
			{
				foreach(string secondary in aSecondaryAL) 
				{
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    string[] secondaryParts = secondary.ToString().Split(new char[] { '~' });
                    string secondaryName = secondaryParts[0];
                    int secondaryRID = Convert.ToInt32(secondaryParts[1], CultureInfo.CurrentUICulture);
                    // End TT#234 
					int total = 0;
					DataRow dRow = dtSizes.NewRow();
					dRow["KeyH"] = aHeaderRID;
					dRow["KeyP"] = aPackRID;
					dRow["KeyC"] = aColorRID;
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    //dRow["Secondary"] = secondary;
                    dRow["SecondaryRID"] = secondaryRID;
                    dRow["Secondary"] = secondaryName;
                                       
                    //if (secondary == Include.NoSecondarySize || secondary.Trim() == string.Empty || secondary.Trim() == _noSizeDimensionLbl)
                    if (secondaryName == Include.NoSecondarySize || secondaryName.Trim() == string.Empty || secondaryName.Trim() == _noSizeDimensionLbl)
                    {
                        dRow[" - "] = _lblQuantity;
                    }
                    else
                    {
                        //dRow[" - "] = secondary;
                        dRow[" - "] = secondaryName;
                    }
                    // End TT#234  

					dRow["TotalQuantity"] = 0;

					for (int i = 7; i < dtSizes.Columns.Count; i++)
					{
						DataColumn dCol = dtSizes.Columns[i];
						string primary = dCol.ColumnName;
                        
						if (aBothHash.Contains(primary  + "~" + secondaryRID)) 
						{
							if (aPackSizes)
							{
								total += ((PackContentBin)aBothHash[primary  + "~" + secondaryRID]).ContentUnits;
								dRow[dCol] = ((PackContentBin)aBothHash[primary  + "~" + secondaryRID]).ContentUnits;
								dCol.ExtendedProperties.Add(primary  + "~" + secondaryRID , ((PackContentBin)aBothHash[primary  + "~" + secondaryRID]).ContentCodeRID);
							}
							else
							{
								total += ((HdrSizeBin)aBothHash[primary  + "~" + secondaryRID]).SizeUnitsToAllocate;
								dRow[dCol] = ((HdrSizeBin)aBothHash[primary  + "~" + secondaryRID]).SizeUnitsToAllocate;
								dCol.ExtendedProperties.Add(primary  + "~" + secondaryRID, ((HdrSizeBin)aBothHash[primary  + "~" + secondaryRID]).SizeKey);
							}
						}
						else
						{
							dRow[dCol] = 0;
							if (aSizeCodeList == null)
                            {   // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                //SizeGroup sizeData = new SizeGroup();
                                //DataTable dtGetSize = sizeData.GetSizeForPrimarySecondary(primary, secondary);
                                //if (dtGetSize != null && dtGetSize.Rows.Count > 0)
                                //{
                                //    DataRow row = dtGetSize.Rows[0];
                                //    dCol.ExtendedProperties.Add(primary+"~"+secondary,row["SIZE_CODE_RID"]);
                                //}
                                //else
                                //{
                                //    dtGetSize = sizeData.GetSizeForPrimarySecondary(primary, Include.NoSecondarySize);
                                //    if (dtGetSize != null && dtGetSize.Rows.Count > 0)
                                //    {
                                //        DataRow row = dtGetSize.Rows[0];
                                //        dCol.ExtendedProperties.Add(primary+"~"+secondary,row["SIZE_CODE_RID"]);
                                //    }
                                //}	
							}   // End #234
							else 
							{
								SizeCodeProfile scp = null;
								bool foundSize = false;
								for (int j = 0; j < aSizeCodeList.ArrayList.Count; j++)
								{
									scp  = (SizeCodeProfile)aSizeCodeList.ArrayList[j];
                                    //if (scp.SizeCodePrimary == primary && scp.SizeCodeSecondary == secondary) // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                    if (scp.SizeCodePrimary  == primary  && scp.SizeCodeSecondaryRID == secondaryRID)
									{
										dCol.ExtendedProperties.Add(primary  + "~" + secondaryRID,scp.Key);
										foundSize = true;
										break;
									}
								}
                                if (scp == null || !foundSize)
                                {   // Begin TT#558 - TMW - multi header is incorrect- additinal changes from Working 3.1 Fixes
                                    SizeGroup sizeData = new SizeGroup();
                                    DataTable dtGetSize = sizeData.GetSizeForPrimarySecondary(primary, secondaryName);
                                    if (dtGetSize != null && dtGetSize.Rows.Count > 0)
                                    {
                                        DataRow row = dtGetSize.Rows[0];
                                        dCol.ExtendedProperties.Add(primary + "~" + secondaryRID, row["SIZE_CODE_RID"]);
                                        foundSize = true;
                                    }
                                    else
                                    {
                                        dtGetSize = sizeData.GetSizeForPrimarySecondary(primary, Include.NoSecondarySize);
                                        if (dtGetSize != null && dtGetSize.Rows.Count > 0)
                                        {
                                            DataRow row = dtGetSize.Rows[0];
                                            dCol.ExtendedProperties.Add(primary + "~" + secondaryRID, row["SIZE_CODE_RID"]);
                                            foundSize = true;
                                        }
                                    }
                                    if (!foundSize)
                                    {
                                        dCol.ExtendedProperties.Add(primary + "~" + secondaryRID, Include.NoRID);
                                    }
                                }   // End TT#558  
							}
						}
					}
					dRow["TotalQuantity"] = total;
					aSizeTotal += total;
					dtSizes.Rows.Add(dRow);
				}
			}
			catch (Exception ex) 
			{
				HandleException(ex);
			}
		}
		private void LoadSizeArraysFromGroup(SizeCodeList aScl, ref ArrayList aSizeID, ref SortedList aPrimarySL, ref ArrayList aSecondaryAL)
		{
			try
			{
				foreach(SizeCodeProfile scp in aScl.ArrayList) 
				{
					if (scp.Key == Include.NoRID) 
					{
						throw new MIDException (eErrorLevel.severe,
							(int)eMIDTextCode.msg_CantRetrieveSizeCode,
							MIDText.GetText(eMIDTextCode.msg_CantRetrieveSizeCode));
					}
				 
					if (!aSizeID.Contains(scp.SizeCodeID))
					{
						aSizeID.Add(scp.SizeCodeID);		// SizeCodeID is used by the hierarachy QuickAdd
					}
                    if (!aPrimarySL.ContainsValue(scp.SizeCodePrimary + "~" + scp.SizeCodePrimaryRID))
					{
                        aPrimarySL.Add(scp.PrimarySequence, scp.SizeCodePrimary + "~" + scp.SizeCodePrimaryRID);
					}
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    //if (!aSecondaryAL.Contains(scp.SizeCodeSecondary))
                    //{
                    //    aSecondaryAL.Add(scp.SizeCodeSecondary);
                    //}
                    if (!aSecondaryAL.Contains(scp.SizeCodeSecondary + "~" + scp.SizeCodeSecondaryRID))
                    {
                        aSecondaryAL.Add(scp.SizeCodeSecondary + "~" + scp.SizeCodeSecondaryRID);
                    }
                }   // End TT#234  
			}
			catch (Exception ex) 
			{
				HandleException(ex);
			}
		}	

		private SizeGroupProfile GetSizeGroup(int aSizeGroupRID)
		{
			if (_sizeGroupHashLastKey != aSizeGroupRID)
			{
				_sizeGroupHashLastKey = aSizeGroupRID;
				if (_sizeGroupHash == null)
				{
					_sizeGroupHash = new Hashtable();
				}
				if (_sizeGroupHash.Contains(aSizeGroupRID))
				{
					_sizeGroupHashLastValue = (SizeGroupProfile)_sizeGroupHash[aSizeGroupRID];
				}
				else
				{
					_sizeGroupHashLastValue = new SizeGroupProfile(aSizeGroupRID);
					_sizeGroupHash.Add(aSizeGroupRID, _sizeGroupHashLastValue);
				}
			}
			return _sizeGroupHashLastValue;
		}
	
		private void AddSizesNotInGroup(int aSizeKey, ref SizeCodeProfile aScp, ref ArrayList aSizeID, ref SortedList aPrimarySL, ref ArrayList aSecondaryAL, Hashtable aBothHash)
		{
			try
			{
				aScp = _SAB.HierarchyServerSession.GetSizeCodeProfile(aSizeKey);
				if (aScp.Key == Include.NoRID) 
				{
                    throw new MIDException(eErrorLevel.severe, 0,
                            string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeRetrieveError), aSizeKey.ToString(CultureInfo.CurrentUICulture)));
				}
				if (!aSizeID.Contains(aScp.SizeCodeID))
				{
					aSizeID.Add(aScp.SizeCodeID);
				}
                
                // scp.PrimarySequnce is not valid here so increment the count
                int seq = aPrimarySL.Count;
                if (!aPrimarySL.ContainsValue(aScp.SizeCodePrimary + "~" + aScp.SizeCodePrimaryRID))
                {
                    seq++;
                    aPrimarySL.Add(seq, aScp.SizeCodePrimary + "~" + aScp.SizeCodePrimaryRID);
                }
                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                else if (aBothHash.Contains(aScp.SizeCodePrimary + "~" + aScp.SizeCodeSecondaryRID))
                {
                    if (!aPrimarySL.ContainsValue(aScp.SizeCodePrimary + "~" + aScp.SizeCodePrimaryRID + "~" + aScp.SizeCodeID))
                    {
                        seq++;
                        aPrimarySL.Add(seq, aScp.SizeCodePrimary + "~" + aScp.SizeCodePrimaryRID + "~" + aScp.SizeCodeID);
                    }
                }
                //if (!aSecondaryAL.Contains(aScp.SizeCodeSecondary))
                //{
                //    aSecondaryAL.Add(aScp.SizeCodeSecondary);
                //}
                if (!aSecondaryAL.Contains(aScp.SizeCodeSecondary + "~" + aScp.SizeCodeSecondaryRID))
                {
                    aSecondaryAL.Add(aScp.SizeCodeSecondary + "~" + aScp.SizeCodeSecondaryRID);
                }
                // End TT#234 
			}
			catch (Exception ex) 
			{
				HandleException(ex);
			}
		}
	
		private void LoadSizeArraysFromHeader(int aSizeKey, ref ArrayList aSizeID, ref SortedList aPrimarySL, ref ArrayList aSecondaryAL)
		{
			try
			{
				SizeCodeProfile scp = _SAB.HierarchyServerSession.GetSizeCodeProfile(aSizeKey);
				if (scp.Key == Include.NoRID) 
				{
                    throw new MIDException(eErrorLevel.severe, 0,
                            string.Format(MIDText.GetText(eMIDTextCode.msg_SizeCodeRetrieveError), aSizeKey.ToString(CultureInfo.CurrentUICulture)));
				}
				if (!aSizeID.Contains(scp.SizeCodeID))
				{
					aSizeID.Add(scp.SizeCodeID);
				}
                // scp.PrimarySequnce is not valid here so increment the count
                int seq = aPrimarySL.Count;
                if (!aPrimarySL.ContainsValue(scp.SizeCodePrimary + "~" + scp.SizeCodePrimaryRID))
				{
                    seq++;
                    aPrimarySL.Add(seq,scp.SizeCodePrimary + "~" + scp.SizeCodePrimaryRID);
				}
                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                //if (!aSecondaryAL.Contains(scp.SizeCodeSecondary))
                //{
                //    aSecondaryAL.Add(scp.SizeCodeSecondary);
                //}
                if (!aSecondaryAL.Contains(scp.SizeCodeSecondary + "~" + scp.SizeCodeSecondaryRID))
                {
                    aSecondaryAL.Add(scp.SizeCodeSecondary + "~" + scp.SizeCodeSecondaryRID);
                }
            }   // End TT#234  
			catch (Exception ex) 
			{
				HandleException(ex);
			}
		}

        private bool SaveAddedColorsSizes()
        {
            HierarchyMaintenance hierMaint = new HierarchyMaintenance(_SAB); 
            HierarchyNodeProfile hnpStyle;
            EditMsgs editMsg = new EditMsgs();
            ArrayList colorSizeAL;
            Hashtable styleColorHash;
            int sizeNodeRID = Include.NoRID;
            bool processOK = true;
            try
            {
                foreach (int styleRID in _addedColorSizeHash.Keys)
                {
                    hnpStyle = _SAB.HierarchyServerSession.GetNodeData(styleRID);
                    if(hnpStyle.Key > 0) 
			    	{
					    int colorNodeRID = Include.NoRID;
					   
                        styleColorHash = (Hashtable)_addedColorSizeHash[styleRID];
                        foreach (string colorCodeID in styleColorHash.Keys)
                        {    // add color to style if it somehow does not exist
                            if(!_SAB.HierarchyServerSession.ColorExistsForStyle(hnpStyle.HomeHierarchyRID, hnpStyle.Key, colorCodeID, ref colorNodeRID))
					        {
                                colorNodeRID = hierMaint.QuickAdd(ref editMsg, hnpStyle.Key, colorCodeID);
                                if (editMsg.ErrorFound) 
						        {
                                    DisplayMessages.Show(editMsg, _SAB, Include.MIDAllocationWorkspaceExplorer);
                                    processOK = false;
                                    break;
						        }
					        }
                            colorSizeAL = (ArrayList)styleColorHash[colorCodeID];
                            foreach (string sizeID in colorSizeAL)
                            {
                                sizeNodeRID = hierMaint.QuickAdd(ref editMsg, colorNodeRID, sizeID);
                                if (editMsg.ErrorFound)
                                {
                                    DisplayMessages.Show(editMsg, _SAB, Include.MIDAllocationWorkspaceExplorer);
                                    processOK = false;
                                    break;
                                }
                            }
                            if (!processOK)
                            {
                                break;
                            }
                        }
					}
                    if (!processOK)
                    {
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
            return processOK;
        }
 
		#endregion

        #region Validation Methods

        private bool PackNameEntered(UltraGridRow aRow)
        {
            if (_creatingMulti)
                return true;
            UltraGridCell cell = aRow.Cells["Pack"];
            string errorMessage = string.Empty;
            try
            {
                if (!RequiredFieldEntered(cell, ref errorMessage))
                {
                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return false;
                }
                else
                    return true;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private int GetAnchorNodeKey(string anchorID)
        {
            try
            {
                string errorMessage1 = string.Format
                    (MIDText.GetText(eMIDTextCode.msg_MustBeCorrectLevel),
                    _lblHierarchyNode);

                string errorMessage2 = string.Format
                    (MIDText.GetText(eMIDTextCode.msg_Data1NotValidData2),
                    anchorID, _lblHierarchyNode);

                if (anchorID.Trim() == string.Empty)
                {
                    MessageBox.Show(errorMessage1, _thisTitle);
                    return -1;
                }
                HierarchyNodeProfile anchorHnp = _SAB.HierarchyServerSession.GetNodeData(anchorID);
                if (anchorHnp.Key == -1)
                {
                    string errorMessage3 = errorMessage2 + Environment.NewLine + errorMessage1;
                    MessageBox.Show(errorMessage3, _thisTitle);
                    return -1;
                }

                if (anchorHnp.HomeHierarchyLevel >= _hlpStyle.Level)
                { 
                    string errorMessage3 = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_InvalideAnchorNodeLevel);
                    MessageBox.Show(errorMessage3, _thisTitle);
                    return -1;
                }
                return anchorHnp.Key;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return -1;
            }
        }

        private bool ValidAssortmentLink(UltraGridRow aRow, int aPhAnchorKey)
        {
            bool isValidLink = false;
            try
            {   //TODO must ancestorally link to assortment row anchor node 
                int asrtAnchorKey = Include.NoRID; 
                int asrtRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (row.Cells["AsrtRID"].Value != DBNull.Value
                     && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == asrtRID)
                    {
                        asrtAnchorKey = Convert.ToInt32(row.Cells["AnchorHnRID"].Value, CultureInfo.CurrentUICulture);
                        break;
                    }
                }
                HierarchyNodeProfile anchorHnp = _SAB.HierarchyServerSession.GetNodeData(aPhAnchorKey);
                NodeAncestorList nal = _SAB.HierarchyServerSession.GetNodeAncestorList(aPhAnchorKey, anchorHnp.HomeHierarchyRID);
                if (nal.Contains(asrtAnchorKey))
                {
                    isValidLink = true;
                }
                else
                {
                    string errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AsrtNodePhNodeNotLinked);
                    MessageBox.Show(errorMessage, _thisTitle);
                    isValidLink = false;
                }
            }
            catch  
            {
                throw;
            }
            return isValidLink;
        }

        private int GetProductIdKey(string productID)
        {
            try
            {
                string errorMessage1 = string.Format
                    (MIDText.GetText(eMIDTextCode.msg_MustBeCorrectLevel),
                    _hlpProduct.LevelID);

                string errorMessage2 = string.Format
                    (MIDText.GetText(eMIDTextCode.msg_Data1NotValidData2),
                    productID, _hlpProduct.LevelID);

                if (productID.Trim() == string.Empty)
                {
                    MessageBox.Show(errorMessage1, _thisTitle);
                    return -1;
                }
                HierarchyNodeProfile styleParentHnp = _SAB.HierarchyServerSession.GetNodeData(productID);
                if (styleParentHnp.Key == -1)
                {
                    string errorMessage3 = errorMessage2 + Environment.NewLine + errorMessage1;
                    MessageBox.Show(errorMessage3, _thisTitle);
                    return -1;
                }
              
                int styleParentHomeHierarchyRID = styleParentHnp.HomeHierarchyRID;
                HierarchyProfile hp = _SAB.HierarchyServerSession.GetHierarchyData(styleParentHomeHierarchyRID);

                HierarchyLevelProfile hlp = (HierarchyLevelProfile)hp.HierarchyLevels[styleParentHnp.HomeHierarchyLevel + 1];
                if (hlp.LevelType != eHierarchyLevelType.Style)
                {
                    string errorMessage3 = errorMessage2 + Environment.NewLine + errorMessage1;
                    MessageBox.Show(errorMessage3, _thisTitle);
                    return -1;
                }
                return styleParentHnp.Key;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return -1;
            }
        }

        private bool AllDataValid()
        {
            bool dataIsValid = true;
            EditMsgs editMessages = new EditMsgs();
            try
            {
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    ValidRow(row, ref editMessages);
                }
                if (editMessages.EditMessages.Count > 0)
                {
                    _errors = null;
                    for (int i = 0; i < editMessages.EditMessages.Count; i++)
                    {
                        EditMsgs.Message emm = (EditMsgs.Message)editMessages.EditMessages[i];
                        AddErrorMessage(emm);
                    }
                    EAB.Explorer.DisplayWorkspacePane();    // MID Track #5501 - add 'nag' message
                    MessageBox.Show(_errors, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    dataIsValid = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                dataIsValid = false;
            }
            return dataIsValid;
        }

        private bool ValidRow(UltraGridRow aRow, ref EditMsgs em)
        {
            bool dataIsValid;
            try
            {
                dataIsValid = ValidateSpecificFields(aRow, ref em);

                if (dataIsValid)
                {
                    if (aRow.HasChild())
                    {
                        UltraGridRow childRow = aRow.GetChild(ChildRow.First);
                        while (childRow != null)
                        {
                            dataIsValid = ValidRow(childRow, ref em);
                            if (!dataIsValid)
                            {
                                childRow.ExpandAncestors();
                                break;
                            }
                            childRow = childRow.GetSibling(SiblingRow.Next, true);
                        }
                    }
                }
                else
                {
                    aRow.ExpandAncestors();
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                dataIsValid = false;
            }
            return dataIsValid;
        }

        private bool ValidateSpecificFields(UltraGridRow aRow, ref EditMsgs em)
        {
            bool fieldsValid = true;
            string errorMessage = string.Empty;
            UltraGridCell gridCell;
            try
            {
                switch (aRow.Band.Key)
                {
                    case "Header":
                    //case "Placeholder":
                        gridCell = aRow.Cells["HeaderID"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        else if (!ValidHeaderID(gridCell, ref errorMessage, null))
                        {
                            fieldsValid = false;
                        }
                       
                        gridCell = aRow.Cells["Product"];
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["Style"];
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["Description"];
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["Multiple"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        else if (!ValidMultiple(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }

						// BEGIN TT#1401 - stodd - add VSW (IMO)
						gridCell = aRow.Cells["ImoId"];
						eHeaderType headerType = (eHeaderType)Convert.ToInt32(aRow.Cells["Type"].Value);
						if (!ValidImoId(gridCell, headerType, ref errorMessage))
						{
							fieldsValid = false;
						}
						// BEGIN TT#1401 - stodd - add VSW (IMO)

                        // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                        gridCell = aRow.Cells["UnitsPerCarton"];
                        if (gridCell.Text.ToString().Trim() == string.Empty)
                        {
                            _skipBeforeCellUpdate = true;
                            gridCell.Value = System.DBNull.Value;
                        }
                        // End TT#5047 - jsmith - Units Per Carton / Multiple Check
 
                        //if (!fieldsValid)
                        //{
                        //    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_ErrorsFoundReviewCorrect);
                        //    em.AddMsg(eMIDMessageLevel.Edit, errorMessage, this.ToString());
                        //}
                        break;
           
                    case "Pack":
                        gridCell = aRow.Cells["Pack"];
                        string packName = aRow.Cells["Pack"].Value.ToString();
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        else if (!ValidPackName(gridCell, packName, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["QuantityPerPack"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        break;
                    case "BulkColor":
                        gridCell = aRow.Cells["BulkColor"];
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        else if (!ValidBulkColor(gridCell, aRow.Cells["BulkColor"].Value.ToString(), ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["Description"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["Quantity"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        break;
                    case "PackColor":
                        gridCell = aRow.Cells["PackColor"];
                        errorMessage = string.Empty;
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        else if (!ValidPackColor(gridCell, aRow.Cells["PackColor"].Value.ToString(), ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        gridCell = aRow.Cells["QuantityPerPack"];
                        if (!RequiredFieldEntered(gridCell, ref errorMessage))
                        {
                            fieldsValid = false;
                        }
                        break;
                }
                // Begin TT#2035 - JSmith - Add color/size edit for VSW headers with packs
                if (aRow.Band.Key.StartsWith("PackSize"))
                {
                    if (Convert.ToInt32(aRow.ParentRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.IMO)
                    {
                        errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_ColorNotDefinedInPack);
                        gridCell = aRow.ParentRow.Cells["Pack"];
                        SetErrorImage(gridCell, true, ref errorMessage);
                        fieldsValid = false;
                    }
                }
                // End TT#2035 - JSmith - Add color/size edit for VSW headers with packs
                if (!fieldsValid)
                {
                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_ErrorsFoundReviewCorrect);
                    em.AddMsg(eMIDMessageLevel.Edit, errorMessage, this.ToString());
                }
                return fieldsValid;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

		private bool ValidImoId(UltraGridCell imoIdCell, eHeaderType headerType, ref string errMsg)
		{
			bool errorFound = false;
			string errorMessage = string.Empty;
			try
			{
				string imoId = imoIdCell.Text.Trim();
				string headerId = imoIdCell.Row.Cells["HeaderID"].ToString();

				if (imoId == "" || imoId == null)
				{
					if (headerType == eHeaderType.IMO)
					{
						errorFound = true;
						errorMessage = MIDText.GetText(eMIDTextCode.msg_al_IMOIdRequired);
						errorMessage = errorMessage.Replace("{0}", headerId);
						errorMessage = errorMessage + System.Environment.NewLine;
					}
				}
				else
				{
					if (headerType != eHeaderType.IMO)
					{
						errorMessage = MIDText.GetText(eMIDTextCode.msg_al_IMOIdWarning);
						errorMessage = errorMessage.Replace("{0}", headerId);
						errorMessage = errorMessage + System.Environment.NewLine;
					}
					else
					{
                        if (!StoreMgmt.DoesIMOExist(imoId)) //if (!_SAB.StoreServerSession.DoesIMOExist(imoId))
						{
							errorFound = true;

							errorMessage = MIDText.GetText(eMIDTextCode.msg_al_IMOIdNotFound);
							errorMessage = errorMessage.Replace("{0}", headerId);
							errorMessage = errorMessage + System.Environment.NewLine;
						}
					}
				}

				if (errorFound)
				{
					SetErrorImage(imoIdCell, errorFound, ref errorMessage);
					return false;
				}
				else
				{
					SetErrorImage(imoIdCell, errorFound, ref errorMessage);
					return true;
				}
			}
			catch (Exception ex)
			{
				HandleException(ex);
				return false;
			}
		}

        private bool RequiredFieldEntered(UltraGridCell gridCell, ref string errorMessage)
        {
            bool errorFound = false;
            try
            {
                if (gridCell.Text.Trim().Length == 0)
                {	// cell is empty
                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_FieldIsRequired);
                    errorFound = true;
                }
                if (errorFound)
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }
   
        private bool ValidHeaderID(UltraGridCell aGridCell, ref string errorMessage, string aNewValue)
        {
            bool errorFound = false;
            try
            {
                string headerID;
                if (aNewValue != null) 
                {
                    headerID = aNewValue.Trim();
                }
                else
                {
                    headerID = aGridCell.Row.Cells["HeaderID"].Value.ToString().Trim();
                }    
                int hdrRID = Convert.ToInt32(aGridCell.Row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                // begin MID Track 4024 Header ID cannot be used as file name because it contains invalid characters
                if (headerID != null
                    && headerID != string.Empty
                    && !MIDMath.ValidFileName(headerID))
                {
                    ugDetails.ActiveCell = aGridCell;
                    errorMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_HeaderNameInvalid), headerID, Include.HeaderNameExcludedCharacters);
                    errorFound = true;
                }
                else
                {
                    // end MID Track 4024 Header ID cannot be used as file name because it contains invalid characters
                    foreach (AllocationProfile app in _allocProfileList)
                    {   // BEGIN MID Track #6127 - ComponentOne Case Insensitve issue: prohibit duplicate name regardless of case
                        //if (app.HeaderID == headerID && app.Key != hdrRID)
                        if (app.HeaderID != null && app.HeaderID.ToUpper().Trim() == headerID.ToUpper() && app.Key != hdrRID)
                        // END MID Track #6127
                        {
                            ugDetails.ActiveCell = aGridCell;
                            errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicateHeaderIdNotAllowed);
                            errorFound = true;
                            break;
                        }
                    }
                    if (!errorFound)
                    {
                        Header hd = new Header();
                        // BEGIN MID Track #6127 - ComponentOne Case Insensitve issue: prohibit duplicate name regardless of case
                        //int rid = hd.GetHeaderRID(headerID);
                        //if (rid > 0 && rid != hdrRID)
                        if (hd.DuplicateHeaderExists(headerID, hdrRID))
                        // END MID Track #6127
                        {
                            ugDetails.ActiveCell = aGridCell;
                            errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicateHeaderIdNotAllowed);
                            errorFound = true;
                        }
                    }
                } 	
                if (errorFound)
                {
                    SetErrorImage(aGridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(aGridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }
 
        private void SetErrorImage(UltraGridCell gridCell, bool showError, ref string errorMessage)
        {
            if (showError)
            {
                gridCell.Appearance.Image = ErrorImage;
                gridCell.Tag = errorMessage;
            }
            else
            {
                gridCell.Appearance.Image = null;
                gridCell.Tag = null;
            }
        }

        private bool ValidCharDate(ref BeforeCellUpdateEventArgs e, ref string errorMessage)
        {
            bool errorFound = false;

            if (e.NewValue == System.DBNull.Value || e.Cell.ValueList != null)
            {
                SetErrorImage(e.Cell, errorFound, ref errorMessage);
                return !errorFound;
            }

            try
            {
                Convert.ToDateTime(e.NewValue);
            }
            catch (Exception)
            {
                errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DateValuesOnly);
                errorFound = true;
            }

            SetErrorImage(e.Cell, errorFound, ref errorMessage);
            return !errorFound;
        }

        private bool ValidCharNumber(ref BeforeCellUpdateEventArgs e, ref string errorMessage)
        {
            bool errorFound = false;

            if (e.NewValue == System.DBNull.Value || e.Cell.ValueList != null)
            {
                SetErrorImage(e.Cell, errorFound, ref errorMessage);
                return !errorFound;
            }

            try
            {
                Convert.ToDouble(e.NewValue);
            }
            catch (Exception)
            {
                errorFound = true;
                errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_NumericValuesOnly);
            }

            SetErrorImage(e.Cell, errorFound, ref errorMessage);
            return !errorFound;
        }

        private bool ValidStyle(UltraGridCell gridCell, string aStyleID, ref string errorMessage)
        {
            bool validStyle = true, errorFound = false;
            string styleID, productID;
            int productKey;
            try
            {
                styleID = aStyleID.Trim();
                HierarchyNodeProfile styleHnp = _SAB.HierarchyServerSession.GetNodeData(styleID);
				if (styleHnp.Key == -1) 
				{
                    // Begin TT#1324 - RMatelic - When adding a new Style, the description does not update.
                    //errorMessage = string.Format(_sab.ClientServerSession.Audit.GetText(eMIDTextCode.msg_LevelNotFoundAddQuestion),
                    //                             _hlpStyle.LevelID, styleID);
                    //DialogResult ret = MessageBox.Show(errorMessage, string.Empty, MessageBoxButtons.YesNo,
                    //                   MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);

                    errorMessage = string.Format(MIDText.GetTextOnly(eMIDTextCode.msg_LevelNotFoundAddQuestion),
                                                      _hlpStyle.LevelID, string.Empty);
                    NameDescriptionDialog descDialog = new NameDescriptionDialog(_thisTitle, errorMessage, _hlpStyle.LevelID, _lblDescription, styleID, styleID);
                    descDialog.StartPosition = FormStartPosition.CenterParent;
                    DialogResult ret = descDialog.ShowDialog();
                    //if (ret == DialogResult.No)
                    if (ret != DialogResult.Yes)
                    // End TT#1324
					{
						validStyle = false;
					}
                    else
                    {    
                        productID = gridCell.Row.Cells["Product"].Value.ToString();
                        productKey = 0;
                        if (productID == null || productID == string.Empty)
                        {
                            productKey = GetProductIdKey(productID); // this will force an error message
                        }
                        else if (gridCell.Row.Cells["ProductRID"].Value != System.DBNull.Value)
                        {
                            productKey = Convert.ToInt32(gridCell.Row.Cells["ProductRID"].Value, CultureInfo.CurrentUICulture);
                        }

                        if (productKey > 0)
                        {
                            EditMsgs em = new EditMsgs();
                            // BEGIN MID Track #5565 - add style error 
                            HierarchyMaintenance hm = new HierarchyMaintenance(_SAB);
                            // Begin TT#1324 - RMatelic - When adding a new Style, the description does not update.
                            //hm.QuickAdd(ref em, productKey, styleID);
                            // END MID Track #5565

                            hm.QuickAdd(ref em, productKey, styleID, descDialog.TextValue2);
                            // End TT#1324

                            if (em.ErrorFound)
                            {
                                DisplayMessages.Show(em, _SAB, Include.MIDAllocationWorkspaceExplorer);
                                validStyle = false;
                                errorFound = true;
                            }
                        }
                    }
                    descDialog.Dispose();   // TT#1324 - RMatelic - When adding a new Style, the description does not update.
                }
                else if (styleHnp.LevelType != eHierarchyLevelType.Style)
                {
                    errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_Data1NotValidData2),
                                                 styleID, _hlpStyle.LevelID);
                    MessageBox.Show(errorMessage, _thisTitle);
                    validStyle = false;
                    errorFound = true;
                }

                else if (Convert.ToInt32(gridCell.Row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                {
                    validStyle = ValidPlaceholderStyle(gridCell.Row, styleHnp.Key, ref errorMessage);
                    errorFound = !validStyle;
                }

                SetErrorImage(gridCell, errorFound, ref errorMessage);
                
                return validStyle;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }    

        private bool ValidPlaceholderStyle(UltraGridRow aRow, int aStyleHnRID, ref string errorMessage)
        {
            bool validStyle = true;
            try
            {
                int asrtRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                int phHdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (row.Cells["AsrtRID"].Value != DBNull.Value
                     && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == asrtRID
                     && Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder
                     && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != phHdrRID
                     && Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture) == aStyleHnRID)
                    {
                        errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_as_DupPhStylesNotAllowed),
                                                      _lblPlaceholder + " " + _hlpStyle.LevelID);
                        validStyle = false;
                        MessageBox.Show(errorMessage, _thisTitle);
                        break;
                    }
                }
            }
            catch 
            {
                throw;
            }
            return validStyle;
        }

        private bool ValidMultiple(UltraGridCell gridCell, ref string errorMessage)
        {
            bool errorFound = false;
            try
            {
                int multiple = Convert.ToInt32(gridCell.Value, CultureInfo.CurrentUICulture);
                if (multiple < 1)
                {
                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_MultipleCannotBeLessThan1);
                    errorFound = true;
                }
                if (errorFound)
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }
                // Begin TT#1652-MD - RMatelic - DC Carton Rounding
                else if (!ValidMultiple2(gridCell, ref errorMessage, multiple))    
                {
                    errorFound = true;
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }                                                              
                // End TT#1652-MD 
                else
                { 
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    // Begin TT#1652-MD - RMatelic - DC Carton Rounding
                    SetErrorImage(gridCell.Row.Cells["UnitsPerCarton"], errorFound, ref errorMessage);
                    // End TT#1652-MD 
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        // Begin TT#1652-MD - RMatelic - DC Carton Rounding
        private bool ValidMultiple2(UltraGridCell aCell, ref string errorMessage, int aMultiple)
        {
            bool isValid = true;
            try
            {
                UltraGridColumn unitsPerCartonColumn = aCell.Row.Band.Columns["UnitsPerCarton"];
                if (aCell.Row.GetCellValue(unitsPerCartonColumn) != DBNull.Value)
                {
                    int unitsPerCarton = Convert.ToInt32(aCell.Row.GetCellValue(unitsPerCartonColumn), CultureInfo.CurrentUICulture);
                    if (unitsPerCarton > 0)
                    {
                        if (aMultiple > 1)
                        {
                            bool errorFound = false;
                            if (unitsPerCarton < aMultiple)
                            {
                                errorFound = true;
                            }
                            else
                            {
                                int remainder = unitsPerCarton % aMultiple;
                                if (remainder > 0)
                                {
                                    errorFound = true;
                                }
                            }
                            if (errorFound)
                            {
                                isValid = false;
                                errorMessage = String.Format(MIDText.GetText(eMIDTextCode.msg_ValueMustEvenlyDivideInto),
                                              aCell.Row.Cells["Multiple"].Column.Header.Caption,
                                              aCell.Row.Cells["UnitsPerCarton"].Column.Header.Caption);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                isValid = false;
            }
            return isValid;
        }
        // End TT#1652-MD

        private bool ValidPackName(UltraGridCell gridCell, string aPackName, ref string errorMessage)
        {
            bool errorFound = false;
            try
            {
                UltraGridRow row = gridCell.Row.GetSibling(SiblingRow.First, false);
               
                while (row != null)
                {  
                    // BEGIN MID Track #6127 - ComponentOne Case Insensitve issue: prohibit duplicate name regardless of case
                    //if (row != gridCell.Row &&
                    //     Convert.ToString(row.Cells["Pack"].Value, CultureInfo.CurrentUICulture) == aPackName)
                    string packName = Convert.ToString(row.Cells["Pack"].Value, CultureInfo.CurrentUICulture);
                    // BEGIN MID Track #6164 - allow duplicate pack name on Multi since ID gets changed
                    if (row != gridCell.Row && packName.ToUpper().Trim() == aPackName.ToUpper().Trim())
                    //if ( !_creatingMulti && row != gridCell.Row && packName.ToUpper().Trim() == aPackName.ToUpper().Trim())
                    // END MID Track #6164
                    // END MID Track #6127
                    {
                        errorFound = true;
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next, false);
                }
                if (errorFound)
                {
                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicatePackNameNotAllowed);
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool ValidBulkColor(UltraGridCell gridCell, string aColorName, ref string errorMessage)
        {
            bool errorFound = false;
            try
            {
                UltraGridRow row = gridCell.Row.GetSibling(SiblingRow.First, false);
                while (row != null)
                {
                    // BEGIN MID Track #6127 - ComponentOne Case Insensitve issue: prohibit duplicate name regardless of case
                    string bulkColor = Convert.ToString(row.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture);
                    //if (row != gridCell.Row &&
                    //     Convert.ToString(row.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture) == aColorName)
                    if (row != gridCell.Row && bulkColor.ToUpper().Trim() == aColorName.ToUpper().Trim())
                    // END MID Track #6127
                    {
                        errorFound = true;
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next, false);
                }
                if (errorFound)
                {
                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_DuplicateBulkColorNotAllowed);
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool ValidPackColor(UltraGridCell gridCell, string aPackColor, ref string errorMessage)
        {
            bool errorFound = false;
            try
            {
                UltraGridRow row = gridCell.Row.GetSibling(SiblingRow.First, false);
                while (row != null)
                {
                    // BEGIN MID Track #6127 - ComponentOne Case Insensitve issue: prohibit duplicate name regardless of case
                    //if (row != gridCell.Row &&
                    //    Convert.ToString(row.Cells["PackColor"].Value, CultureInfo.CurrentUICulture) == aPackColor)
                    string packColor = Convert.ToString(row.Cells["PackColor"].Value, CultureInfo.CurrentUICulture);
                    if (row != gridCell.Row && packColor.ToUpper().Trim() == aPackColor.ToUpper().Trim())
                    // END MID Track #6127
                    {
                        errorFound = true;
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next,false);
                }
                if (errorFound)
                {
                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_DuplicateColorInPackNotAllowed);
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return false;
                }
                else
                {
                    SetErrorImage(gridCell, errorFound, ref errorMessage);
                    return true;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private string AddErrorMessage(EditMsgs.Message emm)
        {
            string error = null;
            try
            {
                if (emm.code != 0)
                {
                    error = _SAB.ClientServerSession.Audit.GetText(emm.code);
                }
                else
                {
                    error = emm.msg;
                }
                _errors += Environment.NewLine + "     " + error;
                return error;
            }
            catch (Exception exception)
            {
                HandleException(exception);
                error = exception.Message;
                return error;
            }
        }

        // Begin TT#1652-MD - RMatelic - DC Carton Rounding - this method is not currently executed 
        private bool ValidDistCenter(UltraGridCell aCell, ref string errorMessage, string aDistCenter)
        {
            bool isValid = true;
            try
            {
                UltraGridColumn unitsPerCartonColumn = aCell.Row.Band.Columns["UnitsPerCarton"];
                if (aCell.Row.GetCellValue(unitsPerCartonColumn) != DBNull.Value)
                {
                    int unitsPerCarton = Convert.ToInt32(aCell.Row.GetCellValue(unitsPerCartonColumn), CultureInfo.CurrentUICulture);
                    if (unitsPerCarton > 0)
                    {
                        int dcCartonRoundSGRid = _SAB.ClientServerSession.GlobalOptions.DCCartonRoundingSGRid;
                        if (dcCartonRoundSGRid != Include.NoRID)
                        {
                            bool foundDC = false;
                            //ProfileList sgll = _SAB.StoreServerSession.GetStoreGroupLevelListViewList(dcCartonRoundSGRid, false);
                            ProfileList sgll = StoreMgmt.StoreGroup_GetLevelListViewList(dcCartonRoundSGRid, false);  // TT#1386-MD - stodd - manual merge
                            foreach (StoreGroupLevelListViewProfile strGrpLvlProf in sgll)
                            {
                                if (strGrpLvlProf.Name == aDistCenter)
                                {
                                    foundDC = true;
                                    break;
                                }
                            }
                            if (!foundDC)
                            {
                                isValid = false;
                                // if this edit is ever implemented, the following text needs to be added as soft text enum
                                errorMessage = "DC is not an attribute set of the global option DC Carton Rounding Attribute.";
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                isValid = false;
            }
            return isValid;
        }

        private bool ValidUnitsPerCarton(UltraGridCell aCell, ref string errorMessage, int aUnitsPerCarton)
        {
            bool isValid = true;
            try
            {
                UltraGridColumn multipleColumn = aCell.Row.Band.Columns["Multiple"];
                if (aCell.Row.GetCellValue(multipleColumn) != DBNull.Value)
                {
                    int multiple = Convert.ToInt32(aCell.Row.GetCellValue(multipleColumn), CultureInfo.CurrentUICulture);
                    if (multiple > 1)
                    {
                        bool errorFound = false;
                        if (aUnitsPerCarton < multiple)
                        {
                            errorFound = true;
                        }
                        else
                        {
                            int remainder = aUnitsPerCarton % multiple;
                            if (remainder > 0)
                            {
                                errorFound = true;
                            }
                        }
                        if (errorFound)
                        {
                            isValid = false;
                            errorMessage = String.Format(MIDText.GetText(eMIDTextCode.msg_al_MultipleValueIncorrect),
                                          aCell.Row.Cells["UnitsPerCarton"].Column.Header.Caption,
                                          aCell.Row.Cells["Multiple"].Column.Header.Caption);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                isValid = false;
            }
            return isValid;
        }
        // End TT#1652-MD
        #endregion

        #region Public Methods for External Access
        public int GetSelectedHeaders() 
		{
			return this.ugHeaders.Selected.Rows.Count;
		}
        //Begin TT#739-MD -jsobek -Delete Stores -Allocation & Forecast Analysis
        public List<int> GetSelectedHeaderRIDs() 
		{
            List<int> headerRidList = new List<int>();

			foreach(UltraGridRow ur in this.ugHeaders.Selected.Rows)
            {
                if (ur.ListObject != null)
                {
                   DataRow dr = ((DataRowView)ur.ListObject).Row;
                   if (dr.Table.Columns.Contains("KeyH") == true)
                   {
                       headerRidList.Add((int)dr["KeyH"]);
                   }
                }
            }

            return headerRidList;
		}
        //End TT#739-MD -jsobek -Delete Stores -Allocation & Forecast Analysis
      

        // BEGIN MID Track #6336 - KJohnson - Header Load API Enhancement
        public string setGeneratedWorkflowName(string aHeaderID, string workflowName)
        {
            try
            {
                if ((workflowName != null) && (workflowName == aHeaderID + "(generated)"))
                {
                    return "\"Generated\"";
                }
                else
                {
                    return workflowName;
                }
            }
            catch
            {
                return workflowName;
            }
        }
        // END MID Track #6336

		public bool IsHeaderUpdateable (int aKey)
		{
			try
			{
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                //DataRow dRow = _dsDetails.Tables["Header"].Rows.Find(aKey);
                DataRow dRow;
                if (_detailsShown)
                {
                    dRow = _dsDetails.Tables["Header"].Rows.Find(aKey);
                }
                else
                {
                    dRow = _dtHeader.Rows.Find(aKey);
                }
				
				if (dRow != null)
				{
					eSecurityType styleSecurity = (eSecurityType)Convert.ToInt32(dRow["StyleSecurity"], CultureInfo.CurrentUICulture);
					if (styleSecurity == eSecurityType.Update)
					{
						return true;
					}
					else
					{
						return false;
					}
				}
				else
				{
					return false;
				}
			}
			catch
			{
				throw;
			}
		}

        // Begin TT#1705 - JSmith - Reset Header with Piggybacking
        public void OnHeaderChange(object source, HeaderChangeEventArgs e)
        {
            try
            {
                if (e.ChangeType == eChangeType.none)
                {
                    // set flag to indicate events are updating the grid
                    _refreshingGrid = true;
                    _deletedHeaderRows.Clear();
                }
                else if (e.ChangeType == eChangeType.update)
                {
                    ReloadProfileToGrid(e.HeaderRID);
                }
                else if (e.ChangeType == eChangeType.delete)
                {
                    // find grid row for deleted header
                    // Begin TT#2273 - JSmith - Error when Reseting Original Piggybacked Header
                    //foreach (UltraGridRow row in ugHeaders.Rows)
                    //{
                    //    if (row.Cells["KeyH"].Value != DBNull.Value
                    //     && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == e.HeaderRID)
                    //    {
                    //        _deletedHeaderRows.Add(e.HeaderRID, row);
                    //        break;
                    //    }
                    //}
                    UltraGridRow row = FindHeaderRow(ugHeaders.GetRow(ChildRow.First), e.HeaderRID);
                    if (row != null)
                    {
                        _deletedHeaderRows.Add(e.HeaderRID, row);
                    }
                    // End TT#2273
                }
                else if (e.ChangeType == eChangeType.populate)
                {
                    if (_deletedHeaderRows.Count > 0)
                    {
                        this.RebuildHeaderCharacteristicData(); //TT#1170-MD -jsobek -Remove Binary database objects and normalize the Filter definitions

                        //RemoveExcludedHeaders(); //TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS
                        _excludedHeadersRemoved = true;
                        foreach (int headerRID in _deletedHeaderRows.Keys)
                        {
                            // delete header row from ugHeaders grid
                            UltraGridRow hRow = (UltraGridRow)_deletedHeaderRows[headerRID];
                            if (hRow != null)
                            {
                                hRow.Delete(false);
                            }
                        }
                        ResetGrids();
                    }
                    _deletedHeaderRows.Clear();
                    _refreshingGrid = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
                _refreshingGrid = false;
            }
        }
        // End TT#1705
        
		
        public bool HeaderIsOnWorkspace(int aKey)
        {
            try
            {
                DataRow dtHeaderRow = this._dtHeader.Rows.Find(aKey);
                if (dtHeaderRow == null)
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }
            catch
            {
                throw;
            }
        }


		public void ReloadUpdatedHeaders(int[] aHdrList) 
		{
			int key;
            int asrtRID;    // TT#2 - RMatelic - Assortment Planning 
            ArrayList asrtAL = new ArrayList();
            bool reapplyFilter = false;   // TT#1966-MD - JSmith - DC Fulfillment
			try 
			{
                Header headerData = new Header();   
				for (int i = 0; i < aHdrList.Length; i++) 
				{
					key = aHdrList[i];
                    // Begin TT#2 - Assortment Planning - updated header may not be in the workspace
                    //ReloadProfileToGrid(key);
                    // begin TT#19 - Intransit status incorrect on 2nd header of a multi after Releasing multi
                    asrtRID = Include.NoRID;
                    DataRow dtHeaderRow = this._dtHeader.Rows.Find(key);
                    if (dtHeaderRow == null)
                    {
                        DataTable dt = headerData.GetHeader(key);
                        if (dt != null && dt.Rows.Count > 0)
                        {
                            DataRow dtRow = dt.Rows[0];
                            asrtRID = Convert.ToInt32(dtRow["ASRT_RID"], CultureInfo.CurrentUICulture);
                            // Begin TT#1966-MD - JSmith - DC Fulfillment
                            if (asrtRID == Include.NoRID)
                            {
                                reapplyFilter = true;
                            }
                            // End TT#1966-MD - JSmith - DC Fulfillment
                        }
                    }
                    else
                    {
                        //BEGIN MID Track #6394 - Update Header Characteristic comment out for now
                        _customWindowsRoutines.CheckCustomCharacteristic(dtHeaderRow);
						//END MID Track #6394
                        // Begin TT#5550 - JSmith - Custom API Upload - Asst Name Not Removed in Wrkspc When Canceled
                        if (_dsDetails != null)
                        {
                            DataRow dr = _dsDetails.Tables["Header"].Rows.Find(key);
                            if (dr != null)
                            {
                                _customWindowsRoutines.CheckCustomCharacteristic(dr);
                            }
                        }
                        // End TT#5550 - JSmith - Custom API Upload - Asst Name Not Removed in Wrkspc When Canceled
                        //END MID Track #6394
                        // Begin TT#5697 - JSmith - Subordinate header release fails in Style Review
                        //ReloadProfileToGrid(key);
                        if (ReloadProfileToGrid(key))
                        {
                        // End TT#5697 - JSmith - Subordinate header release fails in Style Review
                            // End TT#2
                            if (((eHeaderType)Convert.ToInt32(dtHeaderRow["Type"], CultureInfo.CurrentUICulture) == eHeaderType.MultiHeader))
                            {
                                Header hd = new Header();
                                DataTable dtChildren = hd.GetHeaderGroupChildren(key);
                                foreach (DataRow drChild in dtChildren.Rows)
                                {
                                    int childRID = Convert.ToInt32(drChild["HDR_RID"], CultureInfo.CurrentUICulture);
                                    //BEGIN MID Track #6394 - Update Header Characteristic comment out for now
                                    _customWindowsRoutines.CheckCustomCharacteristic(drChild);
                                    //END MID Track #6394
                                    ReloadProfileToGrid(childRID);
                                }
                            }
                            // end TT#19 - Intransit status incorrect on 2nd header of a multi after Releasing multi
                            // Begin TT#2 - Assortment Planning - updated header may not be in the workspace
                            if (dtHeaderRow["AsrtRID"] != DBNull.Value)
                            {
                                asrtRID = Convert.ToInt32(dtHeaderRow["AsrtRID"], CultureInfo.CurrentUICulture);
                            }
                        // Begin TT#5697 - JSmith - Subordinate header release fails in Style Review
                        }
                        else
                        {
                            reapplyFilter = true;
                        }
                        // End TT#5697 - JSmith - Subordinate header release fails in Style Review
                    }  
                    if (asrtRID != Include.NoRID && !asrtAL.Contains(asrtRID))
                    {
                        asrtAL.Add(asrtRID);
                    }    
                }
                if (asrtAL.Count > 0)
                {
                    foreach (int aRID in asrtAL)
                    {
                        CheckForOpenAssortmentView(aRID);
                    }
                }    
                // Begin TT#1966-MD - JSmith - DC Fulfillment
                if (reapplyFilter)
                {
                    LoadHeadersOnGrid();
                }
                // End TT#1966-MD - JSmith - DC Fulfillment
			}
			catch( Exception ex) 
			{
				HandleException(ex);
			}
			// Begin TT#1470-MD - stodd - Able to cancel an allocated a header attached to an assortment when the assortment is not open. 
            finally
            {
                SetActionListCombo();
            }
			// End TT#1470-MD - stodd - Able to cancel an allocated a header attached to an assortment when the assortment is not open. 
        }

        private void CheckForOpenAssortmentView(int aAsrtRID)
        {
            try
            {
                //MIDRetail.Windows.AssortmentView frmAssortmentView = (MIDRetail.Windows.AssortmentView)_SAB.ApplicationServerSession.GetOpenAsrtView(aAsrtRID);      // TT#918 - Group Allocation errors prevent action (Invalid cast when trying to re-populate Workspace)
                MIDRetail.Windows.AssortmentView frmAssortmentView = _SAB.ApplicationServerSession.GetOpenAsrtView(aAsrtRID) as MIDRetail.Windows.AssortmentView; ;    // TT#918 - Group Allocation errors prevent action (Invalid cast when trying to re-populate Workspace)

                if (frmAssortmentView != null)
                {
					// Begin TT#795-MD - stodd - Build Packs not working on a Placeholder in an assortment.
					// Rebuilds Matrixs Grid
                    frmAssortmentView.UpdateData(true);
					// Rebuilds the Content and Product Char Grids
                    frmAssortmentView.BuildDetailsGrid = true;
                    frmAssortmentView.BuildProductCharsGrid = true;
                    frmAssortmentView.LoadProductCharGrid();
                    frmAssortmentView.LoadSurroundingPages();
					// End TT#795-MD - stodd - Build Packs not working on a Placeholder in an assortment.
					// Begin TT#1472-MD - stodd - Assortment Matrix not recognizing entered values as a pending change.
                    // If we're here, the data in the assortment/group allocation has been saved through another process.
                    // if the screen had pending changes, those changes have been resolved.
                    frmAssortmentView.ChangePending = false;
					// End TT#1472-MD - stodd - Assortment Matrix not recognizing entered values as a pending change.
                }
            }
            catch
            {
                throw;
            }
        }
        // Begin TT#2 - RMatelic - Assortment Planning  
		// Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
        public void UpdateAssortmentID(int aAsrtRID, string aNewID, int asrtType)
        {
            try
            {
                 //ReloadProfileToGrid(aAsrtRID);
                 DataRow dRow = _assortments.Rows.Find(aAsrtRID);
                 if (dRow != null)
                 {
                     dRow["AssortmentID"] = aNewID;
                 }
                 else
                 {
                     _assortments.Rows.Add(new object[] { aAsrtRID, aNewID, asrtType });
                 }
                 _assortments.AcceptChanges();

                RebuildAssortmentValueLists();

                 //_assortmentValueList.ValueListItems.Clear();
                 //foreach (DataRow dr in _assortments.Rows)
                 //{
                 //    _assortmentValueList.ValueListItems.Add(Convert.ToInt32(dr["AsrtRID"], CultureInfo.CurrentUICulture), dr["AssortmentID"].ToString());
                 //    //_assortmentValueList.ValueListItems.Add(Convert.ToInt32(dr["GroupAllocRID"], CultureInfo.CurrentUICulture), dr["AssortmentID"].ToString());  // TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                 //}

            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
		// ENd TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
        // End TT#2 
        #endregion

       	#region METHODS TO START LISTENING
        // Begin TT#1914-MD - JSmith - Header Characteristics upon creation in 8.6 SVC the user must close and open the app for it to appear in the column chooser and alloc workspace.
        public void startListening(HeaderCharacteristics frm)
        {
            frm.OnSavedHandler += new HeaderCharacteristics.HeaderMaintSaved(frm_OnSavedHandler);
            //frm.OnNewColumnHandler += new HeaderCharacteristicMaint.HeaderMaintNewColumn(frm_OnNewColumnHandler);
        }

        public void stopListening(HeaderCharacteristics frm)
        {
            frm.OnSavedHandler -= new HeaderCharacteristics.HeaderMaintSaved(frm_OnSavedHandler);
            //frm.OnNewColumnHandler -= new HeaderCharacteristicMaint.HeaderMaintNewColumn(frm_OnNewColumnHandler);
        }

        private void frm_OnSavedHandler()
        {
            RebuildHeaderCharacteristicData();
            IRefresh();
            _headerCharGroupProfileList = _SAB.HeaderServerSession.GetHeaderCharGroups();
            BuildCharacteristicValueLists();
            AssignCharacterisicValueLists(ugHeaders);
        }

        // End TT#1914-MD - JSmith - Header Characteristics upon creation in 8.6 SVC the user must close and open the app for it to appear in the column chooser and alloc workspace.
        //public void startListening(HeaderCharacteristicMaint frm) 
        //{
        //    frm.OnSavedHandler += new HeaderCharacteristicMaint.HeaderMaintSaved(frm_OnSavedHandler);
        //    // BEGIN MID Track #5743 - KJohnson - Allow creation of PO field in header charac, when already defined.
        //    frm.OnNewColumnHandler += new HeaderCharacteristicMaint.HeaderMaintNewColumn(frm_OnNewColumnHandler);
        //    // END MID Track #5743 - KJohnson
        //}

        //public void stopListening(HeaderCharacteristicMaint frm) 
        //{
        //    frm.OnSavedHandler -= new HeaderCharacteristicMaint.HeaderMaintSaved(frm_OnSavedHandler);
        //    // BEGIN MID Track #5743 - KJohnson - Allow creation of PO field in header charac, when already defined.
        //    frm.OnNewColumnHandler -= new HeaderCharacteristicMaint.HeaderMaintNewColumn(frm_OnNewColumnHandler);
        //    // END MID Track #5743 - KJohnson
        //}

        //private void frm_OnSavedHandler() 
        //{
        //    // Begin TT#1406-MD - RMatelic - Header characteristic columns in the allocation workspace do not refresh
        //    RebuildHeaderCharacteristicData(); 
        //    // End TT#1406-MD
        //    IRefresh();     // TT#78 -Ron Matelic - Header Characteristic delete issue 
        //    // Begin TT#2726 - JSmith - Header Characteristic showing HC_RID instead of text in Header
        //    _headerCharGroupProfileList = _SAB.HeaderServerSession.GetHeaderCharGroups();
        //    BuildCharacteristicValueLists();
        //    AssignCharacterisicValueLists(ugHeaders);
        //    // End TT#2726 - JSmith - Header Characteristic showing HC_RID instead of text in Header
        //}

        // BEGIN MID Track #5743 - KJohnson - Allow creation of PO field in header charac, when already defined.
        //private bool frm_OnNewColumnHandler(string columnName)
        //{
        //    bool foundMatch = false;
        //    if (_dtHeader.Columns.Count > 0)
        //    {
        //        foreach (System.Data.DataColumn col in _dtHeader.Columns)
        //        {
        //            if (col.ColumnName.Trim().ToUpper() == columnName.Trim().ToUpper())
        //            {
        //                foundMatch = true;
        //                break;
        //            }
        //        }
        //    }
        //    return foundMatch;
        //}
        // END MID Track #5743 - KJohnson
		#endregion

		#region Button events and methods
	
        // Begin TT#1966-MD - JSmith - DC Fulfillment
        //private void SaveChanges()
        private void SaveChanges(ref bool bMasterHeaderDeleted)
        // End TT#1966-MD - JSmith - DC Fulfillment
		{
            int hdrRID;
            UltraGridRow headersHdrRow; // the header row in the top grid 
            try
            {
                if (ugDetails.ActiveRow != null && ugDetails.ActiveRow.DataChanged)
                {
                    _skipBeforeCellUpdate = false;  // TT#5309 - JSmith - Change not applied
                    ugDetails.ActiveRow.Update();
                }

                _dsDetails.AcceptChanges();
         
                // check to save any added colors and sizes
                if (_addedColorSizeHash.Count > 0)
                {
                    SaveAddedColorsSizes();
                }

                // need to first update any headers with components that were removed from Assortments
                // to avoid referential integrity errors in the subsequent loop
                if (_removedAsrtHeaders.Count > 0)
                {
                    foreach (int hRID in _removedAsrtHeaders)
                    {
                        WriteHeader(hRID, null);
                    }
                }  
  
                foreach (UltraGridRow dRow in ugDetails.Rows)
                {
                    UltraGridRow row = dRow;
                    hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                 
                    if (!_removedAsrtHeaders.Contains(hdrRID))  // not already updated in prior loop
                    {
                        // BEGIN MID Track #5654, #5655 - MultiHeader issues
                        //WriteHeader(hdrRID);
                        DetermineHeaderWrite(row);
                        // END MID Track #5654, #5655
                    }
                    if (Convert.ToBoolean(row.Cells["CharUpdated"].Value, CultureInfo.CurrentUICulture))
                    {
                        UpdateHeaderCharacteristics(row);
                    }

                    if (row.Cells["HeaderRow"].Value != System.DBNull.Value)
                    {
                        headersHdrRow = (UltraGridRow)row.Cells["HeaderRow"].Value;
                        if (headersHdrRow.Cells.Count == 0)
                        {
                            IEnumerable enumerator = ugHeaders.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
                            foreach (UltraGridRow hRow in enumerator)
                            {
                                if (Convert.ToInt32(hRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == hdrRID)
                                {
                                    headersHdrRow = hRow;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {   // added new header
                        headersHdrRow = AddNewRowToHeadersGrid();
                        _selectedRowsSequence.Add(headersHdrRow);    // TT#620 - RMatelic - Base 3.1 -> Created multi - select SAVE button -> get system argument exception error
                    }
                 
                    for (int i = 0; i < headersHdrRow.Cells.Count; i++)
                    {  
                        // BEGIN MID Track #5654, #5655, #5657 - MultiHeader errors 
                        //headersHdrRow.Cells[i].Value = row.Cells[i].Value;
                        if (row.Cells[i].Column.Key == "Balance")
                        {
                            if (row.Cells[i].Value != System.DBNull.Value && Convert.ToInt32(row.Cells[i].Value, CultureInfo.CurrentUICulture) == 0)
                            {
                                headersHdrRow.Cells[i].Value = System.DBNull.Value;
                            }
                            else
                            {
                                headersHdrRow.Cells[i].Value = row.Cells[i].Value;
                            }
                        }
                        else
                        {
                            headersHdrRow.Cells[i].Value = row.Cells[i].Value;
                        }
                    }   // END MID Track #5654, #5655, #5657  

                    headersHdrRow.Update();
                    //row.Cells["HeaderRow"].Value = headersHdrRow;
                    //row.Update();

                    string notes = Convert.ToString(headersHdrRow.Cells["Notes"].Value, CultureInfo.CurrentUICulture);
                    if (notes != null && notes.Trim() != string.Empty)
                    {
                        headersHdrRow.Cells["HeaderID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                        headersHdrRow.Cells["HeaderID"].ButtonAppearance.Image = NotesImage;
                    }

                    else
                    {   // change the cell style so the edit button doesn't show
                        headersHdrRow.Cells["HeaderID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.Edit;
                    }
                    
                    headersHdrRow.RefreshSortPosition();
                    SetHeaderRowInfo(headersHdrRow);
                    dRow.Cells["HeaderRow"].Value = headersHdrRow;
                    dRow.Update(); 
                }
               
                if (_deletedHeaderRows.Count > 0)
                {
                    // Begin TT#1966-MD - JSmith - DC Fulfillment
                    //DeleteHeaders();
                    DeleteHeaders(ref bMasterHeaderDeleted);
                    // End TT#1966-MD - JSmith - DC Fulfillment
                }
                
                CheckForPlaceholderStyleDelete(true);
                UpdateAnchorNodes();

                if (_headersRemovedFromMulti.Count > 0 && _multiHeaderGroups.Count > 0)
                {
                    foreach (int removedRID in _headersRemovedFromMulti.Keys)
                    {
                        int groupRID = (int)_headersRemovedFromMulti[removedRID];
                        if (_multiHeaderGroups.ContainsKey(groupRID))
                        {
                            Hashtable multiHeaderListHash = (Hashtable)_multiHeaderGroups[groupRID];
                            if (multiHeaderListHash.ContainsKey(removedRID))
                            {
                                multiHeaderListHash.Remove(removedRID);
                            }
                        }
                    }
                    _headersRemovedFromMulti.Clear();
                    ReloadDetailGridData();     // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary); unrelated to error 
                }
                if (_groupByReload)     // work around for Infragistic's inability to add new row to group by  
                {
                    _groupByReload = false;

                    InfragisticsLayoutData layoutData = new InfragisticsLayoutData();
                    layoutData.InfragisticsLayout_Save(_SAB.ClientServerSession.UserRID, eLayoutID.allocationWorkspaceGrid, _layoutStream);
                    // Begin TT#620 - RMatelic - Base 3.1 -> Created multi - select SAVE button -> get system argument exception error
                    //ugHeaders.DataSource = null;
                    //ugHeaders.DataSource = _bindSourceHeader;
                    SaveSelectedHeadersAndRebindGrid();
                    // End TT#620
                }
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                //_dsDetailsSaved = null;
                ClearSavedDetails();
                // End TT#1434
                _dsDetailsSaved = _dsDetails.Copy();

                _headersAddedToMulti.Clear();
            }
            catch (Exception ex)
            {
                HandleException(ex);
            } 
		}
        // BEGIN MID Track #5654, 5655 - MultiHeader issues
        private void DetermineHeaderWrite(UltraGridRow aRow)
        {
            try
            {
                AllocationProfile multiHeaderProfile = null, multiHeaderMemberProfile;
                int hdrRID, headerType, headerStatus, groupRID;
                string headerID;
                // Begin TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header
                //bool success;
                bool success = true;
                string errorMessage;
                // End TT#687

                AllocationProfileList multiMemberAddedProfiles = new AllocationProfileList(eProfileType.Allocation);
                AllocationProfileList multiMemberRemovedProfiles = new AllocationProfileList(eProfileType.Allocation);
               
                hdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                headerType = Convert.ToInt32(aRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                headerStatus = Convert.ToInt32(aRow.Cells["Status"].Value, CultureInfo.CurrentUICulture);
                if (headerType == (int)eHeaderType.MultiHeader)
                { 
                    headerID = Convert.ToString(aRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                    
                    foreach (UltraGridRow row in this.ugDetails.Rows)
                    {
                        int rowHdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                      
                        if ( Convert.ToInt32(row.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader 
                          && Convert.ToInt32(row.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture) == hdrRID )
                        {
                            if (_headersAddedToMulti.ContainsKey(rowHdrRID))
                            {
                                groupRID = (int)_headersAddedToMulti[rowHdrRID];
                                if (groupRID == hdrRID)
                                {
                                    multiHeaderMemberProfile = (AllocationProfile)_allocProfileList.FindKey(rowHdrRID);
                                    // AllocationProfile is expecting added header to not be InUseByMultiHeader; AllocationProfile will turn it back on
                                    multiHeaderMemberProfile.HeaderGroupRID = Include.UndefinedHeaderGroupRID;
                                    multiMemberAddedProfiles.Add(multiHeaderMemberProfile);
                                }
                            }
                        }
                        else if (_headersRemovedFromMulti.ContainsKey(rowHdrRID))
                        {
                            groupRID = (int)_headersRemovedFromMulti[rowHdrRID];
                            if (groupRID == hdrRID)
                            {
                                multiHeaderMemberProfile = (AllocationProfile)_allocProfileList.FindKey(rowHdrRID);
                                // AllocationProfile is expecting HeaderGroupRID value to still be there so put it back in
                                multiHeaderMemberProfile.HeaderGroupRID = groupRID; 
                                multiMemberRemovedProfiles.Add(multiHeaderMemberProfile);
                            }    
                        }
                    }

                    if (multiMemberAddedProfiles.Count > 0)
                    {
                        if (hdrRID < 0)
                        {
                            success = ((AllocationProfile)multiMemberAddedProfiles[0]).CreateMultiHeader(headerID, multiMemberAddedProfiles);
                            if (success)
                            {
                                multiHeaderProfile = new AllocationProfile(
                                                           ((AllocationProfile)multiMemberAddedProfiles[0]).SAB,
                                                           null,
                                                           ((AllocationProfile)multiMemberAddedProfiles[0]).HeaderGroupRID,
                                                           ((AllocationProfile)multiMemberAddedProfiles[0]).Session);

                                // Begin TT#304  - RMatelic - Multi Header - made the multiple 10 received message "multiple cannot exceed units to allocate
                                int sizeGroupRID = Convert.ToInt32(aRow.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture);
                                int multiple = Convert.ToInt32(aRow.Cells["Multiple"].Value, CultureInfo.CurrentUICulture);
                                if (sizeGroupRID != multiHeaderProfile.SizeGroupRID || multiple != multiHeaderProfile.AllocationMultiple)
                                {
                                    multiHeaderProfile.AllocationMultiple = multiple;
                                    multiHeaderProfile.SizeGroupRID = sizeGroupRID;
                                    success = multiHeaderProfile.WriteHeader();  // TT#1185 - Verify ENQ before Update
                                }
                                // End TT#304
                                if (success)  // TT#1185 - Verify ENQ before Update
								// Begin TT#4954 - JSmith - Multi header error
                                //_allocProfileList.Add(multiHeaderProfile);
                                {
                                    AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(Include.NoRID);
                                    _allocProfileList.Remove(ap);
                                    DataRow[] dr = _multiHeaders.Select("HdrRID = " + Include.NoRID);
                                    dr[0]["HdrRID"] = multiHeaderProfile.Key;
                                    UpdateMultiHeaderKeys(Include.NoRID, multiHeaderProfile.Key);
                                    bool saveSkipHeaderEdit = _skipHeaderEdit;
                                    _skipHeaderEdit = true;
                                    aRow.Cells["KeyH"].Value = multiHeaderProfile.Key;
                                    aRow.Cells["HdrGroupRID"].Value = multiHeaderProfile.Key;
                                    RebuildMultiHeaderValueLists();
                                    _skipHeaderEdit = saveSkipHeaderEdit;
                                    hdrRID = multiHeaderProfile.Key;
                                    _allocProfileList.Add(multiHeaderProfile);
                                }
								// End TT#4954 - JSmith - Multi header error
                            }
                            // Begin TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header 
                            else
                            {
                                errorMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderCreateFailed, false), headerID);
                                CancelEdit();
                                throw new MIDException(eErrorLevel.severe, (int)eMIDTextCode.msg_al_MultiHeaderCreateFailed, errorMessage);
                            }
                        }   // End TT#687
                        else
                        {
                            multiHeaderProfile = (AllocationProfile)_allocProfileList.FindKey(hdrRID);
                            success = multiHeaderProfile.AddToMultiHeader(multiHeaderProfile, multiMemberAddedProfiles, false);
                            // Begin TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header 
                            if (!success)
                            {
                                errorMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderAddToFailed, false), headerID);
                                CancelEdit();
                                throw new MIDException(eErrorLevel.severe, (int)eMIDTextCode.msg_al_MultiHeaderAddToFailed, errorMessage);
                            }
                        }   // End TT#687
                    }

                    if (success)  // TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header  
                    {
                        if (multiMemberRemovedProfiles.Count > 0)
                        {
                            multiHeaderProfile = (AllocationProfile)_allocProfileList.FindKey(hdrRID);
                            success = multiHeaderProfile.RemoveHeaderFromMulti(multiHeaderProfile, multiMemberRemovedProfiles);
                            // Begin TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header 
                            if (!success)
                            {
                                errorMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_RemoveHeadersFromMultiHeaderFailed, false), headerID);
                                CancelEdit();
                                throw new MIDException(eErrorLevel.severe, (int)eMIDTextCode.msg_al_RemoveHeadersFromMultiHeaderFailed, errorMessage);
                            }
                        }   // End TT#687
                    }

                    if (success)  // TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header  
                    {
                        success = WriteHeader(hdrRID, multiHeaderProfile);
                    }

                    if (success)  // TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header  
                    {
                        for (int i = 0; i < multiMemberAddedProfiles.Count; i++)
                        {
                            multiHeaderMemberProfile = (AllocationProfile)multiMemberAddedProfiles[i];
                            if (multiHeaderMemberProfile.Key != hdrRID)
                            {
                                multiHeaderMemberProfile.ReReadHeader();
                                multiHeaderMemberProfile.ProcessingMultiHeader = true;
                                WriteHeader(multiHeaderMemberProfile.Key, multiHeaderMemberProfile);
                                multiHeaderMemberProfile.ProcessingMultiHeader = false;
                            }
                        }
                    }
                    if (success)  // TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header  
                    {
                        for (int i = 0; i < multiMemberRemovedProfiles.Count; i++)
                        {
                            multiHeaderMemberProfile = (AllocationProfile)multiMemberRemovedProfiles[i];
                            multiHeaderMemberProfile.ReReadHeader();
                            multiHeaderMemberProfile.ProcessingMultiHeader = true;
                            WriteHeader(multiHeaderMemberProfile.Key, multiHeaderMemberProfile);
                            multiHeaderMemberProfile.ProcessingMultiHeader = false;
                        }
                    }
                }
                else if  ( headerStatus != (int)eHeaderAllocationStatus.InUseByMultiHeader) 
                //else if (!multiMemberAddedProfiles.Contains(hdrRID) && !multiMemberRemovedProfiles.Contains(hdrRID))
                {
                     
                    WriteHeader(hdrRID, null);
                }    
            }
            catch
            {
                throw;
            }
        }
        // END MID Track #5654, 5655

        private UltraGridRow AddNewRowToHeadersGrid()
        {
            UltraGridRow headersHdrRow = null;
            // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            //this.ugHeaders.BeginUpdate();
            ugHeadersBeginUpdate();
            // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            try
            {
                UltraGridRow firstRow = ugHeaders.GetRow(ChildRow.First);
                // BEGIN MID Track 5732- unable to determine where to add row  
                //if (firstRow != null && firstRow.IsGroupByRow)
                if ((firstRow != null && firstRow.IsGroupByRow) || ugHeaders.Rows.Count == 0)
                // END MID TRack 5732
                {   // work around for Infragistic's inability to add new row to group by - undo GroupBy & add back later   
                    _groupByReload = true;        
                    _layoutStream  = new MemoryStream();
                    ugHeaders.DisplayLayout.Save(_layoutStream, Infragistics.Win.UltraWinGrid.PropertyCategories.All);
                    IRestoreLayout();   // Workspace Usabilty
                }
                headersHdrRow = this.ugHeaders.DisplayLayout.Bands["Header"].AddNew();
            }
            catch  
            {
                throw;
            }
            // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            //this.ugHeaders.EndUpdate();
            ugHeadersEndUpdate();
            // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            return headersHdrRow;
        }

        // Begin TT#1966-MD - JSmith - DC Fulfillment
        //private void DeleteHeaders()
        private void DeleteHeaders(ref bool bMasterHeaderDeleted)
        // End TT#1966-MD - JSmith - DC Fulfillment
        {
            List<int> asrtRidList = new List<int>();    // TT#936 - MD - Prevent the saving of empty Group Allocations
            bool error = false;                         // TT#936 - MD - Prevent the saving of empty Group Allocations
            bMasterHeaderDeleted = false;               // TT#1966-MD - JSmith - DC Fulfillment
            try
            {
                // begin TT#488 - MD - Jellis - Group Allocation
                //int[] selectedHeaderArray = new int[_deletedHeaderRows.Count];
                //_deletedHeaderRows.Keys.CopyTo(selectedHeaderArray,0);
				// Begin TT#974 - MD - stodd - cancel GA header and get action failed
                //List<int> selectedHeaderRIDs = new List<int>();
                //List<int> selectedAssortmentRIDs = new List<int>();
                foreach (int headerRID in _deletedHeaderRows.Keys)
                {
                    //AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(headerRID);
                    //if (ap.HeaderType == eHeaderType.Assortment)
                    //{
                    //    selectedAssortmentRIDs.Add(headerRID);
                    //}
                    //else
                    //{
                    //    selectedHeaderRIDs.Add(headerRID);
                    //}
                    _selectedHeaderKeyList.Add(headerRID);
                }
                //int[] selectedHeaderArray = new int[selectedHeaderRIDs.Count];
                //int[] selectedAssortmentArray = new int[selectedAssortmentRIDs.Count];
                //selectedAssortmentRIDs.CopyTo(selectedAssortmentArray);
                //selectedHeaderRIDs.CopyTo(selectedHeaderArray);
                // end TT#488 - MD - Jellis - Group Allocation

                // begin TT#1185 - Verify ENQ before Update
                //ApplicationSessionTransaction trans = _SAB.ApplicationServerSession.CreateTransaction();
                //trans.NewAllocationMasterProfileList();
                //trans.LoadHeaders(selectedHeaderArray);
                ApplicationSessionTransaction trans = GetApplicationSessionTransaction();
                //LoadSelectedHeadersToTransaction(ref trans, selectedHeaderArray); // TT#488 - MD - Jellis - Group Allocation
                //LoadSelectedHeadersToTransaction(ref trans, selectedAssortmentArray, selectedHeaderArray); // TT3488 - MD - Jellis- Group Allocation
				// Begin TT#980 - MD - stodd - null ref running size need -
                trans.LoadHeadersInTransaction(_selectedHeaderKeyList, _selectedAssortmentKeyList, false);
                //LoadHeadersInTransaction(ref trans, false);
				// End TT#980 - MD - stodd - null ref running size need -
                _selectedHeaderKeyList.Clear();
				// End TT#974 - MD - stodd - cancel GA header and get action failed
                // *********************************************************************************************************
                // *
                // *  NOTE:  the LoadSelectedHeadersToTransaction abouve will Re-read the headers from the database
                // *         the AllocationProfiles in _allocProfileList will be DIFFERENT than those in the transsaction
                // *
                // **********************************************************************************************************
                // end TT#1185 - Verify ENQ before Update

                foreach (int headerRID in _deletedHeaderRows.Keys)
                {
                    AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(headerRID);
                    if (ap == null)
                    {
                        continue;
                    }

                    if (ap.Key != Include.NoRID)
                    {
                        // Begin TT#936 - MD - Prevent the saving of empty Group Allocations
                        // If a header to be deleted is "attached" to an assortment/group allocation, add it to the list
                        if (ap.AsrtRID != Include.NoRID)
                        {
                            if (!asrtRidList.Contains(ap.AsrtRID))
                            {
                                asrtRidList.Add(ap.AsrtRID);
                            }
                        }
                        // End TT#936 - MD - Prevent the saving of empty Group Allocations

                        if (ap.MultiHeader)
                        {
                            Header hd = new Header();
                            DataTable dtChildren = hd.GetHeaderGroupChildren(ap.Key);
                            foreach (DataRow drChild in dtChildren.Rows)
                            {
                                int hdrRID = Convert.ToInt32(drChild["HDR_RID"], CultureInfo.CurrentUICulture);
                                AllocationProfile apInUse = (AllocationProfile)_allocProfileList.FindKey(hdrRID);
                                if (apInUse != null)
                                {
                                    apInUse.HeaderGroupRID = Include.UndefinedHeaderGroupRID;
                                    //apInUse.InUseByMulti = false;
                                    apInUse.WriteHeader();
                                }
                                ReloadProfileToGrid(hdrRID);
                            }
                            ugHeaders.Selected.Rows.Clear();  // TT#4954 - JSmith - Multi header error
                        }
                        trans.DeleteAllocationHeader(headerRID);
                        // Begin TT#1966-MD - JSmith - DC Fulfillment
                        if (ap.IsMasterHeader)
                        {
                            bMasterHeaderDeleted = true;
                        }
                        // End TT#1966-MD - JSmith - DC Fulfillment
                    }
                    if (ap.MultiHeader)
                    {
                        foreach (DataRow mRow in _multiHeaders.Rows)
                        {
                            if ((int)mRow["HdrRID"] == ap.Key)
                            {
                                _multiHeaders.Rows.Remove(mRow);
                                break;
                            }
                        }
                    }
                    else if (ap.Placeholder)
                    {
                        if (_assortmentGroups.ContainsKey(ap.AsrtRID))
                        {
                            Hashtable asrtHeaderListHash = (Hashtable)_assortmentGroups[ap.AsrtRID];
                            if (asrtHeaderListHash.ContainsKey(ap.Key))
                            {
                                asrtHeaderListHash.Remove(ap.Key);
                            }
                        }
                    }
                    else if (ap.Assortment)
                    {
                        if (_assortmentGroups.ContainsKey(ap.Key))
                        {
                            _assortmentGroups.Remove(ap.Key);
                        }
                    }
                    _allocProfileList.Remove(ap);
                    AllocationHeaderProfile ahp = (AllocationHeaderProfile)_headerList.FindKey(headerRID);
                    if (ahp != null)
                    {
                        _headerList.Remove(ahp);
                    }
                    foreach (AllocationHeaderProfile ahp2 in _headerProfileArrayList)
                    {
                        if (ahp2.Key == headerRID)
                        {
                            _headerProfileArrayList.Remove(ahp2);
                            break;
                        }
                    }
                    // delete header row from ugHeaders grid
                    UltraGridRow hRow = (UltraGridRow)_deletedHeaderRows[headerRID];
                    if (hRow != null)
                    {
                        CheckForSelectedRemoval(hRow);      // MID Track #6264    
                        hRow.Delete(false);
                    }
                    if (_selectedHeaderKeyList.Contains(headerRID))
                    {
                        _selectedHeaderKeyList.Remove(headerRID);
                    }
                    // TT#488 - MD - Jellis - Group Allocation
                    else if (_selectedAssortmentKeyList.Contains(headerRID))
                    {
                        _selectedAssortmentKeyList.Remove(headerRID);
                    }
                    // end TT#488 - MD - Jellis - Group Allocation
                }

            }
            catch (Exception ex)
            {
                error = true;	// TT#936 - MD - Prevent the saving of empty Group Allocations
                HandleException(ex);
            }
			// Begin TT#936 - MD - Prevent the saving of empty Group Allocations
            finally
            {
                if (!error && asrtRidList.Count > 0)
                {
                    SAB.HeaderServerSession.DeleteEmptyGroupAllocationHeaders(asrtRidList, SAB);
                }
            }
			// End TT#936 - MD - Prevent the saving of empty Group Allocations
        }

        // BEGIN MID Track #6264 - Headers not in priority order
        private void CheckForSelectedRemoval(UltraGridRow aRow)
        {
            try
            {
                if (_selectedRowsSequence.Count > 0)
                {
                    if (_selectedRowsSequence.Contains(aRow))
                    {
                        _selectedRowsSequence.Remove(aRow);
                    }
                    else if (aRow.Cells["HeaderRow"].Value != System.DBNull.Value)
                    {
                        UltraGridRow hRow = (UltraGridRow)aRow.Cells["HeaderRow"].Value;
                        if (_selectedRowsSequence.Contains(hRow))
                        {
                            _selectedRowsSequence.Remove(hRow);
                        }
                    }  
                }  
            }
            catch
            {
                throw;
            } 
        }
        // END MID Track #6264 

        private void CheckForPlaceholderStyleDelete(bool fromSave)
        {
            try
            {
                if (_deletedPlaceholderStyles.Count > 0)
                {
                    if (fromSave)   // user selected Save
                    {
                        foreach (int styleRID in _deletedPlaceholderStyles.Values)
                        {
                            if (_anchorNodes.Rows.Contains(styleRID))
                            {
                                _anchorNodes.Rows.Remove(_anchorNodes.Rows.Find(styleRID));
                            }
                            DeletePlaceholderStyle(styleRID);
                        }
                    }
                    else   // user selected Cancel; only delete Placeholder styles on unsaved Placeholder headers  
                    {
                        foreach (int hdrRID in _deletedPlaceholderStyles.Keys)
                        {
                            if (hdrRID < 0) // header not saved
                            {
                                int styleRID = (int)_deletedPlaceholderStyles[hdrRID];
                                DeletePlaceholderStyle(styleRID);
                            }
                        }
                    }
                    _deletedPlaceholderStyles.Clear();
                }

                if (_deletedAssortmentStyles.Count > 0)
                {
                    if (fromSave)   // user selected Save
                    {
                        foreach (int styleRID in _deletedAssortmentStyles.Values)
                        {
                            if (_anchorNodes.Rows.Contains(styleRID))
                            {
                                _anchorNodes.Rows.Remove(_anchorNodes.Rows.Find(styleRID));
                            }
                            DeletePlaceholderStyle(styleRID);
                        }
                    }
                    else   // user selected Cancel; only delete Assortment styles on unsaved Assortment headers  
                    {
                        foreach (int hdrRID in _deletedAssortmentStyles.Keys)
                        {
                            if (hdrRID < 0) // header not saved
                            {
                                int styleRID = (int)_deletedAssortmentStyles[hdrRID];
                                DeletePlaceholderStyle(styleRID);
                            }
                        }
                    }
                    _deletedAssortmentStyles.Clear();
                }
            }
            catch
            {
                throw;
            }
        }
     
        private void DeletePlaceholderStyle(int aStyleRID)
        {
            try
            {
                EditMsgs em = new EditMsgs();
                HierarchyNodeProfile styleHnp = _SAB.HierarchyServerSession.GetNodeData(aStyleRID);
                if (styleHnp.IsVirtual && (styleHnp.Purpose == ePurpose.Placeholder || styleHnp.Purpose == ePurpose.Assortment))
                {
                    HierarchyMaintenance hierMaint = new HierarchyMaintenance(_SAB);
                    hierMaint.DeletePlaceholderStyleAnchorNode(aStyleRID, ref em);
                }
                if (em.ErrorFound)
                {
                    DisplayMessages.Show(em, _SAB, Include.MIDAllocationWorkspaceExplorer);
                }
            }
            catch
            {
                throw;
            } 
        }

        private void UpdateAnchorNodes()
        {
            int phStyleRID, oldAnchorRID, newAnchorRID; 
            try
            {
                if (_anchorNodes.Rows.Count > 0)
                {
                    foreach (DataRow dr in _anchorNodes.Rows)
                    {
                        phStyleRID = Convert.ToInt32(dr["PhStyleRID"], CultureInfo.CurrentUICulture);
                        oldAnchorRID = Convert.ToInt32(dr["PhOldAnchorRID"], CultureInfo.CurrentUICulture);
                        newAnchorRID = Convert.ToInt32(dr["PhNewAnchorRID"], CultureInfo.CurrentUICulture);
                        _hierMaint.MovePlaceholderStyleAnchorNode(phStyleRID, oldAnchorRID, newAnchorRID);
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private bool WriteHeader(int aKey, AllocationProfile aAllocationProfile)
        {
            AllocationProfile ap;
            DataRow dr = null;
            try
            {
                ap = (AllocationProfile)_allocProfileList.FindKey(aKey);
                if (ap != null && ap.HeaderID != null)
                {
                    if (aAllocationProfile == null)
                    {
                        ap.WriteHeader();
                    }
                    else
                    {
                        ap = aAllocationProfile;
                    }
                    
                    if (aKey != ap.Key)
                    {   // this was a new header
                        dr = _dsDetails.Tables["Header"].Rows.Find(aKey);
                        dr["KeyH"] = ap.Key;

                        _allocProfileList.HashRebuild();
                        
                        if (ap.MultiHeader)
                        {
                            UpdateMultiHeaderKeys(aKey, ap.Key);
                        }
                        else if (ap.Assortment)
                        {
                            UpdateAssortmentKeys(aKey, ap.Key);
                        }
                        else if (ap.Placeholder)
                        {
                            UpdatePlaceholderKeys(aKey, ap.Key);
                        }  

                        if ((ap.Packs.Count > 0 || ap.BulkColors.Count > 0))
                        {
                            UpdateDataRowKeys(aKey, ap);
                        }

                        // begin TT#488 - MD - JEllis - Group Allocation
                        if (ap.HeaderType == eHeaderType.Assortment)
                        {
                            if (_selectedAssortmentKeyList.Count > 0)
                            {
                                for (int i = 0; i < _selectedAssortmentKeyList.Count; i++)
                                {
                                    if (Convert.ToInt32(_selectedAssortmentKeyList[i], CultureInfo.CurrentUICulture) == aKey)
                                    {
                                        _selectedAssortmentKeyList[i] = ap.Key;
                                        _SAB.ClientServerSession.AddSelectedHeaderList(ap.Key, ap.HeaderID, ap.HeaderType, ap.AsrtRID, ap.StyleHnRID);
                                        break;
                                    }
                                }
                            }
                        }
                        // end TT#488 - MD - Jellis - Group Allocation
                        else if (_selectedHeaderKeyList.Count > 0) // TT#488 - MD - Jellis - Group Allocation
                        {
                            for (int i = 0; i < _selectedHeaderKeyList.Count; i++)
                            {
                                if (Convert.ToInt32(_selectedHeaderKeyList[i], CultureInfo.CurrentUICulture) == aKey)
                                {
                                    _selectedHeaderKeyList[i] = ap.Key;
                                    _SAB.ClientServerSession.AddSelectedHeaderList(ap.Key, ap.HeaderID, ap.HeaderType, ap.AsrtRID, ap.StyleHnRID);
                                    break;
                                }
                            }
                        }
                        if (aKey < 0 && _allocProfileList.Contains(aKey))
                        {
                            _allocProfileList.Remove((AllocationProfile)_allocProfileList.FindKey(aKey));
                        }
                    }
                     
                    ReloadProfileToGrid(ap.Key);
                }
                return true;
            }
            catch (MIDException MIDexc)
            {
                HandleMIDException(MIDexc);
                return false;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }
       
        private void UpdateMultiHeaderKeys(int aOldRID, int aNewRID)
        {
            try
            {
                foreach (DataRow dRow in _multiHeaders.Rows)
                {
                    if ((int)dRow["HdrRID"] == aOldRID)
                    {
                        dRow["HdrRID"] = aNewRID;
                        break;
                    }
                }
                _multiHeaders.AcceptChanges();
                // Begin TT#2839 - JSmith - MultiHeader IDs in 5.0
                //ugDetails.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Clear();
                //foreach (DataRow mRow in _multiHeaders.Rows)
                //{
                //    ugDetails.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Add(Convert.ToInt32(mRow["HdrRID"], CultureInfo.CurrentUICulture), mRow["HeaderID"].ToString());
                //}
                RebuildMultiHeaderValueLists();
                // End TT#2839 - JSmith - MultiHeader IDs in 5.0
                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (row.Cells["HdrGroupRID"].Value != DBNull.Value &&
                         Convert.ToInt32(row.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture) == aOldRID)
                    {
                        row.Cells["HdrGroupRID"].Value = aNewRID;
                        row.Update();
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAssortmentKeys(int aOldRID, int aNewRID)
        {
            try
            {
                foreach (DataRow dRow in _assortments.Rows)
                {
                    if ((int)dRow["AsrtRID"] == aOldRID)
                    {
                        dRow["AsrtRID"] = aNewRID;
                        break;
                    }
                }
                _assortments.AcceptChanges();
                ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Clear();
                foreach (DataRow dr in _assortments.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Add(Convert.ToInt32(dr["AsrtRID"], CultureInfo.CurrentUICulture), dr["AssortmentID"].ToString());
                }
                
                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (row.Cells["AsrtRID"].Value != DBNull.Value &&
                         Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == aOldRID)
                    {
                        row.Cells["AsrtRID"].Value = aNewRID;
                        row.Update();
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePlaceholderKeys(int aOldRID, int aNewRID)
        {
            try
            {
                foreach (DataRow dRow in _placeHolders.Rows)
                {
                    if ((int)dRow["PlaceHolderRID"] == aOldRID)
                    {
                        dRow["PlaceHolderRID"] = aNewRID;
                        break;
                    }
                }
                _placeHolders.AcceptChanges();
                ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Clear();
                foreach (DataRow dr in _placeHolders.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Add(Convert.ToInt32(dr["PlaceHolderRID"], CultureInfo.CurrentUICulture), dr["PlaceHolderID"].ToString());
                }

                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (row.Cells["PlaceHolderRID"].Value != DBNull.Value &&
                         Convert.ToInt32(row.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == aOldRID)
                    {
                        row.Cells["PlaceHolderRID"].Value = aNewRID;
                        row.Update();
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdateMultiHeaderID(string aOldID, string aNewID)
        {
            try
            {
                foreach (DataRow dRow in _multiHeaders.Rows)
                {
                    if (dRow["HeaderID"].ToString() == aOldID)
                    {
                        dRow["HeaderID"] = aNewID;
                        break;
                    }
                }
                _multiHeaders.AcceptChanges();
                // Begin TT#2839 - JSmith - MultiHeader IDs in 5.0
                //ugDetails.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Clear();
                //foreach (DataRow mRow in _multiHeaders.Rows)
                //{
                //    ugDetails.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Add(Convert.ToInt32(mRow["HdrRID"], CultureInfo.CurrentUICulture), mRow["HeaderID"].ToString());
                //}
                RebuildMultiHeaderValueLists();
                // End TT#2839 - JSmith - MultiHeader IDs in 5.0
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAssortmentID(string aOldID, string aNewID)
        {
            try
            {
                foreach (DataRow dRow in _assortments.Rows)
                {
                    if (dRow["AssortmentID"].ToString() == aOldID)
                    {
                        dRow["AssortmentID"] = aNewID;
                        break;
                    }
                }
                _assortments.AcceptChanges();
                ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Clear();
                foreach (DataRow mRow in _assortments.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Add(Convert.ToInt32(mRow["AsrtRID"], CultureInfo.CurrentUICulture), mRow["AssortmentID"].ToString());
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePlaceholderID(string aOldID, string aNewID)
        {
            try
            {
                foreach (DataRow dRow in _placeHolders.Rows)
                {
                    if (dRow["PlaceHolderID"].ToString() == aOldID)
                    {
                        dRow["PlaceHolderID"] = aNewID;
                        break;
                    }
                }
                _placeHolders.AcceptChanges();
                ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Clear();
                foreach (DataRow mRow in _placeHolders.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Add(Convert.ToInt32(mRow["PlaceHolderRID"], CultureInfo.CurrentUICulture), mRow["PlaceHolderID"].ToString());
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdateDataRowKeys(int aOldHdrKey, AllocationProfile ap)
        {
            try
            {
                string oldSizeTableName = string.Empty;
                string newSizeTableName = string.Empty;
                int oldPackKey = 0, oldColorCodeRID = 0;
                if (ap.Packs.Count > 0)
                {
                    object[] Keys = new object[2];
                    Keys[0] = ap.Key;
                    foreach (PackHdr aPack in ap.Packs.Values)
                    {
                        Keys[1] = aPack.PackName;
                        DataRow drPack = _dsDetails.Tables["Pack"].Rows.Find(Keys);
                        if (drPack != null)
                        {
                            oldPackKey = (int)drPack["KeyP"];
                            if (oldPackKey < 0)
                            {
                                oldSizeTableName = "PackSize" + "~" + aOldHdrKey.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + oldPackKey.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + Include.DummyColorRID.ToString(CultureInfo.CurrentUICulture);
                                newSizeTableName = "PackSize" + "~" + ap.Key.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + aPack.PackRID.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + Include.DummyColorRID.ToString(CultureInfo.CurrentUICulture);
                                drPack["KeyP"] = aPack.PackRID;
                                drPack["Sequence"] = aPack.Sequence;
                                _dsDetails.Tables["Pack"].AcceptChanges();

                                ReplaceSizeTable("PackSize", oldSizeTableName, newSizeTableName);
                                if (ap.Placeholder)
                                {
                                    UpdateAssortmentLinkedPacks(ap.Key, oldPackKey, aPack.PackRID);
                                }
                            }
                            if (aPack.PackColors != null && aPack.PackColors.Count > 0)
                            {
                                UpdatePackColorCodeRIDs(aOldHdrKey, ap.Key, oldPackKey, aPack);
                            }
                        }
                    }
                }

                if (ap.BulkColors.Count > 0)
                {
                    object[] Keys = new object[2];
                    Keys[0] = ap.Key;
                    foreach (HdrColorBin aColor in ap.BulkColors.Values)
                    {
                        Keys[1] = aColor.ColorCodeRID;
                        DataRow drColor = _dsDetails.Tables["BulkColor"].Rows.Find(Keys);
                        if (drColor != null)
                        {
                            if ((int)drColor["KeyC"] < 0)
                            {
                                oldColorCodeRID = (int)drColor["KeyC"];
                                oldSizeTableName = "BulkSize" + "~" + aOldHdrKey.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + oldColorCodeRID.ToString(CultureInfo.CurrentUICulture);
                                newSizeTableName = "BulkSize" + "~" + ap.Key.ToString(CultureInfo.CurrentUICulture)
                                                       + "~" + aColor.HdrBCRID.ToString(CultureInfo.CurrentUICulture);

                                drColor["KeyC"] = aColor.HdrBCRID;
                                drColor["Sequence"] = aColor.ColorSequence;
                                ReplaceSizeTable("BulkSize", oldSizeTableName, newSizeTableName);
                                if (ap.Placeholder)
                                {
                                    UpdateAssortmentLinkedColors(ap.Key, oldColorCodeRID, aColor.HdrBCRID);
                                }
                            }
                        }
                    }
                }

            }
            catch
            {
                throw;
            }
        }

        private void UpdateAssortmentLinkedColors(int aPhKey, int aOldValue, int aNewValue)
        {
            try
            {
                IEnumerable enumerator = ugDetails.DisplayLayout.Bands["BulkColor"].GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    if ( Convert.ToInt32(row.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Placeholder 
                      && Convert.ToInt32(row.ParentRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == aPhKey
                      && Convert.ToInt32(row.Cells["AsrtBCRID"].Value, CultureInfo.CurrentUICulture) == aOldValue)
                    {
                        row.Cells["AsrtBCRID"].Value = aNewValue;
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdateAssortmentLinkedPacks(int aPhKey, int aOldValue, int aNewValue)
        {
            try
            {
                IEnumerable enumerator = ugDetails.DisplayLayout.Bands["Pack"].GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow row in enumerator)
                {
                    if (Convert.ToInt32(row.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Placeholder
                      && Convert.ToInt32(row.ParentRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == aPhKey
                      && Convert.ToInt32(row.Cells["AssociatedPackRID"].Value, CultureInfo.CurrentUICulture) == aOldValue)
                    {
                        row.Cells["AssociatedPackRID"].Value = aNewValue;
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void UpdatePackColorCodeRIDs(int aOldHdrKey, int aNewHdrRID, int aOldPackKey, PackHdr aPack)
        {
            try
            {  // aOldHdrKey & aNewBdrRID may be the same; aOldPAckKey & aPack.PackRID may be the same;
                string oldSizeTableName = string.Empty;
                string newSizeTableName = string.Empty;
                object[] pcKeys = new object[3];
                //pcKeys[0] = aOldHdrKey;
                pcKeys[0] = aNewHdrRID;
                //pcKeys[1] = aOldPackKey;
                pcKeys[1] = aPack.PackRID;

                foreach (PackColorSize aColor in aPack.PackColors.Values)
                {
                    if (aColor.ColorCodeRID != Include.DummyColorRID)
                    {
                        pcKeys[2] = aColor.ColorCodeRID;
                        DataRow drPackColor = _dsDetails.Tables["PackColor"].Rows.Find(pcKeys);
                        int oldPackColorRID = (int)drPackColor["KeyC"];

                        if (oldPackColorRID < 0)
                        {
                            oldSizeTableName = "PackColorSize" + "~" + aOldHdrKey.ToString(CultureInfo.CurrentUICulture)
                                                + "~" + aOldPackKey.ToString(CultureInfo.CurrentUICulture)
                                                + "~" + oldPackColorRID.ToString(CultureInfo.CurrentUICulture);
                            newSizeTableName = "PackColorSize" + "~" + aNewHdrRID.ToString(CultureInfo.CurrentUICulture)
                                                + "~" + aPack.PackRID.ToString(CultureInfo.CurrentUICulture)
                                                + "~" + aColor.HdrPCRID.ToString(CultureInfo.CurrentUICulture);
                            drPackColor["KeyC"] = aColor.HdrPCRID;
                            drPackColor["Sequence"] = aColor.ColorSequenceInPack;
                            ReplaceSizeTable("PackColorSize", oldSizeTableName, newSizeTableName);
                        }
                    }
                }    
            }
            catch
            {
                throw;
            }
        }
        private void ReplaceSizeTable(string aBandKey, string aOldTableName, string aNewTableName)
        {
            try
            {
                if (_dsDetails.Relations.Contains(aOldTableName))
                {
                    DataTable dtSize = _dsDetails.Relations[aOldTableName].ChildTable.Copy();

                    _dsDetails.Tables[aOldTableName].Constraints.Remove(aOldTableName);
                    _dsDetails.Relations.Remove(aOldTableName);
                    _dsDetails.Tables.Remove(aOldTableName);
                    _dsDetails.AcceptChanges();
                   
                    dtSize.TableName = aNewTableName;
                    _dsDetails.Tables.Add(dtSize);

                    switch (aBandKey)
                    {
                        case "BulkSize":
                            _dsDetails.Relations.Add(aNewTableName,
                                new DataColumn[] { _dsDetails.Tables["BulkColor"].Columns["KeyH"], _dsDetails.Tables["BulkColor"].Columns["KeyC"] },
                                new DataColumn[] { _dsDetails.Tables[aNewTableName].Columns["KeyH"], _dsDetails.Tables[aNewTableName].Columns["KeyC"] }, true);
                            break;

                        case "PackSize":
                            _dsDetails.Relations.Add(aNewTableName,
                                new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                                new DataColumn[] { _dsDetails.Tables[aNewTableName].Columns["KeyH"], _dsDetails.Tables[aNewTableName].Columns["KeyP"] }, true);
                            break;

                        case "PackColorSize":
                            _dsDetails.Relations.Add(aNewTableName,
                              new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"], _dsDetails.Tables["PackColor"].Columns["KeyC"] },
                              new DataColumn[] { _dsDetails.Tables[aNewTableName].Columns["KeyH"], _dsDetails.Tables[aNewTableName].Columns["KeyP"], _dsDetails.Tables[aNewTableName].Columns["KeyC"] }, true);
                            break;
                    }
                    
                    _dsDetails.AcceptChanges();
                }
            }
            catch
            {
                throw;
            }
        }

        // Begin TT#5697 - JSmith - Subordinate header release fails in Style Review
        //private void ReloadProfileToGrid(int aHdrRID)
        private bool ReloadProfileToGrid(int aHdrRID)
        // End TT#5697 - JSmith - Subordinate header release fails in Style Review
        {
            try
            {
                Header headerData = new Header();  // TT#457-MD - JSmith - Add additional Header information to the Allocation Workspace

                ////BEGIN TT#154 – Add number of stores variable to Allocation workspace - apicchetti
                //object numberOfStores;
                ////END TT#154 – Add number of stores variable to Allocation workspace - apicchetti
                object packCount, bulkColorCount, bulkColorSizeCount; // Workspace Usability Enhancement 
               
                // Begin TT#2 - RMatelic - Assortment Planning - force the HeaderServerSssion to reread the header
                AllocationHeaderProfile ahp = _SAB.HeaderServerSession.GetHeaderData(aHdrRID, true, true, true);
                // End TT#2  

                // Begin TT#5697 - JSmith - Subordinate header release fails in Style Review
                if (ahp.Key == Include.NoRID)
                {
                    return false;
                }
                // End TT#5697 - JSmith - Subordinate header release fails in Style Review
               
                AllocationProfile ap = (AllocationProfile)this._allocProfileList.FindKey(aHdrRID);
                if (ap == null)
                {
                    // Begin MID Track 5760 Master Header not Refreshed when Subordinate Modified
                    // Begin TT#2 - RMatelic - Assortment Planning
                    //AllocationHeaderProfile ahp = _SAB.HeaderServerSession.GetHeaderData(aHdrRID, true, true);
                    //AllocationHeaderProfile ahp = _SAB.HeaderServerSession.GetHeaderData(aHdrRID, true, true, true); >>>>> moved up above the if ...
                    // End TT#2
                    ap = new AllocationProfile(_SAB, ahp, _SAB.ClientServerSession);
                    _allocProfileList.Add(ap);

                    //return;
                    // end MID Track 5760 Master Header not Refreshed when Subordinate Modified
                }
   
                ap.ReReadHeader();

                //WorkflowBaseData workflowData = new WorkflowBaseData();
                string workflowMethodStr = string.Empty;
                int masterRID = Include.NoRID;
                int subordRID = Include.NoRID;

                string masterID = String.Empty;
                string subordID = String.Empty;
                string msgMasterSubord = String.Empty;

                //Begin TT#1313-MD -jsobek -Header Filters -performance
                if (ap.WorkflowRID > Include.UndefinedWorkflowRID)
                {
                    workflowMethodStr = ahp.WorkflowName; //workflowData.GetWorkflowName(ap.WorkflowRID);

                    // BEGIN MID Track #6336 - KJohnson - Header Load API Enhancement
                    workflowMethodStr = setGeneratedWorkflowName(ap.HeaderID, workflowMethodStr);
                    // END MID Track #6336
                }
                else
                {
                    //ApplicationBaseMethod abm = (ApplicationBaseMethod)_getMethods.GetUnknownMethod(ap.MethodRID, false);
                    //if (abm.Key > Include.UndefinedMethodRID)
                    if (ap.MethodRID > Include.UndefinedMethodRID)
                    {
                        workflowMethodStr = ahp.HeaderMethodName; //abm.Name;
                        // BEGIN MID Track #6336 - KJohnson - Header Load API Enhancement
                        workflowMethodStr = setGeneratedWorkflowName(ap.HeaderID, workflowMethodStr);
                        // END MID Track #6336
                    }
                }
                //End TT#1313-MD -jsobek -Header Filters -performance

                // begin MID Track 4554 AnF Enhancement API Workflow
                string APIworkflowMethodStr = string.Empty;
                if (ap.API_WorkflowRID > Include.UndefinedWorkflowRID)
                {
                    APIworkflowMethodStr = (string)_workflowNameHash[ap.API_WorkflowRID];
                    if (APIworkflowMethodStr == null)
                    {
                        //Begin TT#1313-MD -jsobek -Header Filters -performance
                        //APIworkflowMethodStr = workflowData.GetWorkflowName(ap.API_WorkflowRID);
                        APIworkflowMethodStr = ahp.APIWorkflowName;
                        //End TT#1313-MD -jsobek -Header Filters -performance
                        // BEGIN MID Track #6336 - KJohnson - Header Load API Enhancement
                        APIworkflowMethodStr = setGeneratedWorkflowName(ap.HeaderID, APIworkflowMethodStr);
                        // END MID Track #6336
                        _workflowNameHash.Add(ap.API_WorkflowRID, APIworkflowMethodStr);
                    }
                    // BEGIN MID Track #6336 - KJohnson - Header Load API Enhancement
                    APIworkflowMethodStr = setGeneratedWorkflowName(ap.HeaderID, APIworkflowMethodStr);
                    // END MID Track #6336
                }
                // end MID Track 4554 AnF Enhancement API Workflow

                // Begin TT#1966-MD - DC Fulfillment
                //subordRID = ap.SubordinateRID;

                //if (subordRID != Include.NoRID)
                //{
                //    subordID = ap.SubordinateID;
                //    if (subordID != null && subordID != string.Empty)
                //    {
                //        msgMasterSubord = ap.HeaderID + " / " + subordID;
                //    }
                //}
                //else
                //{
                //    masterRID = ap.MasterRID;
                //    if (masterRID != Include.NoRID)
                //    {
                //        masterID = ap.MasterID;
                //        if (masterID != null && masterID != string.Empty)
                //        {
                //            msgMasterSubord = masterID + " / " + ap.HeaderID;
                //        }
                //    }
                //}
                if (ahp.IsMasterHeader)
                {
                    msgMasterSubord = ahp.HeaderID;
                }
                else if (ahp.IsSubordinateHeader)
                {
                    msgMasterSubord = ahp.MasterID;
                }
                // End TT#1966-MD - DC Fulfillment

                // BEGIN Workspace Usability Enhancement - Ron Matelic
                packCount = System.DBNull.Value;
                bulkColorCount = System.DBNull.Value;
                bulkColorSizeCount = System.DBNull.Value;
                if (ap.PackCount > 0)
                {
                    packCount = ap.PackCount;
                }
                if (ap.BulkColorCount > 0)
                {
                    bulkColorCount = ap.BulkColorCount;
                }
                if (ap.BulkColorSizeCount > 0)
                {
                    bulkColorSizeCount = ap.BulkColorSizeCount;
                }
                // END Workspace  Usability Enhancement

                // Begin TT#705 - RMatelic - WUB when Cancel a WUB header the total quantity goes to 0 but the components do not
                if (ap.WorkUpTotalBuy && _processingAction)
                {
                    // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                    if (_detailsShown)
                    {
                    // End TT#1434
                        UltraGridRow dRow = null;
                        foreach (UltraGridRow row in ugDetails.Rows)
                        {
                            if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aHdrRID)
                            {
                                dRow = row;
                                break;
                            }
                        }
                        if ((ap.PackCount == 0 && dRow.HasChild(this.ugDetails.DisplayLayout.Bands["Pack"], false)) ||
                             (ap.BulkColorCount == 0 && dRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false)))
                        {
                            _removeAndReselectHeaders.Add(dRow);
                        }
                    // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                    }
                    // End TT#1434
                }
                // End TT#705

                
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                //DataRow dr = _dsDetails.Tables["Header"].Rows.Find(aHdrRID);
                DataRow dr = null;
				// Begin TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                //if (_detailsShown)
                if (_dsDetails != null)
				// End TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                {
                    dr = _dsDetails.Tables["Header"].Rows.Find(aHdrRID);
                }
                // End TT#1434
                if (dr != null)
                {
                    // Begin TT#2 - RMatelic - Assortment Planning
                    dr["HeaderID"] = ap.HeaderID;
                    dr["Description"] = ap.HeaderDescription;
                    // End TT#2 
                    dr["Type"] = Convert.ToInt32(ap.HeaderType, CultureInfo.CurrentUICulture);
                    dr["Status"] = Convert.ToInt32(ap.HeaderAllocationStatus, CultureInfo.CurrentUICulture);
                    dr["Intransit"] = Convert.ToInt32(ap.HeaderIntransitStatus, CultureInfo.CurrentUICulture);
                    dr["ShipStatus"] = Convert.ToInt32(ap.HeaderShipStatus, CultureInfo.CurrentUICulture);
                    dr["HdrQuantity"] = ap.TotalUnitsToAllocate;
                    dr["UnitRetail"] = ap.UnitRetail;
                    dr["UnitCost"] = ap.UnitCost;
                    dr["Multiple"] = ap.AllocationMultiple;
                    dr["PO"] = ap.PurchaseOrder;
                    dr["Vendor"] = ap.Vendor;
                    dr["Workflow"] = workflowMethodStr;
                    dr["APIWorkflow"] = APIworkflowMethodStr; // MID Track 4554 AnF Enhancement API Workflow
                    dr["DC"] = ap.DistributionCenter;
                    if (ap.ReleaseDate == Include.UndefinedDate)
                    {
                        dr["Release"] = string.Empty;
                    }
                    else
                    {
                        // Begin TT#5072 - JSmith - Release date field not recognized as date?
                        //dr["Release"] = ap.ReleaseDate.ToShortDateString();
                        dr["Release"] = ap.ReleaseDate.ToString("MM/dd/yyyy");
                        // End TT#5072 - JSmith - Release date field not recognized as date?
                    }
                    dr["Master"] = msgMasterSubord;
                    dr["AllocatedUnits"] = ap.AllocatedUnits;
                    dr["OrigAllocatedUnits"] = ap.OrigAllocatedUnits;
                    dr["RsvAllocatedUnits"] = ap.RsvAllocatedUnits;
                 
                    if ( (!ap.MultiHeader) && (ap.Packs.Count > 0 || ap.BulkColors.Count > 0) )
                    {
                        UpdateDataRowKeys(ap.Key, ap);
                    }

                    if (ap.WorkUpTotalBuy)
                    {
                        int hdrChildTotal = 0;
                        if (ap.BulkColors != null //TT#601 released WUB balance not zero
                            || (ap.Packs != null && ap.Packs.Count > 0)) // #TT#601 released WUB balance not zero
                        {
                            //ReloadWorkUpTotalBuy(aHdrRID, ap.BulkColors, ref hdrChildTotal);  // TT#601 released WUB balance not zero
                            ReloadWorkUpTotalBuy(ap, ref hdrChildTotal); // #TT#601 released WUB balance not zero
                            dr["ChildTotal"] = hdrChildTotal;
                            dr["Balance"] = Convert.ToInt32(dr["HdrQuantity"], CultureInfo.CurrentUICulture) - hdrChildTotal;
                        }
                    }

                    //BEGIN TT#154 – Add variables to Allocation workspace - apicchetti
                    dr["NumberOfStores"] = ap.GetCountOfStoresWithAllocation(new GeneralComponent(eGeneralComponentType.Total));
                    //END TT#154 – Add variables to Allocation workspace - apicchetti
                    // BEGIN Workspace Usability Enhancement - Ron Matelic
                    dr["NumPacks"] = packCount;
                    dr["NumBulkColors"] = bulkColorCount;
                    dr["NumBulkSizes"] = bulkColorSizeCount;
                    // END Workspace Usability Enhancement 

                    // Begin TT#1401 - RMatelic - Reservation Stores
                    dr["ImoId"] = ap.ImoID;
					// BEGIN TT1401 - stodd - TEMP removal of these fields from displaying on Alloc workspace
					//dr["ItemUnitsAllocated"] = ap.TotalItemUnitsAllocatedDisplay;
					//dr["ItemOrigUnitsAllocated"] = ap.TotalItemOrigUnitsAllocatedDisplay;
					// END TT1401 - stodd - TEMP removal of these fields from displaying on Alloc workspace
                    // BEGIN TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
                    int storetot = 0;
                    int vSWtot = 0;
                    storetot = ap.ItemAllocatedUnits - ap.RsvAllocatedUnits;
                    vSWtot = ap.AllocatedUnits - storetot;                    
                    dr["ItemUnitsAllocated"] = storetot;
                    dr["ItemOrigUnitsAllocated"] = vSWtot;
                    // END TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
                    // End TT#1401 

					// Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                    dr["AsrtRID"] = DBNull.Value;
                    dr["GroupAllocRID"] = DBNull.Value;
                    if (ap.AsrtRID != 0 && ap.AsrtRID != Include.NoRID)
                    {
                        AllocationHeaderProfile asrtHdr = SAB.HeaderServerSession.GetHeaderData(ap.AsrtRID, false, false, true);
                        if ((eAssortmentType)asrtHdr.AsrtType == eAssortmentType.GroupAllocation)
                        {
                            dr["GroupAllocRID"] = ap.AsrtRID;

                        }
                        else
                        {
                            dr["AsrtRID"] = ap.AsrtRID;
                        }
                        UpdateAssortmentID(asrtHdr.Key, asrtHdr.HeaderID, asrtHdr.AsrtType);
                    }
					// End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces

					// BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
					if (ap.AdjustVSW_OnHand)
					{
						dr["AdjustVSW"] = (int)eAdjustVSW.Adjust;
					}
					else
					{
						if (ap.HeaderType == eHeaderType.IMO)
						{
							dr["AdjustVSW"] = (int)eAdjustVSW.Replace;
						}
						else
						{
							dr["AdjustVSW"] = Include.NoRID;
						}
					}
                    //dr["AdjustVSW"] = ap.AdjustVSW_OnHand; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
					// END TT#2225 - stodd - VSW ANF Enhancement (IMO)

                    // Begin TT#457-MD - JSmith - Add additional Header information to the Allocation Workspace
                    string otsForecast = string.Empty;
                    if (ahp.PlanHnRID != Include.DefaultPlanHnRID)
                    {
                        otsForecast = headerData.GetNodeDisplay(ahp.PlanHnRID);
                    }

                    string onHand = string.Empty;
                    if (ahp.OnHandHnRID != Include.DefaultOnHandHnRID)
                    {
                        onHand = headerData.GetNodeDisplay(ahp.OnHandHnRID);
                    }

                    string gradeInvBasis = string.Empty;
                    if (ahp.GradeInventoryBasisHnRID > 0)
                    {
                        gradeInvBasis = headerData.GetNodeDisplay(ahp.GradeInventoryBasisHnRID);
                    }
                    // End TT#457-MD 
                    dr["PlanHnRID"] = otsForecast;
                    dr["OnHandHnRID"] = onHand;
                    dr["GradeInvHnRID"] = gradeInvBasis;
                    // End TT#457-MD - JSmith - Add additional Header information to the Allocation Workspace

                    DataRow hdrDataRow = _dtHeader.Rows.Find(aHdrRID);
                    if (hdrDataRow  != null)
                    {
                        ugHeaders.EventManager.SetEnabled(GridEventIds.InitializeRow, false);
                        for (int i = 0; i < _dsDetails.Tables["Header"].Columns.Count; i++)
                        {  
                            // BEGIN MID Track #5654, #5655, #5657 - MultiHeader errors 
                            //hdrDataRow[i] = dr[i];
                            if (dr.Table.Columns[i].ColumnName == "Balance" )
                            {
                                if (dr[i] != System.DBNull.Value && (int)dr[i] == 0)
                                {
                                    hdrDataRow[i] = System.DBNull.Value;
                                }
                                else
                                {
                                    hdrDataRow[i] = dr[i];
                                }
                            }
                            else
                            {
                                hdrDataRow[i] = dr[i];
                            }
                        }   // END MID Track #5654, #5655, #5657  
                        ugHeaders.EventManager.SetEnabled(GridEventIds.InitializeRow, true);
                    }
                }
                // begin MID Track 5760 Master Header not refreshed when Subordinate changed
                else
                {
                    dr = _dtHeader.Rows.Find(aHdrRID);
                    if (dr != null)
                    {
                        ugHeaders.EventManager.SetEnabled(GridEventIds.InitializeRow, false);
                        // Begin TT#2 - RMatelic - Assortment Planning
                        dr["HeaderID"] = ap.HeaderID;
                        dr["Description"] = ap.HeaderDescription;
                        // End TT#2 
                        dr["Type"] = Convert.ToInt32(ap.HeaderType, CultureInfo.CurrentUICulture);
                        dr["Status"] = Convert.ToInt32(ap.HeaderAllocationStatus, CultureInfo.CurrentUICulture);
                        dr["Intransit"] = Convert.ToInt32(ap.HeaderIntransitStatus, CultureInfo.CurrentUICulture);
                        dr["ShipStatus"] = Convert.ToInt32(ap.HeaderShipStatus, CultureInfo.CurrentUICulture);
                        dr["HdrQuantity"] = ap.TotalUnitsToAllocate;
                        dr["UnitRetail"] = ap.UnitRetail;
                        dr["UnitCost"] = ap.UnitCost;
                        dr["Multiple"] = ap.AllocationMultiple;
                        dr["PO"] = ap.PurchaseOrder;
                        dr["Vendor"] = ap.Vendor;
                        dr["Workflow"] = workflowMethodStr;
                        dr["APIWorkflow"] = APIworkflowMethodStr; // MID Track 4554 AnF Enhancement API Workflow
                        dr["DC"] = ap.DistributionCenter;
                        if (ap.ReleaseDate == Include.UndefinedDate)
                        {
                            dr["Release"] = string.Empty;
                        }
                        else
                        {
                            // Begin TT#5072 - JSmith - Release date field not recognized as date?
                            //dr["Release"] = ap.ReleaseDate.ToShortDateString();
                            dr["Release"] = ap.ReleaseDate.ToString("MM/dd/yyyy");
                            // End TT#5072 - JSmith - Release date field not recognized as date?
                        }
                        dr["Master"] = msgMasterSubord;
                        dr["AllocatedUnits"] = ap.AllocatedUnits;
                        dr["OrigAllocatedUnits"] = ap.OrigAllocatedUnits;
                        dr["RsvAllocatedUnits"] = ap.RsvAllocatedUnits;
                        // BEGIN MID Track #6106 - MultiHeader delete not getting rid of Multi reference
                        // Begin TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0
                        //if (!ap.InUseByMulti && dr["HdrGroupRID"] != System.DBNull.Value)
                        if (!ap.MultiHeader && !ap.InUseByMulti && dr["HdrGroupRID"] != System.DBNull.Value)
                        // End TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0
                        {
                            dr["HdrGroupRID"] = System.DBNull.Value;
                            dr["MultiSortSeq"] = System.DBNull.Value;
                        }
                        // END MID Track #6106

                        //BEGIN TT#154 – Add variables to Allocation workspace - apicchetti
                        dr["NumberOfStores"] = ap.GetCountOfStoresWithAllocation(new GeneralComponent(eGeneralComponentType.Total));
                        //END TT#154 – Add variables to Allocation workspace - apicchetti

                        // BEGIN Workspace Usability Enhancement - Ron Matelic
                        dr["NumPacks"] = packCount;
                        dr["NumBulkColors"] = bulkColorCount;
                        dr["NumBulkSizes"] = bulkColorSizeCount;
                        // END Workspace Usability Enhancement 

                        // Begin TT#1401 - RMatelic - Reservation Stores
                        dr["ImoId"] = ap.ImoID;
						// BEGIN TT1401 - stodd - TEMP removal of these fields from displaying on Alloc workspace
                        //dr["ItemUnitsAllocated"] = ap.TotalItemUnitsAllocatedDisplay;
                        //dr["ItemOrigUnitsAllocated"] = ap.TotalItemOrigUnitsAllocatedDisplay;
						// BEGIN TT1401 - stodd - TEMP removal of these fields from displaying on Alloc workspace
                        // BEGIN TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
                        int storetot = 0;
                        int vSWtot = 0;
                        storetot = ap.ItemAllocatedUnits - ap.RsvAllocatedUnits;
                        vSWtot = ap.AllocatedUnits - storetot;
                        dr["ItemUnitsAllocated"] = storetot;
                        dr["ItemOrigUnitsAllocated"] = vSWtot; ;
                        // END TT#3475 - agallagher - Add the Store Allocated Units and VSW Allocated Units breakdown to the Allocation Workspace
                        // End TT#1401 

						// Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                        dr["AsrtRID"] = DBNull.Value;
                        dr["GroupAllocRID"] = DBNull.Value;
                        if (ap.AsrtRID != 0 && ap.AsrtRID != Include.NoRID)
                        {
                            AllocationHeaderProfile asrtHdr = SAB.HeaderServerSession.GetHeaderData(ap.AsrtRID, false, false, true);
                            if ((eAssortmentType)asrtHdr.AsrtType == eAssortmentType.GroupAllocation)
                            {
                                dr["GroupAllocRID"] = ap.AsrtRID;
                            }
                            else
                            {
                                dr["AsrtRID"] = ap.AsrtRID;
                            }
                            UpdateAssortmentID(asrtHdr.Key, asrtHdr.HeaderID, asrtHdr.AsrtType);
                        }
						// End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces

                        // BEGIN TT#2225 - stodd - VSW ANF Enhancement (IMO)
						//dr["AdjustVSW"] = ap.AdjustVSW_OnHand; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
						if (ap.AdjustVSW_OnHand)
						{
                            //dr["AdjustVSW"] = (int)eAdjustVSW.Replace;    // Begine TT#1313-MD - RMatelic - Header Filters >>> unrelated - made correction
                            dr["AdjustVSW"] = (int)eAdjustVSW.Adjust;       // End TT#1313-MD 
						}
						else
						{
							if (ap.HeaderType == eHeaderType.IMO)
							{
								dr["AdjustVSW"] = (int)eAdjustVSW.Replace;
							}
							else
							{
								dr["AdjustVSW"] = Include.NoRID;
							}
						}
						// END TT#2225 - stodd - VSW ANF Enhancement (IMO)

                        // Begin TT#457-MD - JSmith - Add additional Header information to the Allocation Workspace
                        string otsForecast = string.Empty;
                        if (ahp.PlanHnRID != Include.DefaultPlanHnRID)
                        {
                            otsForecast = headerData.GetNodeDisplay(ahp.PlanHnRID);
                        }

                        string onHand = string.Empty;
                        if (ahp.OnHandHnRID != Include.DefaultOnHandHnRID)
                        {
                            onHand = headerData.GetNodeDisplay(ahp.OnHandHnRID);
                        }

                        string gradeInvBasis = string.Empty;
                        if (ahp.GradeInventoryBasisHnRID > 0)
                        {
                            gradeInvBasis = headerData.GetNodeDisplay(ahp.GradeInventoryBasisHnRID);
                        }
                        // End TT#457-MD 
                        dr["PlanHnRID"] = otsForecast;
                        dr["OnHandHnRID"] = onHand;
                        dr["GradeInvHnRID"] = gradeInvBasis;
                        // End TT#457-MD - JSmith - Add additional Header information to the Allocation Workspace

                        ugHeaders.EventManager.SetEnabled(GridEventIds.InitializeRow, true);
                    }
                }
                // end MID Track 5760 Master Header not refreshed when Subordinate changed
                // Begin TT#736 - RMatelic - Build Packs Apply unselects the header in the Allocation Workspace
                if (ap.WorkUpTotalBuy && (ap.BulkColors != null || (ap.Packs != null && ap.Packs.Count > 0)))
                {
                    // Begin TT#3147 - JSmith - WUB header-> applied packs from build pack method-> cancel allocation and get Unhandled Exception
                    
                    ArrayList alKeys = new ArrayList();
                    // Begin TT#3231 - JSmith - Allocation Workspace -> adding new headers Right click add->header-> system null reference exception
                    if (_removeAndReselectHeaders != null)
                    {
                    // End TT#3231 - JSmith - Allocation Workspace -> adding new headers Right click add->header-> system null reference exception
                        foreach (UltraGridRow dRow in _removeAndReselectHeaders)
                        {
                            alKeys.Add(Convert.ToInt32(dRow.Cells["KeyH"].Value));
                        }
                    // Begin TT#3231 - JSmith - Allocation Workspace -> adding new headers Right click add->header-> system null reference exception
                    }
                    // End TT#3231 - JSmith - Allocation Workspace -> adding new headers Right click add->header-> system null reference exception
                    // End TT#3147 - JSmith - WUB header-> applied packs from build pack method-> cancel allocation and get Unhandled Exception

                    foreach (UltraGridRow dRow in ugDetails.Rows)
                    {
                        if (Convert.ToInt32(dRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == ap.Key)
                        {
                            UltraGridRow hRow = null;
                            if (dRow.Cells["HeaderRow"].Value != System.DBNull.Value)
                            {
                                hRow = (UltraGridRow)dRow.Cells["HeaderRow"].Value;
                                hRow.Selected = true;

                                // Begin TT#1080 - RMatelic - Created a header and upon saving it is not recognized in the headers Selected Window
                                if (_afterSelectChangeEventArgs != null)
                                {
                                    AfterSelectChange(_sender, _afterSelectChangeEventArgs);
                                }
                                // End TT1080
                            }
                            break;
                        }
                    }

                    // Begin TT#3147 - JSmith - WUB header-> applied packs from build pack method-> cancel allocation and get Unhandled Exception
                    // Begin TT#3231 - JSmith - Allocation Workspace -> adding new headers Right click add->header-> system null reference exception
                    if (_removeAndReselectHeaders != null)
                    {
                    // End TT#3231 - JSmith - Allocation Workspace -> adding new headers Right click add->header-> system null reference exception
                        _removeAndReselectHeaders.Clear();
                        foreach (int KeyH in alKeys)
                        {
                            foreach (UltraGridRow dRow in ugDetails.Rows)
                            {
                                if (Convert.ToInt32(dRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == KeyH)
                                {
                                    _removeAndReselectHeaders.Add(dRow);
                                    break;
                                }
                            }
                        }
                        // End TT#3147 - JSmith - WUB header-> applied packs from build pack method-> cancel allocation and get Unhandled Exception
                    // Begin TT#3231 - JSmith - Allocation Workspace -> adding new headers Right click add->header-> system null reference exception
                    }
                    // End TT#3231 - JSmith - Allocation Workspace -> adding new headers Right click add->header-> system null reference exception
                }    
            }   // End TT#736 
            catch (Exception ex)
            {
                HandleException(ex);
            }

            // Begin TT#5697 - JSmith - Subordinate header release fails in Style Review
            return true;
            // End TT#5697 - JSmith - Subordinate header release fails in Style Review
        }

        //private void ReloadWorkUpTotalBuy(int aHeaderRID, Hashtable aBulkColors, ref int hdrChildTotal)  // TT#601 released WUB balance not zero
        private void ReloadWorkUpTotalBuy(AllocationProfile aAP, ref int hdrChildTotal)                    // TT#601 released WUB balance not zero
        {
            // begin TT#601 released WUB balance not zero
            int aHeaderRID = aAP.HeaderRID;
            hdrChildTotal = 0;
            // end TT#601 released WUB balance not zero
            try
            {
                object[] Keys = new object[2];
                // begin TT#601 release WUB balance not zero
                if (aAP.Packs != null && aAP.Packs.Count > 0)
                {
                    Hashtable packs = aAP.Packs;
                    Keys[0] = aHeaderRID;
                    int packColorTotal;
                    int packSizeTotal;
                    DataTable packTable = _dsDetails.Tables["Pack"];
                    DataTable packColorTable;
                    DataTable packSizeTable;  // TT#612 BP not refreshing WUB after apply
                    object[] packColorKeys = new object[3];
                    packColorKeys[0] = aHeaderRID;
                    foreach (PackHdr aPack in packs.Values)
                    {
                        Keys[1] = aPack.PackName;
                        packColorKeys[1] = aPack.PackRID;
                        hdrChildTotal += aPack.UnitsToAllocate;
                        packColorTotal = 0;
                        DataRow packRow = packTable.Rows.Find(Keys);
                        // begin TT#612 BP not refreshing WUB after apply
                        if (packRow == null)
                        {
                            int packType;
                            if (aPack.GenericPack)
                            {
                                packType = (int)eAllocationType.GenericType;
                            }
                            else
                            {
                                packType = (int)eAllocationType.DetailType;
                            }
                            packRow = packTable.Rows.Add(new object[] { aAP.HeaderRID, aPack.PackRID, Include.NoRID,
                                                          aPack.PackName, packType, aPack.PacksToAllocate,
                                                          aPack.PackMultiple, aPack.UnitsToAllocate, 
                                                          aPack.AssociatedPackRID, aPack.Sequence});
                        }
                        if (aPack.PackColors != null && aPack.PackColors.Count > 0)
                        {
                            packColorTable = _dsDetails.Tables["PackColor"];
                            foreach (PackColorSize aColor in aPack.PackColors.Values)
                            {
                                packColorTotal += aColor.ColorUnitsInPack;
                                packSizeTotal = 0;
                                packColorKeys[2] = aColor.ColorCodeRID;
                                DataRow colorRow = packColorTable.Rows.Find(packColorKeys);
                                ColorCodeProfile ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(aColor.ColorCodeRID);
                                if (colorRow == null)
                                {
                                    string packColorDescription = string.Empty;
                                    string colorID = string.Empty;

                                    if (ccp.VirtualInd)
                                    {
                                        colorID = aColor.ColorName;
                                        packColorDescription = aColor.ColorDescription;
                                    }
                                    else
                                    {
                                        colorID = ccp.ColorCodeID;
                                        packColorDescription = GetColorDescription(GetNodeData(aAP.StyleHnRID), ccp);
                                    }
                                    if (aColor.ColorCodeRID != Include.DummyColorRID)
                                    {
                                        colorRow = packColorTable.Rows.Add(new object[] { aAP.HeaderRID, aPack.PackRID,
                                                                      aColor.HdrPCRID, aColor.ColorCodeRID, 
                                                                      colorID, packColorDescription, 
                                                                      aColor.ColorUnitsInPack, aColor.ColorSequenceInPack, aColor.ColorName });
                                    }
                                }
                                if (aColor.ColorSizes != null && aColor.ColorSizes.Count > 0)
                                {  
                                    string dtSizeNamePrefix = aColor.ColorCodeRID == Include.DummyColorRID ? "PackSize" : "PackColorSize";
                                    string sizeTableName = dtSizeNamePrefix
                                        + "~" + aAP.HeaderRID.ToString(CultureInfo.CurrentUICulture)
                                        + "~" + aPack.PackRID.ToString(CultureInfo.CurrentUICulture)
                                        + "~" + aColor.HdrPCRID.ToString(CultureInfo.CurrentUICulture);
                                    packSizeTable = _dsDetails.Tables[sizeTableName]; 
                                    if (packSizeTable == null)
                                    {
                                        DataTable dtSizes = FormatPackSizeTable(aColor, aAP.SizeGroupRID, aAP.HeaderRID, aPack.PackRID, aColor.HdrPCRID, ccp.ColorCodeID, sizeTableName, ref packSizeTotal);
                                        if (dtSizes != null)
                                        {
                                            _dsDetails.Tables.Add(dtSizes);
                                            if (aColor.ColorCodeRID == Include.DummyColorRID)
                                            {
                                                _dsDetails.Relations.Add(sizeTableName,
                                                    new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                                                    new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyP"] }, true);
                                                packRow["ChildTotal"] = packSizeTotal;
                                                packRow["Balance"] = Convert.ToInt32(packRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - packSizeTotal;

                                            }
                                            else
                                            {
                                                _dsDetails.Relations.Add(sizeTableName,
                                                    new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"], _dsDetails.Tables["PackColor"].Columns["KeyC"] },
                                                    new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyP"], _dsDetails.Tables[sizeTableName].Columns["KeyC"] }, true);
                                                colorRow["ChildTotal"] = packSizeTotal;
                                                colorRow["Balance"] = Convert.ToInt32(colorRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - packSizeTotal;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        foreach (PackContentBin aSize in aColor.ColorSizes.Values)
                                        {
                                            packSizeTotal += aSize.ContentUnits;
                                        }
                                    }
                                }
                                colorRow["ChildTotal"] = packSizeTotal;
                                colorRow["Balance"] = Convert.ToInt32(colorRow["QuantityPerPack"], CultureInfo.CurrentCulture) - packSizeTotal;
                                if (aColor.ColorCodeRID == Include.DummyColorRID)
                                {
                                    packColorTotal = packSizeTotal;
                                }
                            }
                            packRow["ChildTotal"] = packColorTotal;
                            packRow["Balance"] = Convert.ToInt32(packRow["QuantityPerPack"], CultureInfo.CurrentUICulture) - packColorTotal;
                        }

                    }
                    _dsDetails.AcceptChanges();
                    // end TT#612 BP not refreshing WUB after apply
                }
                if (aAP.BulkColors != null && aAP.BulkColors.Count > 0)
                {
                    Hashtable aBulkColors = aAP.BulkColors;
                    // end TT#601 release WUB balance not zero
                    foreach (HdrColorBin aColor in aBulkColors.Values)
                    {
                        Keys[0] = aHeaderRID;
                        Keys[1] = aColor.ColorCodeRID;

                        DataRow drColor = _dsDetails.Tables["BulkColor"].Rows.Find(Keys);
                        drColor["Quantity"] = aColor.ColorUnitsToAllocate;
                        hdrChildTotal += aColor.ColorUnitsToAllocate;

                        int sizeKey, rowTotal, childTotal = 0;
                        string primary, secondary;

                        if (aColor.ColorSizes != null && aColor.ColorSizes.Count > 0)
                        {
                            string sizeTableName = "BulkSize" + "~"
                                + aHeaderRID.ToString(CultureInfo.CurrentUICulture) + "~"
                                + aColor.HdrBCRID.ToString(CultureInfo.CurrentUICulture);

                            DataTable dtBulkSize = _dsDetails.Tables[sizeTableName];

                            // BEGIN MID Track #6026 - WorkUpBuy issues
                            if (dtBulkSize == null)
                            {
                                bool addSizeTable = false;
                                IEnumerable enumerator = ugDetails.DisplayLayout.Bands["BulkColor"].GetRowEnumerator(GridRowType.DataRow);
                                foreach (UltraGridRow row in enumerator)
                                {
                                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aHeaderRID
                                      && Convert.ToInt32(row.Cells["KeyC"].Value, CultureInfo.CurrentUICulture) == aColor.HdrBCRID)
                                    {
                                        this.ugDetails.ActiveRow = row;
                                        addSizeTable = true;
                                        break;
                                    }
                                }
                                if (addSizeTable)
                                {
                                    cmsAddBulkSize_Click(cmsAddBulkSize, null);
                                    dtBulkSize = _dsDetails.Tables[sizeTableName];
                                }
                            }
                            // END MID Track #6026
                            foreach (DataRow dRow in dtBulkSize.Rows)
                            {
                                rowTotal = 0;
                                secondary = Convert.ToString(dRow[3], CultureInfo.CurrentUICulture);
                                for (int i = 6; i < dtBulkSize.Columns.Count; i++)
                                {
                                    DataColumn dCol = dtBulkSize.Columns[i];
                                    primary = dCol.ColumnName;
                                    sizeKey = Convert.ToInt32(dCol.ExtendedProperties[primary + "~" + secondary], CultureInfo.CurrentUICulture);

                                    if (aColor.ColorSizes.ContainsKey(sizeKey))
                                    {
                                        HdrSizeBin aSize = (HdrSizeBin)aColor.ColorSizes[sizeKey];
                                        dRow[i] = aSize.SizeUnitsToAllocate;
                                        rowTotal += aSize.SizeUnitsToAllocate;
                                    }
                                }
                                dRow["TotalQuantity"] = rowTotal;
                                childTotal += rowTotal;
                            }
                            drColor["ChildTotal"] = childTotal;
                            drColor["Balance"] = Convert.ToInt32(drColor["Quantity"], CultureInfo.CurrentUICulture) - childTotal;
                        }
                    }
                }   // TT#601 released WUB balance not zero
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void UpdateHeaderCharacteristics(UltraGridRow aRow)
        {
            try
            {
                int hdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                
                ArrayList charArrayList = new ArrayList();
                DataRow dr = _dsDetails.Tables["Header"].Rows.Find(hdrRID);

                for (int i = _nonCharColCount; i < _dsDetails.Tables["Header"].Columns.Count; i++)
                {
                    DataColumn col = (DataColumn)_dsDetails.Tables["Header"].Columns[i];
                    if (col.ExtendedProperties.ContainsKey("IsChar"))
                    {
                        if (dr[i] != System.DBNull.Value && dr[i].ToString() != string.Empty)
                        {
                            int charRID = 0;
                            HeaderCharGroupProfile hcgp = (HeaderCharGroupProfile)col.ExtendedProperties["IsChar"];
                            if (hcgp.ListInd)
                            {
                                charRID = (int)dr[i];
                            }
                            else
                            {
                                string charString = hcgp.Key.ToString() + "~" + Convert.ToString(dr[i], CultureInfo.CurrentUICulture);
                                charRID =  (int)col.ExtendedProperties[charString];
                            }
                            charArrayList.Add(charRID);
                        }
                    }
                }
                _SAB.HeaderServerSession.RefreshHeaderCharacteristics(hdrRID, charArrayList);
                aRow.Cells["CharUpdated"].Value = false;
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        // BEGIN Workspace Usability Enhancement - Ron Matelic
        private void ShowHideDetails()
        {
            try
            {
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //if (_dtView.Rows[cboView.SelectedIndex]["SHOW_DETAILS"] != System.DBNull.Value)
				// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
				//int viewSelectedIndex = ((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).SelectedIndex;
                //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
                //MIDComboBoxEnh.MyComboBox cmbView = (MIDComboBoxEnh.MyComboBox)cct.Control;
                MIDComboBoxEnh.MyComboBox cmbView = GetViewComboBoxControl();
                int viewSelectedIndex = cmbView.SelectedIndex;
				// End TT#4071 - stodd - Matrix does not allow search for attribute - 
				if (_dtView.Rows[viewSelectedIndex]["SHOW_DETAILS"] != System.DBNull.Value)
                {
                    //bool showDetails = Include.ConvertCharToBool(Convert.ToChar(_dtView.Rows[(int)cboView.SelectedIndex]["SHOW_DETAILS"], CultureInfo.CurrentUICulture));
					bool showDetails = Include.ConvertCharToBool(Convert.ToChar(_dtView.Rows[viewSelectedIndex]["SHOW_DETAILS"], CultureInfo.CurrentUICulture));
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
                    if (showDetails)
                    {
                        if (!_detailsShown)
                        {
                            ShowDetails();
                        }
                    }
                    else if (_detailsShown)
                    {
                        HideDetails();
                    }
                }
            }
            catch
            {
                throw;
            }
        }
        // END Workspace Usability Enhancement

    	private void ShowDetails()
		{
			try
			{
                this.SuspendLayout();

                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                _fromHeaderGrid = true;
                BuildDetailsGrid();
                _fromHeaderGrid = false;
                // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
                // Begin TT#2019 - JSmith - received Systme Null Reference when clicking on Edit button in Show Detail section of Allocation Workspace
                //btnEditSave.Enabled = true;
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnEditSave"]).SharedProps.Enabled = true;
                // End TT#1434
                // End TT#1126-MD
                this.splitContainer.Panel2Collapsed = false;
  
                if (this.Height > _showP2Height)
                {
                    _showP2Height = this.Height;
                }

                this.EAB.Explorer.ResizeWorkspacePane(new Size(this.Width, _showP2Height));
                
				_detailsShown = true;
                cmsDetails.Checked = true;
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //btnShowDetails.Enabled = false;      // Usability Enhancement
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["showDetails"]).SharedProps.Enabled = false;
				// END TT#767-MD - Stodd - remove old controls from allocation workspace

                // Begin TT#2682 - RMatelic - Show Details of a header
                //_expandAll = true;                   // Usability Enhancement
                //cmsExpand_Click(cmsExpand, null);    // Usability Enhancement

                if (_expandAll)
                {
                    cmsExpand_Click(cmsExpand, null);
                }
                // End TT#2682  
				this.ResumeLayout();
			}
			catch ( Exception ex ) 
			{
				HandleException(ex);
			} 
		}

		private void HideDetails()
		{
			try
			{
				this.SuspendLayout();

                if (!_fromLoadEvent)
                {
                    _showP2Height = this.Height + 18;
                   
                } 
                this.splitContainer.Panel2Collapsed = true;
               
               // int height = this.panel1.Height + this.splitContainer.SplitterDistance + this.splitContainer.SplitterWidth + 14;
                int height = this.panel1.Height + this.splitContainer.SplitterDistance + 18;
        
                this.EAB.Explorer.ResizeWorkspacePane(new Size(this.Width, height));

                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                ClearDetails();
                // End TT#1434

				_detailsShown = false;
                cmsDetails.Checked = false;
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //btnShowDetails.Enabled = true;      // Usability Enhancement
				((Infragistics.Win.UltraWinToolbars.ButtonTool)this.headerToolbarsManager.Tools["showDetails"]).SharedProps.Enabled = true;
				// END TT#767-MD - Stodd - remove old controls from allocation workspace

				this.ResumeLayout();
			}
			catch ( Exception ex ) 
			{
				HandleException(ex);
			}
		}

        // BEGIN TT#1135 - AGallagher - Export headers from allocation workspace
        private void btnExcel_Click(object sender, System.EventArgs e)
        {
            ExportToExcel();
        }
        private void ExportToExcel()
        {
            string caption = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_Caption);
            string messageBoxText = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_Text);
            string button1text = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_But1);
            string button2text = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_But2);
            string button3text = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_But3);
            string NoSelectError = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_No_Sel);
			int answer = 0;

			MIDMessageBox mmb = new MIDMessageBox(caption, messageBoxText, new Color[3] {Color.Empty, Color.Empty, Color.Empty,}, //button colors            
					new string[3] { button1text, button2text, button3text,}, 0, null, MIDGraphics.GetIcon(MIDGraphics.ExcelImage), true);

			answer = mmb.Show();

            string errorMsg = string.Empty;

            if (answer == 0)
            { CreateExcelAllHeader(FindSavePath()); }

            if (answer == 1)
            { if (ugHeaders.Selected.Rows.Count > 0)
            {
                CreateExcelHeaderSelected(FindSavePath());
            }
            else
            {
                errorMsg = NoSelectError;
                MessageBox.Show(errorMsg, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            }

            if (answer == 2)
            {
                // BEGIN TT#5543 - AGallagher - Detail - Selected Headers Option for Export to Excel
                //if (ugDetails.Selected.Rows.Count > 0)
                if (ugHeaders.Selected.Rows.Count > 0)
                // END TT#5543 - AGallagher - Detail - Selected Headers Option for Export to Excel
                {
                    BuildDetailsGrid();  // T#5543 - AGallagher - Detail - Selected Headers Option for Export to Excel
                    CreateExcelHeaderSelectedDetail(FindSavePath());
                }
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                else if (!_detailsShown &&
                    ugHeaders.Selected.Rows.Count > 0)
                {
                    BuildDetailsGrid();
                    CreateExcelHeaderSelectedDetail(FindSavePath());
                }
                // End TT#1434
                else
                {
                    errorMsg = NoSelectError;
                    MessageBox.Show(errorMsg, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }
                
        private void CreateExcelAllHeader(String myFilepath)
        {
            string MessBoxAlltext1 = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_All);
            string MessBoxAlltext2 = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_Exp_Lit);
            try
            {
                if (myFilepath != null)
                {
                    _checkForExportSelected = false;
                    this.ultraGridExcelExporter1.Export(this.ugHeaders, myFilepath);
                    MessageBox.Show(MessBoxAlltext1 + myFilepath + MessBoxAlltext2 + ugHeaders.Rows.Count);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        private void CreateExcelHeaderSelected(String myFilepath)
        {
            string MessBoxSHtext1 = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_HS);
            string MessBoxSHtext2 = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_Exp_Lit);
            try
            {
                if (myFilepath != null)
                {
                    _checkForExportSelected = true;
                    this.ultraGridExcelExporter1.Export(this.ugHeaders, myFilepath);
                    MessageBox.Show(MessBoxSHtext1 + myFilepath + MessBoxSHtext2 + ugHeaders.Selected.Rows.Count);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        private void CreateExcelHeaderSelectedDetail(String myFilepath)
        {
            string MessBoxSHDtext1 = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_HSD);
            string MessBoxSHDtext2 = MIDText.GetTextOnly(eMIDTextCode.lbl_MB_Excel_Exp_Lit);
            try
            {
                if (myFilepath != null)
                {
                    _checkForExportSelected = false;
                    this.ultraGridExcelExporter1.Export(this.ugDetails, myFilepath);
                    MessageBox.Show(MessBoxSHDtext1 + myFilepath + MessBoxSHDtext2 + ugDetails.Selected.Rows.Count);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        private void ultraGridExcelExporter1_RowExporting(object sender, RowExportingEventArgs e)
        {
            // The GridRow property on the event args is a clone of the on-screen row, and it will not pick up the Selected State 
            UltraGridRow exportRow = e.GridRow;

            //  Get the grid
            UltraGrid grid = (UltraGrid)e.GridRow.Band.Layout.Grid;

            // Get the real, on-screen row, from the export row. 
            UltraGridRow onScreenRow = grid.GetRowFromPrintRow(exportRow);

            // If the on-screen row is not selected, do not export it. 
            if (onScreenRow.Selected == false && _checkForExportSelected == true)
                e.Cancel = true;
        }

        private String FindSavePath()
        {
        Stream myStream;
        string myFilepath=null;
        try
        {
           SaveFileDialog saveFileDialog1 = new SaveFileDialog();
           saveFileDialog1.Filter = "excel files (*.xls)|*.xls";
           saveFileDialog1.FilterIndex = 2 ;
           saveFileDialog1.RestoreDirectory = true ;
           if(saveFileDialog1.ShowDialog() == DialogResult.OK)
           {
                if((myStream = saveFileDialog1.OpenFile()) != null)
                {
                      myFilepath=saveFileDialog1.FileName; 
                      myStream.Close(); 
                }
           }
        }
        catch(Exception ex)
        {
             throw ex;
        }
        return myFilepath;
        }
        // END TT#1135 - AGallagher - Export headers from allocation workspace

		// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
		//private void btnProcess_Click(object sender, System.EventArgs e)
		//{
		//    ProcessAction(Convert.ToInt32(cboActionList.SelectedValue, CultureInfo.CurrentUICulture));
		//}
		// END TT#767-MD - Stodd - remove old controls from allocation workspace

        private void ProcessAction(int action)
        {
            string message = string.Empty;
            int colorRID;
            ApplicationSessionTransaction processTransaction = null;
            GeneralComponent aComponent = new GeneralComponent(eGeneralComponentType.Total);
            //bool headersEnqueued = false;   // TT#179 - RMatelic - Apply changes for Track 6419  // TT#1185 - Verify ENQ before Update
            bool blActionSelected = false;  // TT#2658 - JSmith - Action Required in Allocation Workspace
            // Begin TT#1966-MD - JSmith - DC Fulfillment
            // Save list of all header keys involved in master relationship so that all can be refreshed
            bool isMasterOrSubordinate = false;
            // End TT#1966-MD - JSmith - DC Fulfillment
            try
            {
                if (action == Include.NoRID)
                {
                    MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_ActionIsRequired), _thisTitle);
                    return;
                }

                blActionSelected = true;  // TT#2658 - JSmith - Action Required in Allocation Workspace

                // Begin TT#179 - RMatelic - Apply changes for Track 6419 to Release 3.1 (able to modify Released Headers)
                //if (!OKToProcess((eAllocationActionType)action))
                //{
                //    return;
                //}
                //if (!HeadersEnqueued(true))
                //{
                //    return;
                //}
                //headersEnqueued = false;     // TT#1185 - Verify ENQ before Update
                //if (!HeadersEnqueued(true))  // TT#1185 - Verify ENQ before Update
                processTransaction = GetApplicationSessionTransaction(); // TT#1185 Verify ENQ before Update
                if (!EnqueueHeadersForAction(processTransaction))
                {
                    return;
                }
                else
                {
                    // begin TT#1185 - Verify ENQ before Update
                    PutHeadersInPrioritySequence();
					// Begin TT#974 - MD - stodd - cancel GA header and get action failed
                    //int[] selectedHeaders = new int[_selectedHeaderKeyList.Count];
                    //_selectedHeaderKeyList.CopyTo(selectedHeaders, 0);
                    //// begin TT#488 - MD - Jellis - Group Allocation
                    //int[] selectedAssortmentRIDs = new int[_selectedAssortmentKeyList.Count];
                    //_selectedAssortmentKeyList.CopyTo(selectedAssortmentRIDs, 0);
                    //// end TT#488 - MD - Jellis - Group Allocation
                    //LoadSelectedHeadersToTransaction(ref processTransaction, selectedAssortmentRIDs, selectedHeaders); // TT#488 - MD - Jellis - Group Allocation
					// End TT#974 - MD - stodd - cancel GA header and get action failed
					// Begin TT#980 - MD - stodd - null ref running size need -
                    processTransaction.LoadHeadersInTransaction(_selectedHeaderKeyList, _selectedAssortmentKeyList, true);
                    //LoadHeadersInTransaction(ref processTransaction, true);  
					// End TT#980 - MD - stodd - null ref running size need -
                    //headersEnqueued = true;
                    // end TT#1185 - Verify ENQ before Update
                }
                if (!OKToProcess((eAllocationActionType)action))
                {
                    return;
                }
                // End TT#179  

                //processTransaction = NewTransFromSelectedHeaders();  // TT#1185 - Verify ENQ before Update

                // Begin TT#1705 - JSmith - Reset Header with Piggybacking
                // set up event in allocation profile to trigger when header changes
                foreach (AllocationProfile ap in processTransaction.GetMasterProfileList(eProfileType.Allocation))
                {
                    ap.HeaderChangeEvent.OnHeaderChangeHandler += new HeaderChangeEvent.HeaderChangeEventHandler(OnHeaderChange);
                }
                // End TT#1705
                
                Cursor.Current = Cursors.WaitCursor;
                // set ACTION in transaction
                ApplicationBaseAction aMethod = processTransaction.CreateNewMethodAction((eMethodType)action);
                if (_processComponent)
                {
                    UltraGridRow row = ugDetails.ActiveRow;
                    switch (row.Band.Key)
                    {
                        case "Pack":
                            aComponent = new AllocationPackComponent(row.Cells["Pack"].Value.ToString());
                            break;
                        case "BulkColor":
                            // BEGIN MID Track #6026 - WorkUpBuy issues
                            //colorRID = Convert.ToInt32(row.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                            colorRID = Convert.ToInt32(row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                            // END MID Track #6026  
                            aComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorRID);
                            break;
                        case "PackColor":
                            // BEGIN MID Track #6026 - WorkUpBuy issues
                            //colorRID = Convert.ToInt32(row.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                            colorRID = Convert.ToInt32(row.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                            // END MID Track #6026  
                            aComponent = new AllocationColorOrSizeComponent(eSpecificBulkType.SpecificColor, colorRID);
                            break;
                        default:
                            break;
                    }
                }
                else
                {
                    aComponent = new GeneralComponent(eGeneralComponentType.Total);
                }

				processTransaction.ActionOrigin = eActionOrigin.AllocationWorkspace;	// TT#488-MD - Stodd - Group Allocation
                bool aReviewFlag = false;
                bool aUseSystemTolerancePercent = true;
                double aTolerancePercent = Include.DefaultBalanceTolerancePercent;
                int aStoreFilter = Include.AllStoreFilterRID;
                int aWorkFlowStepKey = -1;
                AllocationWorkFlowStep aAllocationWorkFlowStep
                    = new AllocationWorkFlowStep(aMethod, aComponent, aReviewFlag, aUseSystemTolerancePercent, aTolerancePercent, aStoreFilter, aWorkFlowStepKey);

                // Begin TT#1966-MD - JSmith - DC Fulfillment
                // Save list of all header keys involved in master relationship so that all can be refreshed
                foreach (int hdrRID in _selectedHeaderKeyList)
                {
                    AllocationHeaderProfile ahp = SAB.HeaderServerSession.GetHeaderData(hdrRID, false, false, true);
                    if (ahp.IsSubordinateHeader)
                    {
                        isMasterOrSubordinate = true;
                    }
                    if (ahp.IsMasterHeader)
                    {
                        isMasterOrSubordinate = true;
                    }
                }
                // End TT#1966-MD - JSmith - DC Fulfillment
              
                processTransaction.DoAllocationAction(aAllocationWorkFlowStep);

                eAllocationActionStatus actionStatus = processTransaction.AllocationActionAllHeaderStatus;
                message = MIDText.GetTextOnly((int)actionStatus);
                MessageBox.Show(message, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Information);
                // begin TT#241 - MD - JEllis - Header Enqueue Process
                //if (actionStatus == eAllocationActionStatus.HeaderEnqueueFailed
                //    || actionStatus == eAllocationActionStatus.NoHeaderResourceLocks)
                //{
                //    Close();
                //}
                // end TT#241 - MD - JEllis - Header Enqueue Process
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                // Begin TT#2658 - JSmith - Action Required in Allocation Workspace
                if (blActionSelected)
                {
                    // End TT#2658 - JSmith - Action Required in Allocation Workspace
                    // begin TT#1185 - Verify ENQ before Update
                    //// Begin TT#179 - RMatelic - Apply changes for Track 6419 to Release 3.1 
                    ////DequeueHeaders();
                    //if (headersEnqueued)
                    //{
                    //    DequeueHeaders();
                    //}
                    //// End TT#179 
                    processTransaction.DequeueHeaders();
                    // end TT#1185 - Verify ENQ before Update

                    //===================JAE=================//
                    // must reload headers that were updated //

                    // Begin TT#1705 - JSmith - Reset Header with Piggybacking
                    // make sure the event to complete before continuing.
                    while (_refreshingGrid)
                    {
                        System.Threading.Thread.Sleep(100);
                    }
                    // End TT#1705


                    bool workupSelected = false;

                    // Begin TT#705 - RMatelic - WUB when Cancel a WUB header the total quantity goes to 0 but the components do not
                    _processingAction = true;
                    _removeAndReselectHeaders = new ArrayList();
                    // End TT#705

                    // Begin TT#631-MD - JSmith - receive an Unhandled Exception on a Work Up Buy Header
                    ArrayList alSelectedHeaderKeyList = new ArrayList();
                    foreach (int hdrRID in _selectedHeaderKeyList)
                    {
                        alSelectedHeaderKeyList.Add(hdrRID);
                    }
                    //foreach (int hdrRID in _selectedHeaderKeyList)
                    foreach (int hdrRID in alSelectedHeaderKeyList)
                    // End TT#631-MD - JSmith - receive an Unhandled Exception on a Work Up Buy Header
                    {
                        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                        //DataRow dr = _dsDetails.Tables["Header"].Rows.Find(hdrRID);
                        DataRow dr = _dtHeader.Rows.Find(hdrRID);
                        // End TT#1434

                        if ((eHeaderType)Convert.ToInt32(dr["Type"], CultureInfo.CurrentUICulture) == eHeaderType.WorkupTotalBuy)
                        {
                            workupSelected = true;
                        }
                        //BEGIN MID Track #6394 - Update Header Characteristic comment out for now
                        _customWindowsRoutines.CheckCustomCharacteristic(dr);
                        // Begin TT#5550 - JSmith - Custom API Upload - Asst Name Not Removed in Wrkspc When Canceled
                        if (_dsDetails != null)
                        {
                            dr = _dsDetails.Tables["Header"].Rows.Find(hdrRID);
                            if (dr != null)
                            {
                                _customWindowsRoutines.CheckCustomCharacteristic(dr);
                            }
                        }
                        // End TT#5550 - JSmith - Custom API Upload - Asst Name Not Removed in Wrkspc When Canceled
                        //END MID Track #6394
                        ReloadProfileToGrid(hdrRID);
                        // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                        //dr = _dsDetails.Tables["Header"].Rows.Find(hdrRID);
                        dr = _dtHeader.Rows.Find(hdrRID);
                        // End TT#1434
                        // begin MID track 4101 Delete of Multi (and other actions) does not refresh child
                        if (((eHeaderType)Convert.ToInt32(dr["Type"], CultureInfo.CurrentUICulture) == eHeaderType.MultiHeader))
                        {
                            Header hd = new Header();
                            DataTable dtChildren = hd.GetHeaderGroupChildren(hdrRID);
                            foreach (DataRow drChild in dtChildren.Rows)
                            {
                                int childRID = Convert.ToInt32(drChild["HDR_RID"], CultureInfo.CurrentUICulture);
                                // begin TT#19 - Intransit status incorrect on 2nd header of a multi after Releasing multi
                                //AllocationProfile apInUse = (AllocationProfile)_allocProfileList.FindKey(childRID);
                                //if (apInUse != null)
                                //{
                                //    ReloadProfileToGrid(apInUse.Key);
                                //}
                                //BEGIN MID Track #6394 - Update Header Characteristic - comment out for now
                                _customWindowsRoutines.CheckCustomCharacteristic(drChild);
                                //END MID Track #6394
                                ReloadProfileToGrid(childRID);
                                // end TT#19 - Intransit status incorrect on 2nd header of a multi after Releasing multi
                            }
                        }
                        // end MID Track 4101 Delete of Multi (and other actions) does not refresh child
                    }

                    foreach (int hdrRID in _masterKeyList)
                    {
                        ReloadProfileToGrid(hdrRID);
                    }

                    if (processTransaction != null)
                    {
                        // begin TT#2671 - Jellis - Release Action Fails yet released
                        foreach (AllocationProfile ap in processTransaction.LinkedHeaderList)
                        {
                            ReloadProfileToGrid(ap.HeaderRID);
                        }
                        // end TT#2671 - Jellis - Release Action Fails yet released
                        processTransaction.Dispose();
                    }

                    if (workupSelected)
                    {
                        // Begin TT#705 - RMatelic - WUB when Cancel a WUB header the total quantity goes to 0 but the components do not
                        if (_removeAndReselectHeaders.Count > 0)
                        {
                            foreach (UltraGridRow row in _removeAndReselectHeaders)
                            {
                                UltraGridRow hRow = null;
                                if (row.Cells["HeaderRow"].Value != System.DBNull.Value)
                                {
                                    hRow = (UltraGridRow)row.Cells["HeaderRow"].Value;
                                }
                                RemoveDetailGridRows(row);
                                if (hRow != null)
                                {
                                    hRow.Selected = true;
                                    // Begin TT#1080 - RMatelic - Created a header and upon saving it is not recognized in the headers Selected Window
                                    if (_afterSelectChangeEventArgs != null)
                                    {
                                        AfterSelectChange(_sender, _afterSelectChangeEventArgs);
                                    }
                                    // End TT1080
                                }
                            }
                        }
                        // End TT#705
                        UpdateSelectedTotals();
                    }
                // Begin TT#2658 - JSmith - Action Required in Allocation Workspace

                    // Begin TT#1966-MD - JSmith - DC Fulfillment
                    if (isMasterOrSubordinate
                        && (eAllocationActionType)action == eAllocationActionType.Release)
                    {
                        LoadHeadersOnGrid();
                    }
                    // End TT#1966-MD - JSmith - DC Fulfillment
                }
                // End TT#2658 - JSmith - Action Required in Allocation Workspace

                _processingAction = false;  // TT#705 - RMatelic - WUB when Cancel a WUB header the total quantity goes to 0 but the components do not

                Cursor.Current = Cursors.Default;
            }
        }

        private bool OKToProcess(eAllocationActionType aAction)
        {
            string errorMessage = string.Empty;
            string errorParm = string.Empty;
            bool okToProcess = true;
            UltraGridRow selRow = null;
            try
            {
                // Begin TT#179 - RMatelic - Apply changes for Track 6419 to Release 3.1 
                _processComponent = false;
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                //if (ugDetails.Selected.Rows.Count > 0)
                if (_detailsShown && 
                    ugDetails.Selected.Rows.Count > 0)
                // End TT#1434
                {
                    foreach (UltraGridRow row in ugDetails.Selected.Rows)
                    {
                        selRow = row;
                        string[] bandKeyParts = selRow.Band.Key.Split(new char[] { '~' });

                        switch (bandKeyParts[0])
                        {
                            case "Header":
                                //case "Placeholder":
                                _processComponent = false;
                                break;
                            case "BulkColor":
                            case "Pack":
                                selRow = selRow.ParentRow;
                                _processComponent = true;
                                break;
                            case "PackColor":
                                okToProcess = false;
                                errorMessage = string.Format
                                    (MIDText.GetText(eMIDTextCode.msg_ActionNotAllowed),
                                    MIDText.GetTextOnly(eMIDTextCode.lbl_PackColor));
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                break;
                            case "PackColorSize":
                                okToProcess = false;
                                errorMessage = string.Format
                                    (MIDText.GetText(eMIDTextCode.msg_ActionNotAllowed),
                                     MIDText.GetTextOnly(eMIDTextCode.lbl_PackSize));
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                break;
                            case "PackSize":
                                okToProcess = false;
                                errorMessage = string.Format
                                    (MIDText.GetText(eMIDTextCode.msg_ActionNotAllowed),
                                    MIDText.GetTextOnly(eMIDTextCode.lbl_PackSize));
                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                break;
                        }
                    }
                    if (okToProcess && _processComponent && ugDetails.Selected.Rows.Count > 1)
                    {
                        errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_SelectSingleComponent);
                        MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        okToProcess = false;
                    }
                }

                if (okToProcess)
                {    // End TT#179
                    foreach (int key in _selectedHeaderKeyList)
                    {
                        AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(key);
                        if (ap != null)
                        {
                            ap.ReReadHeader();  // TT#179 - RMatelic - Apply changes for Track 6419 to Release 3.1 
                            switch (ap.HeaderAllocationStatus)
                            {
                                case eHeaderAllocationStatus.ReceivedOutOfBalance:
                                    if (aAction != eAllocationActionType.BackoutAllocation)  // allow backout allocation when recv'd out of balance
                                    {
                                        okToProcess = false;
                                    }
                                    break;
                                case eHeaderAllocationStatus.ReleaseApproved:
                                    if (aAction != eAllocationActionType.Reset &&
                                        aAction != eAllocationActionType.Release)
                                    {
                                        okToProcess = false;
                                    }
                                    break;
                                case eHeaderAllocationStatus.Released:
                                    if (aAction != eAllocationActionType.Reset)
                                    {
                                        okToProcess = false;
                                    }
                                    break;
                                default:
                                    if (aAction == eAllocationActionType.Reset
                                        && ap.HeaderAllocationStatus != eHeaderAllocationStatus.Released)  // TT#1966-MD - JSmith- DC Fulfillment
                                    {
                                        okToProcess = false;
                                    }
                                    else if (aAction == eAllocationActionType.ChargeIntransit)
                                    {
                                        if (ap.HeaderAllocationStatus != eHeaderAllocationStatus.AllInBalance
                                            && ap.HeaderAllocationStatus != eHeaderAllocationStatus.AllocatedInBalance)
                                            okToProcess = false;
                                    }
                                    break;
                            }
                            if (!okToProcess)
                            {
                                errorMessage = string.Format
                                    (MIDText.GetText(eMIDTextCode.msg_HeaderStatusDisallowsAction),
                                    MIDText.GetTextOnly((int)ap.HeaderAllocationStatus));

                                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                okToProcess = false;
                                break;
                            }
                            if (okToProcess)
                            {
                                if (!_SAB.ClientServerSession.GlobalOptions.IsReleaseable(ap.HeaderType)
                                    && aAction == eAllocationActionType.Release)
                                {
                                    if (ap.IsDummy)
                                    {
                                        errorParm = MIDText.GetTextOnly((int)eHeaderType.Dummy) + " "
                                            + MIDText.GetTextOnly(eMIDTextCode.lbl_Header);
                                    }
                                    else
                                    {
                                        errorParm = MIDText.GetTextOnly((int)ap.HeaderType);
                                    }
                                    errorMessage = string.Format
                                        (MIDText.GetText(eMIDTextCode.msg_ActionNotAllowed),
                                        errorParm);
                                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    okToProcess = false;
                                    break;
                                }
                                // Begin TT#1966-MD - JSmith- DC Fulfillment
                                else if (ap.IsMasterHeader && ap.DCFulfillmentProcessed)
                                {
                                    errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_al_DCFulfillmentProcessedActionNotAllowed), ap.HeaderID);

                                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);

                                    okToProcess = false;
                                }
                                else if (ap.IsSubordinateHeader && !ap.DCFulfillmentProcessed)
                                {
                                    errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_al_DCFulfillmentNotProcessedActionNotAllowed), ap.HeaderID);

                                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);

                                    okToProcess = false;
                                }
                                // End TT#1966-MD - JSmith- DC Fulfillment
                            }

                            if (okToProcess)
                            {
                                if (aAction == eAllocationActionType.BackoutAllocation)
                                {
                                    // Begin TT#1966-MD - JSmith- DC Fulfillment
                                    //if (ap.SubordinateRID != Include.NoRID)
                                    //{
                                    //errorParm = MIDText.GetTextOnly(eMIDTextCode.msg_al_MasterStillAssigned);
                                    //    errorParm = errorParm.Replace("{0}", ap.HeaderID);
                                    //    errorParm = errorParm.Replace("{1}", ap.SubordinateID); // MID Track 4029 ReWork master-Po Logic

                                    //    errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_ActionNotAllowed), errorParm);

                                    //    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);

                                    //    okToProcess = false;
                                    //}
                                    if (ap.IsMasterHeader && ap.DCFulfillmentProcessed)
                                    {
                                        errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_al_DCFulfillmentProcessedActionNotAllowed), ap.HeaderID);

                                        MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);

                                        okToProcess = false;
                                    }
                                    else if (ap.IsSubordinateHeader && !ap.DCFulfillmentProcessed)
                                    {
                                        errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_al_DCFulfillmentNotProcessedActionNotAllowed), ap.HeaderID);

                                        MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);

                                        okToProcess = false;
                                    }
                                    // End TT#1966-MD - JSmith- DC Fulfillment
                                }
                                // Begin TT#785 - Header Load Interfacing a transaction  trying to Modify a WUB header with a PO type
                                else if (aAction == eAllocationActionType.ReapplyTotalAllocation && ap.HeaderType == eHeaderType.WorkupTotalBuy)
                                {
                                    errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_al_CannotPerformActionOnHeader),
                                                    MIDText.GetTextOnly((int)aAction),
                                                    ap.HeaderID,
                                                    MIDText.GetTextOnly((int)ap.HeaderType)); 
                                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    okToProcess = false;
                                    break;
                                }
                                // End TT#785  
                            }

                            if (okToProcess)
                            {
                                int masterRID = Include.NoRID;
                                masterRID = ap.MasterRID;
                                if (masterRID != Include.NoRID)
                                {
                                    if (!_masterKeyList.Contains(masterRID))
                                    {
                                        _masterKeyList.Add(masterRID);
                                    }
                                }
                            }

                        }
                    }
                }  // TT#179
                if (okToProcess)
                {
                    if (aAction == eAllocationActionType.BackoutAllocation
                        || aAction == eAllocationActionType.BackoutSizeAllocation
                        || aAction == eAllocationActionType.BackoutSizeIntransit
                        || aAction == eAllocationActionType.BackoutStyleIntransit
                        || aAction == eAllocationActionType.Reset)
                    {
                        errorMessage = string.Format(MIDText.GetText(eMIDTextCode.msg_ActionWarning),
                                                     MIDText.GetTextOnly((int)aAction));
                        DialogResult diagResult = MessageBox.Show(errorMessage, _thisTitle,
                            MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                        if (diagResult == System.Windows.Forms.DialogResult.No)
                        {
                            okToProcess = false;
                        }
                    }
                }
                // Begin TT#179 - RMatelic - Apply changes for Track 6419 to Release 3.1 - move code to above 
                //if (okToProcess && ugDetails.Selected.Rows.Count > 0)
                //{
                //    foreach (UltraGridRow row in ugDetails.Selected.Rows)
                //    {
                //        selRow = row;
                //        string[] bandKeyParts = selRow.Band.Key.Split(new char[] { '~' });

                //        switch (bandKeyParts[0])
                //        {
                //            case "Header":
                //                //case "Placeholder":
                //                _processComponent = false;
                //                break;
                //            case "BulkColor":
                //            case "Pack":
                //                selRow = selRow.ParentRow;
                //                _processComponent = true;
                //                break;
                //            case "PackColor":
                //                okToProcess = false;
                //                errorMessage = string.Format
                //                    (MIDText.GetText(eMIDTextCode.msg_ActionNotAllowed),
                //                    MIDText.GetTextOnly(eMIDTextCode.lbl_PackColor));
                //                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                //                break;
                //            case "PackColorSize":
                //                okToProcess = false;
                //                errorMessage = string.Format
                //                    (MIDText.GetText(eMIDTextCode.msg_ActionNotAllowed),
                //                     MIDText.GetTextOnly(eMIDTextCode.lbl_PackSize));
                //                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                //                break;
                //            case "PackSize":
                //                okToProcess = false;
                //                errorMessage = string.Format
                //                    (MIDText.GetText(eMIDTextCode.msg_ActionNotAllowed),
                //                    MIDText.GetTextOnly(eMIDTextCode.lbl_PackSize));
                //                MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                //                break;
                //        }
                //    }
                //    if (okToProcess && _processComponent && ugDetails.Selected.Rows.Count > 1)
                //    {
                //        errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_SelectSingleComponent);
                //        MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                //        okToProcess = false;
                //    }
                //}
            }   // End TT#179
            catch (Exception ex)
            {
                HandleException(ex);
                okToProcess = false;
            }
            return okToProcess;
        }

		private void ResetGrids()
		{
			try
			{
                //BEGIN MID Track 4449 error grouping when in edit mode; re-enable disabled group by after 
                //                                                      leaving Edit mode
                ugHeaders.DisplayLayout.Override.AllowGroupBy = DefaultableBoolean.True;
                //END MID Track 4449  
               
	            ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.ExitEditMode, false, false);
                ugDetails.DisplayLayout.Override.CellClickAction = Infragistics.Win.UltraWinGrid.CellClickAction.RowSelect;
             
                _inEditMode = false;
                 
                foreach (UltraGridBand band in ugDetails.DisplayLayout.Bands)
                {
                    IEnumerable enumerator = band.GetRowEnumerator(GridRowType.DataRow);
                    foreach (UltraGridRow row in enumerator)
                    {
                        row.Activation = Activation.NoEdit;
                        switch (band.Key)
                        {
                            case "Header":
                            //case "Placeholder":
                                SetNotesCellButton(row);
                                break;

                            case "BulkColor":
                                row.Cells["BulkColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.Edit;
                                break;

                            case "PackColor":
                                row.Cells["PackColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.Edit;
                                break;

                            default:
                                break;
                        }
                    }
                }
        
                cmsSave.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Edit);
                // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
                // BEGIN Usability Enhancement
                //btnEditSave.Text = cmsSave.Text;
                //btnCancel.Enabled = false;
                //btnHideDetails.Enabled = true;
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnEditSave"]).SharedProps.Caption = cmsSave.Text;
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnCancel"]).SharedProps.Enabled = false;
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnHideDetails"]).SharedProps.Enabled = true;
                // End TT#1126-MD
                SetToolsMenuItem(true); 
                // END Usability Enhancement

                cmsCancel.Visible = false;
                SetFileSaveMenuItem(false);     // MID Track #5501 - File>Save not implemented
                UpdateSelectedTotals(); 
			}
			catch ( Exception ex ) 
			{
				HandleException(ex);
			}
		}

        // BEGIN Usability Enhancement
        private void btnExpandCollapse_Click(object sender, EventArgs e)
        {
            try
            {
                EventArgs args = new EventArgs();
                if (_expandAll)
                {
                    this.btnExpandCollapse.Text = this.cmsExpand.Text;
                    cmsCollapse_Click(cmsCollapse, args);
                }
                else
                {
                    this.btnExpandCollapse.Text = this.cmsCollapse.Text;
                    cmsExpand_Click(cmsExpand, args);
                }
            }
            catch
            {
                throw;
            }
        }

        private void btnEditSave_Click(object sender, EventArgs e)
        {
            try
            {
                EventArgs args = new EventArgs();
                cmsSave_Click(cmsSave, args);
            }
            catch
            {
                throw;
            }
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            CancelEdit();
        }

        private void btnShowDetails_Click(object sender, EventArgs e)
        {
            ShowDetails();
        }
               
        private void btnHideDetails_Click(object sender, EventArgs e)
        {
           HideDetails();
        }

        // END Usability Enhancement
		#endregion

        #region Apply and Save View methods

        private void SetViewComboEnabled()
        {
            try
            {
				// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
                //MIDComboBoxEnh.MyComboBox cmbView = (MIDComboBoxEnh.MyComboBox)cct.Control;
                MIDComboBoxEnh.MyComboBox cmbView = GetViewComboBoxControl();
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                if (_inEditMode)
                {
                    //cboView.Enabled = false;
					//((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).SharedProps.Enabled = false;
                    cct.SharedProps.Enabled = false;
                    cmbView.Enabled = false;
                }
                else
                {
                    //cboView.Enabled = _allocationViewsSecurity.AccessDenied ? false : true;
					//((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).SharedProps.Enabled = _allocationViewsSecurity.AccessDenied ? false : true;
                    cct.SharedProps.Enabled = _allocationViewsSecurity.AccessDenied ? false : true; ;
                    cmbView.Enabled = _allocationViewsSecurity.AccessDenied ? false : true; ;
                }
				// End TT#4071 - stodd - Matrix does not allow search for attribute - 
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
            }
            catch
            {
                throw;
            }
        }

        private void SetUserView(int aViewRID, bool useFilterSorting)
        {
            try
            {
                if (aViewRID != Include.NoRID)
                {
					// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                    //cboView.SelectedValue = aViewRID;
					// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
					//((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).Value = aViewRID;
                    //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
                    //MIDComboBoxEnh.MyComboBox cmbView = (MIDComboBoxEnh.MyComboBox)cct.Control;
                    MIDComboBoxEnh.MyComboBox cmbView = GetViewComboBoxControl();
                    cmbView.SelectedValue = aViewRID;
					// End TT#4071 - stodd - Matrix does not allow search for attribute - 
					// END TT#767-MD - Stodd - remove old controls from allocation workspace
                    //this.cboView_SelectionChangeCommitted(source, new EventArgs()); // TT#294-MD - RBeck - When Opening style review, the view does not open that is selected
                    ApplyViewToGridLayout(aViewRID, useFilterSorting);
                }
                _cancelSelectEvent = false;   // TT#3565 - JSmith - Header not selecting after changing views
            }
            catch   
            {
                throw;
            }
        }

        private void cboView_MouseHover(object sender, EventArgs e)
        {
            toolTip1.Active = true;
        }

        //BEGIN TT#6-MD-VStuart - Single Store Select
        //private void cboView_SelectionChangeCommitted(object sender, EventArgs e)
        //{
        //    try
        //    {
        //        int viewRID; 
        //        if (!_bindingView && !_fromLoadEvent)
        //        {
        //            viewRID = Convert.ToInt32(cboView.SelectedValue, CultureInfo.CurrentUICulture);    //TT#6-MD-VStuart - Single Store Select
        //            // Begin TT#1910 - JSmith - View will not change after update view
        //            //if (viewRID != _lastSelectedViewRID)
        //            //{
        //            //    // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
        //            //    if (_viewSaved)
        //            //    {
        //            //        _viewSaved = false;
        //            //        _lastSelectedViewRID = viewRID;
        //            //    }
        //            //    // END MID Track #6407
        //            //    else if (_gridViewData.GridViewFilterExists(viewRID)) // apply View filter to User Workspace FIlter 
        //            //    {
        //            //        _cancelSelectEvent = true; // MID Track #6407
        //            //        IRefresh();
        //            //    }
        //            //    else
        //            //    {
        //            //        ApplyViewToGridLayout(viewRID);
        //            //    }
        //            //}
        //            if (_viewSaved)
        //            {
        //                _viewSaved = false;
        //            }
        //            if (viewRID != _lastSelectedViewRID)
        //            {
        //                // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
        //                _lastSelectedViewRID = viewRID;
        //                //if (_viewSaved)
        //                //{
        //                //    _viewSaved = false;
        //                //    _lastSelectedViewRID = viewRID;
        //                //}
        //                //// END MID Track #6407
        //                //else if (_gridViewData.GridViewFilterExists(viewRID)) // apply View filter to User Workspace FIlter 
        //                if (_gridViewData.GridViewFilterExists(viewRID)) // apply View filter to User Workspace FIlter 
        //                {
        //                    _cancelSelectEvent = true; // MID Track #6407
        //                    IRefresh();
        //                }
        //                else
        //                {
        //                    ApplyViewToGridLayout(viewRID);
        //                }
        //            }
        //            // End TT#1910
        //        }   
        //    }
        //    catch (Exception ex)
        //    {
        //        HandleException(ex);
        //    }
        //}

		// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
		//private void cboView_SelectionChangeCommitted(object sender, EventArgs e)
		//{
		//    try
		//    {
		//        int viewRID; 
		//        if (!_bindingView && !_fromLoadEvent)
		//        {
		//            viewRID = Convert.ToInt32(cboView.SelectedValue, CultureInfo.CurrentUICulture);
		//            // Begin TT#1910 - JSmith - View will not change after update view
		//            //if (viewRID != _lastSelectedViewRID)
		//            //{
		//            //    // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
		//            //    if (_viewSaved)
		//            //    {
		//            //        _viewSaved = false;
		//            //        _lastSelectedViewRID = viewRID;
		//            //    }
		//            //    // END MID Track #6407
		//            //    else if (_gridViewData.GridViewFilterExists(viewRID)) // apply View filter to User Workspace FIlter 
		//            //    {
		//            //        _cancelSelectEvent = true; // MID Track #6407
		//            //        IRefresh();
		//            //    }
		//            //    else
		//            //    {
		//            //        ApplyViewToGridLayout(viewRID);
		//            //    }
		//            //}
		//            if (_viewSaved)
		//            {
		//                _viewSaved = false;
		//            }
		//            if (viewRID != _lastSelectedViewRID)
		//            {
		//                // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes
		//                _lastSelectedViewRID = viewRID;
		//                //if (_viewSaved)
		//                //{
		//                //    _viewSaved = false;
		//                //    _lastSelectedViewRID = viewRID;
		//                //}
		//                //// END MID Track #6407
		//                //else if (_gridViewData.GridViewFilterExists(viewRID)) // apply View filter to User Workspace FIlter 
		//                if (_gridViewData.GridViewFilterExists(viewRID)) // apply View filter to User Workspace FIlter 
		//                {
		//                    _cancelSelectEvent = true; // MID Track #6407
		//                    IRefresh();
		//                }
		//                else
		//                {
		//                    ApplyViewToGridLayout(viewRID);
		//                }

		//                RebuildMultiHeaderValueLists();
		//            }
		//            // End TT#1910
		//        }   
		//    }
		//    catch (Exception ex)
		//    {
		//        HandleException(ex);
		//    }
		//}
        //END TT#6-MD-VStuart - Single Store Select

        //Begin TT#316 - MD - DOConnell - Replace all Windows Combobox controls with new enhanced control
		//void cboView_MIDComboBoxPropertiesChangedEvent(object source, MIDComboBoxPropertiesChangedEventArgs args)
		//{
		//    this.cboView_SelectionChangeCommitted(source, new EventArgs());
		//}
        //End TT#316 - MD - DOConnell - Replace all Windows Combobox controls with new enhanced control
		// END TT#767-MD - Stodd - remove old controls from allocation workspace
		
        private void ApplyViewToGridLayout(int aViewRID, bool useFilterSorting)
        {
            try
            {
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                ugHeadersBeginUpdate();
                ugDetailsBeginUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls

                int visiblePosition, sortSequence, width;
                string bandKey, colKey, errMessage;
                bool isHidden, isGroupByCol;
            //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                string columnType ;
                int hcgRID;
            //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                eSortDirection sortDirection;

                _lastSelectedViewRID = aViewRID;

                if (aViewRID == Include.NoRID)    // don't modify current grid appearance 
                {
                    return;
                }

                // Begin TT#1909 - JSmith - Column Position Not Saving In Allocation Workspace
                //DataTable dtGridViewDetail = _gridViewData.GridViewDetail_Read(aViewRID);
                DataTable dtGridViewDetail = _gridViewData.GridViewDetail_Read_ByPosition(aViewRID);
                // End TT#1909

                if (dtGridViewDetail == null || dtGridViewDetail.Rows.Count == 0)
                {
                    errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_GridViewDoesNotExist);
                    MessageBox.Show(errMessage, _thisTitle);
                    _lastSelectedViewRID = Include.NoRID;
                    BindViewCombo();
                    return;
                }
                
                // BEGIN Workspace Usability Enhancement - Ron Matelic
                ShowHideDetails();
                // END Workspace Usability Enhancement

                SortedList sortedColumns = new SortedList();

                ugHeaders.ResetLayouts();
                ApplyAppearance(ugHeaders);
                ugHeaders.DisplayLayout.ClearGroupByColumns();
                foreach (UltraGridBand band in ugHeaders.DisplayLayout.Bands)
                {
                    band.SortedColumns.Clear();
                }

                foreach (DataRow row in dtGridViewDetail.Rows)
                {
                    bandKey = Convert.ToString(row["BAND_KEY"], CultureInfo.CurrentUICulture);
                    colKey = Convert.ToString(row["COLUMN_KEY"], CultureInfo.CurrentUICulture);
                    visiblePosition = Convert.ToInt32(row["VISIBLE_POSITION"], CultureInfo.CurrentUICulture);
                    isHidden = Include.ConvertCharToBool(Convert.ToChar(row["IS_HIDDEN"], CultureInfo.CurrentUICulture));
                    isGroupByCol = Include.ConvertCharToBool(Convert.ToChar(row["IS_GROUPBY_COL"], CultureInfo.CurrentUICulture));
                    sortDirection = (eSortDirection)Convert.ToInt32(row["SORT_DIRECTION"], CultureInfo.CurrentUICulture);
                //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                    columnType = Convert.ToString(row["COLUMN_TYPE"], CultureInfo.CurrentUICulture);
                    if (row["HCG_RID"] != DBNull.Value && columnType == "C")
                    {
                        hcgRID = Convert.ToInt32(row["HCG_RID"], CultureInfo.CurrentUICulture);
                        colKey = hcgRID.ToString();
                    }
                //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                    if (row["WIDTH"] != DBNull.Value)
                    {
                        width = Convert.ToInt32(row["WIDTH"], CultureInfo.CurrentUICulture);
                    }
                    else
                    {
                        width = -1;
                    }

                    //Begin TT#1477-MD -jsobek -Header Filter Sort on Workspace

                    if (useFilterSorting)
                    {
                        sortSequence = -1;
                    }
                    else
                    {
                        if (sortDirection == eSortDirection.Ascending || sortDirection == eSortDirection.Descending)
                        {
                            sortSequence = Convert.ToInt32(row["SORT_SEQUENCE"], CultureInfo.CurrentUICulture);
                            if (!sortedColumns.ContainsKey(sortSequence))
                            {
                                sortedColumns.Add(sortSequence, row);
                            }
                        }
                        else
                        {
                           sortSequence = -1;
                         }
                    }

                    if (ugHeaders.DisplayLayout.Bands.Exists(bandKey))
                    {
                        UltraGridBand band = ugHeaders.DisplayLayout.Bands[bandKey];

                        if (band.Columns.Exists(colKey))
                        {
                            UltraGridColumn column = band.Columns[colKey];
                            column.Header.VisiblePosition = visiblePosition;
                            column.Hidden = isHidden;
                            if (width != -1)
                            {
                                column.Width = width;
                            }
                        }
                    }
                }
                if (sortedColumns.Count > 0)
                {
                    for (int i = 0; i < sortedColumns.Count; i++)
                    {
                        bool sortDescending;
                        DataRow sRow = (DataRow)sortedColumns[i];
                        bandKey = Convert.ToString(sRow["BAND_KEY"], CultureInfo.CurrentUICulture);
                        colKey = Convert.ToString(sRow["COLUMN_KEY"], CultureInfo.CurrentUICulture);
                        isGroupByCol = Include.ConvertCharToBool(Convert.ToChar(sRow["IS_GROUPBY_COL"], CultureInfo.CurrentUICulture));
                        sortDirection = (eSortDirection)Convert.ToInt32(sRow["SORT_DIRECTION"], CultureInfo.CurrentUICulture);
                    //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                        columnType = Convert.ToString(sRow["COLUMN_TYPE"], CultureInfo.CurrentUICulture);
                        if (sRow["HCG_RID"] != DBNull.Value && columnType == "C")
                        {
                            hcgRID = Convert.ToInt32(sRow["HCG_RID"], CultureInfo.CurrentUICulture);
                            colKey = hcgRID.ToString();
                        }
                     //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                        switch (sortDirection)
                        {
                            case eSortDirection.Descending:
                                sortDescending = true;
                                break;
                            default:
                                sortDescending = false;
                                break;
                        }

                        if (ugHeaders.DisplayLayout.Bands.Exists(bandKey))
                        {
                            UltraGridBand band = ugHeaders.DisplayLayout.Bands[bandKey];

                            if (!band.SortedColumns.Exists(colKey))
                            {
                                _cancelSelectEvent = true;   // MID Track #6407 
                                band.SortedColumns.Add(colKey, sortDescending, isGroupByCol);
                            }
                        }
                    }
                }
                // Begin TT#620 - RMatelic - Base 3.1 -> Created multi - select SAVE button -> get system argument exception error
                ArrayList hdrList = new ArrayList();
                if (_selectedRowsSequence.Count > 0)
                {
                    foreach (UltraGridRow row in _selectedRowsSequence)
                    {
                        hdrList.Add(Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                    }
                }
                ugHeaders.Selected.Rows.Clear();
                if (hdrList.Count > 0)
                {
                    _selectedRowsSequence = new ArrayList();
                    IEnumerable enumerator = ugHeaders.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
                    foreach (UltraGridRow hRow in enumerator)
                    {
                        int hdrRID = Convert.ToInt32(hRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        if (hdrList.Contains(hdrRID))
                        {
                            _selectedRowsSequence.Add(hRow);
                            hdrList.Remove(hdrRID);
                        }
                        if (hdrList.Count == 0)
                        {
                            break;
                        }
                    }
                }
                ReselectPreviousSelections();  
                // End TT#3620
            }
            catch
            {
                throw;
            }
            // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            finally
            {
                ugHeadersEndUpdate();
                ugDetailsEndUpdate();
            }
            // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
        }

        // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
        private void ugHeadersBeginUpdate()
        {
            if (_ugHeadersBeginUpdateCnt == 0)
            {
                ugHeaders.BeginUpdate();
            }
            ++_ugHeadersBeginUpdateCnt;
        }

        private void ugHeadersEndUpdate(bool aForceEndUpdate = false)
        {
            --_ugHeadersBeginUpdateCnt;
            if (_ugHeadersBeginUpdateCnt == 0 ||
                aForceEndUpdate)
            {
                ugHeaders.EndUpdate();
                _ugHeadersBeginUpdateCnt = 0;
            }
        }

        private void ugHeadersSuspendRowSynchronization()
        {
            if (_ugHeadersSuspendRowSynchronizationCnt == 0)
            {
                ugHeaders.SuspendRowSynchronization();
            }
            ++_ugHeadersSuspendRowSynchronizationCnt;
        }

        private void ugHeadersResumeRowSynchronization(bool aForceResumeRowSynchronization = false)
        {
            --_ugHeadersSuspendRowSynchronizationCnt;
            if (_ugHeadersSuspendRowSynchronizationCnt == 0 ||
                aForceResumeRowSynchronization)
            {
                ugHeaders.ResumeRowSynchronization();
                _ugHeadersSuspendRowSynchronizationCnt = 0;
            }
        }

        private void ugDetailsBeginUpdate()
        {
            if (_ugDetailsBeginUpdateCnt == 0)
            {
                ugDetails.BeginUpdate();
            }
            ++_ugDetailsBeginUpdateCnt;
        }

        private void ugDetailsEndUpdate(bool aForceEndUpdate = false)
        {
            --_ugDetailsBeginUpdateCnt;
            if (_ugDetailsBeginUpdateCnt == 0 ||
                aForceEndUpdate)
            {
                ugDetails.EndUpdate();
                _ugDetailsBeginUpdateCnt = 0;
            }
        }

        private void ugDetailsSuspendRowSynchronization()
        {
            if (_ugDetailsSuspendRowSynchronizationCnt == 0)
            {
                ugDetails.SuspendRowSynchronization();
            }
            ++_ugDetailsSuspendRowSynchronizationCnt;
        }

        private void ugDetailsResumeRowSynchronization(bool aForceResumeRowSynchronization = false)
        {
            --_ugDetailsSuspendRowSynchronizationCnt;
            if (_ugDetailsSuspendRowSynchronizationCnt == 0 ||
                aForceResumeRowSynchronization)
            {
                ugDetails.ResumeRowSynchronization();
                _ugDetailsSuspendRowSynchronizationCnt = 0;
            }
        }
        // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
       
        #endregion

        #region EnqueueDequeue Methods

        // begin TT#1185 - Verify ENQ before Update
        /// <summary>
        /// Attempts to enqueue selected headers for update (for non-store, non-action editting)
        /// </summary>
        /// <returns>True: Enqueue successful; False: Enqueue Failed</returns>
        private bool EnqueueHeadersForEdit()
        {
            List<int> hdrRidList = new List<int>();
            if (ugDetails.Rows.Count > 0)
            {
                 foreach (UltraGridRow row in ugDetails.Rows)
                 {
                     // Begin TT#3620 - JSmith - Right Click - Add - Header receive system argument exception
                     if (row.Cells == null ||
                         row.Cells.Count == 0 ||
                         !RowHasKey(row, "KeyH"))
                     {
                         continue;
                     }
                     // End TT#3620 - JSmith - Right Click - Add - Header receive system argument exception
                      hdrRidList.Add(Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                 }
            }
            return EnqueueHeadersForEdit(hdrRidList);
        }
        /// <summary>
        /// Attempts to enqueue specified headers for update (for non-store, non-action editing)
        /// </summary>
        /// <param name="aHdrRidList">List of header RIDs to enqueue (only these headers will be enqueued; related headers such as members of multi's or the multi header itself will not be enqueued unless it is in the list)</param>
        /// <returns>True: Enqueue successful; False: Enqueue Failed</returns>
        private bool EnqueueHeadersForEdit(List<int> aHdrRidList)
        {
            if (aHdrRidList.Count == 0)
            {
                return false;
            }
            // begin TT#1185 - JEllis - Verify ENQ before Update (part 2)
            //if (_headerEnqueue == null)
            //{
            //    _headerEnqueue = new HeaderEnqueue(SAB.ClientServerSession);
            //}
            // end TT#1185 - JEllis - Verify ENQ before Update (part 2)

            //
            // The assumption is that "edit" will only affect the selected header
            // So it is not necessary to find all related headers
            //
            //if (_headerEnqueue.EnqueueHeaders(aHdrRidList))                                                                               // TT#1185 - JEllis - Verify ENQ before Update (part 2)
            string message;                                                                                                                 // TT#1185 - JEllis - Verify ENQ before Update (part 2)
            if (SAB.ApplicationServerSession.EnqueueHeaders(_clientThreadID, Include.NoTransaction, _clientUserRID, aHdrRidList, out message))  // TT#1185 - JEllis - Verify ENQ before Update (part 2)
            {
                return true;
            }
            _diagResult = 
                SAB.MessageCallback.HandleMessage(
                message,                           // TT#1185 - JEllis - Verify ENQ before Update (part 2)
                "Header Lock Conflict",
                System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Asterisk);
            return false;
        }
        /// <summary>
        /// Attempts to enqueue selected headers for action.  An Action may update other related headers; so any headers related to the selected headers are also enqueued.
        /// </summary>
        /// <param name="aTrans">ApplicationSessionTransaction where the action will take place.</param>
        /// <returns>True: Enqueue was successful for the selected headers and all their related headers; False: Enqueue was not successful for at least one of the selected headers OR a header related to a selected header</returns>
        private bool EnqueueHeadersForAction(ApplicationSessionTransaction aTrans)
        {
            string enqMessage;
            List<int> hdrRidList = new List<int>();
            foreach (int key in _selectedHeaderKeyList)
            {
                hdrRidList.Add(key);
            }
            if (hdrRidList.Count == 0)
            {
                return false;
            }
            if (aTrans.EnqueueHeaders(aTrans.GetHeadersToEnqueue(hdrRidList), out enqMessage))
            {
                return true;
            }
            // Begin TT#4515 - stodd - enqueue message
            //enqMessage =
            //   MIDText.GetTextOnly(eMIDTextCode.msg_al_HeaderEnqFailed)
            //   + System.Environment.NewLine
            //   + enqMessage;
            // End TT#4515 - stodd - enqueue message
            _diagResult = 
                _SAB.MessageCallback.HandleMessage
                (
                    enqMessage,
                    "Header Lock Conflict",
                    System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Asterisk
                );
            return false;
        }
        /// <summary>
        /// Dequeues Headers that were enqueued for edit.
        /// </summary>
        public void DequeueHeaders()
        {
            try
            {
                //if (_headerEnqueue != null)
                //{
                //    _headerEnqueue.DequeueHeaders();
                //}
                SAB.ApplicationServerSession.DequeueHeaders(_clientThreadID, Include.NoTransaction, _clientUserRID);
            }
            catch
            {
                throw;
            }
        }


        //private bool HeadersEnqueued(bool aProcessAction)
        //{
            //AllocationHeaderProfile ahp;
            // end TT#1185 - Verify ENQ before Update
            //int hdrRID;
            ////string headerID;
            //try 
            //{
            //    _headerList.Clear();

            //    if (aProcessAction)
            //    {
            //        foreach (int key in _selectedHeaderKeyList)
            //        {
            //            ahp = new AllocationHeaderProfile(key);
            //            _headerList.Add(ahp);
            //        }
            //    }
            //    else if (ugDetails.Rows.Count > 0)
            //    {
            //        foreach (UltraGridRow row in this.ugDetails.Rows)
            //        {
            //            hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
            //            ahp = new AllocationHeaderProfile(hdrRID);
            //            _headerList.Add(ahp);
            //        }
            //    }
            //    if (_headerList.Count == 0)
            //    {
            //        return false;
            //    }
            //    else
            //    {
            //        _headerEnqueue = new HeaderEnqueue(_trans, _headerList); 
            //        _headerEnqueue.EnqueueHeaders();
            //        return true;
            //    }
               
            //}
            //catch (HeaderConflictException) 
            //{
            //    DisplayEnqueueConflict();
            //    return false;
            //}
		//}
        //private bool HeadersAddedEnqueued(ArrayList aHdrList)
        //{
        //    try
        //    {
        //        if (aHdrList.Count > 0)
        //        {
        //            if (_headerEnqueue != null)
        //            {
        //                _headerEnqueue.EnqueueHeadersAdded(aHdrList); 
        //            }
        //            else if (!HeadersEnqueued(false))
        //            {
        //                return false;
        //            }
        //        }
        //        return true;
        //    }
        //    catch (HeaderConflictException)
        //    {
        //        DisplayEnqueueConflict();
        //        return false;
        //    }
        //}

        //private void DisplayEnqueueConflict()
        //{
        //    SecurityAdmin secAdmin = new SecurityAdmin();
        //    string errMsg = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_HeadersInUse) + ":" + System.Environment.NewLine;
         
        //    foreach (HeaderConflict hdrCon in _headerEnqueue.HeaderConflictList)
        //    {
        //        //AllocationHeaderProfile ahp = (AllocationHeaderProfile)_headerList.FindKey(System.Convert.ToInt32(hdrCon.HeaderRID, CultureInfo.CurrentUICulture));
        //        //errMsg += System.Environment.NewLine + ahp.HeaderID + ", User: " + secAdmin.GetUserName(hdrCon.UserRID);
        //        SelectedHeaderList selectedHeaderList = (SelectedHeaderList)SAB.ClientServerSession.GetSelectedHeaderList();
        //        SelectedHeaderProfile shp = (SelectedHeaderProfile)selectedHeaderList.FindKey(System.Convert.ToInt32(hdrCon.HeaderRID, CultureInfo.CurrentUICulture));
        //        errMsg += System.Environment.NewLine + shp.HeaderID + ", User: " + secAdmin.GetUserName(hdrCon.UserRID);
        //    }
        //    errMsg += System.Environment.NewLine + System.Environment.NewLine;
        //    _diagResult = _trans.SAB.MessageCallback.HandleMessage( 
        //        errMsg,
        //        "Header Lock Conflict",
        //        System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Asterisk);

        //    _headerEnqueue = null;
        //}
    
        //public void DequeueHeaders() 
        //{
        //    try 
        //    {
        //        if (_headerEnqueue != null)
        //        {
        //            _headerEnqueue.DequeueHeaders();
        //            _headerEnqueue = null; 
        //        }
        //    }
        //    catch  
        //    {
        //        throw;
        //    }
        //}
	    // end TT#1185 - Verify ENQ before Update
		#endregion
			
        #region Display Context Menu Options
        private void cmsGrid_Opening(object sender, CancelEventArgs e)
        {
            try
            {
                if (_rClickGrid.Name == "ugHeaders" && _inEditMode)
                {
                    e.Cancel = true;
                    return;
                }

				// Begin TT#1247-MD - stodd - Add Group Allocation as a License Key option -
                cmsReviewGroupAllocation.Visible = _SAB.ClientServerSession.GlobalOptions.AppConfig.GroupAllocationInstalled;
                if (_SAB.ClientServerSession.GlobalOptions.AppConfig.GroupAllocationInstalled)
                {
                    // Begin TT#4796 - AGallagher - Reinstate Multi-Header  
                    //cmsMultiCreate.Visible = false; // TT#1036 - MD - stodd - remove ability to create multi-headers
                    //cmsMultiAddTo.Visible = false;  // TT#3991 - RMatelic - Multi Add To option is available when Group Allocation is installed
                    cmsMultiCreate.Visible = true; // TT#1036 - MD - stodd - remove ability to create multi-headers
                    cmsMultiAddTo.Visible = true;  // TT#3991 - RMatelic - Multi Add To option is available when Group Allocation is installed

                    // End TT#4796 - AGallagher - Reinstate Multi-Header  
                }
				// End TT#1247-MD - stodd - Add Group Allocation as a License Key option -

                if (_rClickGrid.Name == "ugDetails")
                {
                    cmsFilter.Visible = false;
                    cmsSearch.Visible = false;
                    cmsSaveView.Visible = false;
                    cmsAssortment.Visible = false;
                    cmsMulti.Visible = false;
                    cmsAdd.Visible = false;
                    cmsDelete.Visible = false;
                    cmsAutoSelectGroup.Visible = false;
                    cmsRemove.Visible = true;
                    cmsExpand.Visible = true;
                    cmsCollapse.Visible = true;
                    cmsSave.Visible = true;
                    cmsSaveAs.Visible = false;
                    if (_inEditMode)
                    {
                        cmsCancel.Visible = true;
                        cmsDetails.Visible = false;
                    }
                    else
                    {
                        cmsCancel.Visible = false;
                        cmsDetails.Visible = true;
                    }
                }
                else   // ugHeaders grid
                {
                    cmsFilter.Visible = true;
                    // BEGIN MID Track #5650 - Index out of range error when there are no no header rows  
                    //cmsSearch.Visible = true;
                    cmsSearch.Visible = (this.ugHeaders.Rows.Count > 0) ? true : false;
                    // END MID Track #5650
                    cmsSaveView.Visible = _allocationViewsSecurity.AccessDenied ? false : true;
                    cmsDetails.Visible = true;
                    cmsAutoSelectGroup.Visible = true;
                    cmsAssortment.Visible = false;
                    cmsMulti.Visible = false;
                    cmsAdd.Visible = false;
                    cmsDelete.Visible = false;
                    cmsRemove.Visible = false;
                    cmsExpand.Visible = false;
                    cmsCollapse.Visible = false;
                    cmsSave.Visible = false;
                    cmsSaveAs.Visible = false;
                    cmsCancel.Visible = false;
                }
                if (!_inEditMode)
                {
                    cmsReview.Visible = true;
                    UltraGridRow rRow = _rClickRow;
					if (rRow != null)
					{
						// BEGIN TT#488-MD - STodd - Group Allocation - 
						bool assortments = false;
						bool groupAllocations = false;
						foreach (int hKey in _selectedHeaderKeyList)
						{
							// get selected header
							AllocationHeaderProfile ahp = SAB.HeaderServerSession.GetHeaderData(hKey, false, false, true);
							// i
							if (ahp.AsrtRID != Include.UndefinedHeader)
							{
								AllocationHeaderProfile ahpa = SAB.HeaderServerSession.GetHeaderData(ahp.AsrtRID, false, false, true);
								if (ahpa.AsrtType == (int)eAssortmentType.PreReceipt || ahpa.AsrtType == (int)eAssortmentType.PostReceipt) // TT#912 - MD - stodd - context menu assortment 
								{
									assortments = true;
								}
								else if (ahpa.AsrtType == (int)eAssortmentType.GroupAllocation)
								{
									groupAllocations = true;
								}
							}
						}

						// Begin TT#912 - MD - stodd - context menu assortment 
                        //if (assortments)
                        //{
                        //    cmsReviewSummary.Enabled = true;
                        //}
                        //if (groupAllocations)
                        //{
                        //    cmsReviewGroupAllocation.Enabled = true;
                        //}
						// End TT#912 - MD - stodd - context menu assortment 
						cmsReviewSummary.Enabled = assortments;
						cmsReviewGroupAllocation.Enabled = groupAllocations;
						// END TT#488-MD - STodd - Group Allocation - 

						if (rRow.IsGroupByRow)
						{
							UltraGridGroupByRow gRow = (UltraGridGroupByRow)rRow;
							if (gRow.Column.Key == "AsrtRID" || gRow.Column.Key == "PlaceHolderRID")
							{
								this.cmsReviewSummary.Text = _lblAssortment;
                                cmsReviewSummary.Enabled = true;	// TT#912 - MD - stodd - context menu assortment 
							}
							else
							{
								this.cmsReviewSummary.Text = _lblSummary;
								cmsReviewSummary.Enabled = true;	// TT#488-MD - STodd - Group Allocation - 
							}
						}
						else
						{
							while (rRow.Band.Key != "Header")
							{
								rRow = rRow.ParentRow;
							}
							if (rRow.Cells["AsrtRID"].Value != DBNull.Value)
							{
								this.cmsReviewSummary.Text = _lblAssortment;
							}
							else
							{
								this.cmsReviewSummary.Text = _lblSummary;
								cmsReviewSummary.Enabled = true;	// TT#488-MD - STodd - Group Allocation - 
							}
						}
					}
					else
					{
						this.cmsReviewSummary.Text = _lblSummary;
						cmsReviewSummary.Enabled = true;		// TT#488-MD - STodd - Group Allocation - 
					}
                    cmsSeparator1.Visible = true;
                    cmsAssortment.Visible = false;
                    cmsMulti.Visible = false;
                    cmsAdd.Visible = false;
                    // BEGIN Usability Enhancement
                    if (_rClickGrid.Name == "ugHeaders")
                    {
                        if (_allocationNonInterfacedHeadersSecurity.AllowUpdate)
                        {
                            cmsAdd.Visible = true;
                            cmsAddPack.Visible = false;
                            cmsAddPackColor.Visible = false;
                            cmsAddPackSize.Visible = false;
                            cmsAddBulkColor.Visible = false;
                            cmsAddBulkSize.Visible = false;

                            if (this.ugHeaders.Selected.Rows.Count > 0)
                            {
                                cmsMulti.Visible = true;
                                cmsMultiCreate.Enabled = true;
                                cmsMultiAddTo.Enabled = false;
                                cmsMultiRemove.Enabled = false;
                            }
                        }
                    }
                    // END Usability Enhancement
                    cmsDelete.Visible = false;

                    if (ugDetails.Selected.Rows.Count > 0)
                    {
                        cmsRemove.Enabled = true;
                    }
                    else
                    {
                        cmsRemove.Enabled = _rClickRow == null ? false : true;
                    }
                }
                else     // in Edit mode
                {
                    cmsReview.Visible = false;
                    cmsSeparator1.Visible = false;
                    cmsRemove.Visible = false;
                    if (_rClickRow == null)   // possibly in edit cell mode  
                    {
                        cmsDelete.Visible = false;
                        if (!_allocationNonInterfacedHeadersSecurity.AllowUpdate)
                        {
                            cmsAdd.Visible = false;
                        }
                        else
                        {   // Begin TT#2 Assortment Planning - remove Assortment from Allocation Worskspace
                            //if (_SAB.ClientServerSession.GlobalOptions.AppConfig.AssortmentInstalled)
                            //{
                            //    if (_assortmentSecurity.AllowUpdate)
                            //    {
                            //        if (this.ugDetails.Selected.Rows.Count > 0)
                            //        {
                            //            UltraGridRow row = this.ugDetails.Selected.Rows[0];
                            //            cmsAssortment.Visible = (row.Band.Key == "Header") ? true : false;
                            //        }
                            //        else
                            //        {
                            //            cmsAssortment.Visible = true;
                            //        }
                            //    }
                            //} 
                            // End TT#2 Assortment Planning
                            if (this.ugDetails.Selected.Rows.Count > 0)
                            {
                                UltraGridRow row = this.ugDetails.Selected.Rows[0];
                                // BEGIN MID Track #6178 - Edit MultiHeader menu selections incorrect 
                                //cmsMulti.Visible = (row.Band.Key.ToString() == "Header") ? true : false;
                                if (row.Band.Key == "Header")
                                {
                                    cmsMulti.Visible = true;

                                    _rClickRow = row;
                                    if (HeaderMaintainable(_rClickRow))
                                    {
                                        SetMaintainableHeaderMenu();
                                    }
                                    else
                                    {
                                        SetNonMaintainableHeaderMenu();
                                    }
                                }
                                else
                                {
                                    cmsMulti.Visible = false;
                                }
                                // END MID Track #6178
                            }
                            else
                            {
                                cmsMulti.Visible = false;
                            }
                            cmsAdd.Visible = true;
                            cmsAddPack.Visible = false;
                            cmsAddPackColor.Visible = false;
                            cmsAddPackSize.Visible = false;
                            cmsAddBulkColor.Visible = false;
                            cmsAddBulkSize.Visible = false;
                        }
                    }
                    else
                    {
                        if (HeaderMaintainable(_rClickRow))
                        {
                            SetMaintainableHeaderMenu();
                        }
                        else
                        {
                            SetNonMaintainableHeaderMenu();
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetNonMaintainableHeaderMenu()
        {
            try
            {
                bool isInterfaced = HeaderIsInterfaced();   // TT#254 - RMatelic - Add Header Component security to interfaced headers
                if (!_canDeleteHeader)
                {
                    cmsDelete.Enabled = false;
                }
                if (!_canAddHeader)
                {   // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
                    //cmsAdd.Visible = false;
                    //SetOtherNonMaintainableHeaderMenuOptions();
                    if (!isInterfaced)
                    {
                        cmsAdd.Visible = false;
                        SetOtherNonMaintainableHeaderMenuOptions();
                    }
                    else
                    {
                        cmsAddHeader.Visible = false;
                        cmsAddPack.Visible = false;
                        cmsAddPackColor.Visible = false;
                        cmsAddPackSize.Visible = false;
                        cmsAddBulkColor.Visible = false;
                        cmsAddBulkSize.Visible = false;
                        CheckInterfacedComponentSecurity();
                    }
                }   // End TT#254
                else
                {
                    cmsAddPack.Visible = false;
                    cmsAddPackColor.Visible = false;
                    cmsAddPackSize.Visible = false;
                    cmsAddBulkColor.Visible = false;
                    cmsAddBulkSize.Visible = false;
                    if (_rClickRow.Band.Key == "Header")
                    {
                        // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
                        cmsAdd.Visible = true;
                        cmsAddHeader.Visible = true;
                        if (Convert.ToBoolean(_rClickRow.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture))
                        {
                            CheckInterfacedComponentSecurity();
                        }
                        // End TT#254 
                        if (_canDeleteHeader)
                        {
                            cmsDelete.Visible = true;       // TT#254 - RMatelic - Add Header Component security to interfaced headers
                            cmsDelete.Enabled = true;
                        }
                        else
                        {
                            if (_rClickRow.IsGroupByRow)
                            {
                                cmsAssortment.Visible = false;
                                cmsMulti.Visible = false;
                            }
                            else if (Convert.ToBoolean(_rClickRow.Cells["Interfaced"].Value))
                            {
                                cmsMulti.Visible = true;
                                cmsMultiCreate.Enabled = true;
                                cmsMultiAddTo.Enabled = true;

                                if (Convert.ToInt32(_rClickRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader)
                                {
                                    cmsMultiRemove.Enabled = OkToRemoveRows(_rClickRow) ? true : false;
                                }
                                else
                                {
                                    cmsMultiRemove.Enabled = false;
                                }
                                // TODO Add Assortment

                            }
                            else if (Convert.ToInt32(_rClickRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader)
                            {
                                if (OkToRemoveRows(_rClickRow))
                                {
                                    cmsMulti.Visible = true;
                                    cmsMultiCreate.Enabled = false;
                                    cmsMultiAddTo.Enabled = false;
                                    cmsMultiRemove.Enabled = true;
                                }
                            }
                        }
                    }
                    // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
                    else
                    {
                        if (_rClickRow.Band.Key.StartsWith("BulkSize") ||
                            _rClickRow.Band.Key.StartsWith("PackSize") ||
                            _rClickRow.Band.Key.StartsWith("PackColorSize"))
                        {
                            cmsAdd.Visible = false;
                            cmsAddHeader.Visible = false;
                        }
                        else
                        {
                            cmsAdd.Visible = true;
                            cmsAddHeader.Visible = true;
                        }
                    }
                    // End TT#254
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
      
        private void SetOtherNonMaintainableHeaderMenuOptions()
        {
            try
            {
                if (_rClickRow.Band.Key == "Header" && _rClickRow.Cells["AsrtRID"].Value != DBNull.Value)
                {
                     eHeaderType headerType = (eHeaderType)Convert.ToInt32(_rClickRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);

                     switch (headerType)
                     {
                         case eHeaderType.Assortment:
                         case eHeaderType.Placeholder:
                             break;
                        
                         default:
                             if (_assortmentSecurity.AllowUpdate) //TODO: may need to qualify further
                             {
                                 cmsMulti.Visible = false;
                                 // Begin TT#2 Assortment Planning - remove Assortment from Allocation Worskspace
                                 //cmsAssortment.Visible = true;
                                 //cmsAssrtCreate.Enabled = false;
                                 //cmsAssrtAddPlaceholder.Enabled = false;
                                 //cmsAssrtAddTo.Enabled = false;
                                 //cmsAssrtRemove.Enabled = true;
                                 // End TT#2 Assortment Planning 
                             }
                             break;
                     }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
        private void CheckInterfacedComponentSecurity() 
        {
            try
            {
                SetCanAddSwitchInterfacedComponent(_rClickRow);
                if (_canAddInterfacedComponent)
                {
                    cmsAdd.Visible = true;
                    cmsAddBulkColor.Visible = true;
                    cmsAddPack.Visible = true;
                }  
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        // End TT#254  

        private void SetMaintainableHeaderMenu()
        {
            try
            {
                cmsMulti.Visible = false;
                cmsAssortment.Visible = false;
                cmsDelete.Enabled = cmsDelete.Visible = _canDeleteHeader;
                string[] bandKeyParts = _rClickRow.Band.Key.Split(new char[] { '~' });

                bool isInterfaced = HeaderIsInterfaced();   // TT#254 - RMatelic - Add Header Component security to interfaced headers

                switch (bandKeyParts[0])
                {
                    case "Header":
                    //case "Placeholder":
                        SetHeaderContextMenu(isInterfaced);       // TT#254 - RMatelic - Add Header Component security to interfaced headers: add parameter 
                        break;

                    case "Pack":
                        SetPackContextMenu(isInterfaced);       // TT#254 - RMatelic - Add Header Component security to interfaced headers: add parameter 
                        break;

                    case "PackColor":
                        SetPackColorContextMenu(isInterfaced);  // TT#254 - RMatelic - Add Header Component security to interfaced headers: add parameter 
                        break;

                    case "BulkColor":
                        SetBulkColorContextMenu(isInterfaced);  // TT#254 - RMatelic - Add Header Component security to interfaced headers: add parameter 
                        break;

                    case "BulkSize":
                    case "PackColorSize":
                    case "PackSize":
                        SetSizeContextMenu(isInterfaced);      // TT#254 - RMatelic - Add Header Component security to interfaced headers: add parameter 
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
        private bool HeaderIsInterfaced()
        {
            try
            {
                UltraGridRow headerRow = _rClickRow;

                while (headerRow.Band.Key != "Header")
                {
                    headerRow = headerRow.ParentRow;
                }
                return Convert.ToBoolean(headerRow.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture);
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }
        // End TT#254 

        private void SetHeaderContextMenu(bool isInterfaced) // TT#254 - RMatelic - Add Header Component security to interfaced headers: add bool paramater
        {
            //bool canAddTo = false, canAddPlaceholder = false;
            EditMsgs em = new EditMsgs();
            try
            {
                if (_rClickRow.Cells["HeaderID"].Appearance.Image != null && _rClickRow.Cells["HeaderID"].Tag != null)
                {
                    return;
                }

                if (!ValidateSpecificFields(_rClickRow, ref em))
                {
                    if (em.EditMessages.Count > 0)
                    {
                        _errors = null;
                        for (int i = 0; i < em.EditMessages.Count; i++)
                        {
                            EditMsgs.Message emm = (EditMsgs.Message)em.EditMessages[i];
                            AddErrorMessage(emm);
                        }
                        MessageBox.Show(_errors, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                    return;
                }

                cmsAdd.Visible = true;
                cmsAddPackColor.Visible = false;
                cmsAddPackSize.Visible = false;
                cmsAddBulkSize.Visible = false;

                _fromRightClick = true;

                string colValue = Convert.ToString(_rClickRow.Cells["HeaderID"].Value).Trim();
                if (colValue != string.Empty)
                {
                    //ugDetails.UpdateData();
                    foreach (UltraGridRow row in ugDetails.Rows)
                    {
                        if (RowDataChanged(row))
                            return;
                    }

                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(_rClickRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);

                    switch (headerType)
                    {
                        case eHeaderType.MultiHeader:
                            cmsMulti.Visible = true;
                            cmsMultiCreate.Enabled = false;
                            cmsMultiAddTo.Enabled = true;
                            cmsMultiRemove.Enabled = false;
                            cmsAddPack.Visible = false;
                            cmsAddBulkColor.Visible = false;
                            break;
                        
                        case eHeaderType.Assortment:
                            if (_assortmentSecurity.AllowUpdate)
                            {   // Begin TT#2 Assortment Planning - remove Assortment from Allocation Worskspace 
                                //cmsAssortment.Visible = true;
                                //cmsAssrtCreate.Enabled = false;
                                //CheckAddSwitches(ref canAddTo, ref canAddPlaceholder);
                                //cmsAssrtAddTo.Enabled = canAddTo;
                                //cmsAssrtAddPlaceholder.Enabled = canAddPlaceholder;
                                //cmsAssrtRemove.Enabled = false;
                                //cmsSaveAs.Visible = true;
                            }   // End TT#2 Assortment Planning 
                            cmsAddBulkColor.Visible = false;
                            cmsAddPack.Visible = false;
                            break;

                        case eHeaderType.Placeholder:
                            // Begin TT#2 Assortment Planning - remove Assortment from Allocation Worskspace 
                            //if (_assortmentSecurity.AllowUpdate)
                            //{   
                            //    cmsAssortment.Visible = true;
                            //    cmsAssrtCreate.Enabled = false;
                            //    cmsAssrtAddTo.Enabled = true;
                            //    cmsAssrtAddPlaceholder.Enabled = false;
                            //    cmsAssrtRemove.Enabled = false;
                            //}
                            //cmsAddBulkColor.Visible = true;
                            //cmsAddPack.Visible = true;
                            break;
                        
                        default:
                           
                            // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers: add bool paramater check
                            //cmsAddBulkColor.Visible = true;
                            //cmsAddPack.Visible = headerType == eHeaderType.WorkupTotalBuy ? false : true;
                            if (!isInterfaced)
                            {
                                cmsAddBulkColor.Visible = true;
                                cmsAddPack.Visible = headerType == eHeaderType.WorkupTotalBuy ? false : true;
                            }
                            else 
                            {
                                if (_canAddInterfacedComponent)
                                {
                                    cmsAddBulkColor.Visible = true;
                                    cmsAddPack.Visible = headerType == eHeaderType.WorkupTotalBuy ? false : true;
                                }
                                else
                                {
                                    cmsAddBulkColor.Visible = false;
                                    cmsAddPack.Visible = false;
                                }    
                            }
                            // End TT#254
                            if (_SAB.ClientServerSession.GlobalOptions.AppConfig.AssortmentInstalled
                              && _assortmentSecurity.AllowUpdate)
                            {   // Begin TT#2 Assortment Planning - remove Assortment from Allocation Worskspace
                                //cmsAssortment.Visible = true;
                                if (_rClickRow.Cells["AsrtRID"].Value == DBNull.Value)
                                {
                                    cmsMulti.Visible = true;
                                    cmsMultiCreate.Enabled = true;
                                    cmsMultiAddTo.Enabled = true;
                                    cmsMultiRemove.Enabled = false;
                                    cmsAddBulkColor.Visible = true;
                                    //cmsAssrtCreate.Enabled = true;
                                    //cmsAssrtAddPlaceholder.Enabled = false;
                                    //cmsAssrtAddTo.Enabled = true;
                                    //cmsAssrtRemove.Enabled = false;
                                    cmsSaveAs.Visible = true;
                                }
                                else
                                {
                                    cmsMulti.Visible = false;
                                    //cmsAssrtCreate.Enabled = false;
                                    //cmsAssrtAddPlaceholder.Enabled = false;
                                    //cmsAssrtAddTo.Enabled = false;
                                    //cmsAssrtRemove.Enabled = true;
                                }   // End TT#2 Assortment Planning  
                            }
                            // BEGIN MID Track #6178 - Edit MultiHeader menu selections incorrect
                            else
                            if (Convert.ToInt32(_rClickRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader)
                            {
                                if (OkToRemoveRows(_rClickRow))
                                {
                                    cmsMulti.Visible = true;
                                    cmsMultiCreate.Enabled = false;
                                    cmsMultiAddTo.Enabled = false;
                                    cmsMultiRemove.Enabled = true;
                                }
                            }
                            // END MID Track #6178  
                            else
                            {
                                cmsMulti.Visible = true;
                                cmsMultiCreate.Enabled = true;
                                cmsMultiAddTo.Enabled = true;
                                cmsMultiRemove.Enabled = false;
                                cmsSaveAs.Visible = true;       // MID Track #5653 - enable SaveAs
                            }
                            break;
                    }
                }
                else
                {
                    cmsAdd.Visible = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void CheckAddSwitches(ref bool aCanAddTo, ref bool aCanAddPlaceholder)
        {
            try
            {
                aCanAddTo = true;
               
                eAssortmentType asrtType = (eAssortmentType)Convert.ToInt32(_rClickRow.Cells["AsrtType"].Value, CultureInfo.CurrentUICulture);
                aCanAddPlaceholder = (asrtType == eAssortmentType.PreReceipt) ? true : false;
            }
            catch
            {
                throw;
            }
        }

        private void SetPackContextMenu(bool isInterfaced) // TT#254 - RMatelic - Add Header Component security to interfaced headers: add bool paramater
        {
            try
            {
                _fromRightClick = true;
                string colValue = Convert.ToString(_rClickRow.Cells["Pack"].Value).Trim();
                if (colValue != string.Empty)
                {
                    // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers: add bool paramater check
                    cmsAddBulkColor.Visible = false;
                    cmsAddBulkSize.Visible = false;
                    if (!isInterfaced)
                    {
                        cmsAdd.Visible = true;
              
                        if (Convert.ToInt32(_rClickRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                        {
                            cmsAddPack.Visible = false;
                            cmsAddPackColor.Visible = false;
                            cmsAddPackSize.Visible = false;
                            cmsDelete.Enabled = false;
                            cmsDelete.Visible = false;  // TT#395 - RMatelic - Multi Header - user is able to delete a pack from a multi header on line this should not be allowed
                        }
                        else
                        {
                            cmsAddPack.Visible = true;
                            SetPackContextMenuAdds();
                        }
                    }
                    else
                    {
                        if (_canAddInterfacedComponent)
                        {
                            cmsAdd.Visible = true;
      
                            if (Convert.ToInt32(_rClickRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                            {
                                cmsAddPack.Visible = false;
                                cmsAddPackColor.Visible = false;
                                cmsAddPackSize.Visible = false;
                                cmsDelete.Enabled = false;
                                cmsDelete.Visible = false;   // TT#395 - RMatelic - Multi Header - user is able to delete a pack from a multi header on line this should not be allowed
                            }
                            else
                            {
                                cmsAddPack.Visible = true;
                                SetPackContextMenuAdds();
                            }
                        }
                        else if (_canAddHeader)
                        {
                            cmsAdd.Visible = true;
                            cmsAddHeader.Visible = true;
                        }
                        if (_canDeleteInterfacedComponent)
                        {
                            // Begin TT#395 - RMatelic - Multi Header - user is able to delete a pack from a multi header on line this should not be allowed
                            //cmsDelete.Visible = true;
                            //cmsDelete.Enabled = true;
                            if (Convert.ToInt32(_rClickRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                            {
                                cmsDelete.Visible = false;
                                cmsDelete.Enabled = false;
                            }
                            else
                            {
                                cmsDelete.Visible = true;
                                cmsDelete.Enabled = true;
                            }
                            // End TT#395
                        }
                        else
                        {
                            cmsDelete.Visible = false;
                            cmsDelete.Enabled = false;
                        }
                    }
                }   // End TT#254
                else
                {
                    cmsAdd.Visible = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetPackContextMenuAdds()
        {
            try
            {
                if (Convert.ToInt32(_rClickRow.Cells["PackType"].Value, CultureInfo.CurrentUICulture) == (int)eAllocationType.DetailType)
                {
                    if (_rClickRow.HasChild(false))
                    {
                        UltraGridRow childRow = _rClickRow.GetChild(ChildRow.First);
                        if (childRow.Band.Key == "PackColor"  || childRow.Band.Key.StartsWith("PackSize"))
                        {
                            cmsAddPackColor.Visible = true;
                            cmsAddPackSize.Visible = false;
                        }
                        else
                        {
                            cmsAddPackColor.Visible = false;
                            cmsAddPackSize.Visible = true;
                        }
                    }
                    else
                    {
                        cmsAddPackColor.Visible = true;
                        cmsAddPackSize.Visible = true;
                    }
                }
                else
                {
                    cmsAddPackColor.Visible = true;
                    cmsAddPackSize.Visible = _rClickRow.HasChild(false) ? false : true;
                }

                // Begin TT#2035 - JSmith - Add color/size edit for VSW headers with packs
                if (Convert.ToInt32(_rClickRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.IMO)
                {

                    cmsAddPackSize.Visible = false;
                }
                // End TT#2035 - JSmith - Add color/size edit for VSW headers with packs
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetPackColorContextMenu(bool isInterfaced) // TT#254 - RMatelic - Add Header Component security to interfaced headers: add bool paramater
        {
            try
            {
                _fromRightClick = true;
                string colValue = Convert.ToString(_rClickRow.Cells["PackColor"].Value).Trim();
                if (colValue != string.Empty)
                {
                    // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers: add bool paramater check
                    cmsAddBulkColor.Visible = false;
                    cmsAddBulkSize.Visible = false;
                    if (!isInterfaced)
                    {
                        cmsAdd.Visible = true;

                        if (Convert.ToInt32(_rClickRow.ParentRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                        {
                            cmsAddPack.Visible = false;
                            cmsAddPackColor.Visible = false;
                            cmsAddPackSize.Visible = false;
                            cmsDelete.Enabled = false;
                            cmsDelete.Visible = false;   // TT#395 - RMatelic - Multi Header - user is able to delete a pack from a multi header on line this should not be allowed
                        }
                        else
                        {
                            cmsAddPack.Visible = true;
                            cmsAddPackColor.Visible = true;
                            cmsAddPackSize.Visible = _rClickRow.HasChild() ? false : true;
                        }
                    }
                    else
                    {
                        if (_canAddInterfacedComponent)
                        {
                            cmsAdd.Visible = true;
          
                            if (Convert.ToInt32(_rClickRow.ParentRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                            {
                                cmsAddPack.Visible = false;
                                cmsAddPackColor.Visible = false;
                                cmsAddPackSize.Visible = false;
                            }
                            else
                            {
                                cmsAddPack.Visible = true;
                                cmsAddPackColor.Visible = true;
                                cmsAddPackSize.Visible = _rClickRow.HasChild() ? false : true;
                            }
                        }
                        else 
                        {
                            cmsAddPack.Visible = false;
                            cmsAddPackColor.Visible = false;
                            cmsAddPackSize.Visible = false;
                            if (_canAddHeader)
                            {
                                cmsAdd.Visible = true;
                                cmsAddHeader.Visible = true;
                            }
                        }
                        if (_canDeleteInterfacedComponent)
                        {
                            // Begin TT#395 - RMatelic - Multi Header - user is able to delete a pack from a multi header on line this should not be allowed
                            //cmsDelete.Visible = true;
                            //cmsDelete.Enabled = true;
                            if (Convert.ToInt32(_rClickRow.ParentRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                            {
                                cmsDelete.Visible = false;
                                cmsDelete.Enabled = false;
                            }
                            else
                            {
                                cmsDelete.Visible = true;
                                cmsDelete.Enabled = true;
                            }
                            // End TT#395
                        }
                        else
                        {
                            cmsDelete.Visible = false;
                            cmsDelete.Enabled = false;
                        }
                    }
                }   // End TT3254
                else
                {
                    cmsAdd.Visible = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetBulkColorContextMenu(bool isInterfaced) // TT#254 - RMatelic - Add Header Component security to interfaced headers: add bool paramater
        {
            try
            {
                _fromRightClick = true;
                string colValue = Convert.ToString(_rClickRow.Cells["BulkColor"].Value).Trim();
                if (colValue != string.Empty)
                {
                    // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers: add bool paramater check
                    cmsAddPack.Visible = false;
                    cmsAddPackColor.Visible = false;
                    cmsAddPackSize.Visible = false;
                    if (!isInterfaced)
                    {
                        if (Convert.ToInt32(_rClickRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                        {
                            cmsAddBulkColor.Visible = false;
                            cmsAddBulkSize.Visible = false;
                            cmsDelete.Enabled = false;
                            cmsDelete.Visible = false;   // TT#395 - RMatelic - Multi Header - user is able to delete a pack from a multi header on line this should not be allowed
                        }
                        else
                        {
                            cmsAdd.Visible = true;
                            cmsAddBulkColor.Visible = true;
                            cmsAddBulkSize.Visible = _rClickRow.HasChild() ? false : true;
                        }
                    }
                    else
                    {
                        if (_canAddInterfacedComponent)
                        {
                            if (Convert.ToInt32(_rClickRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                            {
                                cmsAddBulkColor.Visible = false;
                                cmsAddBulkSize.Visible = false;
                            }
                            else
                            {
                                cmsAdd.Visible = true;
                                cmsAddBulkColor.Visible = true;
                                cmsAddBulkSize.Visible = _rClickRow.HasChild() ? false : true;
                            }
                        }
                        else if (_canAddHeader)
                        {
                            cmsAdd.Visible = true;
                            cmsAddHeader.Visible = true;
                        }
                        if (_canDeleteInterfacedComponent)
                        {
                            // Begin TT#395 - RMatelic - Multi Header - user is able to delete a pack from a multi header on line this should not be allowed
                            //cmsDelete.Visible = true;
                            //cmsDelete.Enabled = true;
                            if (Convert.ToInt32(_rClickRow.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                            {
                                cmsDelete.Visible = false;
                                cmsDelete.Enabled = false;
                            }
                            else
                            {
                                cmsDelete.Visible = true;
                                cmsDelete.Enabled = true;
                            }
                            // End TT#395
                        }
                        else
                        {
                            cmsDelete.Visible = false;
                            cmsDelete.Enabled = false;
                        }
                    }
                    // End TT#254  
                }
                else
                {
                    cmsAdd.Visible = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetSizeContextMenu(bool isInterfaced) // TT#254 - RMatelic - Add Header Component security to interfaced headers: add bool paramater
        {
            try
            {
                _fromRightClick = true; //TT#690 - MD - DOConnell - Right Click on a Size Row in Assortment and recieve an Argument Exception Error.
                cmsAdd.Visible = false;
                UltraGridRow headerRow = _rClickRow.ParentRow;
                while (headerRow.Band.Key != "Header")
                {
                    headerRow = headerRow.ParentRow;
                }
                if (Convert.ToInt32(headerRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                {
                    cmsDelete.Visible = false;   // TT#395 - RMatelic - Multi Header - user is able to delete a pack from a multi header on line this should not be allowed
                    cmsDelete.Enabled = false;
                }
                // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
                else if (isInterfaced)
                {
                    if (_canDeleteInterfacedComponent)
                    {
                        cmsDelete.Visible = true;
                        cmsDelete.Enabled = true;
                    }
                    else
                    {
                        cmsDelete.Visible = false;
                        cmsDelete.Enabled = false;
                    }
                }
            }   // End TT#254
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private bool RowDataChanged(UltraGridRow aRow)
        {
            try
            {
                //if (aRow.DataChanged)
                //    return true;
                     
                //if (aRow.HasChild())
                //{
                //    foreach (UltraGridChildBand childBand in aRow.ChildBands)
                //    {
                //        foreach (UltraGridRow childRow in childBand.Rows)
                //        {
                //            if (childRow.DataChanged)
                //                return true;
                //            if (childRow.HasChild())
                //            {
                //                RowDataChanged(childRow);
                //            }
                //        }
                //    }
                //}

                
                if (aRow.HasChild())
                {
                    foreach (UltraGridChildBand childBand in aRow.ChildBands)
                    {
                        foreach (UltraGridRow childRow in childBand.Rows)
                        {
                            if (childRow.DataChanged)
                                childRow.Update();
                            if (childRow.HasChild())
                            {
                                RowDataChanged(childRow);
                            }
                        }
                    }
                }

                if (aRow.DataChanged)
                {
                    aRow.Update();
                }
                return false;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private bool HeaderMaintainable(UltraGridRow aRow)
        {
            try
            {
                UltraGridRow headerRow = aRow;
        
                while (headerRow.Band.Key != "Header")
                {
                    headerRow = headerRow.ParentRow;
                }
                // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
                //SetCanDeleteSwitch(headerRow);
                //SetCanAddSwitch(headerRow);

                //return SetCanUpdateSwitch(headerRow);
                if (Convert.ToBoolean(headerRow.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture) &&
                    aRow.Band.Key != "Header")
                {
                    SetCanAddSwitch(headerRow);
                    SetCanDeleteSwitchInterfacedComponent(headerRow);
                    SetCanAddSwitchInterfacedComponent(headerRow);
                    return SetCanUpdateSwitchInterfacedComponent(headerRow);
                }
                else
                {
                    SetCanDeleteSwitch(headerRow);
                    SetCanAddSwitch(headerRow);
                    return SetCanUpdateSwitch(headerRow);
                }
                // End TT#254
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void SetCanDeleteSwitch(UltraGridRow aHeaderRow)
        { 
            try
            {
                _canDeleteHeader = true;

                if (!CanDeleteInterfacedNonInterfaced(aHeaderRow))  
                {
                    _canDeleteHeader = false;
                    return;
                }
                                
                eHeaderAllocationStatus headerStatus = (eHeaderAllocationStatus)Convert.ToInt32(aHeaderRow.Cells["Status"].Value, CultureInfo.CurrentUICulture);
                if (headerStatus == eHeaderAllocationStatus.InUseByMultiHeader)
                {
                    _canDeleteHeader = false;
                    return;
                }
                int key = Convert.ToInt32(aHeaderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(key);
                if (ap != null)
                {
                    // Begin TT#1966-MD - JSmith - DC Fulfillment
                    //if (ap.SubordinateRID != Include.NoRID)
                    //{
                    //    _canDeleteHeader = false;
                    //}
                    if (ap.IsMasterHeader
                        && ap.DCFulfillmentProcessed)
                    {
                        _canDeleteHeader = false;
                    }
                    else if (ap.IsSubordinateHeader)
                    {
                        _canDeleteHeader = false;
                    }
                    // End TT#1966-MD - JSmith - DC Fulfillment
                    else if (ap.MultiHeader && headerStatus != eHeaderAllocationStatus.ReceivedInBalance
                                            && headerStatus != eHeaderAllocationStatus.ReceivedOutOfBalance)
                    {
                        _canDeleteHeader = false;
                    }
                    else if (ap.Assortment || ap.Placeholder)     // TODO further qualify this?
                    {
                        if (headerStatus != eHeaderAllocationStatus.ReceivedInBalance
                         && headerStatus != eHeaderAllocationStatus.ReceivedOutOfBalance)
                        {
                            _canDeleteHeader = false;
                        }
                        else if (!_assortmentSecurity.AllowDelete)
                        {
                            _canDeleteHeader = false;
                        }
                    }
                    else if (aHeaderRow.Cells["AsrtRID"].Value != DBNull.Value)
                    {
                        _canDeleteHeader = false;
                    }
                }
            }
            catch  
            {
                throw;
            }
        }

        private bool CanDeleteInterfacedNonInterfaced(UltraGridRow aHeaderRow)
        {
            bool canDelete = true;
            try
            {
                if (Convert.ToBoolean(aHeaderRow.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture))
                {
                    if (_SAB.ClientServerSession.GlobalOptions.ProtectInterfacedHeadersInd)
                    {
                        canDelete = false;
                    }
                    else  
                    {
                        canDelete = _allocationInterfacedHeadersSecurity.AllowDelete;
                    }
                }
                else	// not Interfaced   
                {
                    canDelete = _allocationNonInterfacedHeadersSecurity.AllowDelete;
                }
            }
            catch
            {
                throw;
            }
            return canDelete;
        }

        private void SetCanAddSwitch(UltraGridRow aHeaderRow)
        { 
            try
            {
                _canAddHeader = true;
                if (!_allocationNonInterfacedHeadersSecurity.AllowUpdate)
                {
                    _canAddHeader = false;
                }
                else if (aHeaderRow.Cells["AsrtRID"].Value != DBNull.Value)
                {
                    int headerType = Convert.ToInt32(aHeaderRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (headerType != (int)eHeaderType.Assortment && headerType != (int)eHeaderType.Placeholder)
                    {
                        _canAddHeader = false;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private bool SetCanUpdateSwitch(UltraGridRow aHeaderRow)
        {
            bool canUpdate = true;
            try
            {
                eHeaderAllocationStatus headerStatus = eHeaderAllocationStatus.ReceivedInBalance;
      
                headerStatus = (eHeaderAllocationStatus)Convert.ToInt32(aHeaderRow.Cells["Status"].Value, CultureInfo.CurrentUICulture);
                if (headerStatus == eHeaderAllocationStatus.InUseByMultiHeader)
                {
                    canUpdate = false;
                }
                else if (aHeaderRow.Cells["AsrtRID"].Value != DBNull.Value)
                {
                    int headerType = Convert.ToInt32(aHeaderRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (headerType != (int)eHeaderType.Assortment && headerType != (int)eHeaderType.Placeholder)
                    {   // real headers in an Assortment
                        canUpdate = false;
                    }
                }
                else if (aHeaderRow.Cells["StyleSecurity"].Value != System.DBNull.Value)
                {
                    eSecurityType styleSecurity = (eSecurityType)Convert.ToInt32(aHeaderRow.Cells["StyleSecurity"].Value, CultureInfo.CurrentUICulture);
                    if (styleSecurity == eSecurityType.View)
                    {
                        canUpdate = false;    //TODO:  not sure if this is correct
                    }
                }
    
                if (canUpdate)
                {
                    int key = Convert.ToInt32(aHeaderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(key);
                    if (ap != null)
                    {
                        if (ap.AllocationStarted)
                        {
                            canUpdate = false;
                        }
                        else if (headerStatus != eHeaderAllocationStatus.ReceivedInBalance
                              && headerStatus != eHeaderAllocationStatus.ReceivedOutOfBalance)
                        {
                            canUpdate = false;
                        }
                        // Begin TT#1966-MD - JSmith - DC Fulfillment
                        else if (ap.IsMasterHeader)
                        {
                            canUpdate = false;
                        }
                        // End TT#1966-MD - JSmith - DC Fulfillment
                        else
                        {
                            canUpdate = CanUpdateInterfacedNonInterfaced(aHeaderRow);
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
            return canUpdate;
        }

        private bool CanUpdateInterfacedNonInterfaced(UltraGridRow aHeaderRow)
        {
            bool canUpdate = true;
            try
            {
                if (Convert.ToBoolean(aHeaderRow.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture))
                {
                    if (_SAB.ClientServerSession.GlobalOptions.ProtectInterfacedHeadersInd)
                    {
                        canUpdate = false;
                    }
                    else  
                    {
                        canUpdate = _allocationInterfacedHeadersSecurity.AllowUpdate;
                    }    
                }
                else	// not Interfaced  
                {
                    canUpdate = _allocationNonInterfacedHeadersSecurity.AllowUpdate;
                }
            }
            catch
            {
                throw;
            }
            return canUpdate;
        }

        // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
        private void SetCanDeleteSwitchInterfacedComponent(UltraGridRow aHeaderRow)
        {
            try
            {
                _canDeleteInterfacedComponent = true;

                if (_SAB.ClientServerSession.GlobalOptions.ProtectInterfacedHeadersInd)
                {
                    _canDeleteInterfacedComponent = false;
                    return;
                }
                else if (!_allocationInterfacedComponentSecurity.AllowDelete)
                {
                    _canDeleteInterfacedComponent = false;
                    return;
                }
               
                eHeaderAllocationStatus headerStatus = (eHeaderAllocationStatus)Convert.ToInt32(aHeaderRow.Cells["Status"].Value, CultureInfo.CurrentUICulture);
                if (headerStatus == eHeaderAllocationStatus.InUseByMultiHeader)
                {
                    _canDeleteInterfacedComponent = false;
                    return;
                }
                int key = Convert.ToInt32(aHeaderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(key);
                if (ap != null)
                {
                    if (ap.SubordinateRID != Include.NoRID)
                    {
                        _canDeleteInterfacedComponent = false;
                    }
                    else if (ap.MultiHeader && headerStatus != eHeaderAllocationStatus.ReceivedInBalance
                                            && headerStatus != eHeaderAllocationStatus.ReceivedOutOfBalance)
                    {
                        _canDeleteInterfacedComponent = false;
                    }
                    else if (ap.Assortment || ap.Placeholder)     // TODO further qualify this?
                    {
                        if (headerStatus != eHeaderAllocationStatus.ReceivedInBalance
                         && headerStatus != eHeaderAllocationStatus.ReceivedOutOfBalance)
                        {
                            _canDeleteInterfacedComponent = false;
                        }
                        else if (!_assortmentSecurity.AllowDelete)
                        {
                            _canDeleteInterfacedComponent = false;
                        }
                    }
                    else if (aHeaderRow.Cells["AsrtRID"].Value != DBNull.Value)
                    {
                        _canDeleteInterfacedComponent = false;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void SetCanAddSwitchInterfacedComponent(UltraGridRow aHeaderRow)
        {
            try
            {
                _canAddInterfacedComponent = true;
                if (_SAB.ClientServerSession.GlobalOptions.ProtectInterfacedHeadersInd)
                {
                    _canAddInterfacedComponent = false;
                }
                else if (!_allocationInterfacedComponentSecurity.AllowUpdate)
                {
                    _canAddInterfacedComponent = false;
                }
                else if (aHeaderRow.Cells["AsrtRID"].Value != DBNull.Value)
                {
                    int headerType = Convert.ToInt32(aHeaderRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (headerType != (int)eHeaderType.Assortment && headerType != (int)eHeaderType.Placeholder)
                    {
                        _canAddInterfacedComponent = false;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private bool SetCanUpdateSwitchInterfacedComponent(UltraGridRow aHeaderRow)
        {
            bool canUpdate = true;
            try
            {
                if (_SAB.ClientServerSession.GlobalOptions.ProtectInterfacedHeadersInd)
                {
                    canUpdate = false;
                }
                else
                {
                    eHeaderAllocationStatus headerStatus = eHeaderAllocationStatus.ReceivedInBalance;

                    headerStatus = (eHeaderAllocationStatus)Convert.ToInt32(aHeaderRow.Cells["Status"].Value, CultureInfo.CurrentUICulture);
                    if (headerStatus == eHeaderAllocationStatus.InUseByMultiHeader)
                    {
                        canUpdate = false;
                    }
                    else if (aHeaderRow.Cells["AsrtRID"].Value != DBNull.Value)
                    {
                        int headerType = Convert.ToInt32(aHeaderRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                        if (headerType != (int)eHeaderType.Assortment && headerType != (int)eHeaderType.Placeholder)
                        {   // real headers in an Assortment
                            canUpdate = false;
                        }
                    }
                    else if (aHeaderRow.Cells["StyleSecurity"].Value != System.DBNull.Value)
                    {
                        eSecurityType styleSecurity = (eSecurityType)Convert.ToInt32(aHeaderRow.Cells["StyleSecurity"].Value, CultureInfo.CurrentUICulture);
                        if (styleSecurity == eSecurityType.View)
                        {
                            canUpdate = false;    //TODO:  not sure if this is correct
                        }
                    }

                    if (canUpdate)
                    {
                        int key = Convert.ToInt32(aHeaderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(key);
                        if (ap != null)
                        {
                            if (ap.AllocationStarted)
                            {
                                canUpdate = false;
                            }
                            else if (headerStatus != eHeaderAllocationStatus.ReceivedInBalance
                                  && headerStatus != eHeaderAllocationStatus.ReceivedOutOfBalance)
                            {
                                canUpdate = false;
                            }
                            else
                            {
                                if (!_allocationInterfacedComponentSecurity.AllowUpdate && !_allocationInterfacedComponentSecurity.AllowDelete)
                                {
                                    canUpdate = false;
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
            return canUpdate;
        }
        // End TT#254  

        private bool OkToRemoveRows(UltraGridRow aRow)
        {
            int hdrGroupRID;
            try
            {
                if (this.ugDetails.Selected.Rows.Count == 0)
                {
                    return false;
                }
                hdrGroupRID = Convert.ToInt32(aRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);

                _multiHdrRowFound = false;
                _multiHdrRow = null;
                GetHeaderRow(ugDetails.GetRow(ChildRow.First), hdrGroupRID);

                if (_multiHdrRow == null || _multiHdrRow.Selected)
                {
                    return false;
                }

                if (!HeaderMaintainable(_multiHdrRow))
                {
                    return false;
                }

                Header hd = new Header();
                DataTable dtChildren = hd.GetHeaderGroupChildren(hdrGroupRID);

                if (this.ugDetails.Selected.Rows.Count >= dtChildren.Rows.Count)
                {
                    return false;
                }
                else
                {   // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary) - unrelated
                    //return true;
                    int inUseCount = 0;
                    foreach (UltraGridRow row in ugDetails.Rows)
                    {
                        if (row.Cells["HdrGroupRID"].Value != DBNull.Value && 
                            Convert.ToInt32(row.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture) == hdrGroupRID &&
                            Convert.ToInt32(row.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader)
                        {
                            inUseCount++;
                            if (inUseCount > 1)
                            {
                                break;
                            }
                        }
                    }
                    if (inUseCount < 2)
                    {
                        return false;
                    }    
                    else
                    {
                       return true;
                    }
                }   // End #234
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }

        private void GetHeaderRow(UltraGridRow aRow, int aHdrGroupRID)
        {
            try
            {
                UltraGridRow gRow = aRow;
                while (gRow != null && !_multiHdrRowFound)
                {
                    if (gRow.IsGroupByRow)
                    {
                        GetHeaderRow(gRow.GetChild(ChildRow.First), aHdrGroupRID);
                        if (_multiHdrRowFound)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (gRow.Band.Key == "Header" && (int)gRow.Cells["KeyH"].Value == aHdrGroupRID)
                        {
                            _multiHdrRowFound = true;
                            _multiHdrRow = gRow;
                            break;
                        }
                    }
                    gRow = gRow.GetSibling(SiblingRow.Next, true, false);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        // Begin TT#2273 - JSmith - Error when Reseting Original Piggybacked Header
        private UltraGridRow FindHeaderRow(UltraGridRow aRow, int aHdrGroupRID)
        {
            try
            {
                while (aRow != null)
                {
                    if (aRow.IsGroupByRow)
                    {
                        FindHeaderRow(aRow.GetChild(ChildRow.First), aHdrGroupRID);
                    }
                    else
                    {
                        if (aRow.Band.Key == "Header" && (int)aRow.Cells["KeyH"].Value == aHdrGroupRID)
                        {
                            return aRow;
                        }
                    }
                    aRow = aRow.GetSibling(SiblingRow.Next, true, false);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }

            return null;
        }
        // End TT#2273

        private void cmsAssrt_Opening(object sender, CancelEventArgs e)
        {
            try
            {
                if (_rClickRow == null)
                {
                    cmsAssrtCreate.Enabled = true;
                    cmsAssrtAddTo.Enabled = false;
                    cmsAssrtAddPlaceholder.Enabled = false;
                    cmsAssrtRemove.Enabled = false;
					cmsReviewGroupAllocation.Enabled = false;	// TT#488-MD - STodd - Group Allocation - 
                }
				else if (_rClickRow.Band.Key != "Header")
				{
					e.Cancel = true;
					return;
				}
				
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        #endregion
    
        #region ContextMenu events and methods
		private void cmsReviewSelect_Click(object sender, EventArgs e)
        {
            DetermineWindow(eAllocationSelectionViewType.None);
        }

        private void cmsReviewStyle_Click(object sender, EventArgs e)
        {
            DetermineWindow(eAllocationSelectionViewType.Style);
        }

        private void cmsReviewSize_Click(object sender, EventArgs e)
        {
            DetermineWindow(eAllocationSelectionViewType.Size);   
        }

        private void cmsReviewSummary_Click(object sender, EventArgs e)
        {
            if (cmsReviewSummary.Text == _lblAssortment)
            {
				// Begin TT#912 - MD - stodd - context menu assortment 
                //DetermineWindow(eAllocationSelectionViewType.Assortment);
                ShowAssortment();
				// End TT#912 - MD - stodd - context menu assortment 
            }
            else
            {
                DetermineWindow(eAllocationSelectionViewType.Summary);
            }
        }

		// Begin TT#911 - MD - stodd - double click to open assortment
        private void ShowAssortment()
        {
            // Save off original header selection list
            ArrayList origSelectedHeaderKeyList = _selectedHeaderKeyList;
            ArrayList origSelectedAssortmentKeyList = _selectedAssortmentKeyList; 
            // The Assortment(s) needs to be extracted out of the selected header(s).
            // Method denotes GroupAlloction, but this works for a regular assortment too.
            ArrayList asrtHeaderKeylist = GetAssortmentListFromSelectedHeaders();

            if (asrtHeaderKeylist.Count > 0)
            {
                //ApplicationSessionTransaction appTransaction = SAB.ApplicationServerSession.CreateTransaction(); // TT#960 - MD - JEllis - Workspace not reflecting status correctly after action in Style Review
				ApplicationSessionTransaction appTransaction = GetApplicationSessionTransaction();                 // TT#960 - MD - JEllis - Workspace not reflecting status correctly after action in Style Review
                AddSelectedHeadersToTrans(asrtHeaderKeylist, appTransaction, ref _selectedAssortmentKeyList, ref _selectedHeaderKeyList);	// TT#1212-MD - stodd - double-clicked on the assortment workspace to open an existing assortment receive an Argument Exception - 
                DetermineWindow(eAllocationSelectionViewType.Assortment, appTransaction);
            }

            // Put original list back in case it's used later.
            _selectedHeaderKeyList = origSelectedHeaderKeyList;
            _selectedAssortmentKeyList = origSelectedAssortmentKeyList; // TT#488 - MD - JEllis - Group Allocation
        }
		// End TT#911 - MD - stodd - double click to open assortment

		// BEGIN TT#488-MD - STodd - Group Allocation - 
		private void cmsGroupAllocation_Click(object sender, EventArgs e)
		{
			ShowGroupAllocation();
		}

		private void ShowGroupAllocation()
		{
            Cursor.Current = Cursors.WaitCursor;	// TT#1137-MD - stodd - refresh summary after GA method - 
			// Save off original header selection list
			// Begin TT#964 - MD - stodd - selected header list - 
			//ArrayList origSelectedHeaderKeyList = _selectedHeaderKeyList;
            ArrayList origSelectedHeaderKeyList = BackupSelectedHeaderKeyList();	// TT#974 - MD - stodd - cancel GA header and get action failed
            //ArrayList origSelectedAssortmentKeyList = _selectedAssortmentKeyList; // TT#488 - MD - Jellis - Group Allocation
            ArrayList origSelectedAssortmentKeyList = BackupSelectedAssortmentKeyList();	// TT#974 - MD - stodd - cancel GA header and get action failed
			// End TT#964 - MD - stodd - selected header list - 
			// The Group Allocation(s) needs to be extracted out of the selected header(s).
			ArrayList gaHeaderKeylist = GetGroupAllocationListFromSelectedHeaders();


			if (gaHeaderKeylist.Count > 0)
			{
                // Begin TT#4515 - stodd - enqueue message
                //================================================================
                // If only 1 GA is selected, this code checked to see if it's
                // already open. If it is, it just activates that window.
                //================================================================
                if (gaHeaderKeylist.Count == 1) // Only 1 GA requested to open
                {
                    Form navToGAForm = null;
                    foreach (Form frm in this.ParentForm.MdiChildren) 
                    {
                        if (frm.GetType() == typeof(AssortmentView))
                        {
                            AssortmentView fhp = (AssortmentView)frm;
                            if (fhp.AssortmentRid == (int)gaHeaderKeylist[0])
                            {
                                navToGAForm = (MIDRetail.Windows.AssortmentView)(frm);
                                break;
                            }
                        }
                    }
                    if (navToGAForm != null)
                    {
                        navToGAForm.Activate();
                        return;
                    }
                }
                // End TT#4515 - stodd - enqueue message

                //ApplicationSessionTransaction appTransaction = SAB.ApplicationServerSession.CreateTransaction();    // TT#960 - MD - JEllis - Workspace not reflecting status correctly after action in Style Review
                ApplicationSessionTransaction appTransaction = GetApplicationSessionTransaction();                    // TT#960 - MD - JEllis - Workspace not reflecting status correctly after action in Style Review
                AddSelectedHeadersToTrans(gaHeaderKeylist, appTransaction, ref _selectedAssortmentKeyList, ref _selectedHeaderKeyList);		// TT#1212-MD - stodd - double-clicked on the assortment workspace to open an existing assortment receive an Argument Exception - 
				DetermineWindow(eAllocationSelectionViewType.GroupAllocation, appTransaction);
			}
			//else
			//{
			//    string errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_NoSelectedGroupAllocation);
			//    MessageBox.Show(errMessage);
			//}

			// Put original list back in case it's used later.
			_selectedHeaderKeyList = origSelectedHeaderKeyList;
            _selectedAssortmentKeyList = origSelectedAssortmentKeyList; // TT#488 - MD - JEllis - Group Allocation
		}

		// Begin TT#974 - MD - stodd - cancel GA header and get action failed
        private ArrayList BackupSelectedHeaderKeyList()
        {
            ArrayList origSelectedHeaderKeyList = new ArrayList();
            foreach (int hdrRid in _selectedHeaderKeyList)
            {
                origSelectedHeaderKeyList.Add(hdrRid);
            }
            return origSelectedHeaderKeyList;
        }

        private ArrayList BackupSelectedAssortmentKeyList()
        {
            ArrayList origSelectedAssortmentKeyList = new ArrayList();
            foreach (int hdrRid in _selectedAssortmentKeyList)
            {
                origSelectedAssortmentKeyList.Add(hdrRid);
            }
            return origSelectedAssortmentKeyList;
        }
		// End TT#974 - MD - stodd - cancel GA header and get action failed

		private ArrayList GetGroupAllocationListFromSelectedHeaders()
		{
			ArrayList gaHeaderKeylist = new ArrayList();
			foreach (int hKey in _selectedHeaderKeyList)
			{
				// get selected header
                AllocationHeaderProfile ahp = SAB.HeaderServerSession.GetHeaderData(hKey, false, false, true);
				if (ahp.AsrtRID != Include.UndefinedHeader)
				{
					AllocationHeaderProfile ahpa = SAB.HeaderServerSession.GetHeaderData(ahp.AsrtRID, false, false, true);
					if (ahpa.AsrtType == (int)eAssortmentType.GroupAllocation)
					{
						gaHeaderKeylist.Add(ahp.AsrtRID);
					}
				}
			}
			return gaHeaderKeylist;
		}
		// END TT#488-MD - STodd - Group Allocation - 

		// Begin TT#911 - MD - stodd - double click to open assortment
        private ArrayList GetAssortmentListFromSelectedHeaders()
        {
            ArrayList asrtHeaderKeylist = new ArrayList();
            foreach (int hKey in _selectedHeaderKeyList)
            {
                // get selected header
                AllocationHeaderProfile ahp = SAB.HeaderServerSession.GetHeaderData(hKey, false, false, true);
                if (ahp.AsrtRID != Include.UndefinedHeader)
                {
                    AllocationHeaderProfile ahpa = SAB.HeaderServerSession.GetHeaderData(ahp.AsrtRID, false, false, true);
                    if (ahpa.AsrtType == (int)eAssortmentType.PostReceipt || ahpa.AsrtType == (int)eAssortmentType.PreReceipt)
                    {
                        asrtHeaderKeylist.Add(ahp.AsrtRID);
                    }
                }
            }
            return asrtHeaderKeylist;
        }

		// End TT#911 - MD - stodd - double click to open assortment

		// BEGIN TT#488-MD - Stodd - Group Allocation
		public void DetermineWindow(eAllocationSelectionViewType aViewType)
		{
			DetermineWindow(aViewType, null);
		}
		// END TT#488-MD - Stodd - Group Allocation
		
        public void DetermineWindow(eAllocationSelectionViewType aViewType, ApplicationSessionTransaction aTrans) 	// TT#488-MD - Stodd - Group Allocation
		{
			try 
			{
                if (!HeaderSelectionOK(aViewType))
                {
                    return;
                }
				// BEGIN TT#488-MD - Stodd - Group Allocation
				ApplicationSessionTransaction processTransaction = null;
				// For group allocation we already have a transaction 
                if (aViewType == eAllocationSelectionViewType.GroupAllocation || aViewType == eAllocationSelectionViewType.Assortment) // TT#911 - MD - stodd - double click to open assortment
				{
					if (aTrans != null)
					{
						processTransaction = aTrans;
					}
					else
					{
						// Error
					}
					// Begin TT#964 - MD - stodd - VSW null ref exception - 

                    if (aViewType == eAllocationSelectionViewType.GroupAllocation)
                    {
						// Begin TT#952 - MD - Add Matrix to Group Allocation - 
                        // Skip selection screen
                        processTransaction.AssortmentViewLoadedFrom = eAssortmentBasisLoadedFrom.GroupAllocation;	// TT#952 - MD - stodd - add matrix to Group Allocation Review
						// End TT#952 - MD - Add Matrix to Group Allocation - 
                        OpenGroupAllocation(processTransaction);
                    }
                    else if (aViewType == eAllocationSelectionViewType.Assortment)
                    {   // Begin TT#2 - RMatelic - Assortment Planning  
                        // Begin TT#911 - MD - stodd - double click to open assortment
                        //if (_selectedAsrtList.Count > 0)
                        //{
                        //    foreach (int asrtRID in _selectedAsrtList)
                        //    {
                        //        GetAllHeadersInAssortment(asrtRID);
                        //    }
                        //}
                        //LoadHeadersInTransaction(ref processTransaction);
                        // End TT#2
                        AssortmentViewSelection avs = new AssortmentViewSelection(EAB, SAB, processTransaction, null, false);
                        //avs.GroupName = ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"]).Text;
                        // End TT#911 - MD - stodd - double click to open assortment
                        if (this.ParentForm.GetType().FullName == "MIDRetail.Windows.Explorer")
                        {
                            avs.MdiParent = this.ParentForm;
                        }
                        else
                        {
                            avs.MdiParent = this.ParentForm.Owner;

                        }
                        avs.DetermineWindow(aViewType);
                    }
				}
				else
				{
					processTransaction = GetApplicationSessionTransaction();
					if (processTransaction == null)
					{
						return;
					}
                    //int[] selectedHeaders = new int[_selectedHeaderKeyList.Count];
                    //_selectedHeaderKeyList.CopyTo(selectedHeaders, 0);
                    //// begin TT#488 - MD - jellis - Group Allocation
                    //int[] selectedAssortmentRIDs = new int[_selectedAssortmentKeyList.Count];
                    //_selectedAssortmentKeyList.CopyTo(selectedAssortmentRIDs, 0);
                    //// end TT#488 - MD - Jellis - Group Allocation
                    //LoadSelectedHeadersToTransaction(ref processTransaction, selectedAssortmentRIDs, selectedHeaders); // TT#488 - MD - Jellis - Group Allocation
                    //// end TT#1185 - Verify ENQ before Update
                    // Begin TT#964 - MD - stodd - style review includes placeholder - 
                    bool loadHeadersOnly = false;
                    if (aViewType == eAllocationSelectionViewType.Style || aViewType == eAllocationSelectionViewType.Size || aViewType == eAllocationSelectionViewType.Summary)
                    {
                        loadHeadersOnly = true;
                    }

                   
                    // Begin TT#980 - MD - stodd - null ref running size need -
                    processTransaction.LoadHeadersInTransaction(_selectedHeaderKeyList, _selectedAssortmentKeyList, loadHeadersOnly, false);	// TT#1154-MD - stodd - augument out of range - 
                    
                    //LoadHeadersInTransaction(ref processTransaction, loadHeadersOnly);       // TT#2 - RMatelic - Assortment Planning  
					// End TT#980 - MD - stodd - null ref running size need -
                    // End TT#964 - MD - stodd - style review includes placeholder - 
                    AllocationViewSelection avs = new AllocationViewSelection(EAB, processTransaction);
                    avs.GroupName = ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"]).Text;
                    if (this.ParentForm.GetType().FullName == "MIDRetail.Windows.Explorer")
                    {
                        avs.MdiParent = this.ParentForm;
                    }
                    else
                    {
                        avs.MdiParent = this.ParentForm.Owner;
                    }
                    avs.DetermineWindow(aViewType);
				}
				// END TT#488-MD - Stodd - Group Allocation

                //if (aViewType == eAllocationSelectionViewType.GroupAllocation)
                //{
                //    OpenGroupAllocation(processTransaction);
                //}
                //else if (aViewType == eAllocationSelectionViewType.Assortment)
                //{   // Begin TT#2 - RMatelic - Assortment Planning  
                //    // Begin TT#911 - MD - stodd - double click to open assortment
                //    //if (_selectedAsrtList.Count > 0)
                //    //{
                //    //    foreach (int asrtRID in _selectedAsrtList)
                //    //    {
                //    //        GetAllHeadersInAssortment(asrtRID);
                //    //    }
                //    //}
                //    //LoadHeadersInTransaction(ref processTransaction);
                //    // End TT#2
                //    AssortmentViewSelection avs = new AssortmentViewSelection(EAB, SAB, processTransaction, null, false);
                //    //avs.GroupName = ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"]).Text;
                //    // End TT#911 - MD - stodd - double click to open assortment
                //    if (this.ParentForm.GetType().FullName == "MIDRetail.Windows.Explorer")
                //    {
                //        avs.MdiParent = this.ParentForm;
                //    }
                //    else
                //    {
                //        avs.MdiParent = this.ParentForm.Owner;

                //    }
                //    avs.DetermineWindow(aViewType);
                //}
                //else
                //{
                //    // Begin TT#964 - MD - stodd - style review includes placeholder - 
                //    bool loadHeadersOnly = false;
                //    if (aViewType == eAllocationSelectionViewType.Style || aViewType == eAllocationSelectionViewType.Size || aViewType == eAllocationSelectionViewType.Summary)
                //    {
                //        loadHeadersOnly = true;
                //    }
                //    LoadHeadersInTransaction(ref processTransaction, loadHeadersOnly);       // TT#2 - RMatelic - Assortment Planning  
                //    // End TT#964 - MD - stodd - style review includes placeholder - 
                //    AllocationViewSelection avs = new AllocationViewSelection(EAB, processTransaction);
                //    avs.GroupName = ((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"]).Text;
                //    if (this.ParentForm.GetType().FullName == "MIDRetail.Windows.Explorer")
                //    {
                //        avs.MdiParent = this.ParentForm;
                //    }
                //    else
                //    {
                //        avs.MdiParent = this.ParentForm.Owner;
                //    }
                //    avs.DetermineWindow(aViewType);
                //}
				// End TT#2 - stodd -assortment
				// End TT#964 - MD - stodd - VSW null ref exception - 
			}
			catch ( Exception ex ) 
			{
                // begin TT#946 - MD - Jellis - Group Allocation Not Working
                if (aTrans != null)
                {
                    aTrans.DataState = eDataState.ReadOnly; 
                    aTrans.DequeueHeaders();
                }
                // end TT#946 - MD - Jellis - Group Allocation Not Working
				HandleException(ex);
				Cursor.Current = Cursors.Default;
			}
		}

		public void OpenGroupAllocation(ApplicationSessionTransaction aTrans)
		{
			try
			{
				System.EventArgs args = new EventArgs();
				Cursor.Current = Cursors.WaitCursor;
				aTrans.CreateAssortmentViewSelectionCriteria();
				aTrans.CreateAllocationViewSelectionCriteria();
				// Begin TT#1103 - md - stodd - Ga method OTS Forecast Level is set to Class or Dept.  It is not observing the correct Plan level - 
                aTrans.AllocationNeedAnalysisPeriodBeginRID = Include.NoRID;
                aTrans.AllocationNeedAnalysisPeriodEndRID = Include.NoRID;
                aTrans.AllocationNeedAnalysisHNID = Include.NoRID;
				// End TT#1103 - md - stodd - Ga method OTS Forecast Level is set to Class or Dept.  It is not observing the correct Plan level - 
                // begin TT#488 - MD - JEllis - Group Allocation
                aTrans.NewAssortmentCriteriaHeaderList();

                _headerList = (AllocationHeaderProfileList)aTrans.GetMasterProfileList(eProfileType.AllocationHeader);
                // note: the above line initializes _headerList for a later routine!
                // end TT#488 - MD - Jellis - Group Allocation
                CheckSecurityEnqueue(aTrans);	// TT#488-MD - STodd - Group Allocation - 
				// Begin TT#1090 - MD - stodd - problems with enqueue message - 
                // _continueProcess is set during CheckSecurityEnqueue()
                if (_continueProcess)
                {
                    if (aTrans.AssortmentStoreAttributeRid == Include.NoRID)
                    {
                        aTrans.AssortmentStoreAttributeRid = SAB.ClientServerSession.GlobalOptions.AllocationStoreGroupRID;
                    }
                    if (aTrans.AllocationStoreAttributeID == Include.NoRID)
                    {
                        aTrans.AllocationStoreAttributeID = SAB.ClientServerSession.GlobalOptions.AllocationStoreGroupRID;
                    }
                    //int asrtCount = 0;
                    //foreach (AllocationHeaderProfile ahp in _headerList)
                    //{
                    //    if (ahp.HeaderType == eHeaderType.Assortment)
                    //    {
                    //        asrtCount++;
                    //        if (asrtCount > 1)
                    //        {
                    //            break;
                    //        }
                    //    }
                    //}
                    OpenGroupAllocationCont(aTrans);

                    //if (_headerList.Count == 0 || viewType == eAllocationSelectionViewType.None || asrtCount > 1)
                    //{
                    //    CheckSecurityAndShow();
                    //}
                    //else
                    //{
                    //    // BEGIN TT#209-MD - stodd - Assortment selection from workspace - 
                    //    if (_trans.AssortmentBasisDataTable.Rows.Count == 0 && asrtCount > 1)
                    //    // END TT#209-MD - stodd - Assortment selection from workspace - 
                    //    {
                    //        CheckSecurityAndShow();
                    //    }
                    //    else
                    //    {
                    //        AssortmentViewSelection_Load(this, args);

                    //        //Begin TT#1962 - DOConnell - When selecting a single assortment from the assrt workspace, review screen is using user selection basis.
                    //        //_bypassScreen = true;
                    //        aTrans.AssortmentViewSelectionBypass = true;
                    //        //End TT#1962 - DOConnell - When selecting a single assortment from the assrt workspace, review screen is using user selection basis.

                    //        OpenGroupAllocationCont(this, args);
                    //    }
                    //}
                }
				// End TT#1090 - MD - stodd - problems with enqueue message -
			}
			catch (Exception exc)
			{
                // begin TT#946 - MD - Jellis - Group Allocation Not Working
                if (aTrans != null)
                {
                    aTrans.DataState = eDataState.ReadOnly;
                    aTrans.DequeueHeaders();
                }
                // end TT#946 - MD - Jellis - Group Allocation Not Working
				HandleException(exc);
			}
			Cursor.Current = Cursors.Default;
		}

		private void OpenGroupAllocationCont(ApplicationSessionTransaction aTrans)
		{
			try
			{
				MIDFormBase frm = null;
				//System.Windows.Forms.Form parentForm;
				System.ComponentModel.CancelEventArgs args = new CancelEventArgs();

				//if (_trans.DataState == eDataState.New || _trans.DataState == eDataState.Updatable)
				//{
				//    //Begin TT#1962 - DOConnell - When selecting a single assortment from the assrt workspace, review screen is using user selection basis.
				//    if (_trans.AssortmentViewSelectionBypass && !OKToProcess())
				//    //if (_bypassScreen && !OKToProcess())
				//    //End TT#1962 - DOConnell - When selecting a single assortment from the assrt workspace, review screen is using user selection basis.
				//    {
				//        this.Close();
				//        this.MdiParent = null;
				//        return;
				//    }
				//}

				//Begin TT#1962 - DOConnell - When selecting a single assortment from the assrt workspace, review screen is using user selection basis.
				//if (_trans.AssortmentViewSelectionBypass)
				//if (_bypassScreen)  // Ron Matelic - added if...
				//End TT#1962 - DOConnell - When selecting a single assortment from the assrt workspace, review screen is using user selection basis.
				{
                    //aTrans.SetCriteriaHeaderList(_headerList);  // TT#488 - MD - Jellis - Group Allocation
					//if (_trans.DataState == eDataState.New)
					//{
					//    Save(eUpdateMode.Create);
					//}
					//else
					//{
					//    Save(eUpdateMode.Update);
					//}

					Cursor.Current = Cursors.WaitCursor;
					// Close this form

					//parentForm = this.MdiParent;
					//this.Close();
					//this.MdiParent = null;

					try
					{
						//// BEGIN TT#209-MD - stodd - Assortment selection from workspace - 
						//if (_trans.AssortmentViewSelectionBypass)
						//{
						//    _trans.AssortmentViewLoadedFrom = eAssortmentBasisLoadedFrom.AssortmentProperties;
						//}
						//else
						//{
						//    _trans.AssortmentViewLoadedFrom = eAssortmentBasisLoadedFrom.UserSelectionCriteria;
						//}
						//// END TT#209-MD - stodd - Assortment selection from workspace - 
						// Begin TT#952 - MD - Add Matrix to Group Allocation - 
						frm = new MIDRetail.Windows.AssortmentView(EAB, aTrans, eAssortmentWindowType.GroupAllocation);
                        ((AssortmentView)frm).Initialize();
						// End TT#952 - MD - Add Matrix to Group Allocation - 
						//((GroupAllocationView)frm).GroupName = _groupName;
                        // Begin TT#4539 - stodd - MDI error opening group allocation
						frm.MdiParent = EAB.Explorer;
                        //frm.MdiParent = this.ParentForm;
                        // End TT#4539 - stodd - MDI error opening group allocation
                        //frm.WindowState = FormWindowState.Maximized; // Begin TT#441-MD - RMatelic - Placeholder fields are not editable >>> unrelated; move maximize to after Show()
						frm.Show();
                        frm.WindowState = FormWindowState.Maximized;   // End TT#441-MD
						if (frm.ExceptionCaught)
						{
							frm.Close();
							frm.MdiParent = null;
						}
					}
					catch (Exception ex)
					{
                        // begin TT#946 - MD - Jellis - Group Allocation Not Working
                        if (aTrans != null)
                        {
                            aTrans.DataState = eDataState.ReadOnly;
                            aTrans.DequeueHeaders();
                        }
                        // end TT#946 - MD - Jellis - Group Allocation Not Working
						frm.Close();
						frm.MdiParent = null;
						HandleException(ex, frm.Name);
					}
					finally
					{
						Cursor.Current = Cursors.Default;
					}
				}
			}
			catch (Exception ex)
			{
                // begin TT#946 - MD - Jellis - Group Allocation Not Working
                if (aTrans != null)
                {
                    aTrans.DataState = eDataState.ReadOnly;
                    aTrans.DequeueHeaders();
                }
                // end TT#946 - MD - Jellis - Group Allocation Not Working
				HandleException(ex);
			}
			//finally
			//{
			//	this.Close();
			//	this.MdiParent = null;
			//}
		}

		// Begin TT#1212-MD - stodd - double-clicked on the assortment workspace to open an existing assortment receive an Argument Exception - 
        // Moved to base class so assortment workspace can use it
		// BEGIN TT#488-MD - STodd - Group Allocation - 
        ///// <summary>
        ///// Builds the full header list from the group allocation/assortment selected
        ///// </summary>
        ///// <param name="gaHeaderKeyList">A list of Group Allocation OR Assortment headers ONLY.</param>
        ///// <param name="aTrans"></param>
        //private void AddSelectedHeadersToTrans(ArrayList gaHeaderKeyList, ApplicationSessionTransaction aTrans)
        //{
        //    //ArrayList gaHeaderKeyList = new ArrayList();
        //    // save off gaHeaders to a different list
        //    //gaHeaderKeyList.AddRange(_selectedHeaderKeyList);
        //    try
        //    {
        //        aTrans.NewAllocationMasterProfileList();

        //        aTrans.DequeueHeaders();
        //        _selectedHeaderKeyList.Clear();
        //        _selectedAssortmentKeyList.Clear(); // TT#488 - MD - Jellis - Group Allocation

        //        // find all "real" headers in each gaHeader
        //        bool createMaster = true;  // TT#488 - MD - Jellis - Group Allocation
        //        List<int> hdrList = new List<int>(); // TT#488 - MD - Jellis - Group ALlocation
        //        ArrayList selectedHeaderRIDs = new ArrayList(); // TT#488 - MD - Jellis - Group Allocation
        //        ArrayList selectedAssortmentRIDs = new ArrayList(); // TT#488 - MD - Jellis - Group Allocation
        //        string enqMessage = string.Empty; // TT#488 - MD - Jellis - Group Allocation
        //        foreach (int gaHeaderRid in gaHeaderKeyList)
        //        {
        //            // Begin TT#1182-MD - stodd - unhandled exception
        //            if (!selectedAssortmentRIDs.Contains(gaHeaderRid))
        //            {
        //                GetAllHeadersInAssortment(gaHeaderRid);

        //                // begin TT#488 - MD - Jellis - Group Allocation
        //                //int[] selectedHeaderArray = new int[_selectedHeaderKeyList.Count];
        //                //_selectedHeaderKeyList.CopyTo(selectedHeaderArray);
        //                selectedHeaderRIDs.AddRange(_selectedHeaderKeyList);

        //                selectedAssortmentRIDs.AddRange(_selectedAssortmentKeyList);
        //                // end TT#488 - MD - Jellis - Group Allocation

        //                // BEGIN TT#66-MD - stodd - values not saving to Allocation profile
        //                //string enqMessage = string.Empty; // TT#488 - MD - Jellis - Group Allocation
        //                //List<int> hdrList = new List<int>(selectedHeaderArray);  // TT#488 - MD - Jellis - Group Allocation

        //                //bool success = aTrans.EnqueueHeaders(hdrList, out enqMessage); // TT#488 - MD - Jellis - Group Allocation
        //                // END TT#66-MD - stodd - 

        //                // load the selected headers in the Application session transaction
        //                // begin TT#488 - MD - Jellis - Group Allocation
        //                //aTrans.LoadHeaders(selectedHeaderArray);
        //                //aTrans.LoadAssortmentMemberHeaders(selectedHeaderArray);
        //                // end TT#488 - MD - Jellis - Group Allocation
        //            }
        //            // End TT#1182-MD - stodd - unhandled exception
        //        }
        //        // begin TT#488 - MD - Jellis - Group Allocation
        //        int[] selectedHeaderArray = new int[selectedHeaderRIDs.Count];
        //        int[] selectedAssortmentArray = new int[selectedAssortmentRIDs.Count];
        //        selectedHeaderRIDs.CopyTo(selectedHeaderArray);
        //        selectedAssortmentRIDs.CopyTo(selectedAssortmentArray);
        //        hdrList.AddRange(selectedAssortmentArray);
        //        hdrList.AddRange(selectedHeaderArray);

        //        if (!aTrans.EnqueueHeaders(hdrList, out enqMessage))
        //        {
        //            // HANDLE Locked selection!  set createMaster to FALSE if they do not want to proceed in READ MODE
        //        }
        //        if (createMaster)
        //        {
        //            aTrans.CreateMasterAssortmentMemberListFromSelectedHeaders(selectedAssortmentArray, selectedHeaderArray);
        //            aTrans.CreateAllocationProfileListFromAssortmentMaster(false, false);  // TT#888 - MD - Jellis - Assortment/Group members not populated // TT#1042 - MD - Jellis - Qty Allocated Cannot Be Negative part 2
        //            //aTrans.CreateAllocationProfileListFromAssortmentMaster(true, false);  // TT#888 - MD - Jellis - Assortment/Group members not populated  // TT#1042 - MD - Jellis - Qty Allocated Cannot Be Negative part 2
        //        }
        //        // end TT#488 - MD - Jellis - Group Allocation
        //    }
        //    catch
        //    {
        //        // begin TT#946 - MD - Jellis - Group Allocation Not Working
        //        if (aTrans != null)
        //        {
        //            if (aTrans.AllocationCriteria != null)  // TT#955 - MD - Jellis - Dup Color Error on Drag Drop Header into Group
        //            {
        //                aTrans.DataState = eDataState.ReadOnly;
        //            }
        //            aTrans.DequeueHeaders();
        //        }
        //        // end TT#946 - MD - Jellis - Group Allocation Not Working
        //        throw;
        //    }
        //}
		// End TT#1212-MD - stodd - double-clicked on the assortment workspace to open an existing assortment receive an Argument Exception - 
		
		protected bool CheckSecurityEnqueue(ApplicationSessionTransaction aTrans)	
		{
			bool securityOk = true;

            CheckSecurityEnqueueForGroupAllocation(aTrans);

			return securityOk;	
		}

		private void CheckSecurityEnqueueForGroupAllocation(ApplicationSessionTransaction aTrans)
		{
            _continueProcess = true;	// TT#1095 - MD - stodd - GA Receive Enque mssg and select OK the Read Only GA does not appear -
			try
			{
				if (!aTrans.VelocityCriteriaExists)
				{
					if (_allocationReviewGroupAllocationSecurity.AllowUpdate)
					{
						try
						{
							bool OKToEnqueue = true;
							FunctionSecurityProfile nodeFunctionSecurity;
							eSecurityFunctions securityFunction;

                            securityFunction = eSecurityFunctions.GroupAllocationReview;	// TT#1007 - md - stodd - change group allocation security - 

							List<int> selectedHdrRIDs = new List<int>(); 
							foreach (AllocationHeaderProfile ahp in _headerList)
							{
								// BEGIN TT#488-MD - STodd - Group Allocation 
                                //if (ahp.StyleHnRID != 1)  // TT#991 - MD - Jellis - GA - Last Header Removed from Group gets Foreign Key Error
                                if (ahp.StyleHnRID > 1)     // TT#991 - MD - Jellis - GA - Last Header Removed from Group gets Foreign Key Error
								{
									nodeFunctionSecurity = _SAB.ClientServerSession.GetMyUserNodeFunctionSecurityAssignment(ahp.StyleHnRID, securityFunction, (int)eSecurityTypes.Allocation);
									if (!nodeFunctionSecurity.AllowUpdate)
									{
										OKToEnqueue = false;
										break;
									}
								}
								// END TT#488-MD - STodd - Group Allocation 
                                // begin TT#488 - MD - Jellis - Group Allocation
                                if (ahp.Key > 0
                                    && ahp.Key != Include.DefaultHeaderRID)
                                {
                                    selectedHdrRIDs.Add(ahp.Key);
                                }
                                // end TT#488 - MD - Jellis - Group Allocation
							}

							if (OKToEnqueue)
							{
								string enqMsg;
								if (aTrans.EnqueueHeaders(aTrans.GetHeadersToEnqueue(selectedHdrRIDs), out enqMsg))
									aTrans.DataState = eDataState.Updatable;
								else
								{
                                    // Begin TT#4515 - stodd - enqueue message
                                    //enqMsg =
                                    //   MIDText.GetTextOnly(eMIDTextCode.msg_al_HeaderEnqFailed)
                                    //   + System.Environment.NewLine
                                    //   + enqMsg;
                                    //enqMsg += "Do you wish to continue with the selected view as read-only?";

                                    enqMsg += "Do you wish to continue with the selected view as read-only?";
                                    // End TT#4515 - stodd - enqueue message

									DialogResult diagResult = SAB.MessageCallback.HandleMessage(
										enqMsg,
										"Header Lock Conflict",
										MessageBoxButtons.OKCancel, System.Windows.Forms.MessageBoxIcon.Asterisk);

									if (diagResult == DialogResult.Cancel)
									{
										throw new CancelProcessException();
									}
									aTrans.DataState = eDataState.ReadOnly;
								}
							}
							else
								aTrans.DataState = eDataState.ReadOnly;
						}
						catch (CancelProcessException)
						{
							_continueProcess = false;
						}
					}
					else
						aTrans.DataState = eDataState.ReadOnly;
				}  
			}
			catch (Exception ex)
			{
				HandleException(ex);
			}
		}
		// END TT#488-MD - STodd - Group Allocation - 

		private void CheckSecurityAndShow()
		{
			try
			{
				FunctionSecurityProfile assortmentReviewSecurity = SAB.ClientServerSession.GetMyUserFunctionSecurityAssignment(eSecurityFunctions.AssortmentReview);
				if (assortmentReviewSecurity.AccessDenied)
				{
					string errorMessage = SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_UnauthorizedFunctionAccess);
					MessageBox.Show(errorMessage, Text, MessageBoxButtons.OK, MessageBoxIcon.Error);
				}
				else
				{
					this.Show();
				}
			}
			catch
			{
				throw;
			}
		}

        // Begin TT#2 - RMatelic - Assortment Planning
        private bool HeaderSelectionOK(eAllocationSelectionViewType aViewType)
        {
            bool okToContinue = true;
            try
            {
                _selectedAsrtList.Clear();
                int asrtRID; 
                // begin TT#488 - MD Jellis - Group Allocation
                if (_selectedAssortmentKeyList.Count > 0)
                {
                    foreach (int key in _selectedAssortmentKeyList)
                    {
                        if (key < 1)
                        {
                            MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_HeadersChanged));
                            okToContinue = false;
                            break;
                        }
                        if (aViewType == eAllocationSelectionViewType.Assortment)
                        {
                            DataRow dtHeaderRow = this._dtHeader.Rows.Find(key);
                            if (dtHeaderRow != null)
                            {
                                if (dtHeaderRow["AsrtRID"] == DBNull.Value)
                                {
                                    MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeadersMustBeInAssortment));
                                    okToContinue = false;
                                    break;
                                }
                                else
                                {
                                    asrtRID = Convert.ToInt32(dtHeaderRow["AsrtRID"], CultureInfo.CurrentUICulture);
                                    if (!_selectedAsrtList.Contains(asrtRID))
                                    {
                                        _selectedAsrtList.Add(asrtRID);
                                    }
                                }
                            }
                        }
                    }
                }
                // end TT#488 - MD - Jellis - Group ALlocation
                if (_selectedHeaderKeyList.Count > 0)
                {
                    foreach (int key in _selectedHeaderKeyList)
                    { 
                        if (key < 1)
                        {
                            MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_HeadersChanged));
                            okToContinue = false;
                            break;
                        }
						if (aViewType == eAllocationSelectionViewType.Assortment)
						{
							DataRow dtHeaderRow = this._dtHeader.Rows.Find(key);
							if (dtHeaderRow != null)
							{
								if (dtHeaderRow["AsrtRID"] == DBNull.Value)
								{
									MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeadersMustBeInAssortment));
									okToContinue = false;
									break;
								}
								else
								{
									asrtRID = Convert.ToInt32(dtHeaderRow["AsrtRID"], CultureInfo.CurrentUICulture);
									if (!_selectedAsrtList.Contains(asrtRID))
									{
										_selectedAsrtList.Add(asrtRID);
									}
								}
							}
						}
                    }
                }
            }
            catch
            {
                throw;
            }
            return okToContinue;
        }
        // End TT#2

		/// <summary>
		/// Return a new transaction which is created on the application server and load the selected headers
		/// into its allocation profile list
		/// </summary>
		/// <returns></returns>
        private ApplicationSessionTransaction GetApplicationSessionTransaction()
        {
            ApplicationSessionTransaction trans = _SAB.ApplicationServerSession.CreateTransaction();
            trans.AllocationWorkspaceExplorer = this;
            trans.NewAllocationMasterProfileList();
            return trans;
        }
		
		// Begin TT#974 - MD - stodd - cancel GA header and get action failed
		// replaced with LoadHeadersInTransaction()
        ///// <summary>
        ///// Load Selected Headers to Application Session Transaction
        ///// </summary>
        ///// <param name="aTrans">Application Session Transaction</param>
        ///// <param name="selectedAssortmentRIDs">Selected Assortment RIDs to Load (excluding Header RIDs)</param>
        ///// <param name="selectedHeaders">Selected Headers to Load (excluding Assortment RIDs)</param>
        //private void LoadSelectedHeadersToTransaction(ref ApplicationSessionTransaction aTrans, int[] selectedAssortmentRIDs,  int[] selectedHeaderRIDs) // TT#488 - MD - Jellis - Group Allocation
        //{
        //    // begin TT#488 - MD - Jellis - Group Allocation
        //    AllocationProfileList apl = aTrans.CreateMasterAllocationProfileListFromSelectedHeaders(selectedAssortmentRIDs, selectedHeaderRIDs); // TT#488 - MD - Jellis - Group Allocation
        //    //AllocationProfileList apl = (AllocationProfileList)aTrans.GetMasterProfileList(eProfileType.Allocation);
        //    //if (apl == null)
        //    //{
        //    //    apl = new AllocationProfileList(eProfileType.Allocation);
        //    //    aTrans.SetMasterProfileList(apl);
        //    //}
        //    //apl.Clear();
        //    //aTrans.LoadHeaders(selectedHeaders);
        //    // end TT#488 - MD - Jellis _ Group Allocation
        //}
		// End TT#974 - MD - stodd - cancel GA header and get action failed
        /// <summary>
        /// Re-sequence selected headers into priority order
        /// </summary>
        private void PutHeadersInPrioritySequence()
        {
            if (_selectedRowsSequence.Count > 0)
            {
                _selectedHeaderKeyList.Clear();
                for (int i = 0; i < _selectedRowsSequence.Count; i++)
                {
                    UltraGridRow hdrRow = (UltraGridRow)_selectedRowsSequence[i];
                    _selectedHeaderKeyList.Add(Convert.ToInt32(hdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                }
            }
        }

		// Begin TT#1212-MD - stodd - double-clicked on the assortment workspace to open an existing assortment receive an Argument Exception - 
		// Moved to Base class so assortment workspace can use it.
        //private void GetAllHeadersInAssortment(int aAsrtRID)
        //{
        //    try
        //    {
        //        ArrayList al = _SAB.HeaderServerSession.GetHeadersInAssortment(aAsrtRID);
        //        for (int i = 0; i < al.Count; i++)
        //        {
        //            int hdrRID = (int)al[i];
        //            // begin TT#488 - MD - Jellis - Group Allocation
        //            if (hdrRID == aAsrtRID)
        //            {
        //                if (!_selectedAssortmentKeyList.Contains(hdrRID))
        //                {
        //                    _selectedAssortmentKeyList.Add(hdrRID);
        //                }
        //            }
        //            else
        //            {
        //                // end TT#488 - MD - Jellis - Group Allocation
        //                if (!_selectedHeaderKeyList.Contains(hdrRID))
        //                {
        //                    _selectedHeaderKeyList.Add(hdrRID);
        //                }
        //            }  // TT#488 - MD - Jellis - Group Allocation
        //        }
        //    }
        //    catch
        //    {
        //        throw;
        //    }
        //}
		// end TT#1212-MD - stodd - double-clicked on the assortment workspace to open an existing assortment receive an Argument Exception - 

		// Begin TT#964 - MD - stodd - style review includes placeholder - 
		// Begin TT#980 - MD - stodd - null ref running size need -
		// MOVED TO APPLICATION SESSION TRANSACTION
        //private void LoadHeadersInTransaction(ref ApplicationSessionTransaction aTrans)
        //{
        //    LoadHeadersInTransaction(ref aTrans, false);
        //}

        // Begin TT#2 - RMatelic - Assortment Planning
        //private void LoadHeadersInTransaction(ref ApplicationSessionTransaction aTrans, bool loadHeadersOnly)
        //{
        //    try
        //    {
        //        // Begin TT#964 - MD - stodd - VSW null ref exception - 
        //        int[] selectedAssortmentArray = null;
        //        int[] selectedHeaderArray = null;
        //        SelectedHeaderList shpl = new SelectedHeaderList(eProfileType.SelectedHeader);

        //        //=======================================================================================================
        //        // If an assortment or group allocation is in play, we want to build the assortment member header list
        //        //=======================================================================================================
        //        if (_selectedAssortmentKeyList.Count > 0)
        //        {
        //            // Converts the selected header key lists into a single selected header profile list
        //            shpl = BuildSelectedHeaderList();	// TT#974 - MD - stodd - cancel GA header and get action failed
        //            // Builds the AssortmentMember master profile list within the transaction
        //            aTrans.LoadAssortmentMemberHeaders(shpl);

        //            //===============================================================================================================
        //            // From the assortment member list, use those allocation profiles to build the master allocation profile list
        //            //===============================================================================================================
        //            ProfileList ampl = aTrans.GetMasterProfileList(eProfileType.AssortmentMember);
        //            AllocationProfileList apl = new AllocationProfileList(eProfileType.Allocation);
        //            foreach (AllocationProfile ap in ampl.ArrayList)
        //            {
        //                if (loadHeadersOnly)
        //                {
        //                    if (ap.HeaderType != eHeaderType.Assortment)
        //                    {
        //                        if (ap.HeaderType == eHeaderType.Placeholder)
        //                        {
        //                            AssortmentProfile asp = (AssortmentProfile)ampl.FindKey(ap.AsrtRID);
        //                            if (asp != null)
        //                            {
        //                                if (asp.AsrtType == (int)eAssortmentType.PreReceipt)
        //                                {
        //                                    apl.Add(ap);    // add the placeholder
        //                                }
        //                            }
        //                            else
        //                            {
        //                                apl.Add(ap);    // add the placeholder
        //                            }
        //                        }
        //                        else
        //                        {
        //                            apl.Add(ap);        // Add regular header 
        //                        }
        //                    }
        //                }
        //                else
        //                {
        //                    // Add ALL selected headers (inlcuding Assortment)
        //                    apl.Add(ap);
        //                }
        //            }

        //            //================================================================
        //            // set the master allocation profile list within the transaction
        //            //================================================================
        //            aTrans.SetMasterProfileList(apl);
        //        }
        //        else    // No Assortment headers in assortment key list
        //        {
        //            // Begin TT#964 - MD - stodd - selected header list - 
        //            //====================================================================================================
        //            // Look through the selected header list to see if any BELONG to an assortment or Group Allocation
        //            //====================================================================================================
        //            AllocationHeaderProfileList AsrtHdrList = new AllocationHeaderProfileList(eProfileType.AllocationHeader);
        //            foreach (int hdrRid in _selectedHeaderKeyList)
        //            {
        //                AllocationHeaderProfile ahp = SAB.HeaderServerSession.GetHeaderData(hdrRid, false, false, true);
        //                if (ahp.AsrtRID != Include.NoRID)
        //                {
        //                    AllocationHeaderProfile ashp = SAB.HeaderServerSession.GetHeaderData(ahp.AsrtRID, false, false, true);
        //                    if (!AsrtHdrList.Contains(ashp.Key))
        //                    {
        //                        AsrtHdrList.Add(ashp);
        //                    }
        //                }
        //            }

        //            //======================================================================
        //            // No headers belong to an assortment or GA, so build the normal list
        //            //======================================================================
        //            if (AsrtHdrList.Count == 0)
        //            {
        //                selectedAssortmentArray = new int[_selectedAssortmentKeyList.Count];
        //                _selectedAssortmentKeyList.CopyTo(selectedAssortmentArray);

        //                selectedHeaderArray = new int[_selectedHeaderKeyList.Count];
        //                _selectedHeaderKeyList.CopyTo(selectedHeaderArray);

        //                aTrans.LoadHeaders(selectedAssortmentArray, selectedHeaderArray); // TT#488 - MD - Jellis - Group Allocation
        //            }
        //            else
        //            //=========================================================================
        //            // Headers were found that belong to an assortment or Group Allocation.
        //            // Because of this we want to build the Assortment Member List
        //            //=========================================================================
        //            {
        //                // Begin TT#974 - MD - stodd - cancel GA header and get action failed
        //                ArrayList origSelectedHeaderKeyList = BackupSelectedHeaderKeyList();
        //                _selectedHeaderKeyList.Clear();

        //                foreach (AllocationHeaderProfile asrtHdr in AsrtHdrList.ArrayList)
        //                {
        //                    GetAllHeadersInAssortment(asrtHdr.Key);
        //                }

        //                //========================================================================================
        //                // Converts the selected header key lists into a single selected header profile list
        //                //========================================================================================
        //                shpl = BuildSelectedHeaderList();
        //                //===================================================
        //                // Builds the AssortmentMember master profile list
        //                //===================================================
        //                aTrans.LoadAssortmentMemberHeaders(shpl);

        //                //===============================================================================================================
        //                // From the assortment member list, use those allocation profiles to build the master allocation profile list
        //                //===============================================================================================================
        //                ProfileList ampl = aTrans.GetMasterProfileList(eProfileType.AssortmentMember);
        //                AllocationProfileList apl = new AllocationProfileList(eProfileType.Allocation);
        //                foreach (int hdrRid in origSelectedHeaderKeyList)
        //                {
        //                    AllocationProfile ap = (AllocationProfile)ampl.FindKey(hdrRid);
        //                    if (ap != null)
        //                    {
        //                        apl.Add(ap);
        //                    }
        //                }

        //                //===============================================================
        //                // Set Master allocation header Profile List within transaction
        //                //===============================================================
        //                aTrans.SetMasterProfileList(apl);

        //                //=========================================
        //                // Restores Selected header key lists
        //                //=========================================
        //                _selectedAssortmentKeyList.Clear();
        //                _selectedHeaderKeyList.Clear();
        //                foreach (int hdrRid in origSelectedHeaderKeyList)
        //                {
        //                    _selectedHeaderKeyList.Add(hdrRid);
        //                }
        //                // End TT#974 - MD - stodd - cancel GA header and get action failed
        //            }
        //            // End TT#964 - MD - stodd - selected header list - 
        //        }
        //        // End TT#964 - MD - stodd - VSW null ref exception - 
        //    }
        //    catch
        //    {
        //        throw;
        //    }
        //}
        //// End TT#964 - MD - stodd - style review includes placeholder - 
        //// End TT#2 

        //// Begin TT#974 - MD - stodd - cancel GA header and get action failed
        ///// <summary>
        ///// Converts the two selected key lists into a single selected header profile list.
        ///// </summary>
        //private SelectedHeaderList BuildSelectedHeaderList()
        //{
        //    SelectedHeaderList shpl = new SelectedHeaderList(eProfileType.SelectedHeader);
        //    foreach (int hdrRid in _selectedAssortmentKeyList)
        //    {
        //        AllocationHeaderProfile ahp = SAB.HeaderServerSession.GetHeaderData(hdrRid, false, false, true);
        //        SelectedHeaderProfile shp = new SelectedHeaderProfile(ahp.Key);
        //        shp.HeaderType = ahp.HeaderType;
        //        shpl.Add(shp);
        //    }
        //    foreach (int hdrRid in _selectedHeaderKeyList)
        //    {
        //        AllocationHeaderProfile ahp = SAB.HeaderServerSession.GetHeaderData(hdrRid, false, false, true);
        //        SelectedHeaderProfile shp = new SelectedHeaderProfile(ahp.Key);
        //        shp.HeaderType = ahp.HeaderType;
        //        shpl.Add(shp);
        //    }
        //    return shpl;
        //}
		// End TT#980 - MD - stodd - null ref running size need -
		// End TT#974 - MD - stodd - cancel GA header and get action failed
		
        ///// <summary>
        ///// Return a new transaction which is created on the application server and load the selected headers
        ///// into its allocation profile list
        ///// </summary>
        ///// <returns></returns>
        //private ApplicationSessionTransaction NewTransFromSelectedHeaders() 
        //{
        //    ApplicationSessionTransaction newTrans = _SAB.ApplicationServerSession.CreateTransaction();
        //    newTrans.AllocationWorkspaceExplorer = this;
        //    //if (_selectedHeaderKeyList.Count > 0) 
        //    if (_selectedRowsSequence.Count > 0)    // MID Track #6264 - Headers not in priority order
        //    {
        //        newTrans.NewAllocationMasterProfileList();
                
        //        // BEGIN MID Track #6264 - Headers not in priority order
        //        _selectedHeaderKeyList.Clear();
        //        for (int i = 0; i < _selectedRowsSequence.Count; i++)
        //        {
        //            UltraGridRow hdrRow = (UltraGridRow)_selectedRowsSequence[i];
                    //_selectedHeaderKeyList.Add(Convert.ToInt32(hdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
        //        }
        //        // END MID Track #6264 - Headers not in priority order

        //        int[] selectedHeaderArray = new int[_selectedHeaderKeyList.Count];
        //        _selectedHeaderKeyList.CopyTo(selectedHeaderArray);

        //        // load the selected headers in the Application session transaction
        //        newTrans.LoadHeaders(selectedHeaderArray);
        //    }
        //    return newTrans;
        //}
        // end TT#1185 - Verify ENQ before Update

        private void cmsAutoSelectGroup_Click(object sender, EventArgs e)
        {
            AutoSelectGroup();
        }
        private void AutoSelectGroup()
        {
            cmsAutoSelectGroup.Checked = !cmsAutoSelectGroup.Checked;
            SetAutoGroupOnToolbar(cmsAutoSelectGroup.Checked);
            // BEGIN MID Track #6230  AutoSelectGroup modification 
            if (cmsAutoSelectGroup.Checked)
            {
                foreach (UltraGridRow selRow in ugHeaders.Selected.Rows)
                {
                    selRow.Selected = false;
                    selRow.Selected = true;

                    // Begin TT#1080 - RMatelic - Created a header and upon saving it is not recognized in the headers Selected Window
                    if (_afterSelectChangeEventArgs != null)
                    {
                        AfterSelectChange(_sender, _afterSelectChangeEventArgs);
                    }
                    // End TT1080
                }
            }
        }   // END MID Track #6230
 
        private void cmsAddHeader_Click(object sender, EventArgs e)
        {
            AddHeader();
        }
        private void AddHeader()
        {
            try
            {
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                if (_dsDetails == null)
                {
                    CreateDetailDataSet();
                }
                // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
                //btnEditSave.Enabled = true;
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnEditSave"]).SharedProps.Enabled = true;
                // End TT#1126-MD
                // End TT#1434
                // BEGIN Usability Enhancement
                CheckToOpenDetailsGrid();
                CheckForEditMode();
                // END Usability Enhancement

                AddHeaderRow();
            }
            catch (Exception ex)
            {
                MIDException MIDExc = new MIDException(eErrorLevel.information, 0, ex.Message);
                HandleMIDException(MIDExc);
            }
        }
        private void CreateGroupAllocation(string groupName)
        {
            Cursor.Current = Cursors.WaitCursor;	// TT#1144-MD - stodd - null ref creating group - 
			// Begin TT#1122 - md - stodd - calendar exception creating group allocation - 
			//      Editing move to separate method
			//Header headerData = new Header();
			// BEGIN TT#488-MD - Stodd - Group Allocation 
			string aMessage = string.Empty;	// TT#941 - MD - stodd - When creating a new Group Allocation from headers selected on the allocation workspace, the selected headers are not getting placed into the Group Allocation.
            ArrayList validSelectedHeaderKeyList = new ArrayList();
            //bool addSelectedHeadersToGroupAllocation = false;

            try
            {
                ApplicationSessionTransaction appTransaction = GetApplicationSessionTransaction();
                int firstStyleRid = Include.NoRID;
                int firstPlanLevelRid = Include.NoRID;
                DateTime firstShipToDay = Include.UndefinedDate;

                bool okToContinue = ValidateNewGroupAllocation(groupName, appTransaction, ref validSelectedHeaderKeyList, ref firstStyleRid, ref firstPlanLevelRid, ref firstShipToDay );

                if (okToContinue)
                {
                    // BEGIN TT#488-MD - Stodd - Group Allocation
                    // Begin TT#941 - MD - stodd - When creating a new Group Allocation from headers selected on the allocation workspace, the selected headers are not getting placed into the Group Allocation.
                    AssortmentProfile asp = null;
                    AllocationHeaderProfile ahp = null;
                    // ** Deleted a bunch of commented out code - stodd - TT#1395-MD 
                    //// End TT#941 - MD - stodd - When creating a new Group Allocation from headers selected on the allocation workspace, the selected headers are not getting placed into the Group Allocation.

                    asp = new AssortmentProfile(appTransaction, groupName, Include.NoRID, SAB.ApplicationServerSession);
                    asp.AsrtType = (int)eAssortmentType.GroupAllocation;
                    asp.HeaderDescription = groupName;
                    //asp.StyleHnRID = Include.DefaultHeaderStyleHnRID;	// TT#488-MD - Stodd - Group Allocation  // TT#991 - MD - Jellis - GA - Last Header Removed from Group gets Foreign Key Error
                    // BEGIN TT#488-MD - Stodd - Group Allocation
                    asp.AsrtAnchorNodeRid = firstStyleRid;
                    asp.AssortmentApplyToDate = SAB.ApplicationServerSession.Calendar.CurrentDate;
                    asp.StyleHnRID = firstStyleRid;
                    // begin TT#3797 - UR - Jellis - Style Review Blank for Groups
                    //asp.PlanHnRID = firstPlanLevelRid;

                    //if (firstShipToDay == Include.UndefinedDate)
                    //{
                    //    asp.ShipToDay = SAB.ApplicationServerSession.Calendar.CurrentDate.Date;
                    //}
                    //else
                    //{
                    //    asp.ShipToDay = firstShipToDay;
                    //}
                    // end TT#3797 - UR - Jellis - Style Review Blank for Groups
                    //asp.ShipToDay = DateTime.Now;                                            // TT#991 - MD - Jellis - GA - Last Header Removed from Group gets Foreign Key Error
                    //asp.PlanHnRID = Include.DefaultPlanHnRID;	//TT#488-MD - Group Allocation - // TT#991 - MD - Jellis - GA - Last Header Removed from Group gets Foreign Key Error
                    // END TT#488-MD - Stodd - Group Allocation
                    MIDException midException;
                    if (!asp.SetHeaderType(eHeaderType.Assortment, out midException))
                    {
                        throw midException;
                    }
                    // BEGIN TT#488-MD - STodd - Group Allocation 
                    //asp.AppSessionTransaction.AddAllocationProfile(asp);
                    asp.AppSessionTransaction.AddAssortmentMemberProfile(asp);
                    // END TT#488-MD - STodd - Group Allocation 
                    bool success = asp.WriteHeader();

                    //string headerId = groupName;
                    // Begin TT#941 - MD - stodd - When creating a new Group Allocation from headers selected on the allocation workspace, the selected headers are not getting placed into the Group Allocation.
                    //AllocationHeaderProfile ahp = SAB.HeaderServerSession.GetHeaderData(asp.HeaderID, false, false, true);
                    ahp = SAB.HeaderServerSession.GetHeaderData(asp.HeaderID, false, false, true);
                    // End TT#941 - MD - stodd - When creating a new Group Allocation from headers selected on the allocation workspace, the selected headers are not getting placed into the Group Allocation.

                    // begin TT#488 - MD - JEllis- Group ALlocation
                    if (ahp.HeaderType == eHeaderType.Assortment)
                    {
                        ahp.AssortmentID = ahp.HeaderID;
                        ahp.AsrtRID = ahp.Key;
                    }
                    // end TT#488 - mD - Jellis - Group ALlocation
                    //_selectedHeaderKeyList = new ArrayList();  // TT#488 - MD - Jellis - Group Allocation
                    //_selectedHeaderKeyList.Add(ahp.Key);      // TT#488 - MD - Jellis - Group Allocation
                    //_selectedHeaderKeyList.Add(1966);

                    // begin TT#488 - MD - Jellis - Group Allocation
                    AllocationHeaderProfileList ahpl = new AllocationHeaderProfileList(eProfileType.AllocationHeader);
                    ahpl.Add(ahp);
                    appTransaction.SetMasterProfileList(ahpl);
                    ArrayList OriginalSelectionList = BackupSelectedHeaderKeyList();	// TT#979 - MD - steve - allocation selection screen showing - 
                    _selectedHeaderKeyList.Clear();
                    _selectedAssortmentKeyList.Clear();

                    int[] selectedHeaderArray = new int[0];
                    int[] selectedAssortmentArray = new int[1];
                    _selectedAssortmentKeyList.Add(ahp.Key);
                    selectedAssortmentArray[0] = ahp.Key;
                    appTransaction.CreateMasterAssortmentMemberListFromSelectedHeaders(selectedAssortmentArray, selectedHeaderArray);
                    appTransaction.CreateAllocationProfileListFromAssortmentMaster(true);
                    // In this case, the Assortment is the ONLY module in the list!!  TT#1042 - MD - Jellis - Qty Allocated Cannot Be Negative part 2
                    // end TT#488 - MD - Jellis - Group Allocation
                    // Begin TT#941 - MD - stodd - When creating a new Group Allocation from headers selected on the allocation workspace, the selected headers are not getting placed into the Group Allocation.
                    //if (addSelectedHeadersToGroupAllocation && validSelectedHeaderKeyList.Count > 0 )
                    if (validSelectedHeaderKeyList.Count > 0)
                    {
                        //===============================================================================================
                        // Instantiates the Group Allocation View from the new Group Allocation header created above.
                        //===============================================================================================
                        // Begin TT#952 - MD - Add Matrix to Group Allocation - 
                        //GroupAllocationView frm = new GroupAllocationView(EAB, appTransaction);
                        AssortmentView frm = new AssortmentView(EAB, appTransaction, eAssortmentWindowType.GroupAllocation);

                        appTransaction.CreateAllocationViewSelectionCriteria();
                        appTransaction.CreateAssortmentViewSelectionCriteria(true);
                        appTransaction.AssortmentViewLoadedFrom = eAssortmentBasisLoadedFrom.GroupAllocation;

                        // Begin TT#1103 - md - stodd - Ga method OTS Forecast Level is set to Class or Dept.  It is not observing the correct Plan level - 
                        appTransaction.AllocationNeedAnalysisPeriodBeginRID = Include.NoRID;
                        appTransaction.AllocationNeedAnalysisPeriodEndRID = Include.NoRID;
                        appTransaction.AllocationNeedAnalysisHNID = Include.NoRID;
                        // End TT#1103 - md - stodd - Ga method OTS Forecast Level is set to Class or Dept.  It is not observing the correct Plan level - 


                        frm.CreateAndAddHeaders = true;		// TT#952 - MD - stodd - add matrix to Group Allocation Review
                        frm.Initialize();
                        frm.LoadContentGrid();
                        // End TT#952 - MD - Add Matrix to Group Allocation - 
                        // Get the first row in the contect grid which is the group allocaiton header.
                        UltraGridRow gaRow = frm.GetSelectedFirstRow();

                        //============================================================================================================
                        // Adds the validated selecgted headers into a SelectedRowsCollection for the call to add them to the GA.
                        //============================================================================================================
                        SelectedRowsCollection hdrRowCollection = new SelectedRowsCollection();
                        foreach (UltraGridRow ugRow in ugHeaders.Selected.Rows)
                        {
                            int key = int.Parse(ugRow.Cells["KeyH"].Value.ToString());
                            if (!validSelectedHeaderKeyList.Contains(key))
                            {
                                ugRow.Selected = false;
                            }
                        }

                        //============================================================================================================
                        // Adds the selected headers to the GA just like if they were dropped onto the GA view
                        //============================================================================================================
                        frm.HeaderDragDrop(gaRow, ugHeaders.Selected.Rows);

                        // Cleanup form
                        frm.Close();
                        frm.CreateAndAddHeaders = false;	//  TT#952 - MD - stodd - add matrix to Group Allocation Review
                        frm.Dispose();
                    }
                    // End TT#941 - MD - stodd - When creating a new Group Allocation from headers selected on the allocation workspace, the selected headers are not getting placed into the Group Allocation.

                    // Begin TT#979 - MD - steve - allocation selection screen showing - 
                    _selectedHeaderKeyList = OriginalSelectionList;
                    _selectedAssortmentKeyList.Clear();
                    // End TT#979 - MD - steve - allocation selection screen showing - 
					
					// Begin TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
                    EnableActions(false);
					// End TT#4162 - stodd - GA -  Recieve Invalid Cast Exception when cancelling an Allocation from the Workspace.  Expected the Workspace to no process Actions since headers are in a GA.
                    DetermineWindow(eAllocationSelectionViewType.GroupAllocation, appTransaction);
                }
            }
            catch
            {
                throw;
            }
			finally
			{
                //if (asp != null)
                //{
                //    //asp.HeaderDataRecord.CloseUpdateConnection();
                //}
			}
			// END TT#488-MD - Stodd - Group Allocation
        }

        private bool ValidateNewGroupAllocation(string groupName, ApplicationSessionTransaction appTransaction, ref ArrayList validSelectedHeaderKeyList, ref int firstStyleRid, ref int firstPlanLevelRid, ref DateTime firstShipToDay)
        {
            string messageTitle = MIDText.GetTextOnly(eMIDTextCode.msg_as_CreateGroupAllocation);
            string aMessage = string.Empty;
            bool okToContinue = true;
            Header headerData = new Header();
            AllocationProfile ap = null;

            if (groupName == string.Empty)
            {
                aMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_ValueRequired);
                aMessage = aMessage.Replace("{0}", "Group Allocation name");
                MessageBox.Show(aMessage, messageTitle, MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                okToContinue = false;
            }
			// Begin TT#4638 - JSmith - Creating a Group name that includes "/" produces an unhandled exception
            else if (!MIDMath.ValidFileName(groupName))
            {
                aMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_HeaderNameInvalid), groupName, Include.HeaderNameExcludedCharacters);
                MessageBox.Show(aMessage, messageTitle, MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                okToContinue = false;
            }
			// End TT#4638 - JSmith - Creating a Group name that includes "/" produces an unhandled exception

            if (okToContinue && headerData.DuplicateHeaderExists(groupName, -1))
            {
                aMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicateHeaderIdNotAllowed);
                MessageBox.Show(aMessage, messageTitle, MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                okToContinue = false;
            }

            if (okToContinue && _selectedHeaderKeyList.Count == 0)
            {
                aMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeaderRequiredForGroupAllocation);
                MessageBox.Show(aMessage, messageTitle, MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                okToContinue = false;
            }

            if (okToContinue && _selectedHeaderKeyList.Count > 0)
            {
                DialogResult diagResult = DialogResult.Ignore;
                {
                    List<string> errList = new List<string>();
                    foreach (int hdrRid in _selectedHeaderKeyList)
                    {
                        ap = new AllocationProfile(appTransaction, null, hdrRid, SAB.ApplicationServerSession);
                        if (!(ap.GetHeaderAllocationStatus(true) == eHeaderAllocationStatus.ReceivedInBalance || ap.GetHeaderAllocationStatus(true) == eHeaderAllocationStatus.AllocationStarted))
                        {
                            aMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_InvalidHeaderStatusGroupAllocation);
                            aMessage = aMessage.Replace("{0}", ap.HeaderID);
                            errList.Add("--" + aMessage);
                            continue;
                        }
                        if (ap.HeaderType == eHeaderType.WorkupTotalBuy || ap.HeaderType == eHeaderType.MultiHeader || ap.HeaderType == eHeaderType.IMO)	// TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                        {
                            aMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_InvalidGroupTypeGroupAllocation);
                            aMessage = aMessage.Replace("{0}", ap.HeaderID);
                            errList.Add("--" + aMessage);
                            continue;
                        }
                        if (ap.AsrtRID > 0)
                        {
                            aMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AlreadyInGroupAllocation);
                            aMessage = aMessage.Replace("{0}", ap.HeaderID);
                            errList.Add("--" + aMessage);
                            continue;
                        }
                        // Begin TT#1966-MD - JSmith - DC Fulfillment
                        if (ap.IsSubordinateHeader)
                        {
                            aMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_SubordinateCannotBeAddedToGroupAllocation);
                            aMessage = aMessage.Replace("{0}", ap.HeaderID);
                            errList.Add("--" + aMessage);
                            continue;
                        }
                        // End TT#1966-MD - JSmith - DC Fulfillment

                        if (validSelectedHeaderKeyList.Count == 0)
                        {
                            firstStyleRid = ap.StyleHnRID;
                            firstPlanLevelRid = ap.PlanHnRID;
                            firstShipToDay = ap.ShipToDay;
                        }
                        validSelectedHeaderKeyList.Add(ap.Key);
                    }

                    if (errList.Count > 0)
                    {
                        string msg = string.Empty;
                        foreach (string line in errList)
                        {
                            msg = msg + line + "\n";
                        }

                        if (validSelectedHeaderKeyList.Count > 0)
                        {
                            aMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AddHeadersErrorGroupAllocation);
                            diagResult = MessageBox.Show(aMessage + msg, messageTitle, MessageBoxButtons.OKCancel, System.Windows.Forms.MessageBoxIcon.Warning);
                            if (diagResult != System.Windows.Forms.DialogResult.OK)
                            {
                                okToContinue = false;
                            }
                        }
                        else
                        {
                            aMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_NoValidHeadersSelectedForGroupAllocation);
                            diagResult = MessageBox.Show(aMessage + msg, messageTitle, MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Warning);
                            okToContinue = false;
                        }
                    }
                }
            }

            return okToContinue;
        }
		// End TT#1122 - md - stodd - calendar exception creating group allocation - 
		
		// BEGIN TT#488-MD - Stodd - Group Allocation
		private void DeleteGroupAllocation(string groupName)
		{
			Header headerData = new Header(); 
            //ApplicationSessionTransaction newTrans = SAB.ApplicationServerSession.CreateTransaction(); // TT#960 - MD - JEllis - Workspace not reflecting status correctly after action in Style Review
            ApplicationSessionTransaction newTrans = GetApplicationSessionTransaction();                 // TT#960 - MD - JEllis - Workspace not reflecting status correctly after action in Style Review
			//bool error = true;
			string errMessage = string.Empty;
            List<int> hdrList = null;   // Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
			try
			{
				if (groupName == string.Empty)
				{
					errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_ValueRequired);
					errMessage = errMessage.Replace("{0}", "Group Allocation name");
					MessageBox.Show(errMessage);
					return;		
				}

				int groupAllocRid = headerData.GetHeaderRID(groupName);
				if (groupAllocRid == 0)
				{
					errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_ValueWasNotFound, false, null);	// TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
					errMessage = errMessage.Replace("{0}", "Group Allocation, " + groupName + ", ");
					MessageBox.Show(errMessage);
					return;	
				}
				
				// Begin TT#931 - MD - When deleting a Group Allocation there is no "Are you sure?" message
                string msg = SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_ConfirmDeleteExplorerChild, false, groupName);
                eMIDMessageLevel messageLevel = SAB.ClientServerSession.Audit.GetMessageLevel(eMIDTextCode.msg_ConfirmDeleteExplorerChild);
                SAB.ClientServerSession.Audit.Add_Msg(messageLevel, msg, this.GetType().Name, true);

                msg = msg.Replace("{0}", groupName);
                DialogResult dialogResult = MessageBox.Show(msg, "Confirm Delete", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                if (dialogResult == DialogResult.Yes)
				// End TT#931 - MD - When deleting a Group Allocation there is no "Are you sure?" message
                {
                    string enqMessage = string.Empty;
                    DataTable dtHeaders = headerData.GetHeadersInAssortment(groupAllocRid);
                    hdrList = new List<int>(dtHeaders.Rows.Count);    // TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                    foreach (DataRow aRow in dtHeaders.Rows)
                    {
                        int hdrRid = int.Parse(aRow["HDR_RID"].ToString());
                        hdrList.Add(hdrRid);
                    }

                    // Enqueue
                    bool success = newTrans.EnqueueHeaders(hdrList, out enqMessage);
                    if (!success)
                    {
                        MessageBox.Show(enqMessage);
                        return;
                    }

                    headerData.OpenUpdateConnection();
                    headerData.DeleteGroupAllocation(groupAllocRid);
                    // Begin TT#931 - MD - When deleting a Group Allocation there is no "Are you sure?" message
                    headerData.CommitData();

                    // Cleans up header array lists in HeaderServerSession
                    SAB.HeaderServerSession.DeleteAssortmentHeader(groupAllocRid, groupName);

					// Begin TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                    object[] parms = new string[1] {"Group Allocation, " + groupName + ", "};
                    errMessage = SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DeleteSuccessfulWithValue, parms);
                    //errMessage = errMessage.Replace("{0}", "Group Allocation, " + groupName + ", ");
					// End TT#1395-MD - stodd - Adding VSW Headers to a Group produces incorrect messages
                    MessageBox.Show(errMessage);

                   
                    // Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                    if (hdrList != null)
                    {
                        //IRefresh();
                        int[] hdrList1 = hdrList.ToArray();
                        ReloadUpdatedHeaders(hdrList1);
                    }
                    // End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                    // End TT#931 - MD - When deleting a Group Allocation there is no "Are you sure?" message
                }

				//error = false;
			}
			catch
			{
				//error = true;
				throw;
			}
			finally
			{
				if (headerData.ConnectionIsOpen)
				{
                    //headerData.CommitData();  // TT#931 - MD - When deleting a Group Allocation there is no "Are you sure?" message
					headerData.CloseUpdateConnection();
				}
				newTrans.DequeueHeaders();
                // Begin TT#931 - MD - When deleting a Group Allocation there is no "Are you sure?" message
                // Moved outside of "Finally"
                //if (!error)
                //{
                //    errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DeleteSuccessfulWithValue);
                //    errMessage = errMessage.Replace("{0}", "Group Allocation, " + groupName + ", ");
                //    MessageBox.Show(errMessage);
                //    // Begin TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces
                //    if (hdrList != null)
                //    {
                //        //IRefresh();
                //        int[] hdrList1 = hdrList.ToArray();
                //        ReloadUpdatedHeaders(hdrList1);
                //    }
                //    // End TT#921 - MD - replace IRefresh with ReloadUpdatedHeaders for workspaces

                //}
                // End TT#931 - MD - When deleting a Group Allocation there is no "Are you sure?" message
			}

		}
		// END TT#488-MD - Stodd - Group Allocation
		
        // BEGIN Usability Enhancement
        private void CheckToOpenDetailsGrid()
        { 
            try
            {
                if (!_detailsShown)
                {
                    ShowDetails();
                }
            }
            catch
            {
                throw;
            }
        }

        private void CheckForEditMode()
        {
            try
            {
                if (!_inEditMode)
                {
                    EventArgs args = new EventArgs();
                    cmsSave_Click(cmsSave, args);
                }
            }
            catch
            {
                throw;
            }
        }
        // END Usability Enhancement

        private void AddHeaderRow()
        {
            try
            {
                // Begin TT#863 - RMatelic - Allocation Workspace-cannot add header, fields appear to be locked from entry
                SetEditInitialization(this.ugDetails.DisplayLayout.Bands["Header"]);
                // End TT#863 

                UltraGridRow row = this.ugDetails.DisplayLayout.Bands["Header"].AddNew();
                // Begin TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0
                this.ugDetails.Rows.Move(row, 0);
                // End TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0
                this.ugDetails.ActiveRow = row;
                this.ugDetails.ActiveRow.Cells["HeaderID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                this.ugDetails.ActiveCell = this.ugDetails.ActiveRow.Cells["HeaderID"];
                this.ugDetails.ActiveRow.Cells["StyleSecurity"].Value = (int)eSecurityType.Update;
                this.ugDetails.ActiveRow.Cells["Status"].Value = (int)eHeaderAllocationStatus.ReceivedInBalance;
                this.ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                _headerAdded = true;
            }
            catch  
            {
                throw;
            }
        }

        private void cmsAddPack_Click(object sender, EventArgs e)
        {
            try
            {
                AddPackRow();
            }
            catch (Exception ex)
            {
                MIDException MIDExc = new MIDException(eErrorLevel.information, 0, ex.Message);
                HandleMIDException(MIDExc);
            }
        }

        private void cmsAddMTColor_Click(object sender, EventArgs e)
        {
            try
            {
                switch (_rClickRow.Band.Key)
                {
                    case "Header":
                    //case "Placeholder":
                    case "BulkColor":
                        AddBulkColorRow();
                        break;
                    
                    case "Pack":
                    case "PackColor":
                        ugDetails.ActiveRow = _rClickRow;
                        AddPackColorRow();
                        break;

                }
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        // Begin TT#376 - RMatelic - Adding Components and scrolling
        private void ScrollRowIntoView(UltraGridRow aRow)
        {
            try
            {
                this.ugDetails.DisplayLayout.RowScrollRegions[0].ScrollRowIntoView(aRow); 
            }
            catch
            {
                throw;
            }
        }
        // End TT#376 

        private bool AddPackRow()
        {
            bool addOK = true;
            try
            {
                CheckForRelations();
                if (!RowActive())
                {
                    addOK = false;
                }
                else
                {
                    while (ugDetails.ActiveRow.Band.Key != "Header")
                    {
                        ugDetails.ActiveRow = ugDetails.ActiveRow.ParentRow;
                    }

                    int hdrRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                    // Begin TT#863 - RMatelic - Allocation Workspace-cannot add header, fields appear to be locked from entry
                    SetEditInitialization(this.ugDetails.DisplayLayout.Bands["Pack"]);
                    // End TT#863

                    UltraGridRow row = this.ugDetails.DisplayLayout.Bands["Pack"].AddNew();
                
                    row.Cells["KeyH"].Value = hdrRID;
                    CalculateBalances(eBalanceAction.RowAdded, row.Cells["QuantityPerPack"]);
                    ugDetails.ActiveRow = row;
                    ugDetails.ActiveCell = row.Cells["Pack"];
                    if (!_creatingMulti && !_creatingAssortment)
                    {
                        ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                    }
                    _rClickRow = row;
                    ScrollRowIntoView(row); // TT#376 - RMatelic - Adding Components and scrolling
                }
            }
            catch
            {
                addOK = false;
                throw;
            }
            return addOK;
        }

        private bool AddBulkColorRow()
        {
            bool addOK = true;
            try
            {
                CheckForRelations();

                if (!RowActive())
                {
                    addOK = false;
                }
                else
                {
                    while (ugDetails.ActiveRow.Band.Key != "Header")
                    {
                        ugDetails.ActiveRow = ugDetails.ActiveRow.ParentRow;
                    }

                    int hdrRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                    // Begin TT#863 - RMatelic - Allocation Workspace-cannot add header, fields appear to be locked from entry
                    SetEditInitialization(this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                    // End TT#863
                    
                    UltraGridRow row = this.ugDetails.DisplayLayout.Bands["BulkColor"].AddNew();

                    row.Cells["KeyH"].Value = hdrRID;
                    this.ugDetails.ActiveRow.Cells["BulkColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                    CalculateBalances(eBalanceAction.RowAdded, row.Cells["Quantity"]);

                    ugDetails.ActiveRow = row;
                    ugDetails.ActiveCell = row.Cells["BulkColor"];
                    if (!_creatingMulti)
                    {   // BEGIN MID Track #5977 - Workup Buy database foreign key error
                        if (Convert.ToInt32(row.ParentRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.WorkupTotalBuy)
                        {
                            row.Cells["Quantity"].Activation = Activation.NoEdit;
                        }
                        // END MID Track #5977  
                        ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                    }
                    _rClickRow = row;
                    ScrollRowIntoView(row); // TT#376 - RMatelic - Adding Components and scrolling
                }
            }
            catch
            {
                addOK = false;
                throw;
            }
            return addOK;
        }


        private bool AddPackColorRow()
        {
            bool addOK = true;

            try
            {
                if (!RowActive())
                {
                    addOK = false;
                }
                else
                {
                    while (ugDetails.ActiveRow.Band.Key != "Pack")
                    {
                        ugDetails.ActiveRow = this.ugDetails.ActiveRow.ParentRow;
                    }

                    int hdrRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    int packRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);

                    // Begin TT#863 - RMatelic - Allocation Workspace-cannot add header, fields appear to be locked from entry
                    SetEditInitialization(this.ugDetails.DisplayLayout.Bands["PackColor"]);
                    // End TT#863

                    UltraGridRow row = this.ugDetails.DisplayLayout.Bands["PackColor"].AddNew();

                    row.Cells["KeyH"].Value = hdrRID;
                    row.Cells["KeyP"].Value = packRID;
                    //row.Cells["ColorCodeRID"].Value = -78;
                    //row.Cells["PackColor"].Value = string.Empty; 
                    this.ugDetails.ActiveRow.Cells["PackColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                    ugDetails.ActiveCell = row.Cells["PackColor"];
                    if (!_creatingMulti && !_creatingAssortment)
                    {
                        ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                    }
                    CalculateBalances(eBalanceAction.RowAdded, row.Cells["QuantityPerPack"]);
                    if (!_creatingMulti && !_skipRowUpdate && !_creatingAssortment)
                    {
                        row.Update();
                    }
                    _rClickRow = row;
                    ScrollRowIntoView(row); // TT#376 - RMatelic - Adding Components and scrolling
                }
            }
            catch
            {
                addOK = false;
                throw;
            }
            return addOK;
        }

        private void CheckForRelations()
        {
            try
            {
                bool relationAdded = false;

                if (!_dsDetails.Relations.Contains("Pack"))
                {
                    _dsDetails.Relations.Add("Pack", _dsDetails.Tables["Header"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyH"]);
                    relationAdded = true;
                }

                if (!_dsDetails.Relations.Contains("PackColor"))
                {
                    _dsDetails.Relations.Add("PackColor", new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                                                    new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"] }, true);
                    relationAdded = true;
                }

                if (!_dsDetails.Relations.Contains("BulkColor"))
                {
                    _dsDetails.Relations.Add("BulkColor", _dsDetails.Tables["Header"].Columns["KeyH"], _dsDetails.Tables["BulkColor"].Columns["KeyH"]);
                    relationAdded = true;
                }

                if (relationAdded)
                {
                    _dsDetails.AcceptChanges();
                }
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }

        private bool RowActive()
        {
            if (ugDetails.ActiveRow == null)
            {
                MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_UnableToAddRow),
                            _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                return false;
            }
            return true;
        }

        private void cmsChooseColor_Click(object sender, EventArgs e)
        {
            try
            {
                ArrayList colorRIDs = new ArrayList();
                bool allowPlaceHolders = false;
                _fromCellButton = false;
                _colorSelectRow = _rClickRow;

                if (ugDetails.Selected.Rows.Count == 0)
                {
                    _colorSelectRow.Selected = true;
                }
                foreach (UltraGridRow selectedRow in ugDetails.Selected.Rows)
                {
                    UltraGridRow selRow = selectedRow;
                    while (selRow.Band.Key != "Header")
                    {
                        selRow = selRow.ParentRow;
                    }
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (headerType == eHeaderType.Assortment || headerType == eHeaderType.Placeholder)
                    {
                        UltraGridRow colorRow = null;
                        allowPlaceHolders = true;

                        switch (selectedRow.Band.Key)
                        {
                            case "Header":
                            //case "Placeholder":
                                if (ugDetails.DisplayLayout.Bands.Exists("BulkColor"))
                                {
                                    colorRow = selectedRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                                }
                                break;
                            
                            case "Pack":
                                if (ugDetails.DisplayLayout.Bands.Exists("PackColor"))
                                {
                                    colorRow = selectedRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                                }
                                break;
                               
                            default:
                                colorRow = selectedRow.GetSibling(SiblingRow.First, false);
                                break;

                        }
                       
                        while (colorRow != null)
                        {
                            int colorCodeRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                            if (Convert.ToBoolean(colorRow.Cells["IsVirtual"].Value, CultureInfo.CurrentUICulture))
                            {
                                if (!colorRIDs.Contains(colorCodeRID))
                                {
                                    colorRIDs.Add(colorCodeRID);
                                }
                            }
                            colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                }
                ChooseColors(allowPlaceHolders, colorRIDs);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void ChooseColors(bool aAllowPlaceHolders, ArrayList aColorRIDs )
        {
            try
            {
                if (_frmColorBrowser != null)
                {
                    _frmColorBrowser.Dispose();
                }
                _frmColorBrowser = new ColorBrowser(_SAB, aAllowPlaceHolders, aColorRIDs);
                _frmColorBrowser.OnColorBrowserSelectHandler += new ColorBrowser.ColorBrowserSelectEventHandler(form_OnColorBrowserSelectHandler);
                //_frmColorBrowser.MdiParent = this.ParentForm.Owner;
                //  Allow for a floating explorer.   ParentForm is not Client.Explorer if floating
                if (this.ParentForm.GetType().FullName == "MIDRetail.Windows.Explorer")
                //{
                //    _frmColorBrowser.MdiParent = this.ParentForm;
                //}
                // Begin TT#623 - RMatelic - add a Bulk color, using the Empty Row option, and recieved a MIDFormsBase.cs error. -  
                // error occurs when Workspace is neither Dockable nor Floating >> the ParentForm.Owner was null
                //else 
                //{
                //    _frmColorBrowser.MdiParent = this.ParentForm.Owner;
                //}
                if (this.ParentForm.Owner != null)
                {
                    _frmColorBrowser.MdiParent = this.ParentForm.Owner;
                }
                // Begin TT#623 - RMatelic - add a Bulk color, using the Empty Row option, and recieved a MIDFormsBase.cs error. -  
                // error occurs when Workspace is neither Dockable nor Floating >> the ParentForm.Owner was null
                //else 
                //{
                //    _frmColorBrowser.MdiParent = this.ParentForm.Owner;
                //}
                else if (this.ParentForm.Owner != null)
                {
                    _frmColorBrowser.MdiParent = this.ParentForm.Owner;
                }
                else
                {
                    _frmColorBrowser.MdiParent = EAB.Explorer;
                }
                // End TT#623
                _frmColorBrowser.StartPosition = FormStartPosition.CenterScreen;
                _frmColorBrowser.Show();
                _frmColorBrowser.Focus();
            }
            catch
            {
                throw;
            }
        }

        private void form_OnColorBrowserSelectHandler(object source, ColorBrowserSelectEventArgs e)
        {
            bool okToContinue = true;
            int colorCodeRID;
            string errorMessage = string.Empty;
            _firstNewRow = null;

            // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            //ugDetails.BeginUpdate();
            ugDetailsBeginUpdate();
            // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
           // ugDetails.SuspendRowSynchronization(); - the Suspend put the new rows at the top instead of the bottom
            ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, false);
            try
            {
                if (_colorSelectRow == null || (e.NumberOfPlaceholderColors == 0 && e.SelectedColors.Count == 0))
                {
                    return;
                }
                if (!_colorSelectRow.Selected)
                {
                    _colorSelectRow.Selected = true;
                }

                // for some reason the CheckForRelations selected more rows so save the current selected
                // rows, then reselect them after the method
                ArrayList selRows = new ArrayList();

                foreach (UltraGridRow selectedRow in ugDetails.Selected.Rows)
                {
                    selRows.Add(selectedRow);
                }
                CheckForRelations();
                ugDetails.Selected.Rows.Clear();

                for (int i = 0; i < selRows.Count; i++)
                {
                    UltraGridRow row = (UltraGridRow)selRows[i];
                    row.Selected = true;
                }

                foreach (UltraGridRow selectedRow in ugDetails.Selected.Rows)
                {
                    if (e.NumberOfPlaceholderColors > 0)
                    {
                        UltraGridRow selRow = selectedRow;
                        
                        while (selRow.Band.Key != "Header")
                        {
                            selRow = selRow.ParentRow;
                        }
                        eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                        if (headerType == eHeaderType.Assortment || headerType == eHeaderType.Placeholder)
                        {
                            ArrayList colorRIDs = new ArrayList();

                            switch (_colorSelectRow.Band.Key)
                            {
                                case "Header":
                                //case "Placeholder":
                                case "BulkColor":
                                    colorRIDs = LoadCurrentColors(selRow, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                                    break;
                               
                                case "Pack":
                                    colorRIDs = LoadCurrentColors(_colorSelectRow, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                                    break;

                                case "PackColor":
                                    colorRIDs = LoadCurrentColors(_colorSelectRow.ParentRow, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                                    break;
                            }
                            _skipRowUpdate = true;
                            if (!AddPlaceholderColorRows(selectedRow, colorRIDs, e.PlaceHolders, e.NumberOfPlaceholderColors))
                            {
                                _skipRowUpdate = false;
                                return;
                            }
                            _skipRowUpdate = false;
                         }
                    }
      
                    if (okToContinue)
                    {
                        if (e.SelectedColors.Count > 0)
                        {
                            if (_fromCellButton)
                            {
                                colorCodeRID = (int)e.SelectedColors[0];
                                ColorCodeProfile ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);
                                UpdateColorValue(selectedRow, ccp.ColorCodeID, ref errorMessage);
                            }
                            else
                            {
                                _skipRowUpdate = true;
                                AddColorRows(selectedRow, e.SelectedColors);
                                _skipRowUpdate = false;
                            }
                        }
                        if (_firstNewRow != null)
                        {
                            ugDetails.ActiveRow = _firstNewRow;
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
            finally
            {
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowDeactivate, true);
               // ugDetails.ResumeRowSynchronization();
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.EndUpdate();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            }
        }

        private ArrayList LoadCurrentColors(UltraGridRow aSelectedRow, UltraGridBand aColorBand)
        {
            try
            {
                ArrayList colorRIDs = new ArrayList();
                UltraGridRow colorRow = aSelectedRow.GetChild(ChildRow.First, aColorBand);
                while (colorRow != null)
                {
                    int colorCodeRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                    if (Convert.ToBoolean(colorRow.Cells["IsVirtual"].Value, CultureInfo.CurrentUICulture))
                    {
                        if (!colorRIDs.Contains(colorCodeRID))
                        {
                            colorRIDs.Add(colorCodeRID);
                        }
                    }
                    colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                }
                return colorRIDs;
            }
            catch
            {
                throw;
            }
            
        }
          
        private bool AddPlaceholderColorRows(UltraGridRow aRow, ArrayList aExistingRIDs, ArrayList aPhColorList, int aRequestedCount)
        {
            bool okToContinue = true;
            try
            {
                string errorMessage = string.Empty;
           
                for (int i = 0; i < aRequestedCount; i++)
                {
                    ColorCodeProfile ccp = null;
                    int colorCodeRID = Include.NoRID;
                    for (int j = 0; j < aPhColorList.Count; j++)
                    {
                        ccp = (ColorCodeProfile)aPhColorList[j];
                       
                        if (!aExistingRIDs.Contains(ccp.Key))
                        {
                            aExistingRIDs.Add(ccp.Key);
                            colorCodeRID = ccp.Key;
                            break;
                        }
                    }
                    if (colorCodeRID == Include.NoRID)
                    {
                        MessageBox.Show("Not enough available Placeholder colors");
                        return false;
                    }
                   
                    ugDetails.ActiveRow = aRow;
                    switch (aRow.Band.Key)
                    {
                        case "Header":
                        //case "Placeholder":
                        case "BulkColor":
                            okToContinue = AddBulkColorRow();
                            break;

                        case "Pack":
                        case "PackColor":
                            okToContinue = AddPackColorRow();
                            break;
                    }
                    if (okToContinue)
                    {
                        UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                        if (_firstNewRow == null)
                        {
                            _firstNewRow = ugDetails.ActiveRow;
                        }
                        if (ccp.VirtualInd && aRow.Band.Key == "Header")
                        {
                            int phRID = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            if (_phColorAutoAdd)
                            {
                                AddPlaceholderColorToLinkProfile(phRID, ugDetails.ActiveRow);
                            }
                        }
                    }
                    else
                    {
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
            return okToContinue;
        }

        private void AddColorRows(UltraGridRow aRow, ArrayList aSelectedColors)
        {
            try
            {
                string errorMessage = string.Empty;
                bool okToContinue = true;
            
                for (int i = 0; i < aSelectedColors.Count; i++)
                {
                    int colorCodeRID = (int)aSelectedColors[i];
                    ColorCodeProfile ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);

                    ugDetails.ActiveRow = aRow;
                    switch (aRow.Band.Key)
                    {
                        case "Header":
                        //case "Placeholder":
                        case "BulkColor":
                            okToContinue = AddBulkColorRow();
                            break;

                        case "Pack":
                        case "PackColor":
                            okToContinue = AddPackColorRow();
                            break;
                    }
                    if (okToContinue)
                    {
                        okToContinue = UpdateColorValue(ugDetails.ActiveRow, ccp.ColorCodeID, ref errorMessage);
                        if (_firstNewRow == null)
                        {
                            _firstNewRow = ugDetails.ActiveRow;
                        }
                    }
                    if (!okToContinue)
                    {
                        break;
                    }
                }
            }
            catch
            {
                throw;
            }
        }
       
        private bool UpdateColorValue(UltraGridRow aRow, string aColorCodeID, ref string errorMessage)
        {
            bool validColor = false;
            try
            {
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeCellUpdate, false);
                switch (aRow.Band.Key)
                {
                    case "BulkColor":
                        aRow.Cells["BulkColor"].Value = aColorCodeID;
                        validColor = ValidBulkColor(aRow.Cells["BulkColor"], aColorCodeID, ref errorMessage);
                             break;

                    case "PackColor":
                        aRow.Cells["PackColor"].Value = aColorCodeID;
                        validColor = ValidPackColor(aRow.Cells["PackColor"], aColorCodeID, ref errorMessage);
                        break;
                }
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeCellUpdate, true);
            }
            catch
            {
                throw;
            }
            return validColor;
        }

    
        private void cmsAddBulkSize_Click(object sender, EventArgs e)
        {
            try
            {
                UltraGridRow bulkColorRow = ugDetails.ActiveRow;

                if (bulkColorRow.Band.Key != "BulkColor")
                {
                    if (_rClickRow.Band.Key == "BulkColor")
                    {
                        bulkColorRow = _rClickRow;
                    }
                    else
                    {
                        return;
                    }
                }

                bulkColorRow.Update();  // MID TRack #5522 data wasn;t getting applied to ugDetails grid 
                UltraGridRow headerRow = bulkColorRow.ParentRow;

                this.ugDetails.UpdateData();

                string colorID = bulkColorRow.Cells["BulkColor"].Value.ToString();
                int headerRID = Convert.ToInt32(bulkColorRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                int colorRID = Convert.ToInt32(bulkColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                // BEGIN MID Track #5977 - Workup Buy database foreign key error
                int colorCodeRID = Convert.ToInt32(bulkColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                // END MID Track #5977
                string sizeTableName = "BulkSize" + "~"
                    + headerRID.ToString(CultureInfo.CurrentUICulture) + "~"
                    + colorRID.ToString(CultureInfo.CurrentUICulture);

                // does it already exist?
                if (_dsDetails.Relations.Contains(sizeTableName))
                {
                    MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SizeTableExists));
                    return;
                }

                // get the size group
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(headerRID);
                if (ap.SizeGroupRID == Include.UndefinedSizeGroupRID)
                {
                    MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SizeGroupRequired),
                            _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
                
                int sizeTotal = 0;
                _addingSizes = true;
                DataTable dtBulkSize = FormatBulkSizeTable(null, ap.SizeGroupRID, headerRID, colorRID, colorID, sizeTableName, ref sizeTotal);
               
                if (dtBulkSize != null)
                {
                    // adding a new table to the DataSet fires the InitializeLayout event, but we don't want that here
                    ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, false);
                    // BEGIN MID Track #6026 - WorkUpBuy issues - AfterSelectChange was clearing _selectedHeaderKeyList
                    ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                    // END MID Track #6026 
                    _dsDetails.Tables.Add(dtBulkSize);
                 
                    _dsDetails.Relations.Add(sizeTableName,
                        new DataColumn[] { _dsDetails.Tables["BulkColor"].Columns["KeyH"], _dsDetails.Tables["BulkColor"].Columns["KeyC"] },
                        new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyC"] }, true);

                    _dsDetails.AcceptChanges();
                    // For some reason if a size band is added, deleted & re-added with no Save or Cancel,
                    // 2 bands with the same sizeTableName were created one of which is actually the BulkColor
                    // band columns. This caused subsequent errors because an erroneous band existed
                    // The BindDetailsGrid gets rid of the erroneous extra band
                    BindDetailsGrid();   
                     
                    FormatAddedSizesLayout(ugDetails.DisplayLayout.Bands[sizeTableName]);
                    // BEGIN MID Track #6026 - WorkUpBuy issues
                    ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                    // END MID Track #6026 - WorkUpBuy issues
                    ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, true);
 
                    // BEGIN MID Track #2921
                    // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    //ugDetails.BeginUpdate();
                    ugDetailsBeginUpdate();
                    // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    headerRow  = bulkColorRow.ParentRow;
                    ugDetails.ActiveRow = headerRow;
                    headerRow.ExpandAll();
                    UltraGridRow row = headerRow.GetChild(ChildRow.First);
                    while (row != null)
                    {
                        int colorRowValue = Convert.ToInt32(row.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                        int bulkColorRowValue = Convert.ToInt32(bulkColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                        if (colorRowValue != bulkColorRowValue)
                        {
                            row.Expanded = false;
                        }
                        row = row.GetSibling(SiblingRow.Next, true, false);
                    }

                    ugDetails.ActiveRow = headerRow;
                    // Begin TT#376 - RMatelic - Adding Components and scrolling
                    //ugDetails.DisplayLayout.RowScrollRegions[0].ScrollRowIntoView(ugDetails.ActiveRow);
                    // End TT#376  
                    //while (ugDetails.DisplayLayout.RowScrollRegions[0].VisibleRows[0].Row != ugDetails.ActiveRow)
                    //{
                    //    ugDetails.DisplayLayout.RowScrollRegions[0].Scroll(RowScrollAction.LineDown);
                    //}

                    // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    //ugDetails.EndUpdate();
                    ugDetailsEndUpdate();
                    // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    // END MID Track #2921

                    // BEGIN MID Track #3807 - Size Review error when selecting Workup SIze Buy 
                    if ((eHeaderType)Convert.ToInt32(headerRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == eHeaderType.WorkupTotalBuy)
                    {
                        UltraGridRow sizeRow = bulkColorRow.GetChild(ChildRow.First);
                        while (sizeRow != null)
                        {
                            for (int j = 7; j < sizeRow.Cells.Count; j++)
                            {
                                int sizeCodeKey = Convert.ToInt32(sizeRow.Cells[j].Tag, CultureInfo.CurrentUICulture);
                                sizeRow.Cells[j].Value = 0;
                                // BEGIN MID Track #5977 - Workup Buy database foreign key error
                                //ap.AddBulkSizeToColor(colorRID, sizeCodeKey, 0, -1);
                                ap.AddBulkSizeToColor(colorCodeRID, sizeCodeKey, 0, -1);
                                sizeRow.Cells[j].Activation = Activation.NoEdit;
                                // END MID Track #5977  
                            }
                            sizeRow = sizeRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                    // END MID Track #3807	 
                    // Begin TT#376 - RMatelic - Adding Components and scrolling
                    UltraGridRow lastRow = bulkColorRow.GetChild(ChildRow.Last);
                    ScrollRowIntoView(lastRow);
                    // End TT#376  
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }

        }
      
        private void cmsAddPackSize_Click(object sender, EventArgs e)
        {
            string errorMessage = string.Empty;
            string colorID, sizeTableName, namePrefix;
            int headerRID, packRID, colorRID, sizeTotal;
			UltraGridRow headerRow;
		    try
            {
                UltraGridRow packColorRow = ugDetails.ActiveRow;
                if (packColorRow.Band.Key != "PackColor" && packColorRow.Band.Key != "Pack")
                {
                    if (_rClickRow.Band.Key == "PackColor" || packColorRow.Band.Key == "Pack")
                    {
                        packColorRow = _rClickRow;
                    }
                    else
                    {
                        return;
                    }
                }
                packColorRow.Update();
                
                if (packColorRow.Band.Key == "PackColor")
                {
                    headerRow = packColorRow.ParentRow.ParentRow;
                    colorID = packColorRow.Cells["PackColor"].Value.ToString();
                    colorRID = Convert.ToInt32(packColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                    namePrefix = "PackColorSize";
                }
                else
                {
                    headerRow = packColorRow.ParentRow;
                    ColorCodeProfile ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(Include.DummyColorRID);
                    colorID = ccp.ColorCodeID;
                    colorRID = ccp.Key;
                    namePrefix = "PackSize";
                    if (!DummyColorCheckOK(packColorRow))
                    {
                        return;
                    }
                }
               
                headerRID = Convert.ToInt32(packColorRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                packRID = Convert.ToInt32(packColorRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                sizeTableName = namePrefix + "~"
                    + headerRID.ToString(CultureInfo.CurrentUICulture) + "~"
                    + packRID.ToString(CultureInfo.CurrentUICulture)   + "~"
                    + colorRID.ToString(CultureInfo.CurrentUICulture);
               
                // does it already exist?
                if (_dsDetails.Relations.Contains(sizeTableName))
                {
                    MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SizeTableExists));
                    return;
                }

                // get the size group
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(headerRID);
                if (ap.SizeGroupRID == Include.UndefinedSizeGroupRID)
                {
                    MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SizeGroupRequired),
                           _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
               
                sizeTotal = 0;
                _addingSizes = true;
                DataTable dtPackSize = FormatPackSizeTable(null, ap.SizeGroupRID, headerRID, packRID, colorRID, colorID, sizeTableName, ref sizeTotal);

                if (dtPackSize != null)
                {   // adding a new table to the DataSet fires the InitializeLayout event, but we don't want that here
                    ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, false);
                    _dsDetails.Tables.Add(dtPackSize);
                  
                    try
                    {
                        if (colorID == Include.DummyColorID)
                        {
                            _dsDetails.Relations.Add(sizeTableName,
                                new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                                new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyP"] }, true);
                        }
                        else
                        {
                            _dsDetails.Relations.Add(sizeTableName,
                                new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"], _dsDetails.Tables["PackColor"].Columns["KeyC"] },
                                new DataColumn[] { _dsDetails.Tables[sizeTableName].Columns["KeyH"], _dsDetails.Tables[sizeTableName].Columns["KeyP"], _dsDetails.Tables[sizeTableName].Columns["KeyC"] }, true);
                        }
                        _dsDetails.AcceptChanges();
                        // For some reason if a size band is added, deleted & re-added with no Save or Cancel,
                        // 2 bands with the same sizeTableName were created one of which is actually the BulkcColor
                        // band columns. This caused subsequent errors because an erroneous band existed
                        // The BindDetailsGrid gets rid of the extra band
                        BindDetailsGrid();   

                        FormatAddedSizesLayout(ugDetails.DisplayLayout.Bands[sizeTableName]);
                        ugDetails.EventManager.SetEnabled(GridEventIds.InitializeLayout, true);

                        packColorRow.Expanded = true;
                        // Begin TT#376 - RMatelic - Adding Components and scrolling
                        UltraGridRow lastRow = packColorRow.GetChild(ChildRow.Last);
                        ScrollRowIntoView(lastRow);
                        // End TT#376  
                    }
                    catch
                    {
                        throw;
                    }
                }
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }
        
        private void FormatAddedSizesLayout(UltraGridBand band)
        {
            try
            {
                band.Columns["KeyH"].Hidden = true;
                band.Columns["KeyP"].Hidden = true;
                band.Columns["KeyC"].Hidden = true;
                band.Columns["SecondaryRID"].Hidden = true;  // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                band.Columns["Secondary"].Hidden = true;
                band.Columns[" - "].CellActivation = Activation.NoEdit;
                band.Columns["TotalQuantity"].CellActivation = Activation.Disabled;
               
                foreach (Infragistics.Win.UltraWinGrid.UltraGridColumn column in band.Columns)
                {
                    switch (column.DataType.ToString())
                    {
                        case "System.Int32":
                            column.CellAppearance.TextHAlign = Infragistics.Win.HAlign.Right;
                            column.Format = "#,###,##0";
                            break;
                        case "System.Double":
                            column.CellAppearance.TextHAlign = Infragistics.Win.HAlign.Right;
                            column.Format = "#,###,###.00";
                            break;
                    }
                }
 
                IEnumerable enumerator = band.GetRowEnumerator(GridRowType.DataRow);
                foreach (UltraGridRow sizeRow in enumerator)
                {
                    SetCellSizeKey(sizeRow);
                }
            }
            catch   
            {
                throw;
            }
        }

        private bool DummyColorCheckOK(UltraGridRow aRow)
        {
            ColorCodeProfile ccp;
            EditMsgs em;
            try
            {
                ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(Include.DummyColorRID);
                if (ccp.Key == -1)
                {
                    throw new Exception();
                }
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));

                HierarchyNodeProfile styleHnp = _SAB.HierarchyServerSession.GetNodeData(ap.StyleHnRID);
                em = new EditMsgs();
                int colorHnRID = _hierMaint.QuickAdd(ref em, styleHnp.Key, ccp.ColorCodeID, ccp.ColorCodeName);
                if (em.ErrorFound)
                {
                    DisplayMessages.Show(em, _SAB, Include.MIDAllocationWorkspaceExplorer);
                    return false;
                }

                string packName = Convert.ToString(aRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture);
             
                // BEGIN MID Tracks 5769, 5827 - multiheader processing errors 
                // Because AllocationProfile was changed to completely add all multiheader packs, the following
                // processing had to be modified
                bool dummyOnPack = false;
                int[] packColorCodeRIDs;

                
                if (ap.PackIsOnHeader(packName))
                {
                    packColorCodeRIDs = ap.GetPackColorCodeRIDs(packName);
                    if (packColorCodeRIDs.Length > 0)
                    {
                        for (int i = 0; i < packColorCodeRIDs.Length; i++)
                        {
                            if (packColorCodeRIDs[i] == Include.DummyColorRID)
                            {
                                dummyOnPack = true;
                                break;
                            }
                        }
                    }
                }
                //else
                //{
                //    UltraGridRow row = aRow.GetSibling(SiblingRow.First, false);
                //    while (row != null)
                //    {
                //        if (Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture) == Include.DummyColorRID)
                //        {
                //            dummyOnPack = true;
                //            break;
                //        }    
                //        row = row.GetSibling(SiblingRow.Next, false);
                //    }
                //}
                if (!dummyOnPack)
                {
                    // finally, add it to the header
                    if (!ap.MultiHeader)
                    {
                        ap.AddColorToPack(packName, Include.DummyColorRID, 0, 0);
                    }
                }
                // END MID Tracks 5769, 5827 
                return true;
            }
            catch (Exception ex)
            {
                HandleException(ex);
                return false;
            }
        }
        
        private void cmsRemove_Click(object sender, EventArgs e)
        {
            try
            {
                // disable event firing
                ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
            
                if (_rClickRow != null)
                {
                    _rClickRow.Selected = true;
                }
                foreach (UltraGridRow selectedRow in ugDetails.Selected.Rows)
                {
                    // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                    if (selectedRow == null ||
                        selectedRow.Disposed)
                    {
                        continue;
                    }
                    // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                    UltraGridRow selRow = selectedRow;
                    while (selRow.Band.Key != "Header")
                    {
                        selRow = selRow.ParentRow;
                    }
                    // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                    if (selRow == null ||
                        selRow.Disposed)
                    {
                        continue;
                    }
                    // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                    if (selRow.Cells["HdrGroupRID"].Value != DBNull.Value)
                    {
                        int hdrGroupRID = Convert.ToInt32(selRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);

                        foreach (UltraGridRow row in ugDetails.Rows)
                        {
                            if (row.Cells["HdrGroupRID"].Value != DBNull.Value 
                                && Convert.ToInt32(row.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture) == hdrGroupRID
                                && !row.Selected)
                            {
                                row.Selected = true;
                            }
                        }
                    }
                    else if (selRow.Cells["AsrtRID"].Value != DBNull.Value)
                    {
                        int asrtRID = Convert.ToInt32(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);

                        foreach (UltraGridRow row in ugDetails.Rows)
                        {
                            if (row.Cells["AsrtRID"].Value != DBNull.Value
                                && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == asrtRID
                                && !row.Selected)
                            {
                                row.Selected = true;
                            }
                        }
                    }
                    else
                    {
                        if (!selRow.Selected)
                        {
                            selRow.Selected = true;
                        }
                    }    
                }
                // enable event firing
                ugDetails.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugHeaders.BeginUpdate();
                //ugDetails.BeginUpdate();
                //ugDetails.SuspendRowSynchronization();

                ugHeadersBeginUpdate();
                
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls

                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, false);
             
                if (ugDetails.Selected.Rows.Count > 0)
                {
                    for (int i = ugDetails.Selected.Rows.Count - 1; i >= 0; i--)
                    {
                        //RemoveDetailGridRows(ugDetails.Selected.Rows[i]);
                        UltraGridRow row = ugDetails.Selected.Rows[i];
                        // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                        if (row == null ||
                            row.Disposed)
                        {
                            continue;
                        }
                        // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                        while (row.Band.Key != "Header")
                        {
                            row = row.ParentRow;
                        }
                        // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                        if (row == null ||
                            row.Disposed)
                        {
                            continue;
                        }
                        // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                        if (row.Cells["HeaderRow"].Value != System.DBNull.Value && 
                            row.Cells["HeaderRow"].Value != null)
                        {
                            UltraGridRow hdrRow = (UltraGridRow)row.Cells["HeaderRow"].Value;
                            hdrRow.Selected = false;
                        }
                    }
                    foreach (UltraGridRow dRow in ugDetails.Selected.Rows)
                    {
                        CheckForSelectedRemoval(dRow);
                    }
                    ugDetails.DeleteSelectedRows(false);
                }
                else if (ugDetails.ActiveRow != null)
                {
                    RemoveDetailGridRows(ugDetails.ActiveRow);
                }
            
                ugDetails.EventManager.SetEnabled(GridEventIds.BeforeRowsDeleted, true);

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.ResumeRowSynchronization();
                //ugDetails.EndUpdate();
                //ugHeaders.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                ugHeadersEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                // enable event firing
                ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);

                if (ugDetails.Rows.Count == 0)
                {
                    ResetWorkspace();
                }

                ClearSavedDetails();
                // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
                //_dsDetailsSaved = _dsDetails.Copy();
                if (_dsDetails != null)
                {
                    _dsDetailsSaved = _dsDetails.Copy();
                }
                // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.

                // BEGIN MID Track #6239 - Multi should not be split up; this reselects the headers
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    row.Selected = true;
                }
                // END MID Track #6239
                UpdateSelectedTotals();
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
		}

		private void RemoveDetailGridRows(UltraGridRow aRow)
		{
            try
            {
                UltraGridRow row = aRow;
                while (row.Band.Key != "Header")
                {
                    row = row.ParentRow;
                }
                if (row.Cells["HeaderRow"].Value != System.DBNull.Value)
                {
                    UltraGridRow hdrRow = (UltraGridRow)row.Cells["HeaderRow"].Value;
                    hdrRow.Selected = false;
                }
                CheckForSelectedRemoval(row);
                row.Delete(false);
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
		}

        private void cmsDelete_Click(object sender, EventArgs e)
        {
            try
            {
                Cursor.Current = Cursors.WaitCursor;
              
                _rowDeleted = false;
              
                if (ugDetails.Selected.Rows.Count == 0 && _rClickRow != null)
                {
                    _rClickRow.Selected = true;
                }
                ugDetails.DeleteSelectedRows();
    
                SetEditActivation();
                
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
            finally
            {
                Cursor.Current = Cursors.Default;
            }			
        }

        private void cmsFilter_Click(object sender, EventArgs e)
        {
            Filter();
        }
        private void Filter()
        {
            try
            {
                 //Begin TT#1170-MD -jsobek -Remove Binary database objects and normalize the Filter definitions

                //AllocationWorkspaceExplorerFilter awef = new AllocationWorkspaceExplorerFilter(_SAB);
                //awef.OnWorkspaceFilterChangeHandler += new AllocationWorkspaceExplorerFilter.WorkspaceFilterChangeEventHandler(OnWorkspaceFilterChangeHandler);

                //int defaultOwnerUserRID = _SAB.ClientServerSession.UserRID;  //From the workspace - just default to a user filter
                //frmFilterBuilder awef = SharedRoutines.GetFilterFormForNewFilters(filterTypes.HeaderFilter, SAB, EAB, defaultOwnerUserRID);
                EAB.FilterExplorerHeader.EditThisFilter(this._headerFilterRID);
               // SetHeaderFilter(this._headerFilterRID); //Execute the filter after it is edited
                //OnFilterPropertiesCloseClass closeHandler;
       
                //HeaderFilterProfile filterProf = new HeaderFilterProfile(this._headerFilterRID);
                //GenericEnqueue objEnqueue = EnqueueObject(filterProf, true);
                //if (objEnqueue != null)
                //{
                //    //filterProperties = new frmFilterProperties(SAB, (MIDFilterNode)node.Parent, _userNode, _globalNode, (HeaderFilterProfile)node.Profile, objEnqueue.IsInConflict);
                //    int _initialUserRID = ((HeaderFilterProfile)node.Profile).UserRID;
                //    int _initialOwnerRID = ((HeaderFilterProfile)node.Profile).OwnerUserRID;


                //    bool isReadOnly = false;
                //    //bool isShared = false;
                //    //if (_sharedNode != null && node.isChildOf(_sharedNode))
                //    //{
                //    //    isShared = true;
                //    //}
                //    if (objEnqueue.IsInConflict) // || isShared)
                //    {
                //        isReadOnly = true;
                //    }

                //    frmFilterBuilder filterProperties = new frmFilterBuilder(SAB, EAB, isReadOnly);

                //    filterProperties = SharedRoutines.GetFilterFormForExistingFilter(filterProf.Key, SAB, EAB, isReadOnly);



                //    closeHandler = new OnFilterPropertiesCloseClass(objEnqueue);

                //    filterProperties.OnFilterPropertiesCloseHandler += new frmFilterBuilder.FilterPropertiesCloseEventHandler(closeHandler.OnClose);
                //    //filterProperties.MdiParent = MDIParentForm;
                //    if (this.ParentForm.GetType().FullName == "MIDRetail.Windows.Explorer")
                //    {
                //        filterProperties.MdiParent = this.ParentForm;
                //    }
                //    else
                //    {
                //        filterProperties.MdiParent = this.ParentForm.Owner;
                //    }
                //    //awef.Show();
                //    filterProperties.Show();
                //    filterProperties.BringToFront();
                //}

                //End TT#1170-MD -jsobek -Remove Binary database objects and normalize the Filter definitions


             
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
        }
        private GenericEnqueue EnqueueObject(HeaderFilterProfile aFilterProf, bool aAllowReadOnly)
        {
            GenericEnqueue objEnqueue;
            string errMsg;

            try
            {
                objEnqueue = new GenericEnqueue(eLockType.Filter, aFilterProf.Key, SAB.ClientServerSession.UserRID, SAB.ClientServerSession.ThreadID);

                try
                {
                    objEnqueue.EnqueueGeneric();
                }
                catch (GenericConflictException)
                {
                    /* Begin TT#1159 - Improve Messaging */
                    string[] errParms = new string[3];
                    errParms.SetValue("MID Filter Node", 0);
                    errParms.SetValue(aFilterProf.Name.Trim(), 1);
                    errParms.SetValue(((GenericConflict)objEnqueue.ConflictList[0]).UserName, 2);
                    errMsg = MIDText.GetText(eMIDTextCode.msg_StandardInUseMsg, errParms);

                    //errMsg = "The Filter \"" + aFilterProf.Name + "\" is in use by User " + ((GenericConflict)objEnqueue.ConflictList[0]).UserName + ".";
                    /* End TT#1159 - Improve Messaging */

                    if (aAllowReadOnly)
                    {
                        errMsg += System.Environment.NewLine + System.Environment.NewLine;
                        errMsg += "Do you wish to continue with the Filter as read-only?";

                        if (MessageBox.Show(errMsg, this.Text, MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                        {
                            objEnqueue = null;
                        }
                    }
                    else
                    {
                        MessageBox.Show(errMsg, this.Text, MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
                        objEnqueue = null;
                    }
                }

                return objEnqueue;
            }
            catch
            {
                throw;
            }
        }

        
        //Begin TT#1170-MD -jsobek -Remove Binary database objects and normalize the Filter definitions
        //private void OnWorkspaceFilterChangeHandler(object source, WorkspaceFilterChangeEventArgs e)
        //{
        //    _fromFilterWindow = true;
        //    IRefresh();
        //    // Begin TT#3177 - JSmith - Incorrect Multi Header IDs again.
        //    //// Begin TT#544-MD - JSmith - Multi Headers show as number when added to filter.
        //    //AssignValueLists(ugHeaders);
        //    //if (_dsDetails != null)
        //    //{
        //    //    AssignValueLists(ugDetails);
        //    //}
        //    //// End TT#544-MD - JSmith - Multi Headers show as number when added to filter.
        //    // End TT#3177 - JSmith - Incorrect Multi Header IDs again.
        //    _fromFilterWindow = false;
        //}
        //End TT#1170-MD -jsobek -Remove Binary database objects and normalize the Filter definitions

		private void cmsSearch_Click(object sender, System.EventArgs e)
		{
		    Search();
		}
    
        private void Search()
        {
			try
			{
				if ( this._gridCol == null ) 
				{
                    //BEGIN TT#5085-VStuart-Search of Allocation Workspace produces IndexOutOfRangeException-MID
                        if (this.ugHeaders.Rows.Count > 0)
                        {
                            if (ugHeaders.ActiveCell == null)
                            {
						        _gridCol = ugHeaders.Rows[0].Band.Columns["HeaderID"];
						        _gridBand = ugHeaders.Rows[0].Band;
					        }
					        else
					        {
						        _gridCol = ugHeaders.ActiveCell.Column;
						        _gridBand = ugHeaders.ActiveCell.Band;
					        }
                        }
                    //END TT#5085-VStuart-Search of Allocation Workspace produces IndexOutOfRangeException-MID
                }

				if ( this._frmUltraGridSearchReplace == null ) 
				{
					this._frmUltraGridSearchReplace = new frmUltraGridSearchReplace(_SAB, false);
				}

				if (this.ugHeaders.Visible == true)
				{
                    //BEGIN TT#5085-VStuart-Search of Allocation Workspace produces IndexOutOfRangeException-MID
                    if (this.ugHeaders.Rows.Count > 0)
                    {
                        if (this.ugHeaders.ActiveRow == null)
                        {
                            ugHeaders.ActiveRow = ugHeaders.Rows[0];
                        }

                        // set the active row if not in band being searched
                        if (ugHeaders.ActiveRow.Band.Key != _gridBand.Key)
                        {
                            if (_gridBand.Key == "Header")
                            {
                                ugHeaders.ActiveRow = ugHeaders.Rows[0];
                            }
                        }

                        if (this.ugHeaders.ActiveRow == null)
                        {
                            MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_NeedSearchRow),
                                _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        }
                        else
                        if (this.ugHeaders.ActiveRow.Band.Columns.Exists(_gridCol.Key))
                        {
                            this._frmUltraGridSearchReplace.ShowSearchReplace(this.ugHeaders, _gridCol, _gridBand);
                        }
                        else
                        {
                            string message = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SearchColumnNotFound);
                            message = message.Replace("{0}", _gridCol.Key);
                            MessageBox.Show(message, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        }
                    }
                    //END TT#5085-VStuart-Search of Allocation Workspace produces IndexOutOfRangeException-MID
                }
			}
			catch( Exception exception )
			{
				HandleException(exception);
			}
		}

        private void cmsAssrtCreate_Click(object sender, EventArgs e)
        {
            bool errorFound = false;
            string headerID = null, errMessage = string.Empty;
            int asrtRID, asrtHdrTotal = 0, asrtChildTotal = 0;
            UltraGridRow asrtRow = null;
            try
            {
                ArrayList selRows = new ArrayList();
                foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                {
                    if (selRow.Cells["AsrtRID"].Value != DBNull.Value)
                    {
                        errorFound = true;
                        errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_AssrtAlreadyExists);
                        break;
                    }
					//TT#686 - MD - DOConnell - Add Restrictions to what types of headers can be dropped on a placeholder.
                    //else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance)
                    else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance ||
                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.WorkupTotalBuy ||
                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)))
                    {
                        errorFound = true;
                        string status = MIDText.GetTextOnly((int)eHeaderAllocationStatus.ReceivedInBalance);
                        errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_InvalidHeaderStatus), status);
                        break;
                    }
                    else
                    {
                        selRows.Add(Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                    }

                }

                if (errorFound)
                {
                    MessageBox.Show(errMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                if (!NameFromDialogOK(cmsAssortment.Text, MIDText.GetTextOnly(eMIDTextCode.lbl_AssortmentID), ref headerID))
                {
                    return;
                }
          
                _rClickRow = null;
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.BeginUpdate();
                //this.ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls

                AddHeaderRow();

                this.ugDetails.ActiveRow.Cells["HeaderID"].Value = headerID;
                this.ugDetails.ActiveRow.Cells["Type"].Value = (int)eHeaderType.Assortment;

                HierarchyNodeProfile hnp = _hierMaint.GetAssortmentNode();

                _skipStyleEdit = true;
                this.ugDetails.ActiveRow.Cells["Style"].Value = hnp.LevelText;
                this.ugDetails.ActiveRow.Cells["StyleHnRID"].Value = hnp.Key;
                this.ugDetails.ActiveRow.Cells["Description"].Value = hnp.NodeDescription;
                HierarchyNodeProfile productHnp = _SAB.HierarchyServerSession.GetNodeData(hnp.HomeHierarchyParentRID);

                _skipProductEdit = true;
                this.ugDetails.ActiveRow.Cells["ProductRID"].Value = productHnp.Key;
                this.ugDetails.ActiveRow.Cells["Product"].Value = productHnp.LevelText;
                this.ugDetails.ActiveRow.Cells["StyleSecurity"].Value = (int)eSecurityType.Update;

                HierarchyNodeProfile anchorHnp = _hierMaint.GetAnchorNode(hnp.Key);
                if (anchorHnp.Key != Include.NoRID)
                {
                    _skipAnchorEdit = true;
                    this.ugDetails.ActiveRow.Cells["AnchorHnRID"].Value = anchorHnp.Key;
                    this.ugDetails.ActiveRow.Cells["AnchorNode"].Value = anchorHnp.LevelText;
                }

                asrtRID = Convert.ToInt32(this.ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                _assortments.Rows.Add(new object[] { asrtRID, headerID, (int)eAssortmentType.GroupAllocation });	// TT#893 - MD - stodd - Add "Group Allocation ID" Column to Allocation Workspace
                _assortments.AcceptChanges();
             
                // update Assortment ValueList
                ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Clear();
                foreach (DataRow dr in _assortments.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Add(Convert.ToInt32(dr["AsrtRID"], CultureInfo.CurrentUICulture), dr["AssortmentID"].ToString());
                }
                this.ugDetails.ActiveRow.Cells["AsrtRID"].Value = asrtRID;

                // reselect originally selected rows
                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    int hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    if (hdrRID == asrtRID)
                    {
                        asrtRow = row;
                    }
                    else if (selRows.Count > 0)
                    {
                        if (selRows.Contains(hdrRID))
                        {
                            row.Selected = true;
                            selRows.Remove(hdrRID);
                        }
                    }
                    else if (asrtRow != null)
                    {
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }
             
                asrtRow.Cells["ChildTotal"].Value = asrtChildTotal;
                asrtRow.Cells["HdrQuantity"].Value = asrtHdrTotal;

                if (ugDetails.Selected.Rows.Count > 0)
                {
                    asrtRow.Selected = true;
                    _creatingAssortment = true;
                    AddHeadersToAssortment();
                    _creatingAssortment = false;
                }
                else
                {
                    asrtRow.Cells["AsrtType"].Value = (int)eAssortmentType.PreReceipt;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                if (asrtRow != null)
                {
                    asrtRow.RefreshSortPosition();
                    asrtRow.Selected = true;
                    this.ugDetails.ActiveCell = asrtRow.Cells["HeaderID"];
                    asrtRow.Selected = false;
                }
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.ResumeRowSynchronization();
                //this.ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                Cursor.Current = Cursors.Default;
            }
        }

        private void cmsAssrtAddPlaceholder_DropDownOpening(object sender, EventArgs e)
        {
            cmsAssrtAddPhTextBox.TextBox.Text = "1";    // sets default value
        }

        private void cmsAssrtAddPlaceholder_DropDownOpened(object sender, EventArgs e)
        {
            cmsAssrtAddPhTextBox.TextBox.Focus();    
        }

        private void cmsAssrtAddPhTextBox_DoubleClick(object sender, EventArgs e)
        {
            AddNewPlaceholders(sender);
        }

        private void cmsAssrtAddPhTextBox_KeyUp(object sender, KeyEventArgs e)
        {
            try
            {
                if (e.KeyCode == Keys.Enter)
                {
                    AddNewPlaceholders(sender);
                }
            }
            catch
            {
                throw;
            }
        }

        private void AddNewPlaceholders(object sender)
        {
            try
            {
                ToolStripTextBox tstb = (ToolStripTextBox)sender;
                int phCount = 0;
                string phCountStr, errorMessage;

                phCountStr = tstb.Text.Trim();
                if (MIDMath.IsPositiveNumber(phCountStr))
                {
                    phCount = Convert.ToInt32(phCountStr, CultureInfo.CurrentUICulture);
                    if (phCount > 0 && OkToAddPlaceholders())
                    {
                        AddPlaceholders(phCount);
                    }
                }
                else
                {
                    errorMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_pl_InvalidValueFormat);
                    MessageBox.Show(errorMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
            catch
            {
                throw;
            }
        }

        private bool OkToAddPlaceholders()
        {
            bool okToAdd = true;
            try
            {
                if (!RowActive())
                {
                    okToAdd = false;
                }
                else
                {
                    while (ugDetails.ActiveRow.Band.Key != "Header")
                    {
                        ugDetails.ActiveRow = ugDetails.ActiveRow.ParentRow;
                    }
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(ugDetails.ActiveRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (headerType != eHeaderType.Assortment)
                    {
                        okToAdd = false;
                    }
                    else
                    {
                        EditMsgs em = new EditMsgs();
                        if (!ValidateSpecificFields(ugDetails.ActiveRow, ref em))
                        {
                            if (em.EditMessages.Count > 0)
                            {
                                _errors = null;
                                for (int i = 0; i < em.EditMessages.Count; i++)
                                {
                                    EditMsgs.Message emm = (EditMsgs.Message)em.EditMessages[i];
                                    AddErrorMessage(emm);
                                }
                                MessageBox.Show(_errors, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            }
                            okToAdd = false;
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
            return okToAdd;
        }    
        
        private void AddPlaceholders(int aReqPhCount)
        {
            try
            {
                if (cmsAssrt.Visible)  // context menus don't AutoClose when there's a TextBox 
                {
                    cmsAssrt.Close();
                    cmsGrid.Close();
                }    
                Cursor.Current = Cursors.WaitCursor;
                int curPhCount = 0;

                // get Assortment row data
                UltraGridRow asrtRow = ugDetails.ActiveRow;
                string asrtID = Convert.ToString(asrtRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                int asrtHdrRID = Convert.ToInt32(asrtRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                int anchorRID = Convert.ToInt32(asrtRow.Cells["AnchorHnRID"].Value, CultureInfo.CurrentUICulture);

                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (row != asrtRow && row.Cells["AsrtRID"].Value != DBNull.Value)
                    {
                        int asrtRID = Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                        if (asrtRID == asrtHdrRID && Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                        {
                            curPhCount++;
                        }
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }

                //HierarchyNodeList hierNodeList = _hierMaint.GetPlaceholderStyles(anchorRID, aReqPhCount, curPhCount, asrtID); // changed but no longer needed
                //for (int i = 0; i < aReqPhCount; i++)
                //{
                //    AddPlaceholderStyle((HierarchyNodeProfile)hierNodeList[i], asrtHdrRID);
                //}    
            }
            catch (Exception ex)
            {
                MIDException MIDExc = new MIDException(eErrorLevel.information, 0, ex.Message);
                HandleMIDException(MIDExc);
            }
            finally
            {
                if (this.ugDetails.ActiveRow != null)
                {
                    this.ugDetails.ActiveRow.RefreshSortPosition();
                    this.ugDetails.ActiveRow.Selected = true; 
                }
                Cursor.Current = Cursors.Default;
            }
        }

        private void AddPlaceholderStyle(HierarchyNodeProfile aHnp, int aAsrtRID)
        {
            try
            {
                AddHeaderRow();     // new row becomes the active row

                _skipStyleEdit = true;
                this.ugDetails.ActiveRow.Cells["Style"].Value = aHnp.LevelText;
                this.ugDetails.ActiveRow.Cells["StyleHnRID"].Value = aHnp.Key;
                this.ugDetails.ActiveRow.Cells["Description"].Value = aHnp.NodeDescription;
             
                HierarchyNodeProfile productHnp = _SAB.HierarchyServerSession.GetNodeData(aHnp.HomeHierarchyParentRID);

                _skipProductEdit = true;
                this.ugDetails.ActiveRow.Cells["ProductRID"].Value = productHnp.Key;
                this.ugDetails.ActiveRow.Cells["Product"].Value = productHnp.LevelText;
                this.ugDetails.ActiveRow.Cells["StyleSecurity"].Value = (int)eSecurityType.Update;

                HierarchyNodeProfile anchorHnp = _hierMaint.GetAnchorNode(aHnp.Key);
                if (anchorHnp.Key != Include.NoRID)
                {
                    _skipAnchorEdit = true;
                    this.ugDetails.ActiveRow.Cells["AnchorHnRID"].Value = anchorHnp.Key;
                    this.ugDetails.ActiveRow.Cells["AnchorNode"].Value = anchorHnp.LevelText;
                }

                string replaceChar = " ";
                string phHeaderID = aHnp.NodeID.Replace(@"\", replaceChar);
                this.ugDetails.ActiveRow.Cells["HeaderID"].Value = phHeaderID;

                this.ugDetails.ActiveRow.Cells["AsrtRID"].Value = aAsrtRID;
                this.ugDetails.ActiveRow.Cells["Type"].Value = (int)eHeaderType.Placeholder;
   
                int hdrRID = Convert.ToInt32(this.ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                this.ugDetails.ActiveRow.Cells["PlaceHolderRID"].Value = hdrRID;
                _lastAsrtSortSeq++;
                this.ugDetails.ActiveRow.Cells["AsrtSortSeq"].Value = _lastAsrtSortSeq;
                              
                this.ugDetails.ActiveRow.Cells["ChildTotal"].Value = 0;
                this.ugDetails.ActiveRow.Cells["HdrQuantity"].Value = 0;
                
                this.ugDetails.ActiveRow.RefreshSortPosition();

                // add new rid and ID to ValueList
                _placeHolders.Rows.Add(new object[] { hdrRID, phHeaderID });
                ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Clear();
                foreach (DataRow dr in _placeHolders.Rows)
                {
                    ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Add(Convert.ToInt32(dr["PlaceHolderRID"], CultureInfo.CurrentUICulture), dr["PlaceHolderID"].ToString());
                }
                SetEditActivation(this.ugDetails.ActiveRow);
            }
            catch
            {
                throw;
            }
        }
      
        private void cmsAssrtAddTo_Click(object sender, EventArgs e)
        {
            _creatingAssortment = true;
            AddHeadersToAssortment();
            _creatingAssortment = false;
        }

        private void AddHeadersToAssortment()
        {
            bool phIsVirtual = true;
            string errMessage = string.Empty;
            int asrtRID = 0;
            int phRID = Include.NoRID, phStyleHnRID = Include.NoRID;
            int phHdrTotal = 0, phChildTotal = 0;
            int firstSizeGroup = Include.UndefinedSizeGroupRID;
            UltraGridRow asrtRow = null, placeHolderRow = null;
            eHeaderType addToHeaderType = eHeaderType.Assortment, selHeaderType;
            ArrayList addedHeaders = new ArrayList();
            ArrayList selectedRows = new ArrayList();
            Hashtable placeholderHash = new Hashtable();
            try
            {
                if (this.ugDetails.Selected.Rows.Count == 0)
                {
                    if (_rClickRow != null && _rClickRow.Band.Key == "Header")
                    {
                        _rClickRow.Selected = true;
                    }
                    else
                    {
                        return;
                    }
                }

                if (!ValidAssortmentHeaderSelection(ref addedHeaders))
                {
                    return;
                }

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.BeginUpdate();
                //this.ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                
                foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                {
                    selectedRows.Add(selRow);
                    selHeaderType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (selHeaderType == eHeaderType.Assortment || selHeaderType == eHeaderType.Placeholder)
                    {
                        asrtRID = Convert.ToInt32(selRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                        addToHeaderType = selHeaderType;
                        if (addToHeaderType == eHeaderType.Placeholder)
                        {
                            phRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            phStyleHnRID = Convert.ToInt32(selRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                            HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(phStyleHnRID);
                            phIsVirtual = hnp.IsVirtual;
                            placeHolderRow = selRow;
                       
                            foreach (UltraGridRow row in ugDetails.Rows)
                            {
                                if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == asrtRID)
                                {
                                    asrtRow = row;
                                    break;
                                }
                            }
                        }
                        else
                        {
                            asrtRow = selRow;
                            UltraGridRow row = asrtRow.GetSibling(SiblingRow.First, false);
                            while (row != null)
                            {   // load all placeholder rows for this assortment to hashtable                    
                                if (row.Cells["AsrtRID"].Value != DBNull.Value
                                 && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == asrtRID
                                 && Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.Placeholder)
                                {
                                    phStyleHnRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                    placeholderHash.Add(phStyleHnRID, row);
                                }
                                row = row.GetSibling(SiblingRow.Next, false);
                            }
                            if (placeholderHash.Count == 0)     // no other Rows so make it a PostReceipt Assortment
                            {
                                asrtRow.Cells["AsrtType"].Value = (int)eAssortmentType.PostReceipt;
                            }
                        }
                    }
                }
        
                _phCompLinks = new PlaceholderComponentLinks(asrtRID);
                _dsMultiSizes = MIDEnvironment.CreateDataSet(); 
                foreach (UltraGridRow row in addedHeaders)
                {
                    int addedHdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    int styleRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                    if (firstSizeGroup == Include.UndefinedSizeGroupRID)
                    {
                        if (Convert.ToInt32(row.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture) != Include.UndefinedSizeGroupRID)
                        {
                            firstSizeGroup = Convert.ToInt32(row.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture);
                        }
                    }
                    if (addToHeaderType == eHeaderType.Placeholder)
                    {
                        if (styleRID != phStyleHnRID)
                        {
                            if (!ValidPlaceholderStyle(placeHolderRow, styleRID, ref errMessage))
                            {
                                return;
                            }
                            else
                            {
                                HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(styleRID);

                                errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PhStyleWillChange),
                                                   _lblPlaceholder + " " + _hlpStyle.LevelID, hnp.LevelText);

                                errMessage += Environment.NewLine + MIDText.GetTextOnly((int)eMIDTextCode.msg_ContinueQuestion);

                                DialogResult diagResult = MessageBox.Show(errMessage, _thisTitle, System.Windows.Forms.MessageBoxButtons.YesNo,
                                                          System.Windows.Forms.MessageBoxIcon.Question);

                                if (diagResult == System.Windows.Forms.DialogResult.No)
                                {
                                    return;
                                }

                                placeHolderRow.Cells["Style"].Value = hnp.NodeID;
                                phStyleHnRID = Convert.ToInt32(placeHolderRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                phIsVirtual = false;
                            }
                        }
                        row.Cells["PlaceHolderRID"].Value = phRID;
                    }
                    else if (addToHeaderType == eHeaderType.Assortment)
                    {   // check for matching placeholder style; otherwise, add placeholder
                        if (!placeholderHash.ContainsKey(styleRID))
                        {
                            ugDetails.ActiveRow = asrtRow;
                            AddPlaceholders(1);
                            phHdrTotal = 0;
                            phChildTotal = 0;
                            placeHolderRow = ugDetails.ActiveRow;

                            HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(styleRID);
                            placeHolderRow.Cells["Style"].Value = hnp.NodeID;
                            phStyleHnRID = Convert.ToInt32(placeHolderRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                            phIsVirtual = false;
                            placeholderHash.Add(phStyleHnRID, placeHolderRow);
                        }
                        else
                        {
                            placeHolderRow = (UltraGridRow)placeholderHash[styleRID];
                        }
                        phRID = Convert.ToInt32(placeHolderRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        row.Cells["PlaceHolderRID"].Value = phRID;
                    }
                    string phID = Convert.ToString(placeHolderRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                    _phCompLinks.AddPlaceholder(phRID, phID);
                  
                    ArrayList currentPhColorRIDs = new ArrayList();
                    if (placeHolderRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                    {
                        UltraGridRow phColorRow = placeHolderRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                        while (phColorRow != null)
                        {
                            int phColorBCRID = Convert.ToInt32(phColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                            currentPhColorRIDs.Add(phColorBCRID); 
                           
                            AddPlaceholderColorToLinkProfile(phRID, phColorRow);
                           
                            phColorRow = phColorRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }

                    phHdrTotal = Convert.ToInt32(placeHolderRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                    phChildTotal = Convert.ToInt32(placeHolderRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                  
                    AddComponentsToMulti(placeHolderRow, row);  //uses same methods as MultHeader
                    
                    phHdrTotal += Convert.ToInt32(row.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                    phChildTotal += Convert.ToInt32(row.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                   
                    if (row.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                    {
                        UltraGridRow colorRow = row.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                        while (colorRow != null)
                        {
                            AddHeaderColorToLinkProfile(phRID, colorRow);
                            colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                    if (firstSizeGroup != Include.UndefinedSizeGroupRID)
                    {
                        if (Convert.ToInt32(placeHolderRow.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture) == Include.UndefinedSizeGroupRID)
                        {
                            placeHolderRow.Cells["SizeGroup"].Value = firstSizeGroup;
                        }
                    }
                    if (!selectedRows.Contains(placeHolderRow))     
                    {
                        selectedRows.Add(placeHolderRow);
                    }    

                    if (_creatingAssortment)
                    {
                        placeHolderRow.Cells["ChildTotal"].Value = phChildTotal;
                        placeHolderRow.Cells["HdrQuantity"].Value = phHdrTotal;
                    }


                //    int hdrColorCount = _phCompLinks.HeaderColorCount(phRID, addedHdrRID);
                //    int phColorCount = _phCompLinks.PlaceholderColorCount(phRID);

                //    int diff = hdrColorCount - phColorCount;
                //    if (diff > 0)   // need more placeholder colors
                //    {
                //        _colorSelectRow = placeHolderRow;
                //        if (_frmColorBrowser != null)
                //        {
                //            _frmColorBrowser.Dispose();
                //        }
                //        _phColorAutoAdd = true;
                //        _frmColorBrowser = new ColorBrowser(_SAB, currentPhColorRIDs, diff);
                //        _frmColorBrowser.OnColorBrowserSelectHandler += new ColorBrowser.ColorBrowserSelectEventHandler(form_OnColorBrowserSelectHandler);
                //        _frmColorBrowser.GetPhColorsAndSetEventHandler();
                //        _frmColorBrowser.Dispose();
                //        _phColorAutoAdd = false;
                //    }

                }

                //if (_phCompLinks.HasHeaderColors)
                //{
                //    MatchComponents();
                //}

                AddMultiSizeTables();

                ugDetails.Selected.Rows.Clear();

                foreach (UltraGridRow row in selectedRows)
                {
                    row.Selected = true;
                }

                for (int i = 0; i < ugDetails.Selected.Rows.Count; i++)
                {
                    UltraGridRow selRow = this.ugDetails.Selected.Rows[i];
                    selHeaderType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    // skip the Assortment or Placeholder row

                    switch (selHeaderType)
                    {
                        case eHeaderType.Assortment:
                            break;

                        case eHeaderType.Placeholder:
                            if (_sizesAutoAdded)
                            {
                                UpdateAddedSizeRows(selRow);
                            }
                            break;

                        default:
                            if (selRow.Cells["AsrtRID"].Value != DBNull.Value)
                            {
                                continue;
                            }
                            else
                            {
                                selRow.Cells["AsrtRID"].Value = asrtRID;
                                _lastAsrtSortSeq++;
                                selRow.Cells["AsrtSortSeq"].Value = _lastAsrtSortSeq;

                                selRow.RefreshSortPosition();
                                if (_expandAll)
                                {
                                    selRow.ExpandAll();
                                }
                            }
                            break;
                    }
                }
                if (_sizesAutoAdded)
                {
                    _sizesAutoAdded = false;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                SetEditActivation();
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.ResumeRowSynchronization();
                //this.ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                Cursor.Current = Cursors.Default;
            }
        }

        private void AddPlaceholderColorToLinkProfile(int aPlaceholderRID, UltraGridRow aPhcRow)
        {
            try
            {
                int bcRID = Convert.ToInt32(aPhcRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);

                if (!_phCompLinks.PlaceholderColorExists(aPlaceholderRID, bcRID))
                {
                    HeaderComponentProfile hcp = CreateHeaderComponentProfile(eComponentType.SpecificColor, aPhcRow);
                    _phCompLinks.AddPlaceholderColor(aPlaceholderRID, hcp);
                }
            }
            catch  
            {
                throw;
            }
        }

        private void AddHeaderColorToLinkProfile(int aPlaceholderRID, UltraGridRow aColorRow)
        {
            try
            {
                int bcRID = Convert.ToInt32(aColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                int headerRID = Convert.ToInt32(aColorRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                if (!_phCompLinks.HeaderColorExists(aPlaceholderRID, headerRID, bcRID))
                {
                    HeaderComponentProfile hcp = CreateHeaderComponentProfile(eComponentType.SpecificColor, aColorRow);
                    _phCompLinks.AddHeaderColor(aPlaceholderRID, headerRID, hcp);
                }
            }
            catch
            {
                throw;
            }
        }

        private HeaderComponentProfile CreateHeaderComponentProfile(eComponentType aComponentType, UltraGridRow aRow)
        {
            try
            {
                int bcRID = Convert.ToInt32(aRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                HeaderComponentProfile hcp = new HeaderComponentProfile(bcRID, aComponentType);
                hcp.HeaderRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                hcp.HeaderID = Convert.ToString(aRow.ParentRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                hcp.HdrBCRID = bcRID;
                hcp.BulkColor = Convert.ToString(aRow.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture);
                hcp.ColorCodeRID = Convert.ToInt32(aRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                hcp.Description = Convert.ToString(aRow.Cells["Description"].Value, CultureInfo.CurrentUICulture);
                hcp.Name = Convert.ToString(aRow.Cells["Name"].Value, CultureInfo.CurrentUICulture); // not used yet
   
                if (aRow.Cells["Sequence"].Value != DBNull.Value)
                {
                    hcp.Sequence = Convert.ToInt32(aRow.Cells["Sequence"].Value, CultureInfo.CurrentUICulture);
                }    
                if (aRow.Cells["AsrtBCRID"].Value == DBNull.Value || (int)aRow.Cells["AsrtBCRID"].Value == Include.NoRID)
                {
                    hcp.AsrtBCRID = 0;
                }
                else
                {
                    hcp.AsrtBCRID = Convert.ToInt32(aRow.Cells["AsrtBCRID"].Value, CultureInfo.CurrentUICulture);
                }
                hcp.IsVirtual = Convert.ToBoolean(aRow.Cells["IsVirtual"].Value, CultureInfo.CurrentUICulture);
                return hcp;   
            }
            catch
            {
                throw;
            }
        }    

        private void MatchComponents()
        {
            try
            {
                //if (_frmComponentMatch != null)
                //{
                //    _frmComponentMatch.Dispose();
                //}
                //_frmComponentMatch = new ComponentMatch(_SAB, _phCompLinks);
                //_frmComponentMatch.OnComponentMatchEventHandler += new ComponentMatch.ComponentMatchEventHandler(form_OnComponentMatchEventHandler);
                //_frmComponentMatch.MdiParent = this.ParentForm.Owner;
                //_frmComponentMatch.StartPosition = FormStartPosition.CenterScreen;
                //_frmComponentMatch.ShowDialog();
            }
            catch
            {
                throw;
            }
        }

        //private void form_OnComponentMatchEventHandler(object source, ComponentMatchEventArgs e)
        //{
        //    try
        //    {
        //    }
        //    catch
        //    {
        //        throw;
        //    }
        //}

        private bool ValidAssortmentHeaderSelection(ref ArrayList addedHeaders)
        {
            bool errorFound = false;
            bool validSelection = false;
            try
            {
                eHeaderType selHeaderType, addToHeaderType = eHeaderType.Assortment;
                int asrtCount = 0, addHeaderCount = 0;
                string errMessage = string.Empty;
                UltraGridRow addToRow = null;

                foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                {
                    selHeaderType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (selHeaderType == eHeaderType.Assortment || selHeaderType == eHeaderType.Placeholder)
                    {
                        addToRow = selRow;
                        addToHeaderType = selHeaderType;
                        asrtCount++;

                        if (asrtCount > 1)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_OnlyOneAssrtAllowed);
                            break;
                        }
						//TT#686 - MD - DOConnell - Add Restrictions to what types of headers can be dropped on a placeholder.
                        //else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance)
                        else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance ||
                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.WorkupTotalBuy ||
                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)))
                        {
                            errorFound = true;
                            string asrtType;
                            if (selHeaderType == eHeaderType.Assortment)
                            {
                                asrtType = MIDText.GetText((int)eHeaderType.Assortment);
                            }
                            else
                            {
                                asrtType = MIDText.GetText((int)eHeaderType.Placeholder);
                            }
                            errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_InvalidAssrtStatus), asrtType);
                            break;
                        }
                    }
					//TT#686 - MD - DOConnell - Add Restrictions to what types of headers can be dropped on a placeholder.
                    else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance ||
                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.WorkupTotalBuy ||
                                    (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)))
                    {
                        errorFound = true;
                        string status = MIDText.GetTextOnly((int)eHeaderAllocationStatus.ReceivedInBalance);
                        errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_InvalidHeaderStatus), status);
                        break;
                    }
                    else if (selRow.Cells["AsrtRID"].Value == DBNull.Value)
                    {
                        addedHeaders.Add(selRow); 
                        addHeaderCount++;
                    }
                }
                if (!errorFound)
                {
                    if (asrtCount == 0)
                    {
                        errorFound = true;
                        errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_NoAssrtRowSelected);
                    }
                    else if (addHeaderCount == 0)
                    {
                        errorFound = true;
                        errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_NoHeaderSelectedForAssrt);
                    }
                    else if (addToHeaderType == eHeaderType.Placeholder) 
                    {
                        int phStyleHnRID = Convert.ToInt32(addToRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                        HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(phStyleHnRID);
                    
                        UltraGridRow row1 = (UltraGridRow)addedHeaders[0];
                        int row1Style = Convert.ToInt32(row1.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);

                        if (hnp.IsVirtual)  // if placeholder is virtual, all added styles must be the same
                        {
                            if (addedHeaders.Count > 1) // if count is 1, placeholder style will be changed to header style
                            {
                                for (int i = 1; i < addedHeaders.Count; i++)
                                {
                                    UltraGridRow row = (UltraGridRow)addedHeaders[i];
                                    if (Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture) != row1Style)
                                    {
                                        errorFound = true;
                                        errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_HeadersMustHaveSameStyle), _hlpStyle.LevelID);
                                        break;
                                    }
                                }   
                            }
                        }
                        else
                        {
                            for (int i = 0; i < addedHeaders.Count; i++)
                            {
                                UltraGridRow row = (UltraGridRow)addedHeaders[i];
                                if (Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture) != hnp.Key)
                                {
                                    errorFound = true;
                                    errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_PlaceholderStyleMismatch);
                                    break;
                                }
                            }
                        }    
                    }
                }
                if (errorFound)
                {
                    MessageBox.Show(errMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                validSelection = !errorFound;
            }
            catch
            {
                throw;
            }
            return validSelection;
        }   
 
        private void cmsAssrtRemove_Click(object sender, EventArgs e)
        {
            try
            {
                if (this.ugDetails.Selected.Rows.Count == 0)
                {
                    if (_rClickRow != null && _rClickRow.Band.Key == "Header")
                    {
                        _rClickRow.Selected = true;
                    }
                    else
                    {
                        return;
                    }
                }
                Cursor.Current = Cursors.WaitCursor;
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.BeginUpdate();
                //this.ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
 
                ArrayList removedHeaders = new ArrayList();

                foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                {
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    switch (headerType)
                    {
                        case eHeaderType.Assortment:
                        case eHeaderType.Placeholder:
                            break;
                       
                        default:
                            if (selRow.Cells["AsrtRID"].Value != DBNull.Value) // TODO may need to further qualify
                            {
                                if (!removedHeaders.Contains(selRow))
                                {
                                    removedHeaders.Add(selRow);
                                }
                            }
                            break;
                    }
                }

                _removingAssortment = true;
                foreach (UltraGridRow removedRow in removedHeaders)
                {
                    RemoveHeaderFromAssortment(removedRow);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                _removingAssortment = false;
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.ResumeRowSynchronization();
                //this.ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                Cursor.Current = Cursors.Default;
            }	
        }

        private void RemoveHeaderFromAssortment(UltraGridRow aRow)
        {
            try
            {
                int asrtHdrRID, phRID, asrtHdrTotal, asrtChildTotal;
                int selRowQty, selRowChildTotal, phHdrTotal, phChildTotal;
                UltraGridRow asrtRow = null;
                UltraGridRow phRow = null;

                asrtHdrRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                phRID = Convert.ToInt32(aRow.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture);

                bool phRowFound = false;
                bool asrtRowFound = false;
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == asrtHdrRID)
                    {
                        asrtRow = row;
                        asrtRowFound = true;
                    }
                    else if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == phRID)
                    {
                        phRow = row;
                        phRowFound = true;
                    }
                    if (asrtRowFound && phRowFound)
                    {
                        break;
                    }
                }

                asrtHdrTotal = Convert.ToInt32(asrtRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                asrtChildTotal = Convert.ToInt32(asrtRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                phHdrTotal = Convert.ToInt32(phRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                phChildTotal = Convert.ToInt32(phRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);

                selRowQty = Convert.ToInt32(aRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                selRowChildTotal = Convert.ToInt32(aRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                asrtHdrTotal -= selRowQty;
                asrtChildTotal -= selRowChildTotal;
                phHdrTotal -= selRowQty;
                phChildTotal -= selRowChildTotal;

                RemoveComponentsFromMulti(aRow, phRow);   // uses same methods as MultiHeader

                aRow.Cells["AsrtRID"].Value = DBNull.Value;
                aRow.Cells["PlaceHolderRID"].Value = DBNull.Value;
                aRow.Cells["AsrtSortSeq"].Value = DBNull.Value;

                aRow.RefreshSortPosition();
                int hdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                if (_assortmentGroups.ContainsKey(asrtHdrRID))
                {
                    Hashtable asrtHeaderListHash = (Hashtable)_assortmentGroups[asrtHdrRID];
                    if (asrtHeaderListHash.ContainsKey(hdrRID))
                    {
                        asrtHeaderListHash.Remove(hdrRID);
                    }
                }

                phRow.Cells["ChildTotal"].Value = phChildTotal;
                phRow.Cells["HdrQuantity"].Value = phHdrTotal;
                asrtRow.Cells["ChildTotal"].Value = asrtChildTotal;
                asrtRow.Cells["HdrQuantity"].Value = asrtHdrTotal;
                // If Post Receipt Assortment and Placeholders have no attached headers, delete the Placeholder 
                if (Convert.ToInt32(asrtRow.Cells["AsrtType"].Value, CultureInfo.CurrentUICulture) == (int)eAssortmentType.PostReceipt) 
                {
                    CheckForPlaceholderDelete(phRow);
                }
            }
            catch  
            {
                throw;
            }
        }

        private void CheckForPlaceholderDelete(UltraGridRow aPhRow)
        {
            try
            {
                int phRID = Convert.ToInt32(aPhRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                int asrtRID = Convert.ToInt32(aPhRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                bool headerRowsFound = false;
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (row.Cells["PlaceHolderRID"].Value != DBNull.Value
                     && Convert.ToInt32(row.Cells["PlaceHolderRID"].Value, CultureInfo.CurrentUICulture) == phRID 
                     && Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderType.Placeholder)
                    {
                        headerRowsFound = true;
                        break;
                    }
                }
                if (!headerRowsFound)
                {
                    if (!_deletedHeaderRows.Contains(phRID))
                    {
                        UltraGridRow hRow = (UltraGridRow)aPhRow.Cells["HeaderRow"].Value;  // row from ugHeaders grid
                        _deletedHeaderRows.Add(phRID, hRow);    
                        aPhRow.Delete(false);
                        CheckForAssortmentTypeUpdate(asrtRID);
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void CheckForAssortmentTypeUpdate(int aAsrtRID)
        {
            try
            {
                UltraGridRow asrtRow = null;
                bool rowsFound = false;

                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == aAsrtRID)
                    {
                        asrtRow = row;
                    }
                    else if (row.Cells["AsrtRID"].Value != DBNull.Value
                          && Convert.ToInt32(row.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture) == aAsrtRID)
                    {
                        rowsFound = true;
                        break;
                    }
                }
                if (!rowsFound)
                {
                    asrtRow.Cells["AsrtType"].Value = (int)eAssortmentType.PreReceipt;
                }
            }
            catch
            {
                throw;
            }
        }

        private void cmsMultiMenu_Opening(object sender, CancelEventArgs e)
        {
            try
            {
                if (this.ugDetails.Selected.Rows.Count > 0)
                {
                    UltraGridRow row = this.ugDetails.Selected.Rows[0];
                    if (row.Band.Key == "Header")
                    {
                        cmsMultiRemove.Enabled = false;
                        foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                        {
                            if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader)
                            {
                                cmsMultiRemove.Enabled = OkToRemoveRows(selRow) ? true : false;
                                break;
                            }
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void cmsMultiCreate_Click(object sender, EventArgs e)
        {
            MultiCreate();
        }
        private void MultiCreate()
        {
            bool errorFound = false, componentsExist = false;
            string errMessage = string.Empty;
            string headerID = null, product, style, desc;
            int styleRID, firstSizeGroup = Include.UndefinedSizeGroupRID;
            UltraGridRow multiHdrRow = null;
            bool createCancelled = false;  // TT#4954 - JSmith - Multi header error
            try
            {
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                if (!_detailsShown)
                {
                    BuildDetailsGrid();
                }
                // End TT#1434

                // BEGIN Usability Enhancement
                if (_rClickGrid.Name == "ugHeaders")
                {
                    if (this.ugHeaders.Selected.Rows.Count > 0)
                    {
                        CheckForEditMode();
                        for (int i = 0; i < _selectedRowsSequence.Count; i++)
                        {
                            UltraGridRow selrowSeq = (UltraGridRow)_selectedRowsSequence[i];
                            int hdrRID = Convert.ToInt32(selrowSeq.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                            IEnumerable enumerator = ugDetails.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
                            foreach (UltraGridRow dRow in enumerator)
                            {
                                if (Convert.ToInt32(dRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == hdrRID)
                                {
                                    dRow.Selected = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                // END Usability Enhancement

                if (this.ugDetails.Selected.Rows.Count == 0)
                {
                    if (_rClickRow != null && _rClickRow.Band.Key == "Header")
                    {
                        _rClickRow.Selected = true;
                    }
                    else
                    {
                        return;
                    }
                }  

                _multiHeaderColor.Clear();
                _multiHeaderColorIds.Clear();   // MID Track #6127

                UltraGridRow firstRow = ugDetails.GetRow(ChildRow.First);
                if (firstRow.IsGroupByRow)
                {
                    errorFound = true;
                    errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_RemoveColumnGrouping);
                }
                else
                {
                    _headerList.Clear();
                    componentsExist = ugDetails.Selected.Rows[0].HasChild(false);
                    foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                    {
                        if (Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) < 0)
                        {
                            errorFound = true;
                            errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_HeaderMustBeSavedBeforeAddingToMulti, false),
                                                Convert.ToString(selRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture),
                                                string.Empty);
                            break;
                        }    
                        if (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_CantSelectExistingMulti);
                            break;
                        }
                        else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) !=  (int)eHeaderAllocationStatus.ReceivedInBalance) 
                        {
                            errorFound = true;
                            string status = MIDText.GetTextOnly((int)eHeaderAllocationStatus.ReceivedInBalance);
                            errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_InvalidStatusForMultiSelection), status);
                            break;
                        }
                        else if (!ValidMultiColorId(selRow))  // MID Track #6127
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_DuplicateBulkColorNotAllowed);
                            break;
                        }
                        else if (!DuplicateColorCheckOK(selRow))
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderDupColorSizeMismatch);
                            break;
                        }
                        else if (selRow.HasChild(false) != componentsExist)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderComponentMismatch);
                            break;
                        }
						// Begin TT#1753-MD - stodd - Object reference error charging intransit on multi-header
                        else if (!string.IsNullOrEmpty(selRow.Cells["AsrtRID"].Value.ToString()) && Convert.ToInt32(selRow.Cells["AsrtRID"].Value) > 0)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderNewMemberBelongsToAssortment); 
                            break;
                        }
                        else if (!string.IsNullOrEmpty(selRow.Cells["GroupAllocRID"].Value.ToString()) && Convert.ToInt32(selRow.Cells["GroupAllocRID"].Value) > 0)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderNewMemberBelongsToGroupAllocation); 
                            break;
                        }
						// End TT#1753-MD - stodd - Object reference error charging intransit on multi-header
                        // Begin TT#1966-MD - JSmith - DC Fulfillment
                        else if (!string.IsNullOrEmpty(selRow.Cells["Master"].Value.ToString()))
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderNewMemberBelongsToMasterHeader);
                            break;
                        }
                        // End TT#1966-MD - JSmith - DC Fulfillment
                    }
                }
                if (errorFound)
                {
                    MessageBox.Show(errMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    // Begin TT#1966-MD - JSmith - DC Fulfillment
                    createCancelled = true;
                    ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.ExitEditMode, false, false);
                    _inEditMode = false;
                    // End TT#1966-MD - JSmith - DC Fulfillment
                    return;
                }

                if (_rClickRow != null && _rClickRow != ugDetails.ActiveRow)
                {
                    _rClickRow = ugDetails.ActiveRow;
                }
               
                if (!NameFromDialogOK(cmsMulti.Text, MIDText.GetTextOnly(eMIDTextCode.lbl_MultiHeaderID), ref headerID))
                {
				    // Begin TT#4954 - JSmith - Multi header error
                    createCancelled = true;
                    ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.ExitEditMode, false, false);
                    _inEditMode = false;
					// End TT#4954 - JSmith - Multi header error
                    return;
                }
         
                Cursor.Current = Cursors.WaitCursor;

                // Save data from first selected header
                UltraGridRow saveRow = this.ugDetails.Selected.Rows[0];
                product = saveRow.Cells["Product"].Value.ToString();
                style = saveRow.Cells["Style"].Value.ToString();
                desc = saveRow.Cells["Description"].Value.ToString();

                styleRID = Convert.ToInt32(saveRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                _dsMultiSizes = MIDEnvironment.CreateDataSet();

                _rClickRow = null;
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.BeginUpdate();
                //this.ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls

                ArrayList selRows = new ArrayList();
                foreach (UltraGridRow sRow in ugDetails.Selected.Rows)
                {
                    selRows.Add(Convert.ToInt32(sRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                }

                _creatingMulti = true;
                AddHeaderRow();

                this.ugDetails.ActiveRow.Cells["HeaderID"].Value = headerID;
                this.ugDetails.ActiveRow.Cells["Type"].Value = (int)eHeaderType.MultiHeader;
              
                _skipProductEdit = true;
                this.ugDetails.ActiveRow.Cells["Product"].Value = product;
             
                _skipStyleEdit = true;
                this.ugDetails.ActiveRow.Cells["Style"].Value = style;
               
                this.ugDetails.ActiveRow.Cells["Description"].Value = desc;
                this.ugDetails.ActiveRow.Cells["StyleHnRID"].Value = styleRID;

                int groupRID = Convert.ToInt32(this.ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                // add new rid and ID to ValueList
                _multiHeaders.Rows.Add(new object[] { groupRID, headerID });
                // Begin TT#2839 - JSmith - MultiHeader IDs in 5.0
                //ugDetails.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Clear();
                //foreach (DataRow dr in _multiHeaders.Rows)
                //{
                //    ugDetails.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Add(Convert.ToInt32(dr["HdrRID"], CultureInfo.CurrentUICulture), dr["HeaderID"].ToString());
                //}
                RebuildMultiHeaderValueLists();
                // End TT#2839 - JSmith - MultiHeader IDs in 5.0

                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    int hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    if (hdrRID == groupRID)
                    {
                        multiHdrRow = row;
                    }
                    else if (selRows.Count > 0)
                    {
                        if (selRows.Contains(hdrRID))
                        {
                            row.Selected = true;
                            selRows.Remove(hdrRID);
                        }
                    }  
                    else if (multiHdrRow != null)
                    {
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }

                int multiHdrTotal = 0;
                int multiChildTotal = 0;
                ArrayList sizeGroups = new ArrayList(); // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                for (int i = 0; i < ugDetails.Selected.Rows.Count; i++)
                {
                    UltraGridRow fromRow = this.ugDetails.Selected.Rows[i];
                    int fromHdrRID = (int)fromRow.Cells["KeyH"].Value;
                    multiHdrTotal += (int)fromRow.Cells["HdrQuantity"].Value;
                    if (fromRow.Cells["ChildTotal"].Value == System.DBNull.Value)
                    {
                        fromRow.Cells["ChildTotal"].Value = 0;
                    }
                    multiChildTotal += (int)fromRow.Cells["ChildTotal"].Value;

                    fromRow.Cells["Status"].Value = (int)eHeaderAllocationStatus.InUseByMultiHeader;
                    fromRow.Cells["HdrGroupRID"].Value = groupRID;
                    _lastMultiSortSeq++;
                    fromRow.Cells["MultiSortSeq"].Value = _lastMultiSortSeq;
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    //if (firstSizeGroup == Include.UndefinedSizeGroupRID)
                    //{
                    //    if (Convert.ToInt32(fromRow.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture) != Include.UndefinedSizeGroupRID)
                    //    {
                    //        firstSizeGroup = Convert.ToInt32(fromRow.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture);
                    //    }
                    //}
                    int fromRowSizeGroup = Convert.ToInt32(fromRow.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture);
                    if (firstSizeGroup == Include.UndefinedSizeGroupRID)
                    {
                        if (fromRowSizeGroup != Include.UndefinedSizeGroupRID)
                        {
                            firstSizeGroup = fromRowSizeGroup;
                        }
                    }
                    if (fromRowSizeGroup != Include.UndefinedSizeGroupRID)
                    {
                        if (!sizeGroups.Contains(fromRowSizeGroup))
                        {
                            sizeGroups.Add(fromRowSizeGroup);
                        }
                    }
                    // End  TT#234  
                    AddComponentsToMulti(multiHdrRow, fromRow);

                    if (!_headersAddedToMulti.Contains(fromHdrRID))
                    {
                        _headersAddedToMulti.Add(fromHdrRID, groupRID);
                    }
   
                    fromRow.RefreshSortPosition();
                }
             
                AddMultiSizeTables();

                row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == groupRID)
                    {
                        multiHdrRow = row;
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);

                }
                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                if (sizeGroups.Count > 1)
                {
                    firstSizeGroup = DetermineSizeGroup(sizeGroups);
                }
                // End TT#234  
                multiHdrRow.Cells["ChildTotal"].Value = multiChildTotal;
                multiHdrRow.Cells["HdrQuantity"].Value = multiHdrTotal;
                multiHdrRow.Cells["SizeGroup"].Value = firstSizeGroup;
                multiHdrRow.Cells["MultiSortSeq"].Value = 0;
                multiHdrRow.Cells["HdrGroupRID"].Value = groupRID;
                multiHdrRow.RefreshSortPosition();

                multiHdrRow.ExpandAll();
                if (_sizesAutoAdded)
                {
                    UpdateAddedSizeRows(multiHdrRow);
                    _sizesAutoAdded = false;
                }
   
                this.ugDetails.Selected.Rows.Clear();
                UpdateSelectedTotals();

                SetEditActivation();
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                _creatingMulti = false;
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.ResumeRowSynchronization();
                //this.ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                // BEGIN Usability Enhancement - auto Save Multi created from top grid
                if (!createCancelled && !errorFound)  // TT#4954 - JSmith - Multi header error
                {  // TT#4954 - JSmith - Multi header error
                    if (_rClickGrid.Name == "ugHeaders")
                    {
                        EventArgs args = new EventArgs();
                        cmsSave_Click(cmsSave, args);
                    }
                }  // TT#4954 - JSmith - Multi header error
                // END Usability Enhancement

                // Begin TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0
				// Make sure multis are in cache
                if (!errorFound)
                {
                    foreach (UltraGridRow row in ugHeaders.Rows)
                    {
                        if (!row.IsGroupByRow)
                        {
                            SetHeaderRowInfo(row);
                        }
                    }
                }
                // End TT#2849 - JSmith - Erroring when deleting Multi-header in 5.0

                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                if (!_detailsShown)
                {
                    ClearDetails();
                }
                // End TT#1434
                Cursor.Current = Cursors.Default;
            }
        }

        // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
        private int DetermineSizeGroup(ArrayList aSizeGroups)
        {
            int sizeGroupRID = Include.UndefinedSizeGroupRID;
            try
            {
                foreach (int sizeGroup1 in aSizeGroups)
                {
                    bool allSizesFound = true;
                    SizeGroupProfile sgp1 = (SizeGroupProfile)_sizeGroupHash[sizeGroup1];
                    SizeCodeList scl_1 = sgp1.SizeCodeList;
                    foreach (int sizeGroup2 in aSizeGroups)
                    {
                        if (sizeGroup2 != sizeGroup1)
                        {
                            SizeGroupProfile sgp2 = (SizeGroupProfile)_sizeGroupHash[sizeGroup2];
                            SizeCodeList scl_2 = sgp2.SizeCodeList;
                            foreach (SizeCodeProfile scp1 in scl_1.ArrayList)
                            {
                                SizeCodeProfile scp2 = (SizeCodeProfile)scl_2.FindKey(scp1.Key);
                                if (scp2 == null)
                                {
                                    allSizesFound = false;
                                    break;
                                }
                            }
                            if (!allSizesFound)
                            {
                                break;
                            }
                        }
                    }
                    if (allSizesFound)
                    {
                        sizeGroupRID = sizeGroup1;
                        break;
                    }
                }    
            }
            catch
            {
                throw;
            }
            return sizeGroupRID;
        }
        // End TT#234  

        private bool NameFromDialogOK(string aDialogLabel, string aTextLabel, ref string aHeaderID)
        {
            bool nameOK = false, errorFound;
            string errMessage = string.Empty;
                       
            try
            {
                bool cancelAction = false;
                NameDialog nameDialog = new NameDialog(aDialogLabel, aTextLabel);

                // Begin TT#814 - RMatelic - DB error creating Multi Header name with more than 32 characters
                nameDialog.SetTextMaxLength(this.ugDetails.DisplayLayout.Bands["Header"].Columns["HeaderID"].MaxLength);
                // End TT#814  

                while (!(nameOK || cancelAction))
                {
                    nameDialog.StartPosition = FormStartPosition.Manual;
                    Point pt = new Point();

                    pt.X = 200;
                    pt.Y = this.splitContainer.SplitterRectangle.Top;
                    nameDialog.Location = pt;
                    DialogResult dialogResult = nameDialog.ShowDialog();

                    if (dialogResult == DialogResult.Cancel)
                        cancelAction = true;
                    else
                    {
                        errorFound = false;
                        aHeaderID = nameDialog.TextValue.Trim();  
                    
                        if (!MIDMath.ValidFileName(aHeaderID))
                        {
                            errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_HeaderNameInvalid), aHeaderID, Include.HeaderNameExcludedCharacters);
                            errorFound = true;
                        }
                        if (!errorFound)
                        {
                            foreach (AllocationHeaderProfile ahp in _headerProfileArrayList)
                            {
                                if (ahp.HeaderID == aHeaderID)
                                {
                                    errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicateHeaderIdNotAllowed);
                                    errorFound = true;
                                    break;
                                }
                            }
                            if (!errorFound)
                            {
                                foreach (AllocationProfile app in _allocProfileList)
                                {
                                    if (app.HeaderID == aHeaderID)
                                    {
                                        errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicateHeaderIdNotAllowed);
                                        errorFound = true;
                                        break;
                                    }
                                }
                            }
                        }
                        // BEGIN MID Track #6127 - ComponentOne Case Insensitve issue: prohibit duplicate name regardless of case
                        if (!errorFound)
                        {
                            Header hd = new Header();
                            if (hd.DuplicateHeaderExists(aHeaderID, -1))
                            { 
                                errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicateHeaderIdNotAllowed);
                                errorFound = true;
                            }
                        }
                        // END MID Track #6127
                        if (errorFound)
                        {
                            MessageBox.Show(errMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        }
                        else
                        {
                            nameOK = true;
                        }
                    }
                }

                if (cancelAction)
                {
                    nameOK = false;
                }
                else
                {
                    nameDialog.Dispose();
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            return nameOK;
         }
 
        private bool DuplicateColorCheckOK(UltraGridRow aSelectedRow)
        {
            bool OkToProcess = true;
            try
            {
                int colorRID;
                // BEGIN MID Track #5654, #5655, #5657 - MultiHeader errors
                if (ugDetails.DisplayLayout.Bands.Exists("BulkColor"))
                {
                    if (aSelectedRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                    {
                        UltraGridRow colorRow = aSelectedRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);

                        while (colorRow != null)
                        {
                            bool hasSizes = false;
                            colorRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                            if (_multiHeaderColor.ContainsKey(colorRID))
                            {
                                hasSizes = (bool)_multiHeaderColor[colorRID];
                                if (hasSizes != colorRow.HasChild())
                                {
                                    OkToProcess = false;
                                    break;
                                }
                            }
                            else
                            {
                                _multiHeaderColor.Add(colorRID, colorRow.HasChild());
                            }
                            colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                }
            }   // END MID Track #5654, #5655, #5657
            catch (Exception ex)
            {
                HandleException(ex);
            }
            return OkToProcess;
        }

        // BEGIN MID Track #6127 - ComponentOne Case Insensitve issue: prohibit duplicate name regardless of case
        private bool ValidMultiColorId(UltraGridRow aSelectedRow)
        {
            bool OkToProcess = true;
            try
            {
                if (ugDetails.DisplayLayout.Bands.Exists("BulkColor"))
                {
                    if (aSelectedRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                    {
                        UltraGridRow colorRow = aSelectedRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                        while (colorRow != null)
                        {
                            string colorID = Convert.ToString(colorRow.Cells["BulkColor"].Value, CultureInfo.CurrentUICulture).ToUpper().Trim();
                            // BEGIN MID Track #6164 - Allow same rid colors to be combined
                            int colorCodeRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                            if (_multiHeaderColorIds.Contains(colorID))
                            {
                                int hashColorRID = (int)_multiHeaderColorIds[colorID];
                                if (hashColorRID != colorCodeRID)
                                {
                                    OkToProcess = false;
                                    break;
                                }
                            }
                            // END MID Track #6164 
                            else
                            {
                                _multiHeaderColorIds.Add(colorID.ToUpper().Trim(), colorCodeRID);
                            }
                            colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                }
            } 
            catch (Exception ex)
            {
                HandleException(ex);
            }
            return OkToProcess;
        }
        // END MID Track #6127

        private void AddComponentsToMulti(UltraGridRow aMultiHdrRow, UltraGridRow aFromRow)
        {
            int multiHdrRID;
            string strKeyH, fromRowHeaderID;

            try
            {
                multiHdrRID = Convert.ToInt32(aMultiHdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                strKeyH = Convert.ToString(aFromRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
               
                if (aFromRow.HasChild(this.ugDetails.DisplayLayout.Bands["Pack"], false))
                {
                    this.ugDetails.ActiveRow = aMultiHdrRow;
                    fromRowHeaderID = Convert.ToString(aFromRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                    UltraGridRow packRow = aFromRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["Pack"]);  
				
					while (packRow != null)
					{
                        AddPackToMulti(aMultiHdrRow, packRow, fromRowHeaderID);
                        packRow = packRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }

                this.ugDetails.ActiveRow = aMultiHdrRow;
                if (aFromRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                {
                    UltraGridRow colorRow = aFromRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);  
					
                    while (colorRow != null)
                    {
                        AddBulkColorToMulti(aMultiHdrRow, colorRow);
                        colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }
                this.ugDetails.UpdateData();
                _dsDetails.AcceptChanges();
            }
            catch  
            {
                throw;
            }
        }

        private void AddPackToMulti(UltraGridRow aMultiHdrRow, UltraGridRow aPackRow, string aFromRowHeaderID)
        {
            try
            {
                int multiHdrRID = Convert.ToInt32(aMultiHdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture); 
                string packName = Convert.ToString(aPackRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture);
                // Begin TT#479 - RMatelic  When a multi header has duplicate packs each pack should display the Header ID.
                //               Always add HeaderID even if not duplicated
                // if multi Header already has the same pack name, modify it to make it distinct
                //if (aMultiHdrRow.HasChild(this.ugDetails.DisplayLayout.Bands["Pack"], false))
                //{
                //    UltraGridRow hdrPackRow = aMultiHdrRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["Pack"]);
                //    while (hdrPackRow != null)
                //    {
                //        // BEGIN Track #6164 - make duplicate name check case insensitive
                //        //if (Convert.ToString(hdrPackRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture) == packName)
                //        if (Convert.ToString(hdrPackRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture).ToUpper().Trim() == packName.ToUpper().Trim())
                //        // END Track #6164
                //        {
                //            packName += " " + aFromRowHeaderID;
                //            break;
                //        }
                //        hdrPackRow = hdrPackRow.GetSibling(SiblingRow.Next, false, false);
                //    }
                //}
                packName += " [" + aFromRowHeaderID + "]";
                // End TT#479

                AddPackRow();
                UltraGridRow newPackRow = this.ugDetails.ActiveRow;

                // Begin TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header
                if (packName.Length > _dtPack.Columns["Pack"].MaxLength)
                {
                    string headerID = Convert.ToString(aMultiHdrRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture);
                    CancelEdit();
                    throw new MIDException(eErrorLevel.severe, (int)eMIDTextCode.msg_al_HeaderFieldLengthError,
                         string.Format(MIDText.GetText(eMIDTextCode.msg_al_HeaderFieldLengthError), headerID, "Pack"));
                }
                // End TT#687
                
                newPackRow.Cells["Pack"].Value = packName;
                newPackRow.Cells["KeyH"].Value = multiHdrRID;
                newPackRow.Cells["PackType"].Value = aPackRow.Cells["PackType"].Value;
                newPackRow.Cells["TotalPacks"].Value = aPackRow.Cells["TotalPacks"].Value;
                newPackRow.Cells["QuantityPerPack"].Value = aPackRow.Cells["QuantityPerPack"].Value;

                if (!aPackRow.HasChild(this.ugDetails.DisplayLayout.Bands["PackColor"], false))
                {
                    newPackRow.Cells["ChildTotal"].Value = aPackRow.Cells["ChildTotal"].Value;
                }
                newPackRow.Cells["AssociatedPackRID"].Value = aPackRow.Cells["KeyP"].Value;
                newPackRow.Update();

                if (aPackRow.HasChild(this.ugDetails.DisplayLayout.Bands["PackColor"], false))
                {
                    AddPackColorToMulti(aPackRow, newPackRow);
                }

                //int keyH = Convert.ToInt32(aPackRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                //int keyP = Convert.ToInt32(aPackRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                //string packSizeTableName = "PackSize" 
                //                         + "~" + keyH.ToString(CultureInfo.CurrentUICulture)
                //                         + "~" + keyP.ToString(CultureInfo.CurrentUICulture);

                //if (_dsDetails.Tables.Contains(packSizeTableName))
                //{ 
                else if (aPackRow.HasChild())
                {
                    this.ugDetails.ActiveRow = newPackRow;
                    
                    AddPackSizeToMulti(aPackRow, newPackRow);
                }

            }
            catch
            {
                throw;
            }
        }

        private void AddPackColorToMulti(UltraGridRow aFromPackRow, UltraGridRow aNewPackRow)
        {
            string errorMessage = string.Empty;
            try
            {
                string strKeyH = Convert.ToString(aFromPackRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                string strFromPackRID = Convert.ToString(aFromPackRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                int multiHdrRID = Convert.ToInt32(aNewPackRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                UltraGridRow packColorRow = aFromPackRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                while (packColorRow != null)
                {
                    AddPackColorRow();
                    string colorCodeID = Convert.ToString(packColorRow.Cells["PackColor"].Value, CultureInfo.CurrentUICulture);
                    UpdateColorValue(ugDetails.ActiveRow, colorCodeID, ref errorMessage);
                    ugDetails.ActiveRow.Cells["Description"].Value = packColorRow.Cells["Description"].Value;
                    ugDetails.ActiveRow.Cells["QuantityPerPack"].Value = packColorRow.Cells["QuantityPerPack"].Value;
                    if (_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                    {
                        this.ugDetails.ActiveRow.Cells["ChildTotal"].Value = packColorRow.Cells["ChildTotal"].Value;
                    }
                    ugDetails.ActiveRow.Update();

                    if (packColorRow.HasChild())	// PackColorSize
                    {
                        int keyP = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                        int keyC = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                        UltraGridRow packColorSizeRow = packColorRow.GetChild(ChildRow.First);
                        
                        string bandKey = packColorSizeRow.Band.Key;

                        string tableName = "PackColorSize" + "~"
                                        + multiHdrRID.ToString(CultureInfo.CurrentUICulture) + "~"
                                        + keyP.ToString(CultureInfo.CurrentUICulture) + "~"
                                        + keyC.ToString(CultureInfo.CurrentUICulture);
                        
                        DataTable dtMultiPackColorSize = MIDEnvironment.CreateDataTable(tableName);
                        dtMultiPackColorSize = _dsDetails.Tables[bandKey].Copy();
                        dtMultiPackColorSize.TableName = tableName;
                        foreach (DataRow dr in dtMultiPackColorSize.Rows)
                        {
                            dr["KeyH"] = multiHdrRID;
                            dr["KeyP"] = keyP;
                            dr["KeyC"] = keyC;
                        }

                        _dsMultiSizes.Tables.Add(dtMultiPackColorSize);
                        _dsMultiSizes.AcceptChanges();
                    }

                    packColorRow = packColorRow.GetSibling(SiblingRow.Next, false, false);
                }    
            }
            catch
            {
                throw;
            }
        }

        private void AddPackSizeToMulti(UltraGridRow aFromPackRow, UltraGridRow aNewPackRow)
        {
            int multiHdrRID, keyP; 
            try
            {
                multiHdrRID = Convert.ToInt32(aNewPackRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                keyP = Convert.ToInt32(aNewPackRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
            
                UltraGridRow packSizeRow = aFromPackRow.GetChild(ChildRow.First);
                string bandKey = packSizeRow.Band.Key;
                string tableName = "PackSize" 
                                 + "~" + multiHdrRID.ToString(CultureInfo.CurrentUICulture)
                                 + "~" + keyP.ToString(CultureInfo.CurrentUICulture)
                                 + "~" + Include.DummyColorRID.ToString(CultureInfo.CurrentUICulture);

                DataTable dtMultiPackSize = MIDEnvironment.CreateDataTable(tableName);
                dtMultiPackSize = _dsDetails.Tables[bandKey].Copy();
                dtMultiPackSize.TableName = tableName;
                foreach (DataRow dr in dtMultiPackSize.Rows)
                {
                    dr["KeyH"] = multiHdrRID;
                    dr["KeyP"] = keyP;
                    dr["KeyC"] = Include.DummyColorRID;
                }
                
                if (!DummyColorCheckOK(aNewPackRow))
                {
                    //MessageBox.Show("Error adding No Color to pack", _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
                
                _dsMultiSizes.Tables.Add(dtMultiPackSize);
            }
            catch
            {
                throw;
            }
        }

        private void AddBulkColorToMulti(UltraGridRow aMultiHdrRow, UltraGridRow aColorRow)
        {
            int multiHdrRID, colorRID, keyC = 0;
            string colorID, errorMessage = string.Empty;
            bool dupColorRowFound;
            try
            {
                multiHdrRID = Convert.ToInt32(aMultiHdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                colorRID = Convert.ToInt32(aColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);	
				colorID = Convert.ToString(aColorRow.Cells["BulkColor"].Value);
                dupColorRowFound = false;
				// if multi Header already has the colorRID add to its qty, otherwise add a new row
				if (aMultiHdrRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))	
				{
                    UltraGridRow hdrColorRow = aMultiHdrRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);  
					while (hdrColorRow != null)
					{
						if (Convert.ToInt32(hdrColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture) == colorRID)
						{
							dupColorRowFound = true;
							int accumQty = (int)hdrColorRow.Cells["Quantity"].Value + (int)aColorRow.Cells["Quantity"].Value;
							hdrColorRow.Cells["Quantity"].Value = accumQty;
                            keyC = Convert.ToInt32(hdrColorRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
							break;
						}
						hdrColorRow = hdrColorRow.GetSibling(SiblingRow.Next,false,false);
					}
				}
                if (!dupColorRowFound)
                {
                    AddBulkColorRow();
                    UpdateColorValue(ugDetails.ActiveRow, colorID, ref errorMessage);
                    ugDetails.ActiveRow.Cells["Description"].Value = aColorRow.Cells["Description"].Value;
                    ugDetails.ActiveRow.Cells["Quantity"].Value = aColorRow.Cells["Quantity"].Value;
                    if (_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                    {
                        ugDetails.ActiveRow.Cells["ChildTotal"].Value = aColorRow.Cells["ChildTotal"].Value;
                    }
                    keyC = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                    ugDetails.ActiveRow.Update();
                }
                if (_creatingAssortment)
                {   // if new placeholder color HdrBCRID = -1, Before & After Cell updates won't fire so change it twice 
                    if (keyC == Include.NoRID)
                    {
                        aColorRow.Cells["AsrtBCRID"].Value = 0;
                    }    
                    aColorRow.Cells["AsrtBCRID"].Value = keyC;
                }
                if (aColorRow.HasChild())
                {
                    UltraGridRow bulkSizeRow = aColorRow.GetChild(ChildRow.First);
                    string bandKey = bulkSizeRow.Band.Key;
                    string tableName = "BulkSize" + "~"
                                        + multiHdrRID.ToString(CultureInfo.CurrentUICulture) + "~"
                                        + keyC.ToString(CultureInfo.CurrentUICulture);
                  
                    DataTable dtMultiBulkSize = MIDEnvironment.CreateDataTable(tableName);
                    dtMultiBulkSize = _dsDetails.Tables[bandKey].Copy();
                    dtMultiBulkSize.TableName = tableName;
                    foreach (DataRow dr in dtMultiBulkSize.Rows)
                    {
                        dr["KeyH"] = multiHdrRID;
                        dr["KeyC"] = keyC;
                    }
                    if (!_dsDetails.Tables.Contains(tableName))
                    {
                        if (!_dsMultiSizes.Tables.Contains(tableName))
                        {
                            _dsMultiSizes.Tables.Add(dtMultiBulkSize);
                        }
                        else
                        {
                            MergeDataTableToTempDataSet(tableName, dtMultiBulkSize, bulkSizeRow);
                        }
                    }
                    else
                    {
                        while (bulkSizeRow != null)
                        {
                            MergeRowToMainDataSet(aMultiHdrRow, tableName, bulkSizeRow);
                           
                            bulkSizeRow = bulkSizeRow.GetSibling(SiblingRow.Next, false, false);
                        }
                        _dsDetails.Tables[tableName].AcceptChanges();
                        FormatAddedSizesLayout(ugDetails.DisplayLayout.Bands[tableName]);
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void MergeDataTableToTempDataSet(string aTableName, DataTable dtMergeBulkSize, UltraGridRow aBulkSizeRow)
        {
            // if the size column and row currently exists for the color in the Multi, add the quantities
            // if the size column doesn't exist for a found row, add the column
            // if the size row doesn't exist, add the row
            string mergeRowHeader, curMultiRowHeader, mergeColName, curMultiColName;
            bool rowFound, colFound;
            int addQty, qty, totalQty, mergeSizeKey, curMultiSizeKey, mergePrimaryRID, curMultiPrimaryRID;
            try
            {
                DataTable dtCurMultiBulkSize = _dsMultiSizes.Tables[aTableName];
        
                foreach (DataRow mergeRow in dtMergeBulkSize.Rows)
                {
                    rowFound = false;
                    mergeRowHeader = Convert.ToString(mergeRow["Secondary"], CultureInfo.CurrentUICulture);
                    int mergeSecondaryRID = Convert.ToInt32(mergeRow["SecondaryRID"], CultureInfo.CurrentUICulture);  // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    foreach (DataRow curMultiRow in dtCurMultiBulkSize.Rows)
                    {
                        curMultiRowHeader = Convert.ToString(curMultiRow["Secondary"], CultureInfo.CurrentUICulture);
                        int curMultiSecondaryRID = Convert.ToInt32(curMultiRow["SecondaryRID"], CultureInfo.CurrentUICulture);  // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                        //if (curMultiRowHeader == mergeRowHeader)
                        if (curMultiSecondaryRID == mergeSecondaryRID)
                        {
                            totalQty = Convert.ToInt32(curMultiRow["TotalQuantity"], CultureInfo.CurrentUICulture);
                            rowFound = true;
                            for (int i = 7; i < dtMergeBulkSize.Columns.Count; i++)
                            {
                                DataColumn dMergeCol = dtMergeBulkSize.Columns[i];
                                colFound = false;
                                mergeColName = dMergeCol.ColumnName;
                                mergePrimaryRID = Convert.ToInt32(dMergeCol.ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                //mergeSizeKey = Convert.ToInt32(dMergeCol.ExtendedProperties[mergeColName + "~" + mergeRowHeader], CultureInfo.CurrentUICulture);
                                mergeSizeKey = Convert.ToInt32(dMergeCol.ExtendedProperties[mergeColName + "~" + mergeSecondaryRID], CultureInfo.CurrentUICulture);
                                // End TT#234  
                                mergePrimaryRID = Convert.ToInt32(dMergeCol.ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                                curMultiPrimaryRID = 0;      //  TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                for (int j = 7; j < dtCurMultiBulkSize.Columns.Count; j++)
                                {
                                    DataColumn dCurCol = dtCurMultiBulkSize.Columns[j];
                                    curMultiColName = dCurCol.ColumnName;
                                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                    //curMultiSizeKey = Convert.ToInt32(dCurCol.ExtendedProperties[curMultiColName + "~" + curMultiRowHeader], CultureInfo.CurrentUICulture);
                                    curMultiSizeKey = Convert.ToInt32(dCurCol.ExtendedProperties[curMultiColName + "~" + curMultiSecondaryRID], CultureInfo.CurrentUICulture);
                                    // End TT#234 
                                    curMultiPrimaryRID = Convert.ToInt32(dCurCol.ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                                 
                                    //if (curMultiSizeKey == mergeSizeKey)
                                    if (curMultiPrimaryRID == mergePrimaryRID) 
                                    {
                                        if (curMultiSizeKey == mergeSizeKey)    // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                        {
                                            colFound = true;
                                            addQty = (int)mergeRow[i];
                                            // Begin TT#558 - RMatelic - TMW - multi header is incorrect- get error message and results leaves out sizes long and XLong
                                            if (curMultiRow[j] == DBNull.Value)
                                            {
                                                curMultiRow[j] = 0;
                                            }
                                            // End TT#558
                                            qty = (int)curMultiRow[j];
                                            curMultiRow[j] = qty + addQty;
                                            totalQty += addQty;
                                            curMultiRow["TotalQuantity"] = totalQty;
                                            break;
                                        }    
                                    }
                                }
                                if (!colFound)
                                {   // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                    if (dtCurMultiBulkSize.Columns.Contains(mergeColName))
                                    {
                                        // Begin TT#558 - RMatelic - TMW - multi header is incorrect- get error message and results leaves out sizes long and XLong
                                        if (mergeSizeKey == Include.NoRID)
                                        {
                                            mergeColName += _dupSizeNameSeparator + "NoSize";
                                        }
                                        else
                                        // End TT#558
                                        {
                                            SizeCodeProfile scp = _SAB.HierarchyServerSession.GetSizeCodeProfile(mergeSizeKey);
                                            mergeColName += _dupSizeNameSeparator + scp.SizeCodeID;
                                        }
                                    }
                                    // End TT#234  
                                    addQty = (int)mergeRow[i];
                                    DataColumn newCol = dtCurMultiBulkSize.Columns.Add(mergeColName, System.Type.GetType("System.Int32"));
                                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                    //newCol.ExtendedProperties.Add(mergeColName + "~" + mergeRowHeader, mergeSizeKey);
                                    newCol.ExtendedProperties.Add(mergeColName + "~" + mergeSecondaryRID, mergeSizeKey);
                                    // End TT#234  
                                    newCol.ExtendedProperties.Add("PrimaryRID", mergePrimaryRID);
                                    curMultiRow[newCol] = addQty;
                                    totalQty += addQty;
                                    curMultiRow["TotalQuantity"] = totalQty;
                                }
                            }
                        }
                    }
                    if (!rowFound)
                    {
                        // Begin TT#558  - RMatelic - TMW - multi header is incorrect- get error message and results leaves out sizes long and XLong
                        UltraGridRow bulkSizeRow = aBulkSizeRow;
                        string rowHeader = string.Empty;
                        while (bulkSizeRow != null)
                        {
                            rowHeader = Convert.ToString(bulkSizeRow.Cells["Secondary"].Value, CultureInfo.CurrentUICulture);
                            if (rowHeader == mergeRowHeader)
                            {
                                break;
                            }
                            bulkSizeRow = bulkSizeRow.GetSibling(SiblingRow.Next, false, false);
                        }
                        //AddNewMergedSizeRow(ref dtCurMultiBulkSize, aBulkSizeRow);
                        AddNewMergedSizeRow(ref dtCurMultiBulkSize, bulkSizeRow);
                    }   // End TT#558
                }
                _dsMultiSizes.Tables[aTableName].AcceptChanges();
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void MergeRowToMainDataSet(UltraGridRow aMultiHdrRow, string aTableName, UltraGridRow aBulkSizeRow)
        {
            // if the size column and row currently exists for the color in the Multi, add the quantities
            // if the size column doesn't exist for a found row, add the column
            // if the size row doesn't exist, add the row
            string mergeRowHeader, curMultiRowHeader, mergeColName, curMultiColName;
            bool rowFound = false, colFound = false;
            int addQty, qty, totalQty = 0, mergeSizeKey, curMultiSizeKey, mergePrimaryRID, curMultiPrimaryRID;
            try
            {
                mergeRowHeader = Convert.ToString(aBulkSizeRow.Cells["Secondary"].Value, CultureInfo.CurrentUICulture);

                int mergeSecondaryRID = Convert.ToInt32(aBulkSizeRow.Cells["Secondary"].Tag, CultureInfo.CurrentUICulture); // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)

                DataTable dtCurMultiBulkSize = _dsDetails.Tables[aTableName];

                foreach (DataRow curMultiRow in dtCurMultiBulkSize.Rows)
                {
                    rowFound = false;
                    curMultiRowHeader = Convert.ToString(curMultiRow["Secondary"], CultureInfo.CurrentUICulture);
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    int curMultiSecondaryRID = Convert.ToInt32(curMultiRow["SecondaryRID"], CultureInfo.CurrentUICulture);  
                    //if (curMultiRowHeader == mergeRowHeader) 
                    if (curMultiSecondaryRID == mergeSecondaryRID)
                    // End TT#234 
                    {
                        // totalQty = Convert.ToInt32(curMultiRow["TotalQuantity"], CultureInfo.CurrentUICulture);
                        rowFound = true;
                        UltraGridRow multiSizeRow = GetMultiBulkSizeRow(aMultiHdrRow, mergeRowHeader, aTableName);

                        for (int i = 7; i < aBulkSizeRow.Cells.Count; i++)
                        {
                            colFound = false;
                            mergeColName = aBulkSizeRow.Cells[i].Column.Key;
                            mergeSizeKey = Convert.ToInt32(aBulkSizeRow.Cells[i].Tag, CultureInfo.CurrentUICulture);
                            mergePrimaryRID = Convert.ToInt32(aBulkSizeRow.Cells[i].Column.Tag, CultureInfo.CurrentUICulture);
                            for (int j = 7; j < multiSizeRow.Cells.Count; j++)
                            {
                                curMultiColName = multiSizeRow.Cells[j].Column.Key;
                                curMultiSizeKey = Convert.ToInt32(multiSizeRow.Cells[j].Tag, CultureInfo.CurrentUICulture);
                                curMultiPrimaryRID = Convert.ToInt32(multiSizeRow.Cells[j].Column.Tag, CultureInfo.CurrentUICulture);
                                //if (curMultiSizeKey == mergeSizeKey)
                                if (curMultiPrimaryRID == mergePrimaryRID)
                                {
                                    if (curMultiSizeKey == mergeSizeKey)    // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                    {
                                        colFound = true;
                                        addQty = Convert.ToInt32(aBulkSizeRow.Cells[i].Value, CultureInfo.CurrentUICulture);
                                        qty = Convert.ToInt32(multiSizeRow.Cells[j].Value, CultureInfo.CurrentUICulture);
                                        multiSizeRow.Cells[j].Value = qty + addQty;
                                        break;
                                    }
                                }
                            }
                            if (!colFound && (int)aBulkSizeRow.Cells[i].Value > 0)
                            {
                                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                if (dtCurMultiBulkSize.Columns.Contains(mergeColName))
                                {
                                    SizeCodeProfile scp = _SAB.HierarchyServerSession.GetSizeCodeProfile(mergeSizeKey);
                                    mergeColName += _dupSizeNameSeparator + scp.SizeCodeID;
                                }
                                // End TT#234 
                                addQty = Convert.ToInt32(aBulkSizeRow.Cells[i].Value, CultureInfo.CurrentUICulture);
                                DataColumn newCol = dtCurMultiBulkSize.Columns.Add(mergeColName, System.Type.GetType("System.Int32"));
                                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                //newCol.ExtendedProperties.Add(mergeColName + "~" + mergeRowHeader, mergeSizeKey);
                                newCol.ExtendedProperties.Add(mergeColName + "~" + mergeSecondaryRID, mergeSizeKey);
                                // End TT#234 
                                newCol.ExtendedProperties.Add("PrimaryRID", mergePrimaryRID);

                                foreach (DataRow multiDR in dtCurMultiBulkSize.Rows)
                                {
                                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                    //if (multiDR["Secondary"].ToString() == curMultiRowHeader)
                                    if (Convert.ToInt32(multiDR["SecondaryRID"], CultureInfo.CurrentUICulture) == curMultiSecondaryRID)
                                    // End TT#234 
                                    {   
                                        multiDR[mergeColName] = addQty;
                                        totalQty = (int)multiDR["TotalQuantity"];
                                        multiDR["TotalQuantity"] = totalQty + addQty;
                                        _sizesAutoAdded = true;
                                    }
                                    else
                                    {
                                        multiDR[mergeColName] = 0;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
                if (!rowFound)
                {
                    AddNewMergedSizeRow(ref dtCurMultiBulkSize, aBulkSizeRow);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private UltraGridRow GetMultiBulkSizeRow(UltraGridRow aMultiHdrRow, string aGridRowHeader, string bandKey)
        {
            UltraGridRow returnRow = null;
            try
            {
                UltraGridRow multiColorRow = aMultiHdrRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                while (multiColorRow != null)
                {
                    if (multiColorRow.HasChild(this.ugDetails.DisplayLayout.Bands[bandKey], false))
                    {
                        UltraGridRow multiSizeRow = multiColorRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands[bandKey]);
                        while (multiSizeRow != null)
                        {
                            if (multiSizeRow.Cells["Secondary"].Value.ToString() == aGridRowHeader)
                            {
                                returnRow = multiSizeRow;
                                break;
                            }
                            multiSizeRow = multiSizeRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                    if (returnRow != null)
                    {
                        break;
                    }
                    multiColorRow = multiColorRow.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch  
            {
               throw; 
            }
            return returnRow;
        }
	
        private void AddNewMergedSizeRow(ref DataTable dtCurMultiBulkSize, UltraGridRow bulkSizeRow)
        {
            string mergeColName, mergeRowHeader;
            bool colFound;
            int addQty, colorRID, multiHdrRID, mergeSizeKey, mergePrimaryRID, mergeSecondaryRID;
            try
            {
                DataRow row = dtCurMultiBulkSize.Rows[0];
                multiHdrRID = Convert.ToInt32(row["KeyH"], CultureInfo.CurrentUICulture);
                colorRID = Convert.ToInt32(row["KeyC"], CultureInfo.CurrentUICulture);
                mergeRowHeader = Convert.ToString(bulkSizeRow.Cells["Secondary"].Value, CultureInfo.CurrentUICulture);
                mergeSecondaryRID = Convert.ToInt32(bulkSizeRow.Cells["Secondary"].Tag, CultureInfo.CurrentUICulture);   // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
            
                for (int c = 7; c < bulkSizeRow.Cells.Count; c++)
                {
                    UltraGridCell cell = bulkSizeRow.Cells[c];
                    mergeColName = cell.Column.Key;
                    mergeSizeKey = Convert.ToInt32(cell.Tag, CultureInfo.CurrentUICulture);
                    addQty = Convert.ToInt32(cell.Value, CultureInfo.CurrentUICulture);
                    mergePrimaryRID = Convert.ToInt32(cell.Column.Tag, CultureInfo.CurrentUICulture);
                    colFound = false;
                    for (int j = 7; j < dtCurMultiBulkSize.Columns.Count; j++)
                    {
                        int curPrimaryRID = Convert.ToInt32(dtCurMultiBulkSize.Columns[j].ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                        //if (dtCurMultiBulkSize.Columns[j].ColumnName == mergeColName)
                        if (curPrimaryRID == mergePrimaryRID)
                        {
                            colFound = true;
                            // Begin TT#558 - RMatelic - TMW - multi header is incorrect- get error message and results leaves out sizes long and XLong
                            DataColumn dCol = dtCurMultiBulkSize.Columns[j];
                            if (!dCol.ExtendedProperties.ContainsKey(mergeColName + "~" + mergeRowHeader))
                            {
                                dCol.ExtendedProperties.Add(mergeColName + "~" + mergeRowHeader, mergeSizeKey);
                            }
                            // End TT#558
                            break;
                        }
                    }

                    if (!colFound)
                    {    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                        if (dtCurMultiBulkSize.Columns.Contains(mergeColName))
                        {
                            SizeCodeProfile scp = _SAB.HierarchyServerSession.GetSizeCodeProfile(mergeSizeKey);
                            mergeColName += _dupSizeNameSeparator + scp.SizeCodeID;
                        }
                        //End TT#234 
                        DataColumn newCol = dtCurMultiBulkSize.Columns.Add(mergeColName, System.Type.GetType("System.Int32"));
                        newCol.ExtendedProperties.Add(mergeColName + "~" + mergeSecondaryRID, mergeSizeKey);  // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                        newCol.ExtendedProperties.Add("PrimaryRID", mergePrimaryRID);
                        foreach (DataRow multiDR in dtCurMultiBulkSize.Rows)
                        {
                            multiDR[newCol] = 0;
                        }
                    }
                }
                
                DataRow newRow = dtCurMultiBulkSize.NewRow();

                newRow["KeyH"] = multiHdrRID;  
                newRow["KeyP"] = Include.NoRID;
                newRow["KeyC"] = colorRID; ;
                newRow["SecondaryRID"] = mergeSecondaryRID;  // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                newRow["Secondary"] = mergeRowHeader;

                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary) - unrelated
                if (mergeRowHeader == Include.NoSecondarySize || mergeRowHeader.Trim() == string.Empty || mergeRowHeader.Trim() == _noSizeDimensionLbl)
                {
                    newRow[" - "] = _lblQuantity;
                }
                else
                {
                    newRow[" - "] = mergeRowHeader;
                }
                // End TT#234  

                newRow["TotalQuantity"] = Convert.ToInt32(bulkSizeRow.Cells["TotalQuantity"].Value, CultureInfo.CurrentUICulture);
                for (int i = 7; i < bulkSizeRow.Cells.Count; i++)
                {
                    mergeColName = bulkSizeRow.Cells[i].Column.Key;
                    mergeSizeKey = Convert.ToInt32(bulkSizeRow.Cells[i].Tag, CultureInfo.CurrentUICulture);
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    mergePrimaryRID = Convert.ToInt32(bulkSizeRow.Cells[i].Column.Tag, CultureInfo.CurrentUICulture);   
                    for (int j = 7; j < dtCurMultiBulkSize.Columns.Count; j++)
                    {
                        DataColumn tblCol = dtCurMultiBulkSize.Columns[j];
                        string tblColName = tblCol.ColumnName;
                        //int tblSizeKey = Convert.ToInt32(tblCol.ExtendedProperties[tblColName + "~" + mergeRowHeader], CultureInfo.CurrentUICulture);
                        int tblColPrimaryRID = Convert.ToInt32(tblCol.ExtendedProperties["PrimaryRID"], CultureInfo.CurrentUICulture);
                        int tblSizeKey = Convert.ToInt32(tblCol.ExtendedProperties[tblColName + "~" + mergeSecondaryRID], CultureInfo.CurrentUICulture);
                        //if (tblSizeKey == mergeSizeKey) 
                        if (tblColName == mergeColName)
                        {
                            newRow[tblColName] = Convert.ToInt32(bulkSizeRow.Cells[i].Value, CultureInfo.CurrentUICulture);
                            if (!tblCol.ExtendedProperties.ContainsKey(mergeColName + "~" + mergeSecondaryRID))
                            {
                                tblCol.ExtendedProperties.Add(mergeColName + "~" + mergeSecondaryRID, mergeSizeKey);
                            }
                            if ((int)newRow[tblColName] > 0)
                            {
                                _sizesAutoAdded = true;
                            }
                        }
                        else if (!bulkSizeRow.Cells.Exists(tblColName))
                        {
                            newRow[tblColName] = 0;
                        }
                    }
                }
                // End TT#234 
                dtCurMultiBulkSize.Rows.Add(newRow);              
            }
            catch
            {
                throw;
            }
        }	

        private void AddMultiSizeTables()
        {
            try
            {
                if (_dsMultiSizes.Tables.Count == 0)
                {
                    return;
                }

                _sizesAutoAdded = true;
                DataTable[] dtRange = new DataTable[_dsMultiSizes.Tables.Count];
                for (int i = 0; i < _dsMultiSizes.Tables.Count; i++)
                {
                    dtRange[i] = _dsMultiSizes.Tables[i].Copy();
                }

                _dsDetails.Tables.AddRange(dtRange);
                for (int i = 0; i < _dsMultiSizes.Tables.Count; i++)
                {
                    DataTable dt = _dsMultiSizes.Tables[i];
                    string tableName = dt.TableName;
                    string[] bandKeyParts = tableName.Split(new char[] { '~' });

                    switch (bandKeyParts[0])
                    {
                        case "PackColorSize":
                            _dsDetails.Relations.Add(tableName,
                                new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"], _dsDetails.Tables["PackColor"].Columns["KeyC"] },
                                new DataColumn[] { _dsDetails.Tables[tableName].Columns["KeyH"], _dsDetails.Tables[tableName].Columns["KeyP"], _dsDetails.Tables[tableName].Columns["KeyC"] }, true);

                            break;

                        case "PackSize":
                             _dsDetails.Relations.Add(tableName,
                                new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                                new DataColumn[] { _dsDetails.Tables[tableName].Columns["KeyH"], _dsDetails.Tables[tableName].Columns["KeyP"] }, true);
                            break;

                        case "BulkSize":
                            _dsDetails.Relations.Add(tableName,
                                new DataColumn[] { _dsDetails.Tables["BulkColor"].Columns["KeyH"], _dsDetails.Tables["BulkColor"].Columns["KeyC"] },
                                new DataColumn[] { _dsDetails.Tables[tableName].Columns["KeyH"], _dsDetails.Tables[tableName].Columns["KeyC"] }, true);
                            break;
                    }
                    FormatAddedSizesLayout(ugDetails.DisplayLayout.Bands[tableName]);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                _dsMultiSizes.Dispose();
            }
        }

        // Begin TT#2061 - JSmith - Size hierarchy node within Style-Color not found - after Header copied to new Style\Color
        private void UpdateAddedSizeRows(UltraGridRow aHdrRow)
        {
            UpdateAddedSizeRows(aHdrRow, false);
        }

        private void UpdateAddedSizeRows(UltraGridRow aHdrRow, bool aIncludeZeroValues)
        // End TT#2061
        {
            string bandKey;
            int qty, hdrRID, styleRID, colorCodeRID;
            ArrayList sizeAL;
            ColorCodeProfile ccp;
            // Changing the qty to 0 and then back forces the AfterCellUpdate event which updates the
            // AllocationProfile
            try
            {
                hdrRID = Convert.ToInt32(aHdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                styleRID = Convert.ToInt32(aHdrRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
              
                // Begin TT#1114 - RMatelic -Did a Save As in the Allocation Workspace and receive a null reference exception
                eHeaderType headerType = (eHeaderType)Convert.ToInt32(aHdrRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(hdrRID);
                // End TT#1114

                // Begin TT#2061 - JSmith - Size hierarchy node within Style-Color not found - after Header copied to new Style\Color
                //if (aHdrRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                if (aHdrRow.HasChild() && 
                    aHdrRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                // End TT#2061
                {
                    UltraGridRow colorRow = aHdrRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                    while (colorRow != null)
                    {
                        if (colorRow.HasChild())
                        {
                            colorCodeRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                            ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);
                            sizeAL = new ArrayList();
                            colorRow.Cells["Balance"].Value = 0;
                            colorRow.Cells["ChildTotal"].Value = colorRow.Cells["Quantity"].Value;
                            UltraGridRow bulkSizeRow = colorRow.GetChild(ChildRow.First);
                            while (bulkSizeRow != null)
                            {
                                for (int i = 7; i < bulkSizeRow.Cells.Count; i++)
                                {
                                    if (bulkSizeRow.Cells[i].Value != DBNull.Value)
                                    {
                                        qty = (int)bulkSizeRow.Cells[i].Value;
                                        // Begin TT#2061 - JSmith - Size hierarchy node within Style-Color not found - after Header copied to new Style\Color
                                        //if (qty > 0)
                                        if (qty > 0 ||
                                            (headerType != eHeaderType.WorkupTotalBuy && aIncludeZeroValues))
                                        // End TT#2061
                                        {
                                            bulkSizeRow.Cells[i].Value = 0;
                                            bulkSizeRow.Cells[i].Value = qty;
                                            AddSizeToArrayList(ref sizeAL, bulkSizeRow.Cells[i]);
                                        }
                                        // Begin TT#1114 - RMatelic -Did a Save As in the Allocation Workspace and receive a null reference exception
                                        else if (headerType == eHeaderType.WorkupTotalBuy)
                                        {
                                            bulkSizeRow.Cells[i].Value = 0;
                                            AddSizeToArrayList(ref sizeAL, bulkSizeRow.Cells[i]);
                                            int sizeCodeKey = Convert.ToInt32(bulkSizeRow.Cells[i].Tag, CultureInfo.CurrentUICulture);
                                            ap.AddBulkSizeToColor(colorCodeRID, sizeCodeKey, 0, -1);
                                        }
                                        // End TT#1114 
                                    }
                                }
                                bulkSizeRow = bulkSizeRow.GetSibling(SiblingRow.Next, false, false);
                            }
                            UpdateColorSizeHash(styleRID, ccp.ColorCodeID, sizeAL);
                        }
                        colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }

                // Begin TT#2061 - JSmith - Size hierarchy node within Style-Color not found - after Header copied to new Style\Color
                //if (aHdrRow.HasChild(this.ugDetails.DisplayLayout.Bands["Pack"], false))
                if (aHdrRow.HasChild() &&
                    aHdrRow.HasChild(this.ugDetails.DisplayLayout.Bands["Pack"], false))
                // End TT#2061
                {
                    UltraGridRow packRow = aHdrRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["Pack"]);
                    string packName = Convert.ToString(packRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture);
                    while (packRow != null)
                    {
                        if (packRow.HasChild())
                        {
                            sizeAL = new ArrayList();
                            UltraGridRow packChildRow = packRow.GetChild(ChildRow.First);
                            while (packChildRow != null)
                            {
                                bandKey = packChildRow.Band.Key;
                                if (bandKey == "PackColor")
                                {
                                    colorCodeRID = Convert.ToInt32(packChildRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                    ccp = _SAB.HierarchyServerSession.GetColorCodeProfile(colorCodeRID);
                                    UltraGridRow packChildSizeRow = packChildRow.GetChild(ChildRow.First);
                                    while (packChildSizeRow != null)
                                    {
                                        for (int i = 7; i < packChildSizeRow.Cells.Count; i++)
                                        {
                                            qty = (int)packChildSizeRow.Cells[i].Value;
                                            // Begin TT#2061 - JSmith - Size hierarchy node within Style-Color not found - after Header copied to new Style\Color
                                            //if (qty > 0)
                                            if (qty > 0 ||
                                                (headerType != eHeaderType.WorkupTotalBuy && aIncludeZeroValues))
                                            // End TT#2061
                                            {
                                                packChildSizeRow.Cells[i].Value = 0;
                                                packChildSizeRow.Cells[i].Value = qty;
                                                AddSizeToArrayList(ref sizeAL, packChildSizeRow.Cells[i]);
                                            }
                                            // Begin TT#1114 - RMatelic -Did a Save As in the Allocation Workspace and receive a null reference exception
                                            else if (headerType == eHeaderType.WorkupTotalBuy)
                                            {
                                                packChildSizeRow.Cells[i].Value = 0;
                                                AddSizeToArrayList(ref sizeAL, packChildSizeRow.Cells[i]);
                                                int sizeCodeKey = Convert.ToInt32(packChildSizeRow.Cells[i].Tag, CultureInfo.CurrentUICulture);
                                                ap.AddSizeToPackColor(packName, colorCodeRID, sizeCodeKey, 0, -1);
                                            }
                                            // End TT#1114 
                                        }
                                        packChildSizeRow = packChildSizeRow.GetSibling(SiblingRow.Next, true, false);
                                    }
                                    if (sizeAL.Count > 0)
                                    {
                                        UpdateColorSizeHash(styleRID, ccp.ColorCodeID, sizeAL);
                                        sizeAL.Clear();
                                    }
                                }
                                else if (bandKey.StartsWith("PackSize"))
                                {
                                    for (int i = 7; i < packChildRow.Cells.Count; i++)
                                    {
                                        qty = (int)packChildRow.Cells[i].Value;
                                        if (qty > 0)
                                        {
                                            packChildRow.Cells[i].Value = 0;
                                            packChildRow.Cells[i].Value = qty;
                                            AddSizeToArrayList(ref sizeAL, packChildRow.Cells[i]);
                                        }
                                        // Begin TT#1114 - RMatelic -Did a Save As in the Allocation Workspace and receive a null reference exception
                                        else if (headerType == eHeaderType.WorkupTotalBuy)
                                        {
                                            packChildRow.Cells[i].Value = 0;
                                            AddSizeToArrayList(ref sizeAL, packChildRow.Cells[i]);
                                            int sizeCodeKey = Convert.ToInt32(packChildRow.Cells[i].Tag, CultureInfo.CurrentUICulture);
                                            ap.AddSizeToPackColor(packName, Include.DummyColorRID, sizeCodeKey, 0, -1);
                                        }
                                        // End TT#1114 
                                    }
                                }
                                packChildRow = packChildRow.GetSibling(SiblingRow.Next, true, false);
                            }
                            if (sizeAL.Count > 0)
                            {
                                UpdateColorSizeHash(styleRID, Include.DummyColorID, sizeAL);
                                sizeAL.Clear();
                            }
                        }
                        packRow = packRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void AddSizeToArrayList(ref ArrayList aSizeAL, UltraGridCell aCell)
        {
            int sizeKey = (int)aCell.Tag;
            // Begin TT#558 - RMatelic - TMW - multi header is incorrect- get error message and results leaves out sizes long and XLong
            if (sizeKey > 0)
            {
            // End TT#558
                SizeCodeProfile scp = _SAB.HierarchyServerSession.GetSizeCodeProfile(sizeKey);
                if (!aSizeAL.Contains(scp.SizeCodeID))
                {
                    aSizeAL.Add(scp.SizeCodeID);
                }
            }
        }

        private void cmsMultiAddTo_Click(object sender, EventArgs e)
        {
            MultiAddTo();
        }
        private void MultiAddTo()
        {
            bool errorFound = false, componentsExist = false;
            string errMessage = string.Empty;
            int multiHdrRID = 0, multiHeaderCount = 0, addHeaderCount = 0;
            int multiHdrTotal, multiChildTotal;
            int firstSizeGroup = Include.UndefinedSizeGroupRID;
            UltraGridRow multiHdrRow = null;

            try
            {
                if (this.ugDetails.Selected.Rows.Count == 0)
                {
                    return;
                }
                
                _multiHeaderColor.Clear();
                _multiHeaderColorIds.Clear();   // MID Track #6127
                componentsExist = ugDetails.Selected.Rows[0].HasChild(false);
                foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                {
                    if (Convert.ToInt32(selRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                    {
                        multiHeaderCount++;
                        if (multiHeaderCount > 1)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_OnlyOneMultiAllowed);
                            break;
                        }
                        if (!ValidMultiColorId(selRow)) // MID Track #6127
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_DuplicateBulkColorNotAllowed);
                            break;
                        }
                        else if (!DuplicateColorCheckOK(selRow))
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderDupColorSizeMismatch);
                            break;
                        }
                        else if (selRow.HasChild(false) != componentsExist)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderComponentMismatch);
                            break;
                        }
						// Begin TT#1753-MD - stodd - Object reference error charging intransit on multi-header
                        else if (!string.IsNullOrEmpty(selRow.Cells["AsrtRID"].Value.ToString()) && Convert.ToInt32(selRow.Cells["AsrtRID"].Value) > 0)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderNewMemberBelongsToAssortment); 
                            break;
                        }
                        else if (!string.IsNullOrEmpty(selRow.Cells["GroupAllocRID"].Value.ToString()) && Convert.ToInt32(selRow.Cells["GroupAllocRID"].Value) > 0)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderNewMemberBelongsToGroupAllocation); 
                            break;
                        }
              			// End TT#1753-MD - stodd - Object reference error charging intransit on multi-header
						
                        multiHdrRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                     
                        if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) !=  (int)eHeaderAllocationStatus.ReceivedInBalance)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_InvalidMultiHeaderStatus);
                            break;
                        }
                        else
                        {
                            multiHdrRow = selRow;
                        } 
                    }
                    else if (Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) < 0)
                        {
                            errorFound = true;
                            errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_HeaderMustBeSavedBeforeAddingToMulti, false),
                                                Convert.ToString(selRow.Cells["HeaderID"].Value, CultureInfo.CurrentUICulture),                     
                                                string.Empty);
                            break;
                        }    
                    else if (Convert.ToInt32(selRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) != (int)eHeaderAllocationStatus.ReceivedInBalance)
                    {
                        errorFound = true;
                        string status = MIDText.GetTextOnly((int)eHeaderAllocationStatus.ReceivedInBalance);
                        errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_InvalidStatusForMultiSelection), status);
                        break;
                    }
                    else if (!ValidMultiColorId(selRow)) // MID Track #6127
                    {
                        errorFound = true;
                        errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_DuplicateBulkColorNotAllowed);
                        break;
                    }
                    else if (!DuplicateColorCheckOK(selRow))
                    {
                        errorFound = true;
                        errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderDupColorSizeMismatch);
                        break;
                    }
                    else
                    {
                        if (selRow.HasChild(false) != componentsExist)
                        {
                            errorFound = true;
                            errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_MultiHeaderComponentMismatch);
                            break;
                        }
                        addHeaderCount++;
                    }
                }
          
                if (!errorFound)
                {
                    if (multiHeaderCount == 0)
                    {
                        errorFound = true;
                        errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_NoMultiHeaderSelected);
                    }
                    else if (addHeaderCount == 0)
                    {
                        errorFound = true;
                        errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_NoHeaderSelectedForMulti);
                    }
                }

                if (errorFound)
                {
                    MessageBox.Show(errMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                _creatingMulti = true;
                _skipQtyUpdate = true;  // TT#304 - RMatelic - Multi Header - made the multiple 10 received message "multiple cannot exceed units to allocate
                Cursor.Current = Cursors.WaitCursor;

                multiHdrTotal = Convert.ToInt32(multiHdrRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                multiChildTotal = Convert.ToInt32(multiHdrRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                firstSizeGroup = Convert.ToInt32(multiHdrRow.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture);

                _dsMultiSizes = MIDEnvironment.CreateDataSet();

                _rClickRow = null;
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.BeginUpdate();
                //this.ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls

                for (int i = 0; i < ugDetails.Selected.Rows.Count; i++)
                {
                    UltraGridRow fromRow = this.ugDetails.Selected.Rows[i];
                    // skip the MultiHeader row
                    if (Convert.ToInt32(fromRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader)
                    {
                        continue;
                    }
                    int fromHdrRID = (int)fromRow.Cells["KeyH"].Value;
                    multiHdrTotal += (int)fromRow.Cells["HdrQuantity"].Value;
                    multiChildTotal += (int)fromRow.Cells["ChildTotal"].Value;

                    fromRow.Cells["Status"].Value = (int)eHeaderAllocationStatus.InUseByMultiHeader;
                    fromRow.Cells["HdrGroupRID"].Value = multiHdrRID;
                    _lastMultiSortSeq++;
                    fromRow.Cells["MultiSortSeq"].Value = _lastMultiSortSeq;

                    if (firstSizeGroup == Include.UndefinedSizeGroupRID)    // if Size group of multi is None and sizes exist, leave it None
                    {
                        if (!HeaderSizesExist(multiHdrRID))   // TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                        {
                            if (Convert.ToInt32(fromRow.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture) != Include.UndefinedSizeGroupRID)
                            {
                                firstSizeGroup = Convert.ToInt32(fromRow.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture);
                            }
                        }
                    }
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    else if (HeaderSizesExist(fromHdrRID))   
                    { 
                        if (ChangeSizeGroupToNone(firstSizeGroup, fromHdrRID))
                        {
                            firstSizeGroup = Include.UndefinedSizeGroupRID;
                        }
                    }
                    // End TT#234  
                    
                    AddComponentsToMulti(multiHdrRow, fromRow);

                    if (!_headersAddedToMulti.Contains(fromHdrRID))
                    {
                        _headersAddedToMulti.Add(fromHdrRID, multiHdrRID);
                    }

                    fromRow.RefreshSortPosition();

                }
                AddMultiSizeTables();

                multiHdrRow.Cells["ChildTotal"].Value = multiChildTotal;
                multiHdrRow.Cells["HdrQuantity"].Value = multiHdrTotal;
                multiHdrRow.Cells["SizeGroup"].Value = firstSizeGroup;
            
                multiHdrRow.ExpandAll();
                if (_sizesAutoAdded)
                {
                    UpdateAddedSizeRows(multiHdrRow);
                    _sizesAutoAdded = false;
                }

                this.ugDetails.Selected.Rows.Clear();
                UpdateSelectedTotals();
                SetEditActivation();
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                _creatingMulti = false;
                _skipQtyUpdate = false;  // TT#304 - RMatelic - Multi Header - made the multiple 10 received message "multiple cannot exceed units to allocate
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.ResumeRowSynchronization();
                //this.ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                Cursor.Current = Cursors.Default;
            }	

        }

        // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
        private bool HeaderSizesExist(int aHdrRID)
        {
            bool sizesExist = false;
            try
            {
                Header hd = new Header();
                if (hd.GetBulkColorSizesForHeader(aHdrRID).Rows.Count > 0)
                {
                    sizesExist = true;
                }
                else if (hd.GetPackColorSizesForHeader(aHdrRID).Rows.Count > 0)
                {
                    sizesExist = true;
                }
            }
            catch
            {
                throw;
            }
            return sizesExist;
        }

        private bool ChangeSizeGroupToNone(int aSizeGroupRID, int aHdrRID)
        {
            bool changeSizeGroup = false;
            try
            {
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(aHdrRID);
                ArrayList keys = new ArrayList();
                if (ap.BulkColors.Count > 0)
                {
                    foreach (HdrColorBin aColor in ap.BulkColors.Values)
                    {
                        if (aColor.ColorSizes.Count > 0)
                        {
                            foreach (HdrSizeBin hsb in aColor.ColorSizes.Values)
                            {
                                if (!keys.Contains(hsb.SizeKey))
                                {
                                    keys.Add(hsb.SizeKey);
                                }
                            }
                        }
                    }
                }

                if (ap.Packs.Count > 0)
                {
                    foreach (PackHdr aPack in ap.Packs.Values)
                    {
                        foreach (PackColorSize pcs in aPack.PackColors.Values)
                        {
                            if (pcs.ColorSizes.Count > 0)
                            {
                                foreach (PackContentBin pcb in pcs.ColorSizes.Values)
                                {
                                    if (!keys.Contains(pcb.ContentCodeRID))
                                    {
                                        keys.Add(pcb.ContentCodeRID);
                                    }
                                }
                            }
                        }
                    }
                }
                if (keys.Count > 0)
                {
                    bool allSizesFound = true;
                    SizeGroupProfile sgp = new SizeGroupProfile(aSizeGroupRID);
                    SizeCodeList scl = sgp.SizeCodeList;
                    foreach (int sizeKey in keys)
                    {
                        SizeCodeProfile scp = (SizeCodeProfile)scl.FindKey(sizeKey);
                        if (scp == null)
                        { 
                            allSizesFound = false;
                            break;
                        }
                    }
                    if (!allSizesFound)
                    {
                        changeSizeGroup = true;
                    }
                    _rebuildSizes = true;
                }
            }
            catch
            {
                throw;
            }
            return changeSizeGroup;
        }
        // End TT#234  

        private void cmsMultiRemove_Click(object sender, EventArgs e)
        {
            MultiRemove();
        }
        private void MultiRemove()
        {
            int hdrRID, hdrGroupRID, multiSizeGroup, multiHdrRID, multiHdrTotal, multiChildTotal;
            UltraGridRow multiHdrRow;
          
            try
            {
                if (this.ugDetails.Selected.Rows.Count == 0)
                {
                    if (_rClickRow != null && _rClickRow.Band.Key == "Header")
                    {
                        _rClickRow.Selected = true;
                    }
                    else
                    {
                        return;
                    }
                }
                Cursor.Current = Cursors.WaitCursor;
                _removingMulti = true;

                multiHdrRow = _multiHdrRow;

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.BeginUpdate();
                //this.ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
               
                multiHdrTotal = Convert.ToInt32(multiHdrRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                multiChildTotal = Convert.ToInt32(multiHdrRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);
                multiSizeGroup = Convert.ToInt32(multiHdrRow.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture);
                multiHdrRID = Convert.ToInt32(multiHdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

                //_headersRemovedFromMulti.Clear(); TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary) - unrelated

                foreach (UltraGridRow selRow in this.ugDetails.Selected.Rows)
                {
                    hdrRID = Convert.ToInt32(selRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    hdrGroupRID = Convert.ToInt32(selRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);

                    multiHdrTotal -= Convert.ToInt32(selRow.Cells["HdrQuantity"].Value, CultureInfo.CurrentUICulture);
                    multiChildTotal -= Convert.ToInt32(selRow.Cells["ChildTotal"].Value, CultureInfo.CurrentUICulture);

                    RemoveComponentsFromMulti(selRow, multiHdrRow);
                   
                    selRow.Cells["HdrGroupRID"].Value = DBNull.Value;
                    selRow.RefreshSortPosition();

                    if (!_headersRemovedFromMulti.Contains(hdrRID))
                    {
                        _headersRemovedFromMulti.Add(hdrRID, hdrGroupRID);
                    }
                }

                _skipQtyUpdate = true;  // TT#304 - RMatelic - Multi Header - made the multiple 10 received message "multiple cannot exceed units to allocate
                multiHdrRow.Cells["ChildTotal"].Value = multiChildTotal;
                multiHdrRow.Cells["HdrQuantity"].Value = multiHdrTotal;

                foreach (string bandKey in _deletedMultiBands)
                {
                    _dsDetails.Tables[bandKey].Constraints.Remove(bandKey);
                    _dsDetails.Relations.Remove(bandKey);
                    _dsDetails.Tables.Remove(bandKey);
                }

                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                ArrayList sizeGroups = new ArrayList(); 
                //if (multiSizeGroup != Include.UndefinedSizeGroupRID)
                //{
                    //bool firstRowFound = false;
                    //int newSizeGroup = 0;
                    UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                    {
                        while (row != null)
                        {
                            if (Convert.ToInt32(row.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader
                             && Convert.ToInt32(row.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture) == multiHdrRID)
                            {
                                int inUseSizeGroup = Convert.ToInt32(row.Cells["SizeGroup"].Value, CultureInfo.CurrentUICulture);
                                // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                //if (inUseSizeGroup == multiSizeGroup)
                                //{
                                //    newSizeGroup = 0;
                                //    break;
                                //}
                                //else if (inUseSizeGroup != Include.UndefinedSizeGroupRID && !firstRowFound)
                                //{
                                //    firstRowFound = true;
                                //    newSizeGroup = inUseSizeGroup;
                                //}
                                if (inUseSizeGroup != Include.UndefinedSizeGroupRID)
                                {
                                    if (!sizeGroups.Contains(inUseSizeGroup))
                                    {
                                        sizeGroups.Add(inUseSizeGroup);
                                    }
                                }
                                // End TT#234  
                            }
                            row = row.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                    // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                    //if (newSizeGroup != 0)
                    //{
                    //    _skipBeforeCellUpdate = true;
                    //    multiHdrRow.Cells["SizeGroup"].Value = newSizeGroup;
                    //}
                    int newSizeGroup = Include.UndefinedSizeGroupRID;
                    if (sizeGroups.Count > 0)
                    {
                        newSizeGroup = DetermineSizeGroup(sizeGroups);
                    }
                    if (newSizeGroup != multiSizeGroup)
                    {
                        _skipBeforeCellUpdate = true;
                        multiHdrRow.Cells["SizeGroup"].Value = newSizeGroup;
                    }
                    // End TT#234  
                //}    
                _dsDetails.AcceptChanges();
                multiHdrRow.RefreshSortPosition();

            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                _removingMulti = false;
                _skipQtyUpdate = false;  // TT#304 - RMatelic - Multi Header - made the multiple 10 received message "multiple cannot exceed units to allocate
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.ResumeRowSynchronization();
                //this.ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                Cursor.Current = Cursors.Default;
            }
        }

        private void RemoveComponentsFromMulti(UltraGridRow aRemovedRow, UltraGridRow aParentRow) 
		{
			UltraGridRow multiHdrRow;
			try 
			{
				multiHdrRow = aParentRow;
				UltraGridRow childRow = aRemovedRow.GetChild(ChildRow.First);  
				
				while (childRow != null)
				{ 
					string bandKey = childRow.Band.Key;
					switch (childRow.Band.Key)
					{
						case "Pack":
                            RemovePackFromMulti(multiHdrRow, childRow);
							break;

						case "BulkColor":
                            RemoveColorFromMulti(multiHdrRow, childRow);
                            if (_removingAssortment)
                            {
                                childRow.Cells["AsrtBCRID"].Value = Include.NoRID;
                                int hdrRID = Convert.ToInt32(childRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                                if (!_removedAsrtHeaders.Contains(hdrRID))
                                {
                                    _removedAsrtHeaders.Add(hdrRID);
                                }
                            }
							break;																										
					}
					 		
					childRow = childRow.GetSibling(SiblingRow.Next,true,false);
				}
			}
			catch  
			{
                throw;
			}
		}

        private void RemovePackFromMulti(UltraGridRow aMultiHdrRow, UltraGridRow aPackRow)
        {
            int multiHdrRID, removedPackRID;
            string removedPackName;
            try
            {
                multiHdrRID = Convert.ToInt32(aMultiHdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(multiHdrRID);

                removedPackRID = Convert.ToInt32(aPackRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);

                UltraGridRow multiPackRow = aMultiHdrRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["Pack"]);
                while (multiPackRow != null)
                {
                    int associatedPackRID = Convert.ToInt32(multiPackRow.Cells["AssociatedPackRID"].Value, CultureInfo.CurrentUICulture);
                    if (removedPackRID == associatedPackRID)
                    {
                        removedPackName = Convert.ToString(multiPackRow.Cells["Pack"].Value, CultureInfo.CurrentUICulture);

                        if (multiPackRow.HasChild(this.ugDetails.DisplayLayout.Bands["PackColor"], false))
                        {
                            UltraGridRow multiPCRow = multiPackRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                            UltraGridRow deleteRow = null;
                            while (multiPCRow != null)
                            {
                                if (deleteRow != null)
                                {
                                    deleteRow.Delete(false);
                                    deleteRow = null;
                                }
                                int packColorCodeRID = Convert.ToInt32(multiPCRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                                // BEGIN  MID Track #5654, #5655, #5657 - MultiHeader errors
                                //ap.RemovePackColor(removedPackName, packColorCodeRID);
                                // END MID Track #5654, #5655, #5657 
                                deleteRow = multiPCRow;
                                if (multiPCRow.HasChild())
                                {
                                    UltraGridRow sizeRow = multiPCRow.GetChild(ChildRow.First);
                                    string bandKey = sizeRow.Band.Key;
                                    if (!_deletedMultiBands.Contains(bandKey))
                                        _deletedMultiBands.Add(bandKey);

                                    while (sizeRow != null)
                                    {
                                        sizeRow.Delete(false);
                                        sizeRow = sizeRow.GetSibling(SiblingRow.Next, false, false);
                                    }
                                }
                                multiPCRow = multiPCRow.GetSibling(SiblingRow.Next, false, false);
                            }
                            if (deleteRow != null)
                            {
                                deleteRow.Delete(false);
                                deleteRow = null;
                            }
                        }
                        else if (multiPackRow.HasChild())
                        {
                            UltraGridRow sizeRow = multiPackRow.GetChild(ChildRow.First);
                            string bandKey = sizeRow.Band.Key;
                            if (!_deletedMultiBands.Contains(bandKey))
                                _deletedMultiBands.Add(bandKey);

                            while (sizeRow != null)
                            {
                                sizeRow.Delete(false);
                                sizeRow = sizeRow.GetSibling(SiblingRow.Next, false, false);
                            }
                        }
                        // BEGIN  MID Track #5654, #5655, #5657 - MultiHeader errors
                        //ap.RemovePack(removedPackName);
                        // END MID Track #5654, #5655, #5657 
                        multiPackRow.Delete(false);
                        break;
                    }
                    multiPackRow = multiPackRow.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch  
            {
                throw;
            }
        }

        private void RemoveColorFromMulti(UltraGridRow aMultiHdrRow, UltraGridRow aColorRow)
        {
            int multiHdrRID, removedRID, removedQty, multiChildQty;
            try
            {
                multiHdrRID = Convert.ToInt32(aMultiHdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(multiHdrRID);

                removedRID = Convert.ToInt32(aColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                removedQty = Convert.ToInt32(aColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
             
                UltraGridRow multiColorRow = aMultiHdrRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                while (multiColorRow != null)
                {
                    if (removedRID == Convert.ToInt32(multiColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture))
                    {
                        multiChildQty = Convert.ToInt32(multiColorRow.Cells["Quantity"].Value, CultureInfo.CurrentUICulture);
                        if (removedQty == multiChildQty)
                        {
                            // BEGIN MID Track #5654, #5655, #5657 - MultiHeader errors 
                            //ap.RemoveBulkColor(removedRID);
                            // END MID Track #5654, #5655, #5657
                            if (multiColorRow.HasChild())
                            {
                                UltraGridRow sizeRow = multiColorRow.GetChild(ChildRow.First);
                                string bandKey = sizeRow.Band.Key;
                                if (!_deletedMultiBands.Contains(bandKey))
                                    _deletedMultiBands.Add(bandKey);

                                while (sizeRow != null)
                                {
                                    sizeRow.Delete(false);
                                    sizeRow = sizeRow.GetSibling(SiblingRow.Next, false, false);
                                }
                            }
                            multiColorRow.Delete(false);
                        }
                        else
                        {
                            multiColorRow.Cells["Quantity"].Value = multiChildQty - removedQty;
                            if (multiColorRow.HasChild() && aColorRow.HasChild())
                            {
                                RemoveBulkSizes(multiColorRow, aColorRow, multiHdrRID);
                            }
                        }
                        break;
                    }
                    multiColorRow = multiColorRow.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch  
            {
                throw;
            }
        }

        private void RemoveBulkSizes(UltraGridRow aMultiColorRow, UltraGridRow aRemovedColorRow, int aMultiHdrRID)
        {
            string colName, sizetableName = string.Empty;
            int multHdrRID, removeQty, multiQty, removedSizeKey, multiSizeKey; 
            int removedHdrRID, removedColorRID, removedPrimaryRID;
            try
            {
                Hashtable deleteColumns = new Hashtable();
              
                multHdrRID = Convert.ToInt32(aMultiColorRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                removedHdrRID = Convert.ToInt32(aRemovedColorRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                removedColorRID = Convert.ToInt32(aRemovedColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                
                UltraGridRow removedSizeRow = aRemovedColorRow.GetChild(ChildRow.First);
                while (removedSizeRow != null)
                {
                    UltraGridRow multiSizeRow = aMultiColorRow.GetChild(ChildRow.First);
                    while (multiSizeRow != null)
                    {
                        string multiRowHeader = multiSizeRow.Cells["Secondary"].Value.ToString();
                        string removeRowHeader = removedSizeRow.Cells["Secondary"].Value.ToString();
                        // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                        //if (multiRowHeader == removeRowHeader)
                        int multiRowSecondaryRID = Convert.ToInt32(multiSizeRow.Cells["SecondaryRID"].Value, CultureInfo.CurrentUICulture);
                        int removedRowSecondaryRID = Convert.ToInt32(removedSizeRow.Cells["SecondaryRID"].Value, CultureInfo.CurrentUICulture);
                        if (multiRowSecondaryRID == removedRowSecondaryRID)
                        // End TT#234  
                        {
                            for (int i = 7; i < removedSizeRow.Cells.Count; i++)
                            {
                                colName = removedSizeRow.Cells[i].Column.Key.Trim();
                                removedSizeKey = Convert.ToInt32(removedSizeRow.Cells[i].Tag, CultureInfo.CurrentUICulture);
                              
                                for (int j = 7; j < multiSizeRow.Cells.Count; j++)
                                {
                                    multiSizeKey = Convert.ToInt32(multiSizeRow.Cells[j].Tag, CultureInfo.CurrentUICulture);
                                    if (multiSizeKey == removedSizeKey)
                                    {
                                        removeQty = Convert.ToInt32(removedSizeRow.Cells[i].Value, CultureInfo.CurrentUICulture);
                                        multiQty = Convert.ToInt32(multiSizeRow.Cells[j].Value, CultureInfo.CurrentUICulture);
                                    
                                        multiSizeRow.Cells[j].Value = multiQty - removeQty;
                                        
                                        if ((int)multiSizeRow.Cells[j].Value == 0)
                                        {
                                            removedPrimaryRID = Convert.ToInt32(removedSizeRow.Cells[i].Column.Tag, CultureInfo.CurrentUICulture);
                                            // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                            string removedColumnKey = Convert.ToString(removedSizeRow.Cells[i].Column.Key, CultureInfo.CurrentUICulture); 
                                            if (!ColumnStillInUse(aMultiHdrRID, removedHdrRID, removedColorRID, removedPrimaryRID, removedColumnKey))
                                            // End TT#234 
                                            {
                                                sizetableName = multiSizeRow.Band.Key;
                                                ArrayList deletedSizes;
                                                if (!deleteColumns.ContainsKey(removedPrimaryRID))
                                                {
                                                    deletedSizes = new ArrayList();
                                                    deletedSizes.Add(multiSizeKey);
                                                    deleteColumns.Add(removedPrimaryRID, deletedSizes);
                                                }
                                                else
                                                {
                                                    deletedSizes = (ArrayList)deleteColumns[removedPrimaryRID];
                                                    deletedSizes.Add(multiSizeKey);
                                                }
                                            }
                                            // Begin TT#234 - RMatelic - Error on multi Header when different size RIDs have the same column name(secondary)
                                            else
                                            {
                                                AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(multHdrRID);
                                                int[] sizeKeys = ap.GetBulkColorSizeCodeRIDs(removedColorRID);
                                                if (sizeKeys.Length > 0)
                                                {
                                                     for (int n = 0; n < sizeKeys.Length; n++)
                                                     {
                                                         if (sizeKeys[n] == multiSizeKey)
                                                        {
                                                            ap.RemoveBulkColorSize(removedColorRID, multiSizeKey);
                                                            break;
                                                        }
                                                     }
                                                }
                                            }
                                        }   // End TT#234  
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                        multiSizeRow = multiSizeRow.GetSibling(SiblingRow.Next, false, false);
                    }
                    removedSizeRow = removedSizeRow.GetSibling(SiblingRow.Next, false, false);
                }

                if (deleteColumns.Count > 0)   
                {                              
                    AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(multHdrRID);
                    DataTable multisizeTable =  _dsDetails.Tables[sizetableName];
                     
                    for (int k = multisizeTable.Columns.Count - 1; k >= 7; k--)
                    {
                        DataColumn dCol = multisizeTable.Columns[k];
                        int primaryRID = (int)dCol.ExtendedProperties["PrimaryRID"];
                        if (deleteColumns.ContainsKey(primaryRID))
                        {
                            //int[] sizeKeys = ap.GetBulkColorSizeKeys(removedColorRID); // Assortment: Color/Size changes
                            int[] sizeKeys = ap.GetBulkColorSizeCodeRIDs(removedColorRID); // Assortment: Color/Size changes

                            if (sizeKeys.Length > 0)
                            {
                                ArrayList deletedSizes = (ArrayList)deleteColumns[primaryRID];
                                foreach (int sizeRID in deletedSizes)
                                {
                                    for (int i = 0; i < sizeKeys.Length; i++)
                                    {
                                        if (sizeKeys[i] == sizeRID)
                                        {
                                            ap.RemoveBulkColorSize(removedColorRID, sizeRID);
                                            break;
                                        }   
                                    }    
                                }
                            }
                            multisizeTable.Columns.Remove(dCol);
                        }        
                    }
                }
            }
            catch  
            {
                throw;
            }
        }

        private bool ColumnStillInUse(int aMultiHDrRID, int aRemovedHdrRID, int aRemovedColorRID, int aColumnSizeRID, string aColumnKey)
        {
            bool sizeColumnFound = false;
            try
            {
                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null && !sizeColumnFound)
                {
                    if (Convert.ToInt32(row.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader
                     && Convert.ToInt32(row.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture) == aMultiHDrRID
                     && Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) != aRemovedHdrRID
                     && row.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                    {
                        UltraGridRow colorRow = row.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);
                        while (colorRow != null && !sizeColumnFound)
                        {
                            int colorRID = Convert.ToInt32(colorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);

                            if (colorRID == aRemovedColorRID)
                            {
                                if (colorRow.HasChild())
                                {
                                    UltraGridRow sizeRow = colorRow.GetChild(ChildRow.First);
                                    for (int i = 7; i < sizeRow.Cells.Count; i++)
                                    {
                                        if ((int)sizeRow.Cells[i].Column.Tag == aColumnSizeRID)
                                        {
                                            sizeColumnFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                        }
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
            return sizeColumnFound;
        }

        private void cmsExpand_Click(object sender, EventArgs e)
        {
            try
            {
                // Begin TT#805 - RMatelic - System out of memory exception
                //foreach (UltraGridRow row in ugDetails.Rows)
                //{
                //    row.ExpandAll();
                //}
                // Begin TT#2682 - RMatelic - Show Details of a header
                //for (int i = 0; i < ugDetails.DisplayLayout.RowScrollRegions[0].VisibleRows.Count; i++)
                //{
                //    ugDetails.DisplayLayout.RowScrollRegions[0].VisibleRows[i].Row.ExpandAll();
                //}
                // End TT#805  
                if (ugDetails.Rows.Count > 0)
                {
                    foreach (UltraGridRow row in ugDetails.Rows)
                    {
                        if (!row.Expanded)
                        {
                            row.ExpandAll();
                        }
                    }
                    this.btnExpandCollapse.Text = this.cmsCollapse.Text;    // Usability Enhancement
                    _expandAll = true;
                }
                // End TT#2682 - 
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void cmsCollapse_Click(object sender, EventArgs e)
        {
            try
            {
                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    // Begin TT#805 - RMatelic - System out of memory exception
                    //row.CollapseAll();
                    if (row.Expanded)
                    {
                        row.CollapseAll();
                    }    
                    // End TT#805 
                }
                this.btnExpandCollapse.Text = this.cmsExpand.Text;      // Usability Enhancement
                _expandAll = false;
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void cmsDetails_Click(object sender, EventArgs e)
        {
            try
            {
                if (_detailsShown)
                {
                    HideDetails();
                }
                else
                {
                    ShowDetails();
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        // Save and Edit context menu items are the same item
        private void cmsSave_Click(object sender, EventArgs e)
        {
            try
            {
                Cursor.Current = Cursors.WaitCursor;
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.BeginUpdate();
                //ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls

                if (_inEditMode)  // this is a Save  
                {
                    if (AllDataValid())
                    {
                        // Begin TT#1966-MD - JSmith - DC Fulfillment
                        bool bMasterHeaderDeleted = false;
                        //SaveChanges();
                        SaveChanges(ref bMasterHeaderDeleted);
                        // End TT#1966-MD - JSmith - DC Fulfillment
                        DequeueHeaders();
                        ResetGrids();
                        BindDetailsGrid();
                        if (_headerAdded)   // this may be temporary; HeaderServerSession doesn't
                        {                   // have newly added headers, so it needs to reload them   
                            this.RebuildHeaderCharacteristicData(); //TT#1170-MD -jsobek -Remove Binary database objects and normalize the Filter definitions
                            _headerAdded = false;
                        }
                        // Begin TT#1966-MD - JSmith - DC Fulfillment
                        else if (bMasterHeaderDeleted)
                        {
                            LoadHeadersOnGrid();
                        }
                        // End TT#1966-MD - JSmith - DC Fulfillment
                        _changesPending = false;    // MID Track #5501 - add 'Save Changes?' message
                        // BEGIN MID Track #5935 - Null Reference after creating header
                        //RemoveExcludedHeaders(); //TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS
                        // END MID Track #5935
                        ReselectPreviousSelections(); // MID Track #6264 - Headers not in priority order
                    }
                }
                else            // set up for editing
                {
                    SetEditMode();
                }
                SetActionListCombo();
                SetViewComboEnabled();
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.ResumeRowSynchronization();
                //ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                Cursor.Current = Cursors.Default;
            }
        }

        private void SetEditMode()
        {
            try
            {
                //ugDetails.BeginUpdate();
                _hdrsInGroups.Clear();
                int selectRID = 0;
                
                _headerAdded = false;
                if (!cmsAutoSelectGroup.Checked)
                {
                    foreach (UltraGridRow dRow in ugDetails.Rows)
                    {
                        // Begin TT#3620 - JSmith - Right Click - Add - Header receive system argument exception
                        if (dRow.Cells == null ||
                            dRow.Cells.Count == 0 ||
                            !RowHasKey(dRow, "HdrGroupRID"))
                        {
                            continue;
                        }
                        // End TT#3620 - JSmith - Right Click - Add - Header receive system argument exception

                        if (dRow.Cells["HdrGroupRID"].Value != System.DBNull.Value || dRow.Cells["AsrtRID"].Value != System.DBNull.Value)
                        {
                            if (dRow.Cells["HdrGroupRID"].Value != System.DBNull.Value)
                            {
                                selectRID = Convert.ToInt32(dRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);
                            }
                            else if (dRow.Cells["AsrtRID"].Value != System.DBNull.Value)
                            {
                                selectRID = Convert.ToInt32(dRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                            }
                            if (!_hdrsInGroups.Contains(selectRID))
                            {
                                _hdrsInGroups.Add(selectRID);
                            }
                        }
                    }
                }
                if (_hdrsInGroups.Count > 0)
                {
                    // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    //ugHeaders.BeginUpdate();
                    ugHeadersBeginUpdate();
                    // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    // RonM - undo following change put 'true' back in
                    cmsAutoSelectGroup.Checked = true;   // MID Track 6180 Auto Select Group default should be false
                    SetAutoGroupOnToolbar(true);
                    //cmsAutoSelectGroup.Checked = false;    // MID Track 6180 Auto Select Group default should be false
                    
                    UltraGridRow hRow = ugHeaders.GetRow(ChildRow.First);
                    while (hRow != null && _hdrsInGroups.Count > 0)
                    {
                        if (hRow.IsGroupByRow)
                        {
                            CheckHeaderGridGroupByRow(hRow);
                        }
                        else
                        {
                            CheckHeaderGridRow(hRow);
                        }
                        hRow = hRow.GetSibling(SiblingRow.Next, false, false);
                    }
                    cmsAutoSelectGroup.Checked = false;
                    SetAutoGroupOnToolbar(false);
                    // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                    //ugHeaders.EndUpdate();
                    ugHeadersEndUpdate();
                    // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                }

                //if (!_detailsShown)
                //{
                //    ShowDetails();
                //}
                if (ugDetails.Rows.Count > 0)
                {   
                    //if (!HeadersEnqueued(false))  // TT#1185 - Verify ENQ before Update 
                    if (!EnqueueHeadersForEdit())   // TT#1185 - Verify ENQ before Update
                    {
                        return;
                    }
                    ReloadDetailGridData();
                }

                _multiHeadersSaved = null;
                if (_multiHeaders.Rows.Count > 0)
                {
                    _multiHeadersSaved = _multiHeaders.Copy();
                }
                _assortmentsSaved = null;
                if (_assortments.Rows.Count > 0)
                {
                    _assortmentsSaved = _assortments.Copy();
                }
                _placeHoldersSaved = null;
                if (_placeHolders.Rows.Count > 0)
                {
                    _placeHoldersSaved = _placeHolders.Copy();
                }

                _anchorNodes.Clear();
                _removedAsrtHeaders.Clear();
                _deletedMultiBands.Clear();
                _headersRemovedFromMulti.Clear();  // TT#234 - RMatelic - unrelataed to TT
                //BEGIN MID Track 4449 error grouping when in edit mode; solution - disallow grouping 
                ugHeaders.DisplayLayout.Override.AllowGroupBy = DefaultableBoolean.False;
                //END MID Track 4449  

                ugHeaders.DisplayLayout.Override.SelectTypeRow = Infragistics.Win.UltraWinGrid.SelectType.ExtendedAutoDrag;
                ugDetails.DisplayLayout.Override.CellClickAction = Infragistics.Win.UltraWinGrid.CellClickAction.EditAndSelectText;
                _inEditMode = true;
                SetEditActivation();

                if (ugDetails.Rows.Count == 0)
                {
                    // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
					//_dsDetails.Clear();
                    if (_dsDetails != null)
                    {
                        _dsDetails.Clear();
                    }
                    else
                    {
                        CreateDetailDataSet();
                    }
                    // End TT#1434
                    BindDetailsGrid();
                }
                else
                {
                    if (ugDetails.Selected.Rows.Count > 0)
                    {
                        ugDetails.ActiveRow = ugDetails.Selected.Rows[0];
                    }
                    else
                    {
                        ugDetails.ActiveRow = ugDetails.Rows[0];
                    }    
                    ugDetails.ActiveCell = null;
                    for (int i = 3; i < ugDetails.ActiveRow.Cells.Count; i++)
                    {
                        UltraGridCell cell = ugDetails.ActiveRow.Cells[i];
                        if (!cell.Column.Hidden && cell.Column.CellActivation == Activation.AllowEdit)
                        {
                            ugDetails.ActiveCell = cell;
                            break;
                        }
                    }
                    ugDetails.PerformAction(Infragistics.Win.UltraWinGrid.UltraGridAction.EnterEditMode, false, false);
                }

                _deletedHeaderRows.Clear();
                _addedColorSizeHash.Clear();

                cmsSave.Text = MIDText.GetTextOnly(eMIDTextCode.lbl_Button_Save);
                cmsCancel.Visible = true;
                
                // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
                // BEGIN Usability Enhancement
                //btnEditSave.Text = cmsSave.Text;
                //btnCancel.Enabled = true;
                //btnHideDetails.Enabled = false;
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnEditSave"]).SharedProps.Caption = cmsSave.Text;
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnCancel"]).SharedProps.Enabled = true;
                ((Infragistics.Win.UltraWinToolbars.ButtonTool)this.detailToolbarsManager.Tools["btnHideDetails"]).SharedProps.Enabled = false;
                // End TT#1126-MD
                SetToolsMenuItem(false); 
                // END Usability Enhancement
              
                //ugDetails.EndUpdate();
                _inEditMode = true;
                // Begin TT#445 - RMatelic - allocation workspace error after save as selected on a Save As header; unrelated to specific error
                //SetFileSaveMenuItem(true);      // MID Track #5501 - File>Save not implemented
                SetFileSaveMenuItem(_allocationNonInterfacedHeadersSecurity.AllowUpdate);  
                // End TT#445 
                // Begin TT#445 - RMatelic - allocation workspace error after save as selected on a Save As header; unrelated to specific error
                //SetFileSaveMenuItem(true);      // MID Track #5501 - File>Save not implemented
                SetFileSaveMenuItem(_allocationNonInterfacedHeadersSecurity.AllowUpdate);  
                // End TT#445 
            }    
            catch
            {
                throw;
            }
        }

        // Begin TT#3620 - JSmith - Right Click - Add - Header receive system argument exception
        private bool RowHasKey (UltraGridRow aRow, string aKey)
        {
            try
            {
                object value = aRow.Cells[aKey].Value;
                return true;
            }
            catch
            {
                return false;
            }
        }

        private bool GridHasBand(UltraGrid aGrid, string aBand)
        {
            try
            {
                UltraGridBand ugb = aGrid.DisplayLayout.Bands[aBand];
                return true;
            }
            catch
            {
                return false;
            }
        }
        // End TT#3620 - JSmith - Right Click - Add - Header receive system argument exception

        // BEGIN MID Track #6264 related multi header error when grouped
        private void CheckHeaderGridGroupByRow(UltraGridRow aGroupByRow)
        {
            try
            {
                UltraGridRow childRow = aGroupByRow.GetChild(ChildRow.First);
                while (childRow != null)
                {
                    if (childRow.IsGroupByRow)
                    {
                        CheckHeaderGridGroupByRow(childRow);
                    }
                    else
                    {
                        CheckHeaderGridRow(childRow);
                    }
                    childRow = childRow.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void CheckHeaderGridRow(UltraGridRow aRow)
        {
            try
            {
                int selectRID = 0;
                //UltraGridRow childRow = aRow ;
               
                if (aRow.Cells["HdrGroupRID"].Value != System.DBNull.Value)
                {
                    selectRID = Convert.ToInt32(aRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);
                }
                else if (aRow.Cells["AsrtRID"].Value != System.DBNull.Value)
                {
                    selectRID = Convert.ToInt32(aRow.Cells["AsrtRID"].Value, CultureInfo.CurrentUICulture);
                }

                if (selectRID != 0 && _hdrsInGroups.Contains(selectRID))
                {
                    _hdrsInGroups.Remove(selectRID);
                    aRow.Selected = true;
                    // Begin TT#3620 - JSmith - Right Click - Add - Header receive system argument exception
                    // Begin TT#1080 - RMatelic - Created a header and upon saving it is not recognized in the headers Selected Window
                    //if (_afterSelectChangeEventArgs != null)
                    //{
                    //    AfterSelectChange(_sender, _afterSelectChangeEventArgs);
                    //}
                    // End TT1080
                    // End TT#3620 - JSmith - Right Click - Add - Header receive system argument exception
                }
            }
            catch
            {
                throw;
            }
        }
        // END MID Track #6264 related

        // BEGIN MID Track #5935 - Null Reference after creating header
        //  if a header is created which is excluded by the workspace filter, remove it from the 
        //   ugDetails grid since it is no longer within the filter parms 
        // BEGIN MID Track #6239 - Multis should not be split up; rewrite method; use Diff for previous code
        //Begin TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS
        //private void RemoveExcludedHeaders()
        //{
        //    try
        //    {
        //        if (this.ugDetails.Rows.Count == 0)
        //        {
        //            return;
        //        }

        //        int hdrRID;
        //        _multiGroupsIncludeAfterDateFilter.Clear();
        //        _multiGroupsIncludeAfterStyleFilter.Clear();
        //        ArrayList removeList = new ArrayList();
        //        foreach (UltraGridRow uRow in ugDetails.Rows)
        //        {
        //            hdrRID = Convert.ToInt32(uRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
        //            AllocationHeaderProfile ahp = _SAB.HeaderServerSession.GetHeaderData(hdrRID, false, false);
        //            if (ahp.Key == Include.NoRID)
        //            {
        //                removeList.Add(uRow);
        //            }
        //            else
        //            {
        //                HeaderType ht = (HeaderType)_allocWorkFilterProfile.SelectedTypes[(eHeaderType)Convert.ToInt32(uRow.Cells["Type"].Value, CultureInfo.CurrentUICulture)];
        //                if (!ht.IsDisplayed)
        //                {
        //                    removeList.Add(uRow);
        //                }
        //                else
        //                {
        //                    HeaderStatus hs = (HeaderStatus)_allocWorkFilterProfile.SelectedStatuses[(eHeaderAllocationStatus)Convert.ToInt32(uRow.Cells["Status"].Value, CultureInfo.CurrentUICulture)];
        //                    if (!hs.IsDisplayed)
        //                    {
        //                        removeList.Add(uRow);
        //                    }
        //                    else
        //                    {
        //                        if (Convert.ToInt32(uRow.Cells["Type"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderType.MultiHeader
        //                            || Convert.ToInt32(uRow.Cells["Status"].Value, CultureInfo.CurrentUICulture) == (int)eHeaderAllocationStatus.InUseByMultiHeader)
        //                        {
        //                            if (!HeaderDatesOkayMulti(uRow))
        //                            {
        //                                removeList.Add(uRow);
        //                            }
        //                            else if (!HeaderStyleOkayMulti(uRow))
        //                            {
        //                                removeList.Add(uRow);
        //                            }
        //                        }
        //                        else
        //                        {
        //                            if (!HeaderDatesOkay(uRow))
        //                            {
        //                                removeList.Add(uRow);
        //                            }
        //                            else if (!HeaderStyleOkay(uRow))
        //                            {
        //                                removeList.Add(uRow);
        //                            }
        //                        }
        //                    }
        //                }
        //            }    
        //        }
        //        _excludedHeadersRemoved = false;
        //        // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
        //        ArrayList alRemoveKeysList = new ArrayList();
        //        // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
        //        if (removeList.Count > 0)
        //        {
        //            string hdrIDs = string.Empty;
        //            foreach (UltraGridRow uRow in removeList)
        //            {
        //                // Begin TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header
        //                if (Convert.ToInt32(uRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == Include.NoRID)
        //                {
        //                    continue;
        //                }
        //                // End TT#687
        //                // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
        //                alRemoveKeysList.Add(Convert.ToInt32(uRow.Cells["KeyH"].Value));
        //                uRow.Selected = true;
        //                CheckForSelectedRemoval(uRow);
        //                // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
        //                if (hdrIDs == string.Empty)
        //                {
        //                    hdrIDs = uRow.Cells["HeaderID"].Value.ToString();
        //                }
        //                else
        //                {
        //                    hdrIDs += ", " + uRow.Cells["HeaderID"].Value.ToString();
        //                }
        //            }

        //            if (hdrIDs != string.Empty) // TT#687 - RMatelic - Multi Header upon Save the associated Receipt headers go to Recieved in Balance Status should be In Use by Multi Header
        //            {
        //                string message = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_HeadersExcludedByFilter), hdrIDs);
        //                MessageBox.Show(message, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Information);
        //            }
        //            _rClickRow = null;
        //            ugDetails.Selected.Rows.Clear();
        //            // Begin TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
        //            //foreach (UltraGridRow uRow in removeList)
        //            //{
        //            //    uRow.Selected = true;
        //            //    CheckForSelectedRemoval(uRow);      // MID Track #6264  
        //            //    if (uRow.Cells["HeaderRow"].Value != System.DBNull.Value)
        //            //    {
        //            //        IEnumerable enumerator = ugHeaders.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
        //            //        foreach (UltraGridRow row in enumerator)
        //            //        {
        //            //            if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) ==
        //            //                Convert.ToInt32(uRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture))
        //            //            {
        //            //                _excludedHeadersRemoved = true;
        //            //                row.Delete(false);
        //            //                break;
        //            //            }
        //            //        }

        //            //        uRow.Cells["HeaderRow"].Value = System.DBNull.Value;
        //            //    }
        //            //}
        //            foreach (int key in alRemoveKeysList)
        //            {
        //                IEnumerable enumerator = ugHeaders.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
        //                foreach (UltraGridRow row in enumerator)
        //                {
        //                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == key)
        //                    {
        //                        _excludedHeadersRemoved = true;
        //                        row.Delete(false);
        //                        break;
        //                    }
        //                }

        //            }
        //            // End TT#540-MD - JSmith - Multi Header Creation receive a system argument exception.
        //            cmsRemove_Click(null, null);
        //        }
        //    }
        //    catch
        //    {
        //        throw;
        //    }
        //}
        //End TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS

        //Begin TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS
        //private bool HeaderDatesOkayMulti(UltraGridRow aRow)
        //{
        //    bool multiOkay = false;
        //    Hashtable multiHeaderListHash;
        //    try
        //    {
        //        int hdrGroupRID = Convert.ToInt32(aRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);
               
        //        if (_multiGroupsIncludeAfterDateFilter.ContainsKey(hdrGroupRID))
        //        {
        //            multiOkay = (bool)_multiGroupsIncludeAfterDateFilter[hdrGroupRID];
        //        }
        //        else if (_multiHeaderGroups.ContainsKey(hdrGroupRID))
        //        {
        //            multiHeaderListHash = (Hashtable)_multiHeaderGroups[hdrGroupRID];
        //            foreach (UltraGridRow row in multiHeaderListHash.Values)
        //            {
        //                if (HeaderDatesOkay(row))
        //                {
        //                    multiOkay = true;
        //                    break;
        //                }
        //            }
        //            _multiGroupsIncludeAfterDateFilter.Add(hdrGroupRID, multiOkay);
        //        }
        //    }
        //    catch
        //    {
        //        throw;
        //    }
        //    return multiOkay;
        //}
        //End TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS

        //Begin TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS
        //private bool HeaderStyleOkayMulti(UltraGridRow aRow)
        //{
        //    bool multiOkay = false;
        //    Hashtable multiHeaderListHash;
        //    try
        //    {
        //        int hdrGroupRID = Convert.ToInt32(aRow.Cells["HdrGroupRID"].Value, CultureInfo.CurrentUICulture);
        //        int hdrRID = Convert.ToInt32(aRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);

        //        if (_multiGroupsIncludeAfterStyleFilter.ContainsKey(hdrGroupRID))
        //        {
        //            multiOkay = (bool)_multiGroupsIncludeAfterStyleFilter[hdrGroupRID];
        //        }
        //        else if (_multiHeaderGroups.ContainsKey(hdrGroupRID))
        //        {
        //            multiHeaderListHash = (Hashtable)_multiHeaderGroups[hdrGroupRID];
        //            foreach (UltraGridRow row in multiHeaderListHash.Values)
        //            {
        //                if (HeaderStyleOkay(row))
        //                {
        //                    multiOkay = true;
        //                    break;
        //                }
        //            }
        //            _multiGroupsIncludeAfterStyleFilter.Add(hdrGroupRID, multiOkay);
        //        }
        //    }
        //    catch
        //    {
        //        throw;
        //    }
        //    return multiOkay;
        //}
        //End TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS

        //Begin TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS
        //private bool HeaderDatesOkay(UltraGridRow aRow)
        //{
        //    bool datesOkay = true;
        //    //Hashtable multiHeaderListHash;
        //    DateTime headerDate, releaseDate;
        //    string releaseDateStr;
        //    try
        //    {
        //        headerDate = Convert.ToDateTime(aRow.Cells["Date"].Value, CultureInfo.CurrentUICulture);

        //        releaseDateStr = Convert.ToString(aRow.Cells["Release"].Value, CultureInfo.CurrentUICulture);
        //        if (releaseDateStr == null || releaseDateStr == string.Empty)
        //        {
        //            releaseDate = Include.UndefinedDate;
        //        }
        //        else
        //        {
        //            releaseDate = Convert.ToDateTime(releaseDateStr, CultureInfo.CurrentUICulture);
        //        }

        //        switch (_allocWorkFilterProfile.HeaderDateType)
        //        {
        //            case eFilterDateType.all:
        //                break;

        //            case eFilterDateType.today:
        //                if (headerDate.Date != DateTime.Today.Date)
        //                {
        //                    datesOkay = false;
        //                }
        //                break;

        //            case eFilterDateType.specify:
        //                if (headerDate.Date < _allocWorkFilterProfile.HeaderDateFrom.Date ||
        //                    headerDate.Date > _allocWorkFilterProfile.HeaderDateTo.Date)
        //                {
        //                    datesOkay = false;
        //                }
        //                break;

        //            case eFilterDateType.between:
        //                if (headerDate.Date < DateTime.Today.Date.Add(new TimeSpan(_allocWorkFilterProfile.HeaderDateBetweenFrom, 0, 0, 0, 0)) ||
        //                    headerDate.Date > DateTime.Today.Date.Add(new TimeSpan(_allocWorkFilterProfile.HeaderDateBetweenTo, 0, 0, 0, 0)))
        //                {
        //                    datesOkay = false;
        //                }
        //                break;
        //        }

        //        if (datesOkay && releaseDate != Include.UndefinedDate)
        //        {
        //            switch (_allocWorkFilterProfile.ReleaseDateType)
        //            {
        //                case eFilterDateType.all:
        //                    break;

        //                case eFilterDateType.today:
        //                    if (releaseDate.Date != DateTime.Today.Date)
        //                    {
        //                        datesOkay = false;
        //                    }
        //                    break;

        //                case eFilterDateType.specify:
        //                    if (releaseDate.Date < _allocWorkFilterProfile.ReleaseDateFrom.Date ||
        //                        releaseDate.Date > _allocWorkFilterProfile.ReleaseDateTo.Date)
        //                    {
        //                        datesOkay = false;
        //                    }
        //                    break;

        //                case eFilterDateType.between:
        //                    if (releaseDate.Date < DateTime.Today.Date.Add(new TimeSpan(_allocWorkFilterProfile.ReleaseDateBetweenFrom, 0, 0, 0, 0)) ||
        //                        releaseDate.Date > DateTime.Today.Date.Add(new TimeSpan(_allocWorkFilterProfile.ReleaseDateBetweenTo, 0, 0, 0, 0)))
        //                    {
        //                        datesOkay = false;
        //                    }
        //                    break;
        //            }
        //        }
        //    }
        //    catch
        //    {
        //        throw;
        //    }
        //    return datesOkay;
        //}
        //End TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS

        //Begin TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS
        //private bool HeaderStyleOkay(UltraGridRow aRow)
        //{
        //    bool styleOkay = true;
        //    try
        //    {
        //        if (_allocWorkFilterProfile.HnRID != Include.NoRID)
        //        {
        //            HierarchyNodeProfile filterHnp = _SAB.HierarchyServerSession.GetNodeData(_allocWorkFilterProfile.HnRID);
        //            if (filterHnp.NodeLevel == 0 && filterHnp.HomeHierarchyType == eHierarchyType.organizational)
        //            {
        //                // do nothing; top main hierarchy node same as no node specified 
        //            }
        //            else
        //            {
        //                int styleHnRID = Convert.ToInt32(aRow.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
        //                // Begin TT#1612 - RMatelic - Multi-header error 
        //                //HierarchyNodeProfile styleHnp = _SAB.HierarchyServerSession.GetNodeData(styleHnRID); >>> not used
        //                //NodeAncestorList nal = _SAB.HierarchyServerSession.GetNodeAncestorList(styleHnRID, filterHnp.HierarchyRID);
        //                // Begin Modify TT#1612 after discovering a failed scenario - eliminate 'if...' condition and search all hierarchies
        //                //NodeAncestorList nal;
        //                //if (filterHnp.HomeHierarchyType == eHierarchyType.alternate)
        //                //{
        //                //    nal = _SAB.HierarchyServerSession.GetNodeAncestorList(styleHnRID, filterHnp.HierarchyRID, eHierarchySearchType.AlternateHierarchiesOnly);
        //                //}
        //                //else
        //                //{
        //                //    nal = _SAB.HierarchyServerSession.GetNodeAncestorList(styleHnRID, filterHnp.HierarchyRID, eHierarchySearchType.HomeHierarchyOnly);
        //                //}
        //                // End TT#1612
        //                NodeAncestorList nal = _SAB.HierarchyServerSession.GetNodeAncestorList(styleHnRID, filterHnp.HierarchyRID, eHierarchySearchType.AllHierarchies);
        //                // End Modify TT#1612
        //                if (!nal.Contains(_allocWorkFilterProfile.HnRID))
        //                {
        //                    styleOkay = false;
        //                }
        //            }
        //        }     
        //    }
        //    catch
        //    {
        //        throw;
        //    }
        //    return styleOkay;
        //}
        //End TT#1313-MD -jsobek -Header Filters -do not re-filter in the AWS
        // END MID Track #6239
        // END MID Track #5935

        // Reread the headers to get most current data
        private void ReloadDetailGridData()
        {
            try
            {
                DataSet ds = MIDEnvironment.CreateDataSet();
                DataSet dsGrid = MIDEnvironment.CreateDataSet();
                int hdrRID;  
                foreach (UltraGridRow uRow in ugDetails.Rows)
                {
                    hdrRID = Convert.ToInt32(uRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    // Begin TT#587-MD - RMatelic - Pressing the "edit" button for a Workup Total Buy in the Allocation Workspace throws an Argument Exception
                    //ReloadProfileToGrid(hdrRID);
                    eHeaderType headerType = (eHeaderType)Convert.ToInt32(uRow.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (headerType == eHeaderType.WorkupTotalBuy)
                    {
                        ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, false);
                        AfterSelectChangeEventArgs args = _afterSelectChangeEventArgs;
                        _afterSelectChangeEventArgs = null;
                        ReloadProfileToGrid(hdrRID);
                        ugHeaders.EventManager.SetEnabled(GridEventIds.AfterSelectChange, true);
                        _afterSelectChangeEventArgs = args;
                    }
                    else
                    {
                        ReloadProfileToGrid(hdrRID);
                    }
                    // End TT#587-MD

                    DataRow headerRow = _dsDetails.Tables["Header"].Rows.Find(hdrRID);
                    AllocationHeaderProfile ahp = _SAB.HeaderServerSession.GetHeaderData(hdrRID, aIncludeComponents: false, aIncludeCharacteristics: true, blForceGet: false);
                    AddCharacteristicsToHeader(headerRow, ahp.Characteristics, true);

                    UltraGridRow headerGridRow = (UltraGridRow)uRow.Cells["HeaderRow"].Value;
                    // BEGIN MID Track #5732 - Workspace add header error - when top grid is empty & 1st row is added,
                    //                         headerGridRow doesn't have any Cells for some reason               
                    if (headerGridRow.Cells.Count == 0)
                    {
                        IEnumerable enumerator = ugHeaders.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
                        foreach (UltraGridRow hRow in enumerator)
                        {
                            if (Convert.ToInt32(hRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == hdrRID)
                            {
                                headerGridRow = hRow;
                                break;
                            }
                        }
                    }
                    // END MID Track #5732
                    ds = BuildComponentData(headerGridRow);
                    dsGrid.Merge(ds, true);
                }
             
                _dsDetails.Clear();
                _dsDetails = dsGrid.Copy();
           
                BindDetailsGrid();

                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                //_dsDetailsSaved = null;
                ClearSavedDetails();
                // End TT#1434
                _dsDetailsSaved = _dsDetails.Copy();

                if (_expandAll)
                {
                    cmsExpand_Click(cmsExpand, null);
                }
            }
            catch
            {
                throw;
            }
        }

        private void SetEditActivation()
        {
            try
            {
                // Begin TT#863 - RMatelic - Allocation Workspace-cannot add header, fields appear to be locked from entry
                foreach (UltraGridBand band in ugDetails.DisplayLayout.Bands)
                {
                    SetEditInitialization(band);
                }
                // End TT#863

                foreach (UltraGridRow uRow in ugDetails.Rows)
                {
                    SetEditActivation(uRow);
                }
            }
            catch
            {
                throw;
            }
        }

        // Begin TT#863 - RMatelic - Allocation Workspace-cannot add header, fields appear to be locked from entry
        private void SetEditInitialization(UltraGridBand aBand)
        {
            try
            { 
                string[] bandKeyParts = aBand.Key.Split(new char[] { '~' });

                switch (bandKeyParts[0])
                {
                    case "Header":
                        SetEditInitializationHeaderBand(aBand);
                        break;

                    case "BulkColor":
                    case "Pack":
                    case "PackColor":
                        foreach (Infragistics.Win.UltraWinGrid.UltraGridColumn column in aBand.Columns)
                        {
                            if (!column.Hidden && column.CellActivation != Activation.Disabled)
                            {
                                column.CellActivation = Activation.AllowEdit;
                            }
                        }
                        break;

                    case "BulkSize":
                    case "PackSize":
                    case "PackColorSize":
                        foreach (Infragistics.Win.UltraWinGrid.UltraGridColumn column in aBand.Columns)
                        {
                            if (!column.Hidden && column.CellActivation != Activation.Disabled && column.Key != " - ")
                            {
                                column.CellActivation = Activation.AllowEdit;
                            }
                        }
                        break;
                }
            }
            catch
            {
                throw;
            }
        }

        private void SetEditInitializationHeaderBand(UltraGridBand aBand)
        {
            try
            {
                foreach (Infragistics.Win.UltraWinGrid.UltraGridColumn column in aBand.Columns)
                {
                    if (!column.Hidden && column.CellActivation != Activation.Disabled)
                    {
                        if (_headerEditColumns.Contains(column.Key) || (column.Tag != null && column.Tag.GetType() == typeof(HeaderCharGroupProfile)))
                        {
                           column.CellActivation = Activation.AllowEdit;
                        }
                    }
                }               
            }
            catch
            {
                throw;
            }
        }
        // End TT#863

        private void SetEditActivation(UltraGridRow row) 
        {
            bool allowHeaderUpdate = false;
            bool isMultiHeader = false;
            bool isInAssortment = false;
            bool allocationStarted;
            bool workUpTotalBuy; 
            bool allowChildUpdate = true;
            //int styleRID;
            AllocationProfile ap = null;
            try
            {
                ap = (AllocationProfile)_allocProfileList.FindKey(Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
               
                eHeaderAllocationStatus headerStatus = (eHeaderAllocationStatus)Convert.ToInt32(row.Cells["Status"].Value, CultureInfo.CurrentUICulture);
                eHeaderType headerType = (eHeaderType)Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture); 
                allocationStarted = ap.AllocationStarted;
                workUpTotalBuy = ap.WorkUpTotalBuy;
                // Begin TT#4149 - JSmith - Multi-Header Creation Error
                //eHeaderIntransitStatus intransitStatus = (eHeaderIntransitStatus)Convert.ToInt32(row.Cells["Intransit"].Value, CultureInfo.CurrentUICulture);  // TT#5047 - jsmith - Units Per Carton / Multiple Check
                eHeaderIntransitStatus intransitStatus = eHeaderIntransitStatus.NotIntransit;
                if (row.Cells["Intransit"].Value != System.DBNull.Value)
                {
                    intransitStatus = (eHeaderIntransitStatus)Convert.ToInt32(row.Cells["Intransit"].Value, CultureInfo.CurrentUICulture);  // TT#5047 - jsmith - Units Per Carton / Multiple Check
                }
                // End TT#4149 - JSmith - Multi-Header Creation Error

                // Begin TT#2 Ron Matelic - Assortment Planning
                //if (row.Cells["AsrtRID"].Value != System.DBNull.Value)
                //{
                //    return;
                //}
                // End TT#2 
                allowHeaderUpdate = CheckHeaderAllowUpdate(row);

                row.Activation = Activation.AllowEdit;
                row.Cells["HeaderID"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                switch (headerStatus)
                {
                    case eHeaderAllocationStatus.AllInBalance:
                    case eHeaderAllocationStatus.AllocatedInBalance:
                    case eHeaderAllocationStatus.AllocatedOutOfBalance:
                    case eHeaderAllocationStatus.PartialSizeInBalance:
                    case eHeaderAllocationStatus.PartialSizeOutOfBalance:
                    case eHeaderAllocationStatus.SizesOutOfBalance:
                    case eHeaderAllocationStatus.ReleaseApproved:
                    case eHeaderAllocationStatus.Released:
                    case eHeaderAllocationStatus.InUseByMultiHeader:

                        row.Cells["HeaderID"].Activation = Activation.ActivateOnly;
                        row.Cells["HeaderID"].Appearance.ForeColor = row.Cells["HeaderID"].Appearance.ForeColorDisabled;
                        row.Cells["Type"].Activation = Activation.NoEdit;
                        row.Cells["Date"].Activation = Activation.NoEdit;
                        row.Cells["AnchorNode"].Activation = Activation.NoEdit;
                        row.Cells["Product"].Activation = Activation.NoEdit;
                        row.Cells["Style"].Activation = Activation.NoEdit;
                        row.Cells["Description"].Activation = Activation.NoEdit;
                        row.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                        row.Cells["UnitRetail"].Activation = Activation.NoEdit;
                        row.Cells["UnitCost"].Activation = Activation.NoEdit;
                        row.Cells["SizeGroup"].Activation = Activation.NoEdit;
                        row.Cells["Multiple"].Activation = Activation.NoEdit;
                        row.Cells["PO"].Activation = Activation.NoEdit;
                        row.Cells["Vendor"].Activation = Activation.NoEdit;
                        row.Cells["Workflow"].Activation = Activation.NoEdit;
                        row.Cells["DC"].Activation = Activation.NoEdit;
						row.Cells["ImoId"].Activation = Activation.NoEdit;	// TT#1401 - stodd - VSW (IMO)
                        row.Cells["AdjustVSW"].Activation = Activation.NoEdit; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
						// Begin TT#4729 - stodd - Request to Allow Updates to Units Per Carton
                        // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                        //row.Cells["UnitsPerCarton"].IgnoreRowColActivation = true;
                        //row.Cells["UnitsPerCarton"].Activation = Activation.AllowEdit; // TT#1652-MD - RMatelic- DC Carton Rounding 
                        SetUnitsPerCartonActivation(row, headerType, headerStatus, intransitStatus);
                        // End TT#5047 - jsmith - Units Per Carton / Multiple Check
						// End TT#4729 - stodd - Request to Allow Updates to Units Per Carton
                        break;

                    default:
                        if (headerType != eHeaderType.Assortment && headerType != eHeaderType.Placeholder
                            && row.Cells["AsrtRID"].Value != DBNull.Value)    // this is a real header in an Assorment
                        {
                            isInAssortment = true;
                            row.Cells["HeaderID"].Activation = Activation.ActivateOnly;
                            row.Cells["HeaderID"].Appearance.ForeColor = row.Cells["HeaderID"].Appearance.ForeColorDisabled;
                            SetNotesCellButton(row); 
                            row.Cells["Type"].Activation = Activation.NoEdit;
                            row.Cells["Date"].Activation = Activation.NoEdit;
                            row.Cells["AnchorNode"].Activation = Activation.NoEdit;
                            row.Cells["Product"].Activation = Activation.NoEdit;
                            row.Cells["Style"].Activation = Activation.NoEdit;
                            row.Cells["Description"].Activation = Activation.NoEdit;
                            row.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                            row.Cells["UnitRetail"].Activation = Activation.NoEdit;
                            row.Cells["UnitCost"].Activation = Activation.NoEdit;
                            row.Cells["SizeGroup"].Activation = Activation.NoEdit;
                            row.Cells["Multiple"].Activation = Activation.NoEdit;
                            row.Cells["PO"].Activation = Activation.NoEdit;
                            row.Cells["Vendor"].Activation = Activation.NoEdit;
                            row.Cells["Workflow"].Activation = Activation.NoEdit;
                            row.Cells["DC"].Activation = Activation.NoEdit;
							row.Cells["ImoId"].Activation = Activation.NoEdit;	// TT#1401 - stodd - VSW (IMO)
                            row.Cells["AdjustVSW"].Activation = Activation.NoEdit; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
							// Begin TT#4729 - stodd - Request to Allow Updates to Units Per Carton
                            // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                            //row.Cells["UnitsPerCarton"].IgnoreRowColActivation = true;
                            //row.Cells["UnitsPerCarton"].Activation = Activation.AllowEdit; // TT#1652-MD - RMatelic- DC Carton Rounding 
                            SetUnitsPerCartonActivation(row, headerType, headerStatus, intransitStatus);
                            // End TT#5047 - jsmith - Units Per Carton / Multiple Check
							// End TT#4729 - stodd - Request to Allow Updates to Units Per Carton
                        }
                        else if (!allowHeaderUpdate)
                        {
                            row.Cells["HeaderID"].Activation = Activation.ActivateOnly;
                            row.Cells["HeaderID"].Appearance.ForeColor = row.Cells["HeaderID"].Appearance.ForeColorDisabled;
                            row.Cells["Type"].Activation = Activation.NoEdit;
                            row.Cells["Date"].Activation = Activation.NoEdit;
                            row.Cells["AnchorNode"].Activation = Activation.NoEdit;
                            row.Cells["Product"].Activation = Activation.NoEdit;
                            row.Cells["Style"].Activation = Activation.NoEdit;
                            row.Cells["Description"].Activation = Activation.NoEdit;
                            row.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                            row.Cells["UnitRetail"].Activation = Activation.NoEdit;
                            row.Cells["UnitCost"].Activation = Activation.NoEdit;
                            row.Cells["PO"].Activation = Activation.NoEdit;
                            row.Cells["Vendor"].Activation = Activation.NoEdit;
                            row.Cells["Workflow"].Activation = Activation.NoEdit;
                            row.Cells["DC"].Activation = Activation.NoEdit;
                            // Begin TT#283 - RMatelic - Allow Multiple and Size Group fields to be maintainable without regards to security
                            //if (!_allocationInterfacedHeadersSecurity.AllowUpdate)
                            //{
                            //    row.Cells["SizeGroup"].Activation = Activation.NoEdit;
                            //    row.Cells["Multiple"].Activation = Activation.NoEdit;
                            //}
                            //else
                            //{
                                row.Cells["SizeGroup"].Activation = Activation.AllowEdit;
                                row.Cells["Multiple"].Activation = Activation.AllowEdit;
                            //}
							row.Cells["ImoId"].Activation = Activation.NoEdit;	// TT#1401 - stodd - VSW (IMO)
                            row.Cells["AdjustVSW"].Activation = Activation.NoEdit; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                            // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                            //row.Cells["UnitsPerCarton"].IgnoreRowColActivation = true; 
                            //row.Cells["UnitsPerCarton"].Activation = Activation.AllowEdit;
                            SetUnitsPerCartonActivation(row, headerType, headerStatus, intransitStatus);
                            // End TT#5047 - jsmith - Units Per Carton / Multiple Check
                        }   // End TT#283
                        else  
                        {
                            // BEGIN TT#1966-MD - AGallagher - DC Fulfillment
                            if (ap.IsMasterHeader)
                            {
                                row.Cells["HeaderID"].Activation = Activation.AllowEdit;
                                row.Cells["HeaderID"].Appearance.ResetForeColor();
                                row.Cells["Type"].Activation = Activation.NoEdit;
                                row.Cells["Date"].Activation = Activation.NoEdit;
                                row.Cells["AnchorNode"].Activation = Activation.NoEdit;
                                row.Cells["Product"].Activation = Activation.NoEdit;
                                row.Cells["Style"].Activation = Activation.NoEdit;
                                row.Cells["Description"].Activation = Activation.NoEdit;
                                row.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                                row.Cells["UnitRetail"].Activation = Activation.NoEdit;
                                row.Cells["UnitCost"].Activation = Activation.NoEdit;
                                row.Cells["PO"].Activation = Activation.NoEdit;
                                row.Cells["Vendor"].Activation = Activation.NoEdit;
                                row.Cells["Workflow"].Activation = Activation.NoEdit;
                                row.Cells["DC"].Activation = Activation.NoEdit;
                                // Begin TT#283 - RMatelic - Allow Multiple and Size Group fields to be maintainable without regards to security
                                //row.Cells["SizeGroup"].Activation = Activation.NoEdit;
                                //row.Cells["Multiple"].Activation = Activation.NoEdit;
                                row.Cells["SizeGroup"].Activation = Activation.AllowEdit;
                                row.Cells["Multiple"].Activation = Activation.AllowEdit;
                                // End TT#283
                                row.Cells["ImoId"].Activation = Activation.NoEdit;	// TT#1401 - stodd - VSW (IMO)
                                row.Cells["AdjustVSW"].Activation = Activation.NoEdit; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                                // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                                //row.Cells["UnitsPerCarton"].Activation = Activation.NoEdit; // TT#1652-MD - RMatelic- DC Carton Rounding 
                                SetUnitsPerCartonActivation(row, headerType, headerStatus, intransitStatus);
                                // End TT#5047 - jsmith - Units Per Carton / Multiple Check
                                break;
                            }
                            else
                                // END TT#1966-MD - AGallagher - DC Fulfillment
                                switch (headerType)
                                {
                                    case eHeaderType.MultiHeader:
                                        isMultiHeader = true;
                                        row.Cells["HeaderID"].Activation = Activation.AllowEdit;
                                        row.Cells["HeaderID"].Appearance.ResetForeColor();
                                        row.Cells["Type"].Activation = Activation.NoEdit;
                                        row.Cells["Date"].Activation = Activation.NoEdit;
                                        row.Cells["AnchorNode"].Activation = Activation.NoEdit;
                                        row.Cells["Product"].Activation = Activation.AllowEdit;
                                        row.Cells["Style"].Activation = Activation.AllowEdit;
                                        row.Cells["Description"].Activation = Activation.AllowEdit;
                                        row.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                                        row.Cells["UnitRetail"].Activation = Activation.NoEdit;
                                        row.Cells["UnitCost"].Activation = Activation.NoEdit;
                                        row.Cells["PO"].Activation = Activation.NoEdit;
                                        row.Cells["Vendor"].Activation = Activation.NoEdit;
                                        row.Cells["Workflow"].Activation = Activation.NoEdit;
                                        row.Cells["DC"].Activation = Activation.NoEdit;
                                        // Begin TT#283 - RMatelic - Allow Multiple and Size Group fields to be maintainable without regards to security
                                        //row.Cells["SizeGroup"].Activation = Activation.NoEdit;
                                        //row.Cells["Multiple"].Activation = Activation.NoEdit;
                                        row.Cells["SizeGroup"].Activation = Activation.AllowEdit;
                                        row.Cells["Multiple"].Activation = Activation.AllowEdit;
                                        // End TT#283
                                        row.Cells["ImoId"].Activation = Activation.NoEdit;	// TT#1401 - stodd - VSW (IMO)
                                        row.Cells["AdjustVSW"].Activation = Activation.NoEdit; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                                        // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                                        //row.Cells["UnitsPerCarton"].Activation = Activation.NoEdit; // TT#1652-MD - RMatelic- DC Carton Rounding 
                                        SetUnitsPerCartonActivation(row, headerType, headerStatus, intransitStatus);
                                        // End TT#5047 - jsmith - Units Per Carton / Multiple Check
                                        break;

                                    case eHeaderType.Assortment:
                                        row.Cells["HeaderID"].Activation = Activation.AllowEdit;
                                        row.Cells["HeaderID"].Appearance.ResetForeColor();
                                        row.Cells["Type"].Activation = Activation.NoEdit;
                                        row.Cells["Date"].Activation = Activation.NoEdit;
                                        row.Cells["AnchorNode"].Activation = Activation.AllowEdit;
                                        row.Cells["Product"].Activation = Activation.NoEdit;
                                        row.Cells["Style"].Activation = Activation.NoEdit;
                                        row.Cells["Description"].Activation = Activation.AllowEdit;
                                        row.Cells["HdrQuantity"].Activation = Activation.AllowEdit;
                                        row.Cells["UnitRetail"].Activation = Activation.NoEdit;
                                        row.Cells["UnitCost"].Activation = Activation.NoEdit;
                                        row.Cells["PO"].Activation = Activation.AllowEdit;
                                        row.Cells["Vendor"].Activation = Activation.AllowEdit;
                                        row.Cells["Workflow"].Activation = Activation.NoEdit;
                                        row.Cells["DC"].Activation = Activation.AllowEdit;
                                        row.Cells["SizeGroup"].Activation = Activation.AllowEdit;
                                        row.Cells["Multiple"].Activation = Activation.AllowEdit;
                                        row.Cells["ImoId"].Activation = Activation.NoEdit;	// TT#1401 - stodd - VSW (IMO)
                                        row.Cells["AdjustVSW"].Activation = Activation.NoEdit; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                                        // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                                        //row.Cells["UnitsPerCarton"].Activation = Activation.NoEdit; // TT#1652-MD - RMatelic- DC Carton Rounding 
                                        SetUnitsPerCartonActivation(row, headerType, headerStatus, intransitStatus);
                                        // End TT#5047 - jsmith - Units Per Carton / Multiple Check
                                        break;

                                    case eHeaderType.Placeholder:
                                        row.Cells["HeaderID"].Activation = Activation.NoEdit;
                                        row.Cells["HeaderID"].Appearance.ForeColor = row.Band.Layout.Override.FixedCellAppearance.BackColor;
                                        SetNotesCellButton(row);
                                        row.Cells["Type"].Activation = Activation.NoEdit;
                                        row.Cells["Date"].Activation = Activation.NoEdit;
                                        // Begin TT#2 Ron Matelic - Assortment Planning 
                                        //styleRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                                        //HierarchyNodeProfile hnp = _SAB.HierarchyServerSession.GetNodeData(styleRID);
                                        //if (hnp.IsVirtual)
                                        //{
                                        //    row.Cells["AnchorNode"].Activation = Activation.AllowEdit;
                                        //}
                                        //else
                                        //{
                                        row.Cells["AnchorNode"].Activation = Activation.NoEdit;
                                        //}
                                        //row.Cells["Product"].Activation = Activation.AllowEdit;
                                        //row.Cells["Style"].Activation = Activation.AllowEdit;
                                        //row.Cells["Description"].Activation = Activation.AllowEdit;
                                        //row.Cells["HdrQuantity"].Activation = Activation.AllowEdit;
                                        //row.Cells["UnitRetail"].Activation = Activation.NoEdit;
                                        //row.Cells["UnitCost"].Activation = Activation.NoEdit;
                                        //row.Cells["PO"].Activation = Activation.AllowEdit;
                                        //row.Cells["Vendor"].Activation = Activation.AllowEdit;
                                        //row.Cells["Workflow"].Activation = Activation.NoEdit;
                                        //row.Cells["DC"].Activation = Activation.AllowEdit;
                                        //row.Cells["SizeGroup"].Activation = Activation.AllowEdit;
                                        //row.Cells["Multiple"].Activation = Activation.AllowEdit;
                                        row.Cells["Product"].Activation = Activation.NoEdit;
                                        row.Cells["Style"].Activation = Activation.NoEdit;
                                        row.Cells["Description"].Activation = Activation.NoEdit;
                                        row.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                                        row.Cells["UnitRetail"].Activation = Activation.NoEdit;
                                        row.Cells["UnitCost"].Activation = Activation.NoEdit;
                                        row.Cells["PO"].Activation = Activation.NoEdit;
                                        row.Cells["Vendor"].Activation = Activation.NoEdit;
                                        row.Cells["Workflow"].Activation = Activation.NoEdit;
                                        row.Cells["DC"].Activation = Activation.NoEdit;
                                        row.Cells["SizeGroup"].Activation = Activation.NoEdit;
                                        row.Cells["Multiple"].Activation = Activation.NoEdit;
                                        row.Cells["ImoId"].Activation = Activation.NoEdit;	// TT#1401 - stodd - VSW (IMO)
                                        // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                                        //row.Cells["UnitsPerCarton"].Activation = Activation.NoEdit; // TT#1652-MD - RMatelic- DC Carton Rounding 
                                        SetUnitsPerCartonActivation(row, headerType, headerStatus, intransitStatus);
                                        // End TT#5047 - jsmith - Units Per Carton / Multiple Check
                                        break;

                                    // BEGIN TT#1401 - stodd - add VSW (IMO)
                                    case eHeaderType.IMO:
                                        row.Cells["HeaderID"].Activation = Activation.AllowEdit;
                                        row.Cells["HeaderID"].Appearance.ResetForeColor();
                                        row.Cells["Type"].Activation = Activation.AllowEdit;
                                        row.Cells["Date"].Activation = Activation.AllowEdit;
                                        row.Cells["AnchorNode"].Activation = Activation.NoEdit;
                                        row.Cells["Product"].Activation = Activation.AllowEdit;
                                        row.Cells["Style"].Activation = Activation.AllowEdit;
                                        row.Cells["Description"].Activation = Activation.AllowEdit;
                                        // BEGIN MID Track #5977 - Workup buy error
                                        //row.Cells["HdrQuantity"].Activation = Activation.AllowEdit;
                                        if (headerType == eHeaderType.WorkupTotalBuy)
                                        {
                                            row.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                                        }
                                        else
                                        {
                                            row.Cells["HdrQuantity"].Activation = Activation.AllowEdit;
                                        }
                                        // END MID Track #5977
                                        row.Cells["UnitRetail"].Activation = Activation.AllowEdit;
                                        row.Cells["UnitCost"].Activation = Activation.AllowEdit;
                                        row.Cells["PO"].Activation = Activation.AllowEdit;
                                        row.Cells["Vendor"].Activation = Activation.AllowEdit;
                                        row.Cells["Workflow"].Activation = Activation.AllowEdit;
                                        row.Cells["DC"].Activation = Activation.AllowEdit;
                                        row.Cells["SizeGroup"].Activation = Activation.AllowEdit;
                                        row.Cells["Multiple"].Activation = Activation.AllowEdit;
                                        row.Cells["ImoId"].Activation = Activation.AllowEdit;
                                        row.Cells["AdjustVSW"].Activation = Activation.AllowEdit; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                                        // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                                        //row.Cells["UnitsPerCarton"].Activation = Activation.NoEdit; // TT#1652-MD - RMatelic- DC Carton Rounding 
                                        SetUnitsPerCartonActivation(row, headerType, headerStatus, intransitStatus);
                                        // End TT#5047 - jsmith - Units Per Carton / Multiple Check
                                        break;
                                    // END TT#1401 - stodd - add VSW (IMO)

                                    default:
                                        row.Cells["HeaderID"].Activation = Activation.AllowEdit;
                                        row.Cells["HeaderID"].Appearance.ResetForeColor();
                                        row.Cells["Type"].Activation = Activation.AllowEdit;
                                        row.Cells["Date"].Activation = Activation.AllowEdit;
                                        row.Cells["AnchorNode"].Activation = Activation.NoEdit;
                                        row.Cells["Product"].Activation = Activation.AllowEdit;
                                        row.Cells["Style"].Activation = Activation.AllowEdit;
                                        row.Cells["Description"].Activation = Activation.AllowEdit;
                                        // BEGIN MID Track #5977 - Workup buy error
                                        //row.Cells["HdrQuantity"].Activation = Activation.AllowEdit;
                                        if (headerType == eHeaderType.WorkupTotalBuy)
                                        {
                                            row.Cells["HdrQuantity"].Activation = Activation.NoEdit;
                                        }
                                        else
                                        {
                                            row.Cells["HdrQuantity"].Activation = Activation.AllowEdit;
                                        }
                                        // END MID Track #5977
                                        row.Cells["UnitRetail"].Activation = Activation.AllowEdit;
                                        row.Cells["UnitCost"].Activation = Activation.AllowEdit;
                                        row.Cells["PO"].Activation = Activation.AllowEdit;
                                        row.Cells["Vendor"].Activation = Activation.AllowEdit;
                                        row.Cells["Workflow"].Activation = Activation.AllowEdit;
                                        row.Cells["DC"].Activation = Activation.AllowEdit;
                                        row.Cells["SizeGroup"].Activation = Activation.AllowEdit;
                                        row.Cells["Multiple"].Activation = Activation.AllowEdit;
                                        row.Cells["ImoId"].Activation = Activation.NoEdit;	// TT#1401 - stodd - VSW (IMO)
                                        row.Cells["AdjustVSW"].Activation = Activation.NoEdit; // TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                                        // Begin TT#1652-MD - RMatelic- DC Carton Rounding 
                                        // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
                                        //row.Cells["UnitsPerCarton"].IgnoreRowColActivation = true; // don't know why I had to do this for this 1 cell to get the AllowEdit to work
                                        //row.Cells["UnitsPerCarton"].Activation = Activation.AllowEdit;
                                        SetUnitsPerCartonActivation(row, headerType, headerStatus, intransitStatus);
                                        // End TT#5047 - jsmith - Units Per Carton / Multiple Check
                                        // End TT#1652-MD 
                                        break;
                                }
                        }
                        break;
                }

                foreach (UltraGridColumn col in row.Band.Columns)
                {
                    if (col.Tag != null && col.Tag.GetType() == typeof(HeaderCharGroupProfile))
                    {
                        HeaderCharGroupProfile hcgp = (HeaderCharGroupProfile)col.Tag;
                        // Begin TT#296 - RMatelic - Cannot type in to a Header Characteristic if Interface Header Security is set to View Only
                        //if (hcgp.ProtectInd || !_allocationNonInterfacedHeadersSecurity.AllowUpdate)
                        if (hcgp.ProtectInd)
                        // End TT#296 
                    //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                        {
                            //row.Cells[hcgp.ID].Activation = Activation.NoEdit;
                            row.Cells[hcgp.Key.ToString()].Activation = Activation.NoEdit;
                        }
                        else  
                        {
                            row.Cells[hcgp.Key.ToString()].Activation = Activation.AllowEdit;
                        }  
                    //TT#440 - MD - RBeck _ Make Header Characteristics references by RID
                    }    
                }

                if (row.HasChild())
                {
                    // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
                    //if (!allowHeaderUpdate || isMultiHeader || isInAssortment)
                    //{
                    //    allowChildUpdate = false;
                    //}
                    if (Convert.ToBoolean(row.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture))
                    {
                        allowChildUpdate = CheckInterfacedComponentAllowUpdate();
                    }
                    else
                    {
                        if (!allowHeaderUpdate || isMultiHeader || isInAssortment || ap.IsMasterHeader)   // TT#1966-MD - AGallagher - DC Fulfillment 
                        {
                            allowChildUpdate = false;
                        }
                    }
                    // End TT#254 
                    UltraGridRow childRow = row.GetChild(ChildRow.First);
                    while (childRow != null)
                    {
                        SetChildRowActivation(childRow, headerStatus, allowChildUpdate, allocationStarted, workUpTotalBuy);
                        childRow = childRow.GetSibling(SiblingRow.Next, true);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetUnitsPerCartonActivation(UltraGridRow row, eHeaderType headerType, eHeaderAllocationStatus headerStatus, eHeaderIntransitStatus intransitStatus)
        {
            // Begin TT#5047 - jsmith - Units Per Carton / Multiple Check
            if (headerType == eHeaderType.MultiHeader ||
                headerType == eHeaderType.Placeholder ||
                headerType == eHeaderType.Assortment ||
                headerType == eHeaderType.IMO || 
                headerStatus == eHeaderAllocationStatus.Released ||
                headerStatus == eHeaderAllocationStatus.ReleaseApproved ||
                headerStatus == eHeaderAllocationStatus.InUseByMultiHeader ||
                intransitStatus != eHeaderIntransitStatus.NotIntransit)
            {
                row.Cells["UnitsPerCarton"].Activation = Activation.NoEdit;
            }
            else
            {
                row.Cells["UnitsPerCarton"].IgnoreRowColActivation = true;
                row.Cells["UnitsPerCarton"].Activation = Activation.AllowEdit;
            }
        }
        // End TT#5047 - jsmith - Units Per Carton / Multiple Check
		
        private void SetChildRowActivation(UltraGridRow aRow, eHeaderAllocationStatus aStatus, bool aAllowUpdate,
                                           bool allocationStarted, bool aWorkUpTotalBuy)
        {
            
            string bandKey = aRow.Band.Key;
            string[] bandKeyParts = bandKey.Split(new char[] { '~' });
            try
            {
                aRow.Activation = Activation.AllowEdit;
                switch (bandKeyParts[0])
                {
                   
                    case "Pack":
                        SetPackRowActivation(aRow, aStatus, aAllowUpdate);
                        break;

                    case "PackColor":
                        SetPackColorRowActivation(aRow, aStatus, aAllowUpdate, allocationStarted);
                        break;

                    case "BulkColor":
                        SetBulkColorRowActivation(aRow, aStatus, aAllowUpdate, allocationStarted, aWorkUpTotalBuy);
                        break;
                  
                    case "BulkSize":
                    case "PackSize":
                    case "PackColorSize":
                        SetSizeRowActivation(aRow, aStatus, aAllowUpdate, allocationStarted, aWorkUpTotalBuy);
                        break;

                    default:
                        break;
                }

                if (aRow.HasChild(false))
                {
                    UltraGridRow cRow = aRow.GetChild(ChildRow.First);
                    while (cRow != null)
                    {
                        SetChildRowActivation(cRow, aStatus, aAllowUpdate, allocationStarted, aWorkUpTotalBuy);
                        cRow = cRow.GetSibling(SiblingRow.Next, true, false);
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetPackRowActivation(UltraGridRow aRow, eHeaderAllocationStatus aStatus, bool aAllowUpdate) 
        {
            try
            {
                switch (aStatus)
                {
                    case eHeaderAllocationStatus.AllInBalance:
                    case eHeaderAllocationStatus.AllocatedInBalance:
                    case eHeaderAllocationStatus.AllocatedOutOfBalance:
                    case eHeaderAllocationStatus.PartialSizeInBalance:
                    case eHeaderAllocationStatus.PartialSizeOutOfBalance:
                    case eHeaderAllocationStatus.SizesOutOfBalance:
                    case eHeaderAllocationStatus.ReleaseApproved:
                    case eHeaderAllocationStatus.Released:
                    case eHeaderAllocationStatus.InUseByMultiHeader:
                        aRow.Cells["PackType"].Activation = Activation.NoEdit;
                        aRow.Cells["TotalPacks"].Activation = Activation.NoEdit;
                        aRow.Cells["QuantityPerPack"].Activation = Activation.NoEdit;
                        if (   aStatus == eHeaderAllocationStatus.ReleaseApproved
                            || aStatus == eHeaderAllocationStatus.Released
                            || aStatus == eHeaderAllocationStatus.InUseByMultiHeader
                            || !aAllowUpdate)
                        {
                            aRow.Cells["Pack"].Activation = Activation.NoEdit;
                        }
                        else
                        {
                            aRow.Cells["Pack"].Activation = Activation.AllowEdit;
                        }
                        break;

                    default:
                        if (aAllowUpdate)
                        {
                            aRow.Cells["Pack"].Activation = Activation.AllowEdit;
                            aRow.Cells["PackType"].Activation = Activation.AllowEdit;
                            aRow.Cells["TotalPacks"].Activation = Activation.AllowEdit;
                            aRow.Cells["QuantityPerPack"].Activation = Activation.AllowEdit;
                           
                        }
                        else
                        {
                            aRow.Cells["Pack"].Activation = Activation.NoEdit;
                            aRow.Cells["PackType"].Activation = Activation.NoEdit;
                            aRow.Cells["TotalPacks"].Activation = Activation.NoEdit;
                            aRow.Cells["QuantityPerPack"].Activation = Activation.NoEdit;
                        }
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }    
        }

        private void SetPackColorRowActivation(UltraGridRow aRow, eHeaderAllocationStatus aStatus, bool aAllowUpdate, bool allocationStarted)
        {
            try
            {
                switch (aStatus)
                {
                    case eHeaderAllocationStatus.AllInBalance:
                    case eHeaderAllocationStatus.AllocatedInBalance:
                    case eHeaderAllocationStatus.AllocatedOutOfBalance:
                    case eHeaderAllocationStatus.PartialSizeInBalance:
                    case eHeaderAllocationStatus.PartialSizeOutOfBalance:
                    case eHeaderAllocationStatus.SizesOutOfBalance:
                    case eHeaderAllocationStatus.ReleaseApproved:
                    case eHeaderAllocationStatus.Released:
                    case eHeaderAllocationStatus.InUseByMultiHeader:
                       
                        aRow.Cells["QuantityPerPack"].Activation = Activation.NoEdit;
                        if (aStatus == eHeaderAllocationStatus.ReleaseApproved ||
                            aStatus == eHeaderAllocationStatus.Released ||
                            aStatus == eHeaderAllocationStatus.InUseByMultiHeader ||
                            !aAllowUpdate)
                        {
                            aRow.Cells["PackColor"].Activation = Activation.NoEdit;
                            aRow.Cells["Description"].Activation = Activation.NoEdit;
                        }
                        else
                        {
                            aRow.Cells["Description"].Activation = Activation.AllowEdit;
                            if (allocationStarted)
                            {
                                aRow.Cells["PackColor"].Activation = Activation.NoEdit;
                            }
                            else
                            {
                                aRow.Cells["PackColor"].Activation = Activation.AllowEdit;
                                aRow.Cells["PackColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                            }
                        }
                        break;

                    default:

                        if (aAllowUpdate)
                        {
                            aRow.Cells["Description"].Activation = Activation.AllowEdit;
                            aRow.Cells["QuantityPerPack"].Activation = Activation.AllowEdit;
                            if (allocationStarted)
                            {
                                aRow.Cells["PackColor"].Activation = Activation.NoEdit;
                            }
                            else
                            {
                                aRow.Cells["PackColor"].Activation = Activation.AllowEdit;
                                aRow.Cells["PackColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                            }
                        }
                        else
                        {
                            aRow.Cells["PackColor"].Activation = Activation.NoEdit;
                            aRow.Cells["Description"].Activation = Activation.NoEdit;
                            aRow.Cells["QuantityPerPack"].Activation = Activation.NoEdit;
                        }
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetBulkColorRowActivation(UltraGridRow aRow, eHeaderAllocationStatus aStatus, bool aAllowUpdate,
                                               bool allocationStarted, bool aWorkUpTotalBuy)
        {
            try
            {
                switch (aStatus)
                {
                    case eHeaderAllocationStatus.AllInBalance:
                    case eHeaderAllocationStatus.AllocatedInBalance:
                    case eHeaderAllocationStatus.AllocatedOutOfBalance:
                    case eHeaderAllocationStatus.PartialSizeInBalance:
                    case eHeaderAllocationStatus.PartialSizeOutOfBalance:
                    case eHeaderAllocationStatus.SizesOutOfBalance:
                    case eHeaderAllocationStatus.ReleaseApproved:
                    case eHeaderAllocationStatus.Released:
                    case eHeaderAllocationStatus.InUseByMultiHeader:

                        aRow.Cells["Quantity"].Activation = Activation.NoEdit;
                        if (aStatus == eHeaderAllocationStatus.ReleaseApproved ||
                            aStatus == eHeaderAllocationStatus.Released ||
                            aStatus == eHeaderAllocationStatus.InUseByMultiHeader ||
                            !aAllowUpdate)
                        {
                            aRow.Cells["BulkColor"].Activation = Activation.NoEdit;
                            aRow.Cells["Description"].Activation = Activation.NoEdit;
                        }
                        else
                        {
                            aRow.Cells["Description"].Activation = Activation.AllowEdit;
                            if (allocationStarted)
                            {
                                aRow.Cells["BulkColor"].Activation = Activation.NoEdit;
                            }
                            else
                            {
                                aRow.Cells["BulkColor"].Activation = Activation.AllowEdit;
                                aRow.Cells["BulkColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                            }
                        }
                        break;

                    default:
                        if (aAllowUpdate)
                        {
                            aRow.Cells["Description"].Activation = Activation.AllowEdit;
                            if (allocationStarted)
                            {
                                aRow.Cells["BulkColor"].Activation = Activation.NoEdit;
                            }
                            else
                            {
                                aRow.Cells["BulkColor"].Activation = Activation.AllowEdit;
                                aRow.Cells["BulkColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                            }
                            if (aWorkUpTotalBuy)
                            {
                                aRow.Cells["Quantity"].Activation = Activation.NoEdit;
                            }
                            else
                            {
                                aRow.Cells["Quantity"].Activation = Activation.AllowEdit;
                                aRow.Cells["BulkColor"].Style = Infragistics.Win.UltraWinGrid.ColumnStyle.EditButton;
                            }
                        }
                        else
                        {
                            aRow.Cells["BulkColor"].Activation = Activation.NoEdit;
                            aRow.Cells["Description"].Activation = Activation.NoEdit;
                            aRow.Cells["Quantity"].Activation = Activation.NoEdit;
                        }
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void SetSizeRowActivation(UltraGridRow aRow, eHeaderAllocationStatus aStatus, bool aAllowUpdate,
                                              bool allocationStarted, bool aWorkUpTotalBuy)
        {
            try
            {
                switch (aStatus)
                {
                    case eHeaderAllocationStatus.AllInBalance:
                    case eHeaderAllocationStatus.AllocatedInBalance:
                    case eHeaderAllocationStatus.AllocatedOutOfBalance:
                    case eHeaderAllocationStatus.PartialSizeInBalance:
                    case eHeaderAllocationStatus.PartialSizeOutOfBalance:
                    case eHeaderAllocationStatus.SizesOutOfBalance:
                    case eHeaderAllocationStatus.ReleaseApproved:
                    case eHeaderAllocationStatus.Released:
                    case eHeaderAllocationStatus.InUseByMultiHeader:

                        for (int i = 7; i < aRow.Cells.Count; i++)
                        {
                            if (Convert.ToInt32(aRow.Cells[i].Tag, CultureInfo.CurrentUICulture) == Include.NoRID)
                            {
                                aRow.Cells[i].Activation = Activation.Disabled;
                            }    
                            else
                            {
                                aRow.Cells[i].Activation = Activation.NoEdit;
                            }
                        }    
                        break;

                    default:

                        for (int i = 7; i < aRow.Cells.Count; i++)
                        {
                            if (!aAllowUpdate || aWorkUpTotalBuy)
                            {
                                aRow.Cells[i].Activation = Activation.NoEdit;
                            }
                            else if (Convert.ToInt32(aRow.Cells[i].Tag, CultureInfo.CurrentUICulture) == Include.NoRID)
                            {
                                aRow.Cells[i].Activation = Activation.Disabled;
                            }
                            else
                            {
                                aRow.Cells[i].Activation = Activation.AllowEdit;
                            }
                        }    
                        break;
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
                 
        private bool CheckHeaderAllowUpdate(UltraGridRow aRow)
        {
            bool allowHeaderUpdate = false;
            string bandKey = aRow.Band.Key;
            string[] bandKeyParts = bandKey.Split(new char[] { '~' });
            try
            {
                switch (bandKeyParts[0])
                {
                    case "Header":
                    //case "Placeholder":
                         break;
                  
                    case "BulkColor":
                    case "Pack":
                        aRow = aRow.ParentRow;
                        break;
                    
                    case "PackColor":
                    case "BulkSize":
                    case "PackSize":
                        aRow = aRow.ParentRow.ParentRow;
                        break;
                  
                    case "PackColorSize":
                        aRow = aRow.ParentRow.ParentRow.ParentRow;
                        break;
                  
                    default:
                        aRow = aRow.ParentRow.ParentRow;
                        break;
                }
                if (Convert.ToBoolean(aRow.Cells["Interfaced"].Value, CultureInfo.CurrentUICulture))
                {
                    if (_SAB.ClientServerSession.GlobalOptions.ProtectInterfacedHeadersInd)
                    {
                        allowHeaderUpdate = false;
                    }
                    else
                    {
                        allowHeaderUpdate = _allocationInterfacedHeadersSecurity.AllowUpdate;
                    }
                }
                else	// not Interfaced
                {
                    allowHeaderUpdate = _allocationNonInterfacedHeadersSecurity.AllowUpdate;
                }
                return allowHeaderUpdate;
            }
            catch  
            {
                throw;
            }
        }

        // Begin TT#254 - RMatelic - Add Header Component security to interfaced headers
        private bool CheckInterfacedComponentAllowUpdate()
        {
            bool allowComponentUpdate = false;
            try
            { 
                if (_SAB.ClientServerSession.GlobalOptions.ProtectInterfacedHeadersInd)
                {
                    allowComponentUpdate = false;
                }
                else
                {
                    allowComponentUpdate = _allocationInterfacedComponentSecurity.AllowUpdate;
                }
            }
            catch
            {
                throw;
            }
            return allowComponentUpdate;
        }
        // End TT#254 

        private void cmsCancel_Click(object sender, EventArgs e)
        {
            CancelEdit();
        }

        private void CancelEdit()
        {
            try
            {    
                DequeueHeaders();
                
                if (_deletedHeaderRows.Count > 0)
                {
                    foreach (int headerRID in _deletedHeaderRows.Keys)
                    {
                        AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(headerRID);
                        if (ap == null)
                        {
                            continue;
                        }
                        else
                        {
                            _allocProfileList.Remove(ap);
                            if (headerRID > 0)
                            {
                                AllocationHeaderProfile ahp = _SAB.HeaderServerSession.GetHeaderData(headerRID, aIncludeComponents: true, aIncludeCharacteristics: true, blForceGet: false);
                                ap = new AllocationProfile(_SAB, ahp, _SAB.ClientServerSession);
                                _allocProfileList.Add(ap);
                            }
                        }
                    }
                }

                foreach (UltraGridRow row in ugDetails.Rows)
                {
                    int hdrRID = Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                    eHeaderType hdrType = (eHeaderType)Convert.ToInt32(row.Cells["Type"].Value, CultureInfo.CurrentUICulture);
                    if (_allocProfileList.Contains(hdrRID))
                    {
                        AllocationProfile ap = (AllocationProfile)_allocProfileList.FindKey(hdrRID);
                        _allocProfileList.Remove(ap);
                        if (hdrRID > 0)
                        {
                            AllocationHeaderProfile ahp = _SAB.HeaderServerSession.GetHeaderData(hdrRID, aIncludeComponents: true, aIncludeCharacteristics: true, blForceGet: false);
                            ap = new AllocationProfile(_SAB, ahp, _SAB.ClientServerSession);
                            _allocProfileList.Add(ap);
                        }
                    }
                    if (hdrRID < 0)
                    {
                        if (hdrType == eHeaderType.Placeholder)
                        {
                            int styleRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                            if (!_deletedPlaceholderStyles.ContainsKey(hdrRID))
                            {
                                _deletedPlaceholderStyles.Add(hdrRID, styleRID);
                            }
                        }
                        else if (hdrType == eHeaderType.Assortment)
                        {
                            int styleRID = Convert.ToInt32(row.Cells["StyleHnRID"].Value, CultureInfo.CurrentUICulture);
                            if (!_deletedAssortmentStyles.ContainsKey(hdrRID))
                            {
                                _deletedAssortmentStyles.Add(hdrRID, styleRID);
                            }
                        }
                    }
                }
              
                CheckForPlaceholderStyleDelete(false);

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.BeginUpdate();
                //ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                
                if (_multiHeadersSaved != null)
                {
                    _multiHeaders = _multiHeadersSaved.Copy();
                    // Begin TT#2839 - JSmith - MultiHeader IDs in 5.0
                    //ugDetails.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Clear();
                    //foreach (DataRow mRow in _multiHeaders.Rows)
                    //{
                    //    ugDetails.DisplayLayout.ValueLists["MultiHeader"].ValueListItems.Add(Convert.ToInt32(mRow["HdrRID"], CultureInfo.CurrentUICulture), mRow["HeaderID"].ToString());
                    //}
                    RebuildMultiHeaderValueLists();
                    // End TT#2839 - JSmith - MultiHeader IDs in 5.0
                }
                if (_assortmentsSaved != null)
                {
                    _assortments = _assortmentsSaved.Copy();
                    ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Clear();
                    foreach (DataRow mRow in _assortments.Rows)
                    {
                        ugDetails.DisplayLayout.ValueLists["AssortmentID"].ValueListItems.Add(Convert.ToInt32(mRow["AsrtRID"], CultureInfo.CurrentUICulture), mRow["AssortmentID"].ToString());
                    }
                }
                if (_placeHoldersSaved != null)
                {
                    _placeHolders = _placeHoldersSaved.Copy();
                    ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Clear();
                    foreach (DataRow mRow in _placeHolders.Rows)
                    {
                        ugDetails.DisplayLayout.ValueLists["PlaceHolderID"].ValueListItems.Add(Convert.ToInt32(mRow["PlaceHolderRID"], CultureInfo.CurrentUICulture), mRow["PlaceHolderID"].ToString());
                    }
                }
               
                // Begin TT#4954 - JSmith - Multi header error
				//_dsDetails.Clear();
				if (_dsDetails != null)
                {
                    _dsDetails.Clear();
                }
				// End TT#4954 - JSmith - Multi header error
                if (_dsDetailsSaved != null)
                {
                    _dsDetails = _dsDetailsSaved.Copy();
                }
                else
                {
                    ArrayList al = new ArrayList(); 
                    foreach (DataRelation dr in _dsDetails.Relations)
                    {
                        string[] relationParts = dr.RelationName.Split(new char[] { '~' });
                       
                        switch (relationParts[0])
                        {
                            case "BulkSize":
                            case "PackSize":
                            case "PackColorSize":

                                al.Add(dr.RelationName);
                                break;
                        
                            default:
                                break;
                        }
                    }
                    if (al.Count > 0)
                    {
                        foreach (string relationName in al)
                        {
                            _dsDetails.Tables[relationName].Constraints.Remove(relationName);
                            _dsDetails.Relations.Remove(relationName);
                            _dsDetails.Tables.Remove(relationName);
                        }
                    }
                }
                BindDetailsGrid();
                ResetWorkspace();
                if (_expandAll)
                {
                    cmsExpand_Click(cmsExpand, null);
                }

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //ugDetails.ResumeRowSynchronization();
                //ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                _changesPending = false;    // MID Track #5501 - add 'Save Changes?' message

                _headersAddedToMulti.Clear();

                ReselectPreviousSelections(); // MID Track #6264 - Headers not in priority order
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        // BEGIN MID Track #6264 - Headers not in priority order
        private void ReselectPreviousSelections()
        {
            try
            {
                if (_selectedRowsSequence.Count > 0)
                {
                    ArrayList selRowsSeq = (ArrayList)_selectedRowsSequence.Clone();
                    for (int i = 0; i < selRowsSeq.Count; i++)
                    {
                        UltraGridRow hdrRow = (UltraGridRow)selRowsSeq[i];
                        // Begin TT#867 - RMatelic - WUB Header Edit and Save the Header is not recognized as being selected in the Allocation Workspace
                        // The re-selecting of a WorkUpBuy header row for TT#736 caused the following row selection to be ignored and not go thru the _AfterSelectChange
                        // event which reselects the row to be processed for actions or methods; unselecting the row first will now fire the event when
                        // hdrRow.Selected = true is set
                        // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                        //ugHeaders.BeginUpdate();
                        ugHeadersBeginUpdate();
                        // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                        if (hdrRow.Selected)
                        {
                            hdrRow.Selected = false;
                        }
                        // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                        //ugHeaders.EndUpdate();
                        ugHeadersEndUpdate();
                        // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                        // End TT#867
                        hdrRow.Selected = true;
                        
                        // Begin TT#1080 - RMatelic - Created a header and upon saving it is not recognized in the headers Selected Window
                        if (_afterSelectChangeEventArgs != null)
                        {
                            AfterSelectChange(_sender, _afterSelectChangeEventArgs);
                        }
                        // End TT1080
                        
                        // Begin TT#620 - RMatelic - Base 3.1 -> Created multi - select SAVE button -> get system argument exception error
                        ugHeaders.DisplayLayout.RowScrollRegions[0].ScrollRowIntoView(hdrRow);
                    }
                    if (_expandAll)
                    {
                        cmsExpand_Click(cmsExpand, null);
                    }
                }       // End TT#620  
            }
            catch  
            {
               throw;
            }
        }
        // END MID Track #6264 

        private void ResetWorkspace()
        {
            try
            {
                ResetGrids();
                SetActionListCombo();
                SetViewComboEnabled();
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void cmsSaveView_Click(object sender, EventArgs e)
        {
            SaveView();
        }
        private void SaveView()
        {
            try
            {
                this.Enabled = false;
                ViewParms viewParms = new ViewParms();
                viewParms.LayoutID = (int)eLayoutID.allocationWorkspaceGrid;
                viewParms.ViewGrid = ugHeaders;

				//Begin TT#1290 - JScott - In the Allocation Workspace when updating the contents of a view and saving a new view is created instead of saving over the orginal view.
				//viewParms.ViewName = Convert.ToString(cboView.Text, CultureInfo.CurrentUICulture);
               
                // Begin TT#1556 - RMatelic - Save as in User View creates new view by appending user signon
                //    readded the above commented line for consistency in saving this view and size, style and velocity views
                //viewParms.ViewName = Convert.ToString(_dtView.Rows[(int)cboView.SelectedIndex]["RAW_VIEW_ID"], CultureInfo.CurrentUICulture);
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //viewParms.ViewName = Convert.ToString(cboView.Text, CultureInfo.CurrentUICulture);
				// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
				//viewParms.ViewName = ((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).Text;	// TT#869 - stodd - Save View received Invalid Operation Exception 
                //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
                //MIDComboBoxEnh.MyComboBox cmbView = (MIDComboBoxEnh.MyComboBox)cct.Control;
                MIDComboBoxEnh.MyComboBox cmbView = GetViewComboBoxControl();
                viewParms.ViewName = cmbView.Text;
                // End TT#1556
				//End TT#1290 - JScott - In the Allocation Workspace when updating the contents of a view and saving a new view is created instead of saving over the orginal view.
				
                //viewParms.ViewRID = Convert.ToInt32(cboView.SelectedValue, CultureInfo.CurrentUICulture);
				//viewParms.ViewRID = Convert.ToInt32(((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).Value);
                viewParms.ViewRID = int.Parse(cmbView.SelectedValue.ToString());
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
                if (viewParms.ViewRID != Include.NoRID)
                {
					// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                    int viewSelectedIndex = cmbView.SelectedIndex;
				// End TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //viewParms.ViewUserRID = Convert.ToInt32(_dtView.Rows[(int)cboView.SelectedIndex]["USER_RID"], CultureInfo.CurrentUICulture);
                    //viewParms.ViewShowDetails = Include.ConvertCharToBool(Convert.ToChar(_dtView.Rows[(int)cboView.SelectedIndex]["SHOW_DETAILS"], CultureInfo.CurrentUICulture));
					viewParms.ViewUserRID = Convert.ToInt32(_dtView.Rows[viewSelectedIndex]["USER_RID"], CultureInfo.CurrentUICulture);
					viewParms.ViewShowDetails = Include.ConvertCharToBool(Convert.ToChar(_dtView.Rows[viewSelectedIndex]["SHOW_DETAILS"], CultureInfo.CurrentUICulture));
					// END TT#767-MD - Stodd - remove old controls from allocation workspace
                }
                else
                {
                    viewParms.ViewUserRID = _SAB.ClientServerSession.UserRID;
                    viewParms.ViewShowDetails = false;  // Workspace Usability
                }
                viewParms.FunctionSecurity = eSecurityFunctions.AllocationViews;
                viewParms.GlobalViewSecurity = eSecurityFunctions.AllocationViewsGlobal;
                viewParms.UserViewSecurity = eSecurityFunctions.AllocationViewsUser;

                ViewSave gridViewSaveForm = new ViewSave(_SAB, viewParms, false);	// TT#1390-MD - stodd - Assortment Workspace Save View lists headers filters instead of assortment header filters.

                gridViewSaveForm.OnViewSaveClosingEventHandler += new ViewSave.ViewSaveClosingEventHandler(OnViewSaveClosing);
                gridViewSaveForm.MdiParent = this.ParentForm.Owner;
                gridViewSaveForm.Show();
            }
            catch (Exception ex)
            {
                HandleException(ex);
                this.Enabled = true;
            }
        }

        // Begin TT#454 - RMatelic - Add Views in Style Review - rewrite using aViewParms
        //void OnViewSaveClosing(object source, bool aViewSaved, int aViewRID, bool aViewDeleted)
        void OnViewSaveClosing(object source, ViewParms aViewParms)
        {
            try
            {
                if (aViewParms.ViewSaved || aViewParms.ViewDeleted)
                {
                    BindViewCombo();
                    // BEGIN MID Track #6407 - Grouping and Saving view takes several minutes  
                    //if (aViewSaved || aViewDeleted)
                    //{
                    //    cboView.SelectedValue = aViewRID;
                    //}
                    if (aViewParms.ViewSaved)
                    {
                        _viewSaved = true;
                    }
					// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                    //cboView.SelectedValue = aViewParms.ViewRID;
					// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
					//((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).Value = aViewParms.ViewRID;
					// END TT#767-MD - Stodd - remove old controls from allocation workspace
                    //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
                    //MIDComboBoxEnh.MyComboBox cmbView = (MIDComboBoxEnh.MyComboBox)cct.Control;
                    MIDComboBoxEnh.MyComboBox cmbView = GetViewComboBoxControl();
                    cmbView.SelectedValue = aViewParms.ViewRID;
					// End TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //this.cboView_SelectionChangeCommitted(source, new EventArgs()); // TT#294-MD - RBeck - When Opening style review, the view does not open that is selected
                    // End TT#454
                    // END MID Track #6407
                    // BEGIN Workspace Usability Enhancement - Ron Matelic
                    ShowHideDetails();
                    // END Workspace Usability Enhancement

                    //Begin TT#1477-MD -jsobek -Header Filter Sort on Workspace
                    if (_viewSaved)
                    {
                        //Refresh the view on grid in case params changed
                        SetView(aViewParms.ViewRID, forceRefresh: true); 
                    }
                    //End TT#1477-MD -jsobek -Header Filter Sort on Workspace
                }
            }
            catch (Exception exc)
            {
                HandleException(exc);
            }
            finally
            {
                this.Enabled = true;
            }
        }

        private void cmsSaveAs_Click(object sender, EventArgs e)
        {
            try
            {
                bool continueSave = false;
                bool saveAsCanceled = false;
                bool errorFound;
                string headerID = string.Empty;
                string errMessage = string.Empty;
                UltraGridRow copyRow;

                if (ugDetails.Selected.Rows.Count > 1)
                {
                    errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_as_SelectOneRowForSaveAs);
                    MessageBox.Show(errMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
                else if (ugDetails.Selected.Rows.Count == 1)
                {
                    copyRow = ugDetails.Selected.Rows[0];
                }
                else if (ugDetails.ActiveRow != null)
                {
                    copyRow = ugDetails.ActiveRow;
                }
                else
                {
                    return;
                }
                frmSaveAs formSaveAs = new frmSaveAs(_SAB);
				formSaveAs.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
                // Begin TT#445 - RMatelic - allocation workspace error after save as selected on a Save As header
                formSaveAs.SaveAsNameMaxLength = ugDetails.DisplayLayout.Bands["Header"].Columns["HeaderID"].MaxLength;
                // End TT#445 
				formSaveAs.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
                while (!continueSave)
                {
                    formSaveAs.ShowDialog(this);
                    saveAsCanceled = formSaveAs.SaveCanceled;
                    if (!saveAsCanceled)
                    {
                        errorFound = false;
                        headerID = formSaveAs.SaveAsName.Trim();

                        if (!MIDMath.ValidFileName(headerID))
                        {
                            errMessage = string.Format(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_al_HeaderNameInvalid), headerID, Include.HeaderNameExcludedCharacters);
                            errorFound = true;
                        }
                        if (!errorFound)
                        {
                            foreach (AllocationHeaderProfile ahp in _headerProfileArrayList)
                            {
                                if (ahp.HeaderID == headerID)
                                {
                                    errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicateHeaderIdNotAllowed);
                                    errorFound = true;
                                    break;
                                }
                            }
                            if (!errorFound)
                            {
                                foreach (AllocationProfile app in _allocProfileList)
                                {
                                    if (app.HeaderID == headerID)
                                    {
                                        errMessage = _SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_DuplicateHeaderIdNotAllowed);
                                        errorFound = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (errorFound)
                        {
                            MessageBox.Show(errMessage, _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        }
                        else
                        {
                            continueSave = true;
                        }
                    }
                    else
                    {
                        MessageBox.Show(_SAB.ClientServerSession.Audit.GetText(eMIDTextCode.msg_SaveCanceled),
                                         _thisTitle, MessageBoxButtons.OK, MessageBoxIcon.Information);
                        continueSave = true;
                    }
                }
                if (!saveAsCanceled)
                {
                    _fromSaveAs = true;
                    _skipRowUpdate = true;
                    CopyHeader(headerID, copyRow);
                }    
            }
            catch (Exception exception)
            {
                HandleException(exception);
            }
            _fromSaveAs = false;
            _skipRowUpdate = false;
        }

        private void CopyHeader(string aHeaderID, UltraGridRow aCopyRow)
        {
            try
            {
                int status, hdrRID;
              
                status = Convert.ToInt32(aCopyRow.Cells["Status"].Value, CultureInfo.CurrentUICulture);
                switch ((eHeaderAllocationStatus)status)
                {
                    case eHeaderAllocationStatus.ReceivedInBalance:
                    case eHeaderAllocationStatus.ReceivedOutOfBalance:
                        break;
                   
                    default:
                        status = (int)eHeaderAllocationStatus.ReceivedInBalance;
                        break;
                }    

                Cursor.Current = Cursors.WaitCursor;
                _rClickRow = null;
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.BeginUpdate();
                //this.ugDetails.SuspendRowSynchronization();
                ugDetailsBeginUpdate();
                ugDetailsSuspendRowSynchronization();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls

                AddHeaderRow();

                this.ugDetails.ActiveRow.Cells["HeaderID"].Value = aHeaderID;
                this.ugDetails.ActiveRow.Cells["Type"].Value = aCopyRow.Cells["Type"].Value;
                this.ugDetails.ActiveRow.Cells["Status"].Value = status;

                _skipAnchorEdit = true;
                this.ugDetails.ActiveRow.Cells["AnchorNode"].Value = aCopyRow.Cells["AnchorNode"].Value;
                this.ugDetails.ActiveRow.Cells["AnchorHnRID"].Value = aCopyRow.Cells["AnchorHnRID"].Value;

                _skipProductEdit = true;
                this.ugDetails.ActiveRow.Cells["Product"].Value = aCopyRow.Cells["Product"].Value;
                this.ugDetails.ActiveRow.Cells["ProductRID"].Value = aCopyRow.Cells["ProductRID"].Value;

                _skipStyleEdit = true;
                this.ugDetails.ActiveRow.Cells["Style"].Value = aCopyRow.Cells["Style"].Value;
                this.ugDetails.ActiveRow.Cells["StyleHnRID"].Value = aCopyRow.Cells["StyleHnRID"].Value;

                this.ugDetails.ActiveRow.Cells["Description"].Value = aCopyRow.Cells["Description"].Value;
                this.ugDetails.ActiveRow.Cells["SizeGroup"].Value = aCopyRow.Cells["SizeGroup"].Value;
             
                this.ugDetails.ActiveRow.Cells["HdrQuantity"].Value = aCopyRow.Cells["HdrQuantity"].Value;
                this.ugDetails.ActiveRow.Cells["ChildTotal"].Value = aCopyRow.Cells["ChildTotal"].Value;

                // TODO other copied columns
                this.ugDetails.ActiveRow.Cells["StyleSecurity"].Value = aCopyRow.Cells["StyleSecurity"].Value;
                this.ugDetails.ActiveRow.Cells["Balance"].Value = aCopyRow.Cells["Balance"].Value;
                this.ugDetails.ActiveRow.Cells["UnitRetail"].Value = aCopyRow.Cells["UnitRetail"].Value;
                this.ugDetails.ActiveRow.Cells["UnitCost"].Value = aCopyRow.Cells["UnitCost"].Value;
                this.ugDetails.ActiveRow.Cells["Multiple"].Value = aCopyRow.Cells["Multiple"].Value;
				// BEGIN TT#1401 - stodd - add VSW (IMO)
				this.ugDetails.ActiveRow.Cells["ImoId"].Value = aCopyRow.Cells["ImoId"].Value;
				// End TT#1401 - stodd - add VSW (IMO)
                // begin TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1
                this.ugDetails.ActiveRow.Cells["AdjustVSW"].Value = aCopyRow.Cells["AdjustVSW"].Value;
                // end TT#2225 - JEllis - AnF VSW Fwos Enhancement pt 1

                hdrRID = Convert.ToInt32(this.ugDetails.ActiveRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                CopyComponents(this.ugDetails.ActiveRow, aCopyRow);
                AddCopySizeTables();

                UltraGridRow newHdrRow = null;
               
                UltraGridRow row = ugDetails.GetRow(ChildRow.First);
                while (row != null)
                {
                    if (Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture) == hdrRID)
                    {
                        newHdrRow = row;
                        break;
                    }
                    row = row.GetSibling(SiblingRow.Next, false, false);

                }

                newHdrRow.ExpandAll();
                if (_sizesAutoAdded)
                {
                    UpdateAddedSizeRows(newHdrRow);
                    _sizesAutoAdded = false;
                }

                this.ugDetails.Selected.Rows.Clear();
                UpdateSelectedTotals();

                SetEditActivation();

            }
            catch  
            {
                throw;
            }
            finally
            {
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                //this.ugDetails.ResumeRowSynchronization();
                //this.ugDetails.EndUpdate();
                ugDetailsResumeRowSynchronization();
                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                Cursor.Current = Cursors.Default;
            }
        }

        private void CopyComponents(UltraGridRow aNewHdrRow, UltraGridRow aCopyFromRow)
        {
            try
            {
                _dsCopySizes = MIDEnvironment.CreateDataSet();
                if (aCopyFromRow.HasChild(this.ugDetails.DisplayLayout.Bands["Pack"], false))
                {
                    this.ugDetails.ActiveRow = aNewHdrRow;
                    UltraGridRow packRow = aCopyFromRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["Pack"]);

                    while (packRow != null)
                    {
                        CopyPackRow(aNewHdrRow, packRow);
                        packRow = packRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }

                this.ugDetails.ActiveRow = aNewHdrRow;
                if (aCopyFromRow.HasChild(this.ugDetails.DisplayLayout.Bands["BulkColor"], false))
                {
                    UltraGridRow colorRow = aCopyFromRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["BulkColor"]);

                    while (colorRow != null)
                    {
                        CopyBulkColorRow(aNewHdrRow, colorRow);
                        colorRow = colorRow.GetSibling(SiblingRow.Next, false, false);
                    }
                }
                this.ugDetails.UpdateData();
                _dsDetails.AcceptChanges();
            }
            catch
            {
                throw;
            }
        }

        private void CopyPackRow(UltraGridRow aNewHdrRow, UltraGridRow aPackRow)
        {
            try
            {
                AddPackRow();
                UltraGridRow newPackRow = this.ugDetails.ActiveRow;

                string packName = aPackRow.Cells["Pack"].Value.ToString();
                newPackRow.Cells["KeyH"].Value = aNewHdrRow.Cells["KeyH"].Value;
                newPackRow.Cells["Pack"].Value = packName;
                newPackRow.Cells["PackType"].Value = aPackRow.Cells["PackType"].Value;
                newPackRow.Cells["TotalPacks"].Value = aPackRow.Cells["TotalPacks"].Value;
                newPackRow.Cells["QuantityPerPack"].Value = aPackRow.Cells["QuantityPerPack"].Value;

                if (!aPackRow.HasChild(this.ugDetails.DisplayLayout.Bands["PackColor"], false))
                {
                    newPackRow.Cells["ChildTotal"].Value = aPackRow.Cells["ChildTotal"].Value;
                }
                //newPackRow.Cells["AssociatedPackRID"].Value = aPackRow.Cells["KeyP"].Value;
                newPackRow.Update();

                if (aPackRow.HasChild(this.ugDetails.DisplayLayout.Bands["PackColor"], false))
                {
                    CopyPackColorRows(aPackRow, newPackRow);
                }
                else if (aPackRow.HasChild())
                {
                    this.ugDetails.ActiveRow = newPackRow;
                    CopyPackSizeRows(aPackRow, newPackRow);
                }
            }
            catch
            {
                throw;
            }
        }

        private void CopyPackColorRows(UltraGridRow aFromPackRow, UltraGridRow aNewPackRow)
        {
            string errorMessage = string.Empty;
            try
            {
                int newHdrRID = Convert.ToInt32(aNewPackRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                UltraGridRow packColorRow = aFromPackRow.GetChild(ChildRow.First, this.ugDetails.DisplayLayout.Bands["PackColor"]);
                while (packColorRow != null)
                {
                    AddPackColorRow();
                    string colorCodeID = Convert.ToString(packColorRow.Cells["PackColor"].Value, CultureInfo.CurrentUICulture);
                    UpdateColorValue(ugDetails.ActiveRow, colorCodeID, ref errorMessage);
                    ugDetails.ActiveRow.Cells["Description"].Value = packColorRow.Cells["Description"].Value;
                    ugDetails.ActiveRow.Cells["QuantityPerPack"].Value = packColorRow.Cells["QuantityPerPack"].Value;
                    if (_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                    {
                        this.ugDetails.ActiveRow.Cells["ChildTotal"].Value = packColorRow.Cells["ChildTotal"].Value;
                    }
                    ugDetails.ActiveRow.Update();

                    if (packColorRow.HasChild())	// PackColorSize
                    {
                        int keyP = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);
                        int keyC = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                        UltraGridRow packColorSizeRow = packColorRow.GetChild(ChildRow.First);

                        string bandKey = packColorSizeRow.Band.Key;

                        string tableName = "PackColorSize" + "~"
                                        + newHdrRID.ToString(CultureInfo.CurrentUICulture) + "~"
                                        + keyP.ToString(CultureInfo.CurrentUICulture) + "~"
                                        + keyC.ToString(CultureInfo.CurrentUICulture);

                        DataTable dtCopyPackColorSize = MIDEnvironment.CreateDataTable(tableName);
                        dtCopyPackColorSize = _dsDetails.Tables[bandKey].Copy();
                        dtCopyPackColorSize.TableName = tableName;
                        foreach (DataRow dr in dtCopyPackColorSize.Rows)
                        {
                            dr["KeyH"] = newHdrRID;
                            dr["KeyP"] = keyP;
                            dr["KeyC"] = keyC;
                        }

                        _dsCopySizes.Tables.Add(dtCopyPackColorSize);
                        _dsCopySizes.AcceptChanges();
                    }

                    packColorRow = packColorRow.GetSibling(SiblingRow.Next, false, false);
                }
            }
            catch
            {
                throw;
            }
        }

        private void CopyPackSizeRows(UltraGridRow aFromPackRow, UltraGridRow aNewPackRow)
        {
            int newHdrRID, keyP;
            try
            {
                newHdrRID = Convert.ToInt32(aNewPackRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                keyP = Convert.ToInt32(aNewPackRow.Cells["KeyP"].Value, CultureInfo.CurrentUICulture);

                UltraGridRow packSizeRow = aFromPackRow.GetChild(ChildRow.First);
                string bandKey = packSizeRow.Band.Key;
                string tableName = "PackSize"
                                 + "~" + newHdrRID.ToString(CultureInfo.CurrentUICulture)
                                 + "~" + keyP.ToString(CultureInfo.CurrentUICulture)
                                 + "~" + Include.DummyColorRID.ToString(CultureInfo.CurrentUICulture);

                DataTable dtCopyPackSize = MIDEnvironment.CreateDataTable(tableName);
                dtCopyPackSize = _dsDetails.Tables[bandKey].Copy();
                dtCopyPackSize.TableName = tableName;
                foreach (DataRow dr in dtCopyPackSize.Rows)
                {
                    dr["KeyH"] = newHdrRID;
                    dr["KeyP"] = keyP;
                    dr["KeyC"] = Include.DummyColorRID;
                }
                if (!DummyColorCheckOK(aNewPackRow))
                {
                    return;
                }
                _dsCopySizes.Tables.Add(dtCopyPackSize);
            }
            catch
            {
                throw;
            }
        }

        private void CopyBulkColorRow(UltraGridRow aNewHdrRow, UltraGridRow aColorRow)
        {
            int newHdrRID, colorRID, keyC = 0;
            string colorID, errorMessage = string.Empty;
            try
            {
                newHdrRID = Convert.ToInt32(aNewHdrRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                colorRID = Convert.ToInt32(aColorRow.Cells["ColorCodeRID"].Value, CultureInfo.CurrentUICulture);
                colorID = Convert.ToString(aColorRow.Cells["BulkColor"].Value);
             
                AddBulkColorRow();
                UpdateColorValue(ugDetails.ActiveRow, colorID, ref errorMessage);
                ugDetails.ActiveRow.Cells["Description"].Value = aColorRow.Cells["Description"].Value;
                ugDetails.ActiveRow.Cells["Quantity"].Value = aColorRow.Cells["Quantity"].Value;
                if (_SAB.ClientServerSession.GlobalOptions.AppConfig.SizeInstalled)
                {
                    ugDetails.ActiveRow.Cells["ChildTotal"].Value = aColorRow.Cells["ChildTotal"].Value;
                }
                keyC = Convert.ToInt32(ugDetails.ActiveRow.Cells["KeyC"].Value, CultureInfo.CurrentUICulture);
                ugDetails.ActiveRow.Update();
                
                if (aColorRow.HasChild())
                {
                    UltraGridRow bulkSizeRow = aColorRow.GetChild(ChildRow.First);
                    string bandKey = bulkSizeRow.Band.Key;
                    string tableName = "BulkSize" + "~"
                                        + newHdrRID.ToString(CultureInfo.CurrentUICulture) + "~"
                                        + keyC.ToString(CultureInfo.CurrentUICulture);

                    DataTable dtCopyBulkSize = MIDEnvironment.CreateDataTable(tableName);
                    dtCopyBulkSize = _dsDetails.Tables[bandKey].Copy();
                    dtCopyBulkSize.TableName = tableName;
                    foreach (DataRow dr in dtCopyBulkSize.Rows)
                    {
                        dr["KeyH"] = newHdrRID;
                        dr["KeyC"] = keyC;
                    }
                    _dsCopySizes.Tables.Add(dtCopyBulkSize);
                }
            }
            catch
            {
                throw;
            }
        }

        private void AddCopySizeTables()
        {
            try
            {
                if (_dsCopySizes.Tables.Count == 0)
                {
                    return;
                }
               
                _sizesAutoAdded = true;
                DataTable[] dtRange = new DataTable[_dsCopySizes.Tables.Count];
                for (int i = 0; i < _dsCopySizes.Tables.Count; i++)
                {
                    dtRange[i] = _dsCopySizes.Tables[i].Copy();
                }

                _dsDetails.Tables.AddRange(dtRange);
                for (int i = 0; i < _dsCopySizes.Tables.Count; i++)
                {
                    DataTable dt = _dsCopySizes.Tables[i];
                    string tableName = dt.TableName;
                    string[] bandKeyParts = tableName.Split(new char[] { '~' });

                    switch (bandKeyParts[0])
                    {
                        case "PackColorSize":
                            _dsDetails.Relations.Add(tableName,
                                new DataColumn[] { _dsDetails.Tables["PackColor"].Columns["KeyH"], _dsDetails.Tables["PackColor"].Columns["KeyP"], _dsDetails.Tables["PackColor"].Columns["KeyC"] },
                                new DataColumn[] { _dsDetails.Tables[tableName].Columns["KeyH"], _dsDetails.Tables[tableName].Columns["KeyP"], _dsDetails.Tables[tableName].Columns["KeyC"] }, true);

                            break;

                        case "PackSize":
                            _dsDetails.Relations.Add(tableName,
                               new DataColumn[] { _dsDetails.Tables["Pack"].Columns["KeyH"], _dsDetails.Tables["Pack"].Columns["KeyP"] },
                               new DataColumn[] { _dsDetails.Tables[tableName].Columns["KeyH"], _dsDetails.Tables[tableName].Columns["KeyP"] }, true);
                            break;

                        case "BulkSize":
                            _dsDetails.Relations.Add(tableName,
                                new DataColumn[] { _dsDetails.Tables["BulkColor"].Columns["KeyH"], _dsDetails.Tables["BulkColor"].Columns["KeyC"] },
                                new DataColumn[] { _dsDetails.Tables[tableName].Columns["KeyH"], _dsDetails.Tables[tableName].Columns["KeyC"] }, true);
                            break;
                    }
                    FormatAddedSizesLayout(ugDetails.DisplayLayout.Bands[tableName]);
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
            finally
            {
                _dsCopySizes.Dispose();
            }
        }

        // BEGIN Workspace Usability Enhancement - Ron Matelic
        private void cmsColSelectAll_Click(object sender, EventArgs e)
        {
            HideColumns(false);
        }

        private void cmsColClearAll_Click(object sender, EventArgs e)
        {
            HideColumns(true);
        }

        private void HideColumns(bool aHideColumn)
        {
            try
            {
                foreach (UltraGridColumn hdrCol in ugHeaders.DisplayLayout.Bands[0].Columns)
                {
                    if (hdrCol.ExcludeFromColumnChooser != ExcludeFromColumnChooser.True)
                    {
                        hdrCol.Hidden = aHideColumn;
                        if (ugDetails != null && ugDetails.DisplayLayout.Bands.Exists("Header"))
                        {
                            ugDetails.DisplayLayout.Bands["Header"].Columns[hdrCol.Key].Hidden = hdrCol.Hidden;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }    
        // END Workspace Usability Enhancement 

        #endregion
		
		#region IFormBase Members
		public override void ICut() 
		{
			
		}

		public override void ICopy() 
		{
			
		}

		public override void IPaste() 
		{
			
		}

		public override void ISave() 
		{
            // BEGIN MID Track #5501 File>Save not implemented 
            try
            {
                System.EventArgs args = new EventArgs();
                cmsSave_Click(this.cmsSave, args);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }	// END MID Track #5501

		public override void ISaveAs() 
		{
            // BEGIN MID Track #5653 File>SaveAs not implemented 
            try
            {
                System.EventArgs args = new EventArgs();
                cmsSaveAs_Click(this.cmsSaveAs, args);
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }   // END MID Track #5653

		public override void IRefresh() 
		{
			try 
			{
				Cursor.Current = Cursors.WaitCursor;
                // Begin TT#2349 - JSmith - Allocation Workspace Freezes when Refreshing using Ctrl-R
                _controlKeyPressedUpperGrid = false;
                // End TT#2349
				_workflowNameHash.Clear();
				//_methodHash.Clear(); //TT#1313-MD -jsobek -Header Filters -unused hash table
				_sizeGroupHash.Clear();
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                //Begin TT#329 - MD - DOConnell - Saving Assortment recieves an Object Reference Error
                if (_allocProfileList != null)
                {
                    _allocProfileList.Clear();
                }
                //End TT#329 - MD - DOConnell - Saving Assortment recieves an Object Reference Error
                // End TT#1434

                SaveLayout();
                System.EventArgs args = new System.EventArgs();

                if (_inEditMode)
                {
                    cmsCancel_Click(cmsCancel, args);
                }
                // Begin TT#1434 - JSmith - Slow Header Selection + Memory Issue?
                //ugDetails.DataSource = null;
                ClearDetails();
                // End TT#1434

				this.ugDetails.ResetLayouts();
                ApplyAppearance(ugDetails);
               
				if (_dtHeader != null)
				{
					_dtHeader.Dispose(); 
				}

                // Begin TT#3620 - JSmith - Right Click - Add - Header receive system argument exception
                _ultraGridRowSelectedType = null;
                // End TT#3620

                //Begin TT#1313-MD -jsobek -Header Filters
                // NOT rebuilding characteristic header data here since we are basically reloading the whole explorer (when pulling for the workspace - header characteristic data is refreshed)
                //RebuildHeaderCharacteristicData(); 
                //End TT#1313-MD -jsobek -Header Filters
                
				AllocationWorkspaceExplorer_Load(this, args);
                // Begin TT#3177 - JSmith - Incorrect Multi Header IDs again.
                AssignValueLists(ugHeaders);
                if (_dsDetails != null)
                {
                    AssignValueLists(ugDetails);
                }
                // Begin TT#544-MD - JSmith - Incorrect Multi Header IDs again.
			}
			catch( Exception ex) 
			{
				HandleException(ex);
			}
			finally 
			{
				Cursor.Current = Cursors.Default;
			}
		}

        //Begin TT#1313-MD -jsobek -Header Filters
        private void RebuildHeaderCharacteristicData()
        {
            FilterHeaderOptions headerFilterOptions = new FilterHeaderOptions();
            headerFilterOptions.USE_WORKSPACE_FIELDS = true;
            headerFilterOptions.filterType = filterTypes.HeaderFilter;
            _SAB.HeaderServerSession.RebuildHeaderCharacteristicData(this._headerFilterRID, headerFilterOptions);
        }
        //End TT#1313-MD -jsobek -Header Filters

        private void SaveLayout()
        {
            try
            {
                //InfragisticsLayoutData layoutData = new InfragisticsLayoutData();
               // layoutData.InfragisticsLayout_Save(_SAB.ClientServerSession.UserRID, eLayoutID.allocationWorkspaceGrid, ugHeaders);
				// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                //int viewRID = Convert.ToInt32(cboView.SelectedValue, CultureInfo.CurrentUICulture);
				// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
				//int viewRID = Convert.ToInt32(((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).Value);
				// END TT#767-MD - Stodd - remove old controls from allocation workspace
                //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
                //MIDComboBoxEnh.MyComboBox cmbView = (MIDComboBoxEnh.MyComboBox)cct.Control;
                MIDComboBoxEnh.MyComboBox cmbView = GetViewComboBoxControl();
				// Begin TT#1485-MD - stodd - Created an asst, ran create placeholders, cannot drag/drop header to asst.  Did a Tools Refresh and receive a Null reference exception.
                if (cmbView != null)
                {
                   // Begin TT#1956-MD - JSmith - Null Reference Exception during Tools Refresh with new user
                   //int viewRID = int.Parse(cmbView.SelectedValue.ToString());
                   int viewRID = Include.NoRID;
                   if (cmbView.SelectedValue != null)
                   {
                       viewRID = int.Parse(cmbView.SelectedValue.ToString());
                   }
                   // End TT#1956-MD - JSmith - Null Reference Exception during Tools Refresh with new user
				   // End TT#4071 - stodd - Matrix does not allow search for attribute - 
                   _userGridView.UserGridView_Update(_SAB.ClientServerSession.UserRID, eLayoutID.allocationWorkspaceGrid, viewRID);
                }
				// End TT#1485-MD - stodd - Created an asst, ran create placeholders, cannot drag/drop header to asst.  Did a Tools Refresh and receive a Null reference exception.
                //Begin TT#1313-MD -jsobek -Header Filters
                _filterData.WorkspaceCurrentFilter_Update(_SAB.ClientServerSession.UserRID, eWorkspaceType.AllocationWorkspace, this._headerFilterRID); //save the current header filter
                //End TT#1313-MD -jsobek -Header Filters
            }
			catch( Exception ex) 
			{
				HandleException(ex);
			}
        }
    
        public override void IDelete() 
		{
			try 
			{
			}
			catch( Exception ex) 
			{
				HandleException(ex);
			}

		}
		
		public override void IFind() 
		{
	        Search();
		}

        // BEGIN Workspace Usability Enhancement
        public override void IRestoreLayout()
        {
            try
            {
                // Begin TT#69-MD - RMatelic - Allocation Workspace - Tools>Restore Layout not working correctly
                _skipInitialize = false;
                // End TT#69-MD
                if (!_groupByReload)
                {
                    InfragisticsLayoutData layoutData = new InfragisticsLayoutData();
                    layoutData.InfragisticsLayout_Delete(_SAB.ClientServerSession.UserRID, eLayoutID.allocationWorkspaceGrid);
                    this.ugDetails.ResetLayouts();
                    ApplyAppearance(ugDetails);
                    this.ugHeaders.ResetLayouts();
                    ApplyAppearance(ugHeaders);
                    ResetGrids();
					// BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
                    //cboView.SelectedValue = Include.NoRID;
					// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
					//((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"]).Value = Include.NoRID;
					// END TT#767-MD - Stodd - remove old controls from allocation workspace
                    //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
                    //MIDComboBoxEnh.MyComboBox cmbView = (MIDComboBoxEnh.MyComboBox)cct.Control;
                    MIDComboBoxEnh.MyComboBox cmbView = GetViewComboBoxControl();
                    cmbView.SelectedValue = Include.NoRID;
					// End TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //this.cboView_SelectionChangeCommitted(source, new EventArgs()); // TT#294-MD - RBeck - When Opening style review, the view does not open that is selected
                }
                // Begin TT#620 - RMatelic - Base 3.1 -> Created multi - select SAVE button -> get system argument exception error
                //this.ugHeaders.DataSource = null;
                //this.ugHeaders.DataSource = _bindSourceHeader;
                SaveSelectedHeadersAndRebindGrid();
                // End TT#620
                UpdateSelectedTotals();
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        // Begin TT#620 - RMatelic - Base 3.1 -> Created multi - select SAVE button -> get system argument exception error
        private void SaveSelectedHeadersAndRebindGrid()
        {
            try
            {
                ArrayList hdrList = new ArrayList();
                if (_selectedRowsSequence.Count > 0)
                {
                    foreach (UltraGridRow row in _selectedRowsSequence)
                    {
                        hdrList.Add(Convert.ToInt32(row.Cells["KeyH"].Value, CultureInfo.CurrentUICulture));
                    }
                }
                // Begin TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                _skipInitialize = false;
                // End TT#2728 - JSmith - Errors when creating a Multi-Header in 5.0
                this.ugHeaders.DataSource = null;
                this.ugHeaders.DataSource = _bindSourceHeader;
                if (hdrList.Count > 0)
                {
                    _selectedRowsSequence = new ArrayList();
                    IEnumerable enumerator = ugHeaders.DisplayLayout.Bands["Header"].GetRowEnumerator(GridRowType.DataRow);
                    foreach (UltraGridRow hRow in enumerator)
                    {
                        int hdrRID = Convert.ToInt32(hRow.Cells["KeyH"].Value, CultureInfo.CurrentUICulture);
                        if (hdrList.Contains(hdrRID))
                        {
                            _selectedRowsSequence.Add(hRow);
                            hdrList.Remove(hdrRID);
                        }
                        if (hdrList.Count == 0)
                        {
                            break;
                        }
                    }
                }
            }
            catch
            {
                throw;
            }
        } 
        // End TT#620
        // END Workspace Usability Enhancement
		#endregion

        #region Workspace Window Events
 
        private void AllocationWorkspaceExplorer_SizeChanged(object sender, System.EventArgs e)
		{
			int height = this.Height;
			int width  = this.Width;

            //BEGIN TT#3978 - DOConnell - Allocation Workspace does not open sized/spaced correctly.
            if (this.FormLoaded)
            {
                this.Adjust(); 
            }
            //END TT#3978 - DOConnell - Allocation Workspace does not open sized/spaced correctly.
		}

        private void AllocationWorkspaceExplorer_Enter(object sender, EventArgs e)
        {
            try
            {
                EAB.Explorer.EnableMenuItem(eMIDMenuItem.EditFind);
                EAB.Explorer.ShowMenuItem(eMIDMenuItem.EditFind);

                // BEGIN MID Track #5501 - File>Save not implemented
                if (_inEditMode)
                {
                    // Begin TT#445 - RMatelic - allocation workspace error after save as selected on a Save As header; unrelated to specific error
                    //SetFileSaveMenuItem(true);      // MID Track #5501 - File>Save not implemented
                    SetFileSaveMenuItem(_allocationNonInterfacedHeadersSecurity.AllowUpdate);
                    // End TT#445 
                }
                // END MID Track #5501  
                
                // BEGIN Workspace Usability Enhancement
                EAB.Explorer.AddMenuOption(Include.btRestoreLayout);
                if (_inEditMode)
                {
                    SetToolsMenuItem(false);
                }
                // END Workspace Usability Enhancement
            }   
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }

        private void AllocationWorkspaceExplorer_Leave(object sender, EventArgs e)
        {
            try
            {
                SaveToolbarLayout();
                EAB.Explorer.DisableMenuItem(eMIDMenuItem.EditFind);
                EAB.Explorer.HideMenuItem(eMIDMenuItem.EditFind);
                // BEGIN MID Track #5501 - File>Save not implemented
                if (_inEditMode)
                {
                    SetFileSaveMenuItem(false);
                }
                // END MID Track #5501  

                EAB.Explorer.RemoveMenuOption(Include.btRestoreLayout); // Workspace Usability Enhancement
               
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        // BEGIN MID Track #5501 - File>Save not implemented
        private void SetFileSaveMenuItem(bool aEnable)
        {
            try
            { 
                if (aEnable)
                {
                    EAB.Explorer.EnableMenuItem(eMIDMenuItem.FileSave);
                    EAB.Explorer.ShowMenuItem(eMIDMenuItem.FileSave);
                    EAB.Explorer.EnableMenuItem(eMIDMenuItem.FileSaveAs);   // BEGIN MID Track #5653 - File>SaveAS not implemented
                    EAB.Explorer.ShowMenuItem(eMIDMenuItem.FileSaveAs);     // END MID Track #5653
                }
                else
                {
                    EAB.Explorer.DisableMenuItem(eMIDMenuItem.FileSave);
                    EAB.Explorer.HideMenuItem(eMIDMenuItem.FileSave);
                    EAB.Explorer.DisableMenuItem(eMIDMenuItem.FileSaveAs);  // BEGIN MID Track #5653 - File>SaveAS not implemented
                    EAB.Explorer.HideMenuItem(eMIDMenuItem.FileSaveAs);     // END MID Track #5653
                }
                 
            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        // END MID Track #5501

        // BEGIN Workspace Usability Enhancemnt
        private void SetToolsMenuItem(bool aEnable)
        {
            try
            {
                if (aEnable)
                {
                    EAB.Explorer.EnableMenuItem(eMIDMenuItem.ToolsRestoreLayout);
                }
                else
                {
                    EAB.Explorer.DisableMenuItem(eMIDMenuItem.ToolsRestoreLayout);
                }

            }
            catch (Exception ex)
            {
                HandleException(ex);
            }
        }
        // END Workspace Usability Enhancemnt
        #endregion

        #region Enums
        public enum eBalanceAction
		{
			RowAdded,
			RowDeleted,
			ValueChanged
		}

		public enum eSecurityType
		{
			View,
			Update
        }
        #endregion    

        #region "Toolbars"

        private void headerToolbarsManager_ToolClick(object sender, Infragistics.Win.UltraWinToolbars.ToolClickEventArgs e)
        {
            switch (e.Tool.Key)
            {
                case "btnAction":
					// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
                    //ProcessAction((int)((Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["actionComboBox"]).Value);
                    //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerAction"];
                    //MIDComboBoxEnh.MyComboBox cmbActions = (MIDComboBoxEnh.MyComboBox)cct.Control;
                    MIDComboBoxEnh.MyComboBox cmbActions = GetActionComboBoxControl();
                    //BEGIN TT#4870-VStuart-Receive Unhandled Exception - Action window not visible-MID
                    if (cmbActions.SelectedValue == null)
                    {
                        DataView dv = (DataView)cmbActions.DataSource;
                        ProcessAction(Convert.ToInt32(dv[cmbActions.SelectedIndex]["TEXT_CODE"]));
                    }
                    else
                    {
                        ProcessAction(int.Parse(cmbActions.SelectedValue.ToString()));
                    }
                    //END TT#4870-VStuart-Receive Unhandled Exception - Action window not visible-MID
					// End TT#4071 - stodd - Matrix does not allow search for attribute - 
                    break;

                case "reviewSelectionScreen":
                    DetermineWindow(eAllocationSelectionViewType.None);
                    break;
                case "reviewStyle":
                    DetermineWindow(eAllocationSelectionViewType.Style);
                    break;
                case "reviewSize":
                    DetermineWindow(eAllocationSelectionViewType.Size);
                    break;
                case "reviewSummary":
                    if (cmsReviewSummary.Text == _lblAssortment)
                    {
                        DetermineWindow(eAllocationSelectionViewType.Assortment);
                    }
                    else
                    {
                        DetermineWindow(eAllocationSelectionViewType.Summary);
                    }
                    break;
                case "searchButton":
                    Search();
                    break;
                case "filter":
                    Filter();
                    break;
                case "saveView":
                    SaveView();
                    break;
                case "autoSelectGroup":
                    if (_settingAutoGroupToolbar == false)
                    {
                        AutoSelectGroup();
                    }
                    break;
                case "gridShowGroupArea":
                    this.ugHeaders.DisplayLayout.GroupByBox.Hidden = !this.ugHeaders.DisplayLayout.GroupByBox.Hidden;
                    break;

                case "gridShowFilterRow":
                    if (this.ugHeaders.DisplayLayout.Override.FilterUIType == Infragistics.Win.UltraWinGrid.FilterUIType.FilterRow)
                    {
                        this.ugHeaders.DisplayLayout.Override.FilterUIType = Infragistics.Win.UltraWinGrid.FilterUIType.HeaderIcons;
                    }
                    else
                    {
                        this.ugHeaders.DisplayLayout.Override.FilterUIType = Infragistics.Win.UltraWinGrid.FilterUIType.FilterRow;
                    }
                    break;
                case "gridEmailPopupMenu":
                    UltraGridExcelExportWrapper exporter4 = new UltraGridExcelExportWrapper(this.ugHeaders);
                    ShowEmailForm(exporter4.ExportAllRowsToExcelAsAttachment());
                    break;

                case "gridChooseColumns":
                    this.ugHeaders.ShowColumnChooser("Choose Columns");
                    break;
                case "headerAdd":
                    AddHeader();
                    break;
                case "multiRemove":
                    MultiRemove();
                    break;
                case "multiCreate":
                    MultiCreate();
                    break;
                case "multiAddTo":
                    MultiAddTo();
                    break;
                case "groupAllocationCreate":
                    CreateGroupAllocation(((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"]).Text);
                    break;
                case "gridExport":
                    ExportToExcel();
                    break;
				// BEGIN TT#488-MD - Stodd - Group Allocation
				case "btnDelete":
					DeleteGroupAllocation(((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"]).Text);
					break;
				// END TT#488-MD - Stodd - Group Allocation
                case "showDetails":
                    if (_detailsShown)
                    {
                        HideDetails();
                    }
                    else
                    {
                        ShowDetails();
                    }
                    break;

            }
        }

        private bool _settingAutoGroupToolbar = false;
        private void SetAutoGroupOnToolbar(bool isChecked)
        {
            _settingAutoGroupToolbar = true;
            ((Infragistics.Win.UltraWinToolbars.StateButtonTool)this.headerToolbarsManager.Tools["autoSelectGroup"]).Checked = isChecked;
            _settingAutoGroupToolbar = false;
        }
 
       

        private void headerToolbarsManager_ValueChanged(object sender, Infragistics.Win.UltraWinToolbars.ToolEventArgs e)
        {
            switch (e.Tool.Key)
            {
                case "viewComboBox":
                    //SetView((int)((Infragistics.Win.UltraWinToolbars.ComboBoxTool)e.Tool).Value);	// TT#4071 - stodd - Matrix does not allow search for attribute - 
                    break;
                case "headerFilterComboBox":
                    //SetHeaderFilter((int)((Infragistics.Win.UltraWinToolbars.ComboBoxTool)e.Tool).Value);
                    break;
                   
            }
        }
   


        private void LoadViewsOnToolbar(DataTable dtView)
        {
			// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
            //Infragistics.Win.UltraWinToolbars.ComboBoxTool cbo = (Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["viewComboBox"];
            //cbo.ValueList.ValueListItems.Clear();
            //foreach (DataRow row in dtView.Rows)
            //{
            //    // BEGIN TT#767-MD - Stodd - remove old controls from allocation workspace
            //    //if ((int)row["VIEW_RID"] != -1)
            //    //{
            //        cbo.ValueList.ValueListItems.Add((int)row["VIEW_RID"], (string)row["VIEW_ID"]);
            //    //}
            //    // END TT#767-MD - Stodd - remove old controls from allocation workspace
            //}

            _bindingView = true;

            //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
            //MIDComboBoxEnh.MyComboBox cmbView = (MIDComboBoxEnh.MyComboBox)cct.Control;
            MIDComboBoxEnh.MyComboBox cmbView = GetViewComboBoxControl();

            dtView.PrimaryKey = new DataColumn[] { dtView.Columns["VIEW_RID"] };
            cmbView.ValueMember = "VIEW_RID";
            cmbView.DisplayMember = "VIEW_ID";
            cmbView.DataSource = dtView;
            if (dtView.Rows.Count > 0)
            {
                cmbView.SelectedIndex = 0;
            }
            _bindingView = false;
			// End TT#4071 - stodd - Matrix does not allow search for attribute - 
        }
        private void LoadActionsOnToolbar(DataTable dtActionsToLoad)
        {
            Infragistics.Win.UltraWinToolbars.ComboBoxTool cbo = (Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["actionComboBox"];
            cbo.ValueList.ValueListItems.Clear();

            DataView dv = new DataView(dtActionsToLoad);
            dv.Sort = "TEXT_ORDER";

            foreach (DataRowView rowView in dv)
            {
                cbo.ValueList.ValueListItems.Add((int)rowView.Row["TEXT_CODE"], (string)rowView.Row["TEXT_VALUE"]);
            }
        	// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
            //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerAction"];
            //MIDComboBoxEnh.MyComboBox cmbAllocationActions = (MIDComboBoxEnh.MyComboBox)cct.Control;
            MIDComboBoxEnh.MyComboBox cmbAllocationActions = GetActionComboBoxControl();

            dtActions.PrimaryKey = new DataColumn[] { dtActions.Columns["TEXT_CODE"] };

            cmbAllocationActions.ValueMember = "TEXT_CODE";
            cmbAllocationActions.DisplayMember = "TEXT_VALUE";
            cmbAllocationActions.DataSource = dv;
			// End TT#4071 - stodd - Matrix does not allow search for attribute - 


        }

        //Begin TT#1313-MD -jsobek -Header Filters
        private void LoadHeaderFiltersOnToolbar(DataTable dtHeaderFilters)
        {
			// Begin TT#1359-MD - stodd - Application abends at startup due to argument exception
            //Infragistics.Win.UltraWinToolbars.ComboBoxTool cbo = (Infragistics.Win.UltraWinToolbars.ComboBoxTool)this.headerToolbarsManager.Tools["headerFilterComboBox"];
            //cbo.ValueList.ValueListItems.Clear();

            DataView dv = new DataView(dtHeaderFilters);
            dv.Sort = "FILTER_NAME";

            //foreach (DataRowView rowView in dv)
            //{
            //    cbo.ValueList.ValueListItems.Add((int)rowView.Row["FILTER_RID"], (string)rowView.Row["FILTER_NAME"]);
            //}
			// End TT#1359-MD - stodd - Application abends at startup due to argument exception

            Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerFilter"];
            MIDComboBoxEnh.MyComboBox cmbFilter = (MIDComboBoxEnh.MyComboBox)cct.Control;

            cmbFilter.ValueMember = "FILTER_RID";
            cmbFilter.DisplayMember = "FILTER_NAME";
            cmbFilter.DataSource = dv;


        }
        //End TT#1313-MD -jsobek -Header Filters

        private void SetView(int viewRID, bool forceRefresh)
        {
            if (!_bindingView && !_fromLoadEvent)
            {
                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                ugHeadersBeginUpdate();
                ugHeadersSuspendRowSynchronization();

                ugDetailsBeginUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls             

                if (_viewSaved)
                {
                    _viewSaved = false;
                }
                if (forceRefresh || viewRID != _lastSelectedViewRID)
                {

                    _lastSelectedViewRID = viewRID;

                    // Begin TT#1712-MD - JSmith - Cannot select Headers from Allocation Workspace Explorer
                    //_fromFilterWindow = false;  // TT#4567 - JSmith - Refreshing Allocation Workspace returns previous filter view
                    _filterChangedAfterView = false;  
					// End TT#1712-MD - JSmith - Cannot select Headers from Allocation Workspace Explorer

                    //Begin TT#1313-MD -jsobek -Header Filters
                    //if (_gridViewData.GridViewFilterExists(viewRID))
                    //{
                    //    _cancelSelectEvent = true;
                    //    IRefresh();
                    //}
                    //else
                    //{
                    //    ApplyViewToGridLayout(viewRID);
                    //}
                    // Begin TT#1370-MD - stodd - change view in allocation workspace, the filter should change to match filter on view - 
                    //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerFilter"];
                    //MIDRetail.Windows.Controls.MIDComboBoxEnh.MyComboBox cmbFilter = (MIDRetail.Windows.Controls.MIDComboBoxEnh.MyComboBox)cct.Control;
                    // End TT#1370-MD - stodd - change view in allocation workspace, the filter should change to match filter on view - 
                    MIDRetail.Windows.Controls.MIDComboBoxEnh.MyComboBox cmbFilter = GetFilterComboBoxControl();

                    bool useFilterSorting = false;
                    int workspaceFilterRID = _gridViewData.GridViewReadWorkspaceFilterRID(viewRID, ref useFilterSorting);
                    if (workspaceFilterRID != Include.NoRID)
                    {
                        _cancelSelectEvent = true;
                        //IRefresh();
                        //SetHeaderFilter(workspaceFilterRID);
						// Begin TT#1370-MD - stodd - change view in allocation workspace, the filter should change to match filter on view - 
                        cmbFilter.SelectedValue = workspaceFilterRID;
						// Begin TT#1362-MD - stodd - Header filter InUse is not returning any filters being InUse even though they are
                        SetHeaderFilter(workspaceFilterRID);
						// End TT#1370-MD - stodd - change view in allocation workspace, the filter should change to match filter on view - 
                        //ApplyViewToGridLayout(viewRID);
						// End TT#1362-MD - stodd - Header filter InUse is not returning any filters being InUse even though they are
                    }
                    else
                    {
                        // Begin TT#1370-MD - stodd - change view in allocation workspace, the filter should change to match filter on view
                        //int userheaderFilterRID = _filterData.WorkspaceCurrentFilter_Read(_SAB.ClientServerSession.UserRID, eWorkspaceType.AllocationWorkspace);
                        //cmbFilter.SelectedValue = userheaderFilterRID;
                        //// Begin TT#1362-MD - stodd - Header filter InUse is not returning any filters being InUse even though they are
                        //if (userheaderFilterRID == Include.NoRID)
                        //{
                        //    cmbFilter.SelectedItem = null;
                        //}
                        //// End TT#1362-MD - stodd - Header filter InUse is not returning any filters being InUse even though they are
                        //SetHeaderFilter(userheaderFilterRID);
                        // End TT#1370-MD - stodd - change view in allocation workspace, the filter should change to match filter on view
                    }
                    ApplyViewToGridLayout(viewRID, useFilterSorting);	// TT#1362-MD - stodd - Header filter InUse is not returning any filters being InUse even though they are

                    //End TT#1313-MD -jsobek -Header Filters

                    RebuildMultiHeaderValueLists();
                }

                // Begin TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
                ugHeadersEndUpdate();
                ugHeadersResumeRowSynchronization();

                ugDetailsEndUpdate();
                // End TT#4171 - JSmith - When view is changed and headers are selected on the allocation workspace, the header grid scrolls
            }
        }

        //Begin TT#1313-MD -jsobek -Header Filters
        public void SetHeaderFilter(int headerFilterRID)
        {
            if (!_bindingView && !_fromLoadEvent)
            {
                this._headerFilterRID = headerFilterRID;

                //_fromFilterWindow = true;  // TT#4567 - JSmith - Refreshing Allocation Workspace returns previous filter view  // TT#1712-MD - JSmith - Cannot select Headers from Allocation Workspace Explorer

                SAB.AllocationWorkspaceCurrentHeaderFilter = this._headerFilterRID; //Store the current header filter in the SAB so it can be used by the Allocate Task when executing against default workspace

				// Begin TT#1362-MD - stodd - Header filter InUse is not returning any filters being InUse even though they are
                // The selected filter needs to be constantly updated so InUse will work properly.
                //_filterData.WorkspaceCurrentFilter_Update(_SAB.ClientServerSession.UserRID, eWorkspaceType.AllocationWorkspace, this._headerFilterRID);
				// End TT#1362-MD - stodd - Header filter InUse is not returning any filters being InUse even though they are
                //IRefresh(); 
                LoadHeadersOnGrid();
            }

        }
        //End TT#1313-MD -jsobek -Header Filters

        //Begin TT#4295 -jsobek -No response when changing filters 
        private System.Windows.Forms.Timer delayedActionTimer = null;
        public void SetHeaderFilterWithDelayedAction(int headerFilterRID)
        {
            if (!_bindingView && !_fromLoadEvent)
            {
                this._headerFilterRID = headerFilterRID;

                _filterChangedAfterView = true;  // TT#1712-MD - JSmith - Cannot select Headers from Allocation Workspace Explorer

                SAB.AllocationWorkspaceCurrentHeaderFilter = this._headerFilterRID; //Store the current header filter in the SAB so it can be used by the Allocate Task when executing against default workspace

                if (delayedActionTimer == null)
                {
                    delayedActionTimer = new System.Windows.Forms.Timer();
                    delayedActionTimer.Tick += new System.EventHandler(this.delayedActionTimer_Tick);
                    delayedActionTimer.Interval = 150;
                    delayedActionTimer.Start();
                }
                else
                {
                    delayedActionTimer.Start();
                }
            }

        }
        private void delayedActionTimer_Tick(object sender, EventArgs e)
        {
            try
            {
                delayedActionTimer.Stop();
                Cursor.Current = Cursors.WaitCursor;
                LoadHeadersOnGrid();
            }
            finally
            {
                Cursor.Current = Cursors.Default;
            }
        }
        //End TT#4295 -jsobek -No response when changing filters 

        private void ShowEmailForm(System.Net.Mail.Attachment a)
        {
  
            EmailMessageForm frm = new EmailMessageForm();
            frm.AddAttachment(a);
            string subject = "Allocation Workspace Headers";
            MIDRetail.Data.SecurityAdmin secAdmin = new MIDRetail.Data.SecurityAdmin();
            DataTable dt = secAdmin.GetUser(_SAB.ClientServerSession.UserRID);
            if (dt.Rows.Count > 0)
            {
                string userName = String.Empty;
                string userFullName = String.Empty;
                if (dt.Rows[0].IsNull("USER_NAME") == false)
                {
                    userName = (string)dt.Rows[0]["USER_NAME"];
                }
                if (dt.Rows[0].IsNull("USER_FULLNAME") == false)
                {
                    userFullName = (string)dt.Rows[0]["USER_FULLNAME"];
                }
                subject += " - " + userName + " (" + userFullName + ")";
            }

            frm.SetDefaults("", "", "", subject, "Please see attached file.");
            frm.ShowDialog();

        }
        private void headerToolbarsManager_ToolKeyPress(object sender, Infragistics.Win.UltraWinToolbars.ToolKeyPressEventArgs e)
        {
            switch (e.Tool.Key)
            {
                case "groupAllocationCreateTextBox":
                    if (e.KeyChar == (char)Keys.Return)
                    {
                        CreateGroupAllocation(((Infragistics.Win.UltraWinToolbars.TextBoxTool)this.headerToolbarsManager.Tools["groupAllocationCreateTextBox"]).Text);
                    }
                    break;
            }
        }


        // Begin TT#1126-MD - RMatelic - Show Details needs consistent “controls” as the main Workspace Explorer
        private void detailToolbarsManager_ToolClick(object sender, Infragistics.Win.UltraWinToolbars.ToolClickEventArgs e)
        {
            EventArgs args = new EventArgs();
            switch (e.Tool.Key)
            {
                case "btnCollapseAll":   
                    cmsCollapse_Click(cmsCollapse, args);
                    break;

                case "btnExpandAll":    
                    cmsExpand_Click(cmsExpand, args);
                    break;
               
                case "btnEditSave":    
                    cmsSave_Click(cmsSave, args);
                    break;

                case "btnCancel":
                    CancelEdit();
                    break;

                case "btnHideDetails":
                    HideDetails();
                    break;
            }

        }
        // End TT#1126-MD  
        
        #region "Grid Export"

        /// <summary>
        /// Used to provide Excel Export Functionality for the Infragistics UltraWinGrid
        /// Just create an instance of this class, pass in your grid and call Export function.
        /// Saves in xls format - does not support xlsx format
        /// </summary>
        private class UltraGridExcelExportWrapper
        {
            private Infragistics.Win.UltraWinGrid.UltraGrid _ug;
            private Infragistics.Win.UltraWinGrid.ExcelExport.UltraGridExcelExporter ultraGridExcelExporter1;
            private bool _checkForExportSelected = false;
            private string _objectDescriptor;
            public UltraGridExcelExportWrapper(Infragistics.Win.UltraWinGrid.UltraGrid ug, string objectDescriptor = "rows")
            {
                _ug = ug;
                _objectDescriptor = objectDescriptor;

                this.ultraGridExcelExporter1 = new Infragistics.Win.UltraWinGrid.ExcelExport.UltraGridExcelExporter();
                this.ultraGridExcelExporter1.RowExporting += new Infragistics.Win.UltraWinGrid.ExcelExport.RowExportingEventHandler(ultraGridExcelExporter1_RowExporting);
            }

            public void ExportAllRowsToExcel()
            {
                string myFilepath = FindSavePath();
                string MessBoxText1 = "All " + _objectDescriptor + " sucessfully exported to \r\n";
                string MessBoxText2 = "Number of " + _objectDescriptor + " exported: ";
                try
                {
                    if (myFilepath != null)
                    {
                        _checkForExportSelected = false;
                        this.ultraGridExcelExporter1.Export(_ug, myFilepath);
                        MessageBox.Show(MessBoxText1 + myFilepath + "\r\n" + MessBoxText2 + _ug.Rows.Count);
                    }
                }
                catch (Exception ex)
                {
                    throw ex;
                }
            }
            public System.Net.Mail.Attachment ExportAllRowsToExcelAsAttachment()
            {
                try
                {
                    _checkForExportSelected = false;
                    return GetEmailAttachment();
                }
                catch (Exception ex)
                {
                    throw ex;
                }
            }
            public System.Net.Mail.Attachment ExportSelectedRowsToExcelAsAttachment()
            {
                try
                {

                    _checkForExportSelected = true;
                    return GetEmailAttachment();

                }
                catch (Exception ex)
                {
                    throw ex;
                }
            }
            private System.Net.Mail.Attachment GetEmailAttachment()
            {
                Infragistics.Documents.Excel.Workbook wb = new Infragistics.Documents.Excel.Workbook();
                this.ultraGridExcelExporter1.Export(_ug, wb);

                //Infragistics does not save nicely directly to a memory stream, so saving as a file and reading it back into memory stream
                string fileName = System.IO.Path.GetTempPath() + "\\tempAllocationWorkspaceHeaders_" + Data.EnvironmentInfo.MIDInfo.userName + "_" + System.DateTime.Now.ToString("yyyy_MM_dd_HH_mm_ss") + ".tmp";
                wb.Save(fileName);
                byte[] b = System.IO.File.ReadAllBytes(fileName);
                System.IO.File.Delete(fileName);
                System.IO.MemoryStream streamAttachment = new System.IO.MemoryStream(b);

                System.Net.Mail.Attachment attachmentWorkbook;
                attachmentWorkbook = new System.Net.Mail.Attachment(streamAttachment, "AllocationWorkspaceHeaders.xls");
                return attachmentWorkbook;
            }

            public void ExportSelectedRowsToExcel()
            {
                string myFilepath = FindSavePath();
                string MessBoxText1 = "Selected " + _objectDescriptor + " sucessfully exported to \r\n";
                string MessBoxText2 = "Number of " + _objectDescriptor + " exported: ";
                try
                {
                    if (myFilepath != null)
                    {
                        _checkForExportSelected = true;
                        this.ultraGridExcelExporter1.Export(_ug, myFilepath);
                        MessageBox.Show(MessBoxText1 + myFilepath + "\r\n" + MessBoxText2 + _ug.Selected.Rows.Count);
                    }
                }
                catch (Exception ex)
                {
                    throw ex;
                }
            }
            private void ultraGridExcelExporter1_RowExporting(object sender, Infragistics.Win.UltraWinGrid.ExcelExport.RowExportingEventArgs e)
            {
                // The GridRow property on the event args is a clone of the on-screen row, and it will not pick up the Selected State 
                //Infragistics.Win.UltraWinGrid.UltraGridRow exportRow = e.GridRow;

                //  Get the grid
                //Infragistics.Win.UltraWinGrid.UltraGrid grid = (Infragistics.Win.UltraWinGrid.UltraGrid)e.GridRow.Band.Layout.Grid;

                // Get the real, on-screen row, from the export row. 
                Infragistics.Win.UltraWinGrid.UltraGridRow onScreenRow = _ug.GetRowFromPrintRow(e.GridRow);

                // If the on-screen row is not selected, do not export it. 
                if (onScreenRow.Selected == false && _checkForExportSelected == true)
                    e.Cancel = true;
            }
            private String FindSavePath()
            {
                System.IO.Stream myStream;
                string myFilepath = null;
                try
                {
                    SaveFileDialog saveFileDialog1 = new SaveFileDialog();
                    saveFileDialog1.Filter = "excel files (*.xls)|*.xls";
                    saveFileDialog1.FilterIndex = 2;
                    saveFileDialog1.RestoreDirectory = true;
                    if (saveFileDialog1.ShowDialog() == DialogResult.OK)
                    {
                        if ((myStream = saveFileDialog1.OpenFile()) != null)
                        {
                            myFilepath = saveFileDialog1.FileName;
                            myStream.Close();
                        }
                    }
                }
                catch (Exception ex)
                {
                    throw ex;
                }
                return myFilepath;
            }
        }

        #endregion

		// Begin TT#4071 - stodd - Matrix does not allow search for attribute - 
        private void midComboBoxView_SelectionChangeCommitted(object sender, EventArgs e)
        {
            //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerView"];
            //MIDRetail.Windows.Controls.MIDComboBoxEnh.MyComboBox cmbView = (MIDRetail.Windows.Controls.MIDComboBoxEnh.MyComboBox)cct.Control;
            MIDComboBoxEnh.MyComboBox cmbView = GetViewComboBoxControl();
            int viewRid = int.Parse(cmbView.SelectedValue.ToString());

            SetView(viewRid, false);
        }

        private void midComboBoxFilter_SelectionChangeCommitted(object sender, EventArgs e)
        {
            //Infragistics.Win.UltraWinToolbars.ControlContainerTool cct = (Infragistics.Win.UltraWinToolbars.ControlContainerTool)this.headerToolbarsManager.Tools["ControlContainerFilter"];
            //MIDRetail.Windows.Controls.MIDComboBoxEnh.MyComboBox cmbFilter = (MIDRetail.Windows.Controls.MIDComboBoxEnh.MyComboBox)cct.Control;
            MIDRetail.Windows.Controls.MIDComboBoxEnh.MyComboBox cmbFilter = GetFilterComboBoxControl();
            int filterRid = int.Parse(cmbFilter.SelectedValue.ToString());
            //Begin TT#4295 -jsobek -No response when changing filters 
            //SetHeaderFilter(filterRid);
            SetHeaderFilterWithDelayedAction(filterRid);
            //End TT#4295 -jsobek -No response when changing filters 
        }
		// End TT#4071 - stodd - Matrix does not allow search for attribute - 
        #endregion

    

    }
	
	#region ToolTipItemCreationFilter
	/// <summary>
	/// A CreationFilter that will trap for elements within the UltraWinGrid
	/// and set tooltip information on them.
	/// </summary>
	public class ToolTipItemCreationFilter : IUIElementCreationFilter
	{	
		#region Private Members

		private	IToolTipItem toolTipItem = null;
		
		#endregion Private Members

		#region Implementation of IUIElementCreationFilter
		void IUIElementCreationFilter.AfterCreateChildElements(Infragistics.Win.UIElement parent)
		{
			// Look for elements that need a tooltip.
			// In this case, we will apply tooltips to the ColumnChooserButton. 
			if (parent is Infragistics.Win.UltraWinGrid.ColumnChooserButtonUIElement
				||  parent is Infragistics.Win.UltraWinGrid.EditButtonUIElement)
			{
				// Set the ToolTipItem of this element.
				// It does not matter which element this is - all elements that need
				// tooltips will be assigned the same instance of the ToolTipItem class.
				// The ToolTipItem will determine what tooltip to display based
				// on the element. 
				parent.ToolTipItem = this.ToolTipItem;
			}
		}

		bool IUIElementCreationFilter.BeforeCreateChildElements(Infragistics.Win.UIElement parent)
		{
			// Do nothing here.
			return false;
		}
		#endregion

		#region ToolTipItem
		/// <summary>
		/// This single instance of a ToolTipItem will be assigned to 
		/// any UIElement in the grid that needs to display a tooltip. The GridToolTipItem
		/// class will determine what tooltip to display based on the element. 
		/// </summary>
		private IToolTipItem ToolTipItem
		{
			get
			{
                if (this.toolTipItem == null)
                {
                    this.toolTipItem = new GridToolTipItem();
                }
				return this.toolTipItem;
			}
		}
		#endregion ToolTipItem
	}
	#endregion ToolTipItemCreationFilter

	#region GridToolTipItem
	/// <summary>
	/// This class provides tooltip information based on the type of UIElement
	/// in the UltraWinGrid.
	/// </summary>
	public class GridToolTipItem : IToolTipItem
	{
		#region Implementation of IToolTipItem
		Infragistics.Win.ToolTipInfo IToolTipItem.GetToolTipInfo(System.Drawing.Point mousePosition, Infragistics.Win.UIElement element, Infragistics.Win.UIElement previousToolTipElement, Infragistics.Win.ToolTipInfo toolTipInfoDefault)
		{
			// Is this a ColumnChooserButton
			if (element is Infragistics.Win.UltraWinGrid.ColumnChooserButtonUIElement)
			{				
				ColumnChooserButtonUIElement buttonElement;
				buttonElement = (ColumnChooserButtonUIElement)element; 
			
				if (buttonElement == null) 
					return toolTipInfoDefault;
				// Change the tool tip text.				
                toolTipInfoDefault.ToolTipText = MIDText.GetTextOnly(eMIDTextCode.tt_ClickToShowHideColumns);
            }
			else if (element is Infragistics.Win.UltraWinGrid.EditButtonUIElement)
			{				
				EditButtonUIElement buttonElement;
				buttonElement = (EditButtonUIElement)element;

                if (buttonElement == null)
                {
                    return toolTipInfoDefault;
                }

                // Change the tool tip text.	
				switch (buttonElement.Control.Name)
				{
					case "ugHeaders":
                    case "ugDetails":

                        switch (buttonElement.Column.Key)
                        {
                            case "HeaderID":
                                toolTipInfoDefault.ToolTipText = MIDText.GetTextOnly(eMIDTextCode.tt_ClickForHeaderNotes);
                                break;

                            case "BulkColor":
                            case "PackColor":
                                toolTipInfoDefault.ToolTipText = MIDText.GetTextOnly(eMIDTextCode.tt_ClickForColorBrowser);
                                break;
                        }
                        break;

                    default:
                        break;
				}
			}
			else
			{
				//Debug.Fail("Unknown Element");
			}

			return toolTipInfoDefault;
		}
	
		#endregion
	}
	#endregion GridToolTipItem
   
    #region Implementation of IUIElementDrawFilter
    // Begin TT#3832 - RMatelic - When a row in a grid is unselected, remove the focus rectangle from the row
    public class NoFocusRect : Infragistics.Win.IUIElementDrawFilter
    {
        public bool DrawElement(Infragistics.Win.DrawPhase drawPhase, ref Infragistics.Win.UIElementDrawParams drawParams)
        {
            return true;
        }
        public Infragistics.Win.DrawPhase GetPhasesToFilter(ref Infragistics.Win.UIElementDrawParams drawParams)
        {
            return Infragistics.Win.DrawPhase.BeforeDrawFocus;
        }
    }
    // End TT#3832
    #endregion
}

